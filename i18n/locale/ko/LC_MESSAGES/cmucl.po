# @ cmucl
# SOME DESCRIPTIVE TITLE
# Copyright (C) 2010
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CMUCL 20b\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI +ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: target:code/intl.lisp
msgid ""
"The message-lookup domain used by INTL:GETTEXT and INTL:NGETTEXT.\n"
"  Use (INTL:TEXTDOMAIN \"whatever\") in each source file to set this."
msgstr ""

#: target:code/intl.lisp
msgid "Encountered illegal token: ="
msgstr ""

#: target:code/intl.lisp
msgid "Encountered illegal token: ~C"
msgstr ""

#: target:code/intl.lisp
msgid "Expected : in ?: construct"
msgstr ""

#: target:code/intl.lisp
msgid "Expected close-paren."
msgstr ""

#: target:code/intl.lisp
msgid "Unexpected token: ~S."
msgstr ""

#: target:code/intl.lisp
msgid "Expecting end of expression.  ~S."
msgstr ""

#: target:code/intl.lisp
msgid "Bad magic number in \"~A.mo\"."
msgstr ""

#: target:code/intl.lisp
msgid ""
"Look up STRING in the current message domain and return its translation."
msgstr ""

#: target:code/intl.lisp
msgid "Look up the singular or plural form of a message in the current domain."
msgstr ""

#: target:code/intl.lisp
msgid ""
"Look up STRING in the specified message domain and return its translation."
msgstr ""

#: target:code/intl.lisp
msgid ""
"Look up the singular or plural form of a message in the specified domain."
msgstr ""

#: target:code/intl.lisp
msgid "_@ is a reserved reader macro prefix."
msgstr ""

#: target:code/kernel.lisp
msgid ""
"Return the 24 bits of data in the header of object X, which must be an\n"
"  other-pointer object."
msgstr ""

#: target:code/kernel.lisp
msgid ""
"Sets the 24 bits of data in the header of object X (which must be an\n"
"  other-pointer object) to VAL."
msgstr ""

#: target:code/kernel.lisp
msgid ""
"Returns the length of the closure X.  This is one more than the number\n"
"  of variables closed over."
msgstr ""

#: target:code/kernel.lisp
msgid "Returns the three-bit lowtag for the object X."
msgstr ""

#: target:code/kernel.lisp
msgid "Returns the 8-bit header type for the object X."
msgstr ""

#: target:code/kernel.lisp
msgid ""
"Return a System-Area-Pointer pointing to the data for the vector X, which\n"
"  must be simple."
msgstr ""

#: target:code/kernel.lisp
msgid "Return a System-Area-Pointer pointing to the end of the binding stack."
msgstr ""

#: target:code/kernel.lisp
msgid ""
"Returns a System-Area-Pointer pointing to the next free work of the current\n"
"  dynamic space."
msgstr ""

#: target:code/kernel.lisp
msgid "Return a System-Area-Pointer pointing to the end of the control stack."
msgstr ""

#: target:code/kernel.lisp
msgid "Return the header typecode for FUNCTION.  Can be set with SETF."
msgstr ""

#: target:code/kernel.lisp
msgid "Extracts the arglist from the function header FUNC."
msgstr ""

#: target:code/kernel.lisp
msgid "Extracts the name from the function header FUNC."
msgstr ""

#: target:code/kernel.lisp
msgid "Extracts the type from the function header FUNC."
msgstr ""

#: target:code/kernel.lisp
msgid "Extracts the function from CLOSURE."
msgstr ""

#: target:code/kernel.lisp
msgid ""
"Return the length of VECTOR.  There is no reason to use this, 'cause\n"
"  (length (the vector foo)) is the same."
msgstr ""

#: target:code/kernel.lisp
msgid "Return the SXHASH for the simple-string STRING."
msgstr ""

#: target:code/kernel.lisp
msgid ""
"Return the SXHASH for the first LENGTH characters of the simple-string\n"
"  STRING."
msgstr ""

#: target:code/kernel.lisp
msgid "Extract the INDEXth slot from CLOSURE."
msgstr ""

#: target:code/kernel.lisp
msgid ""
"Allocate a unboxed, simple vector with type code TYPE, length LENGTH, and\n"
"  WORDS words long.  Note: it is your responsibility to assure that the\n"
"  relation between LENGTH and WORDS is correct."
msgstr ""

#: target:code/kernel.lisp
msgid "Allocate an array header with type code TYPE and rank RANK."
msgstr ""

#: target:code/kernel.lisp
msgid "Return a SAP pointing to the instructions part of CODE-OBJ."
msgstr ""

#: target:code/kernel.lisp
msgid ""
"Extract the INDEXth element from the header of CODE-OBJ.  Can be set with\n"
"  setf."
msgstr ""

#: target:code/format.lisp target:code/print.lisp target:code/irrat-dd.lisp
#: target:code/irrat.lisp target:code/float.lisp target:code/numbers.lisp
#: target:code/kernel.lisp
msgid "Argument ~A is not a ~S: ~S."
msgstr ""

#: target:pcl/dfun.lisp target:code/interr.lisp target:code/lispinit.lisp
msgid "Help! "
msgstr ""

#: target:pcl/dfun.lisp target:code/interr.lisp target:code/lispinit.lisp
msgid " nested errors.  "
msgstr ""

#: target:pcl/dfun.lisp target:code/interr.lisp target:code/lispinit.lisp
msgid "KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"A funcallable instance used to implement fwrappers.\n"
"   The CONSTRUCTOR slot is a function defined with DEFINE-FWRAPPER.\n"
"   This function returns an instance closure closing over an \n"
"   fwrapper object, which is installed as the funcallable-instance\n"
"   function of the fwrapper object."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Print-function for struct FWRAPPER."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Return FUN if it is an fwrapper or nil if it isn't."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Evaluate BODY with VAR bound to consecutive fwrappers of\n"
"   FDEFN.  Return RESULT at the end."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Return tha last encapsulation of FDEFN or NIL if none."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Prepend encapsulation F to the definition of FUNCTION-NAME.\n"
"   Signal an error if FUNCTION-NAME is an undefined function."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Remove fwrapper F from the definition of FUNCTION-NAME."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Return a list of all fwrappers of FUNCTION-NAME, ordered\n"
"   from outermost to innermost."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Set FUNCTION-NAMES's fwrappers to elements of the list\n"
"   FWRAPPERS, which is assumed to be ordered from outermost to\n"
"   innermost.  FWRAPPERS null means remove all fwrappers."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Wrap the function named FUNCTION-NAME in an fwrapper of type TYPE,\n"
"   created by calling CONSTRUCTOR.  CONSTRUCTOR is a function\n"
"   defined with DEFINE-FWRAPPER, or the name of such a function.\n"
"   Return the fwrapper created.  USER-DATA is arbitrary data to be\n"
"   associated with the fwrapper.  It is accessible in wrapper\n"
"   functions defined with DEFINE-FWRAPPER as (FWRAPPER-USER-DATA\n"
"   FWRAPPER)."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Remove fwrappers from the function named FUNCTION-NAME.\n"
"   If TYPE is supplied, remove fwrappers whose type is equal to TYPE.\n"
"   If TEST is supplied, remove fwrappers satisfying TEST.\n"
"   If both are not specified, remove all fwrappers."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Update the funcallable instance function of fwrapper F from its\n"
"   constructor."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Update fwrapper function definitions of FUNCTION-NAME.\n"
"   If TYPE is supplied, update fwrappers whose type is equal to TYPE.\n"
"   If TEST is supplied, update fwrappers satisfying TEST."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Find an fwrapper of FUNCTION-NAME.\n"
"   If TYPE is supplied, find an fwrapper whose type is equal to TYPE.\n"
"   If TEST is supplied, find an fwrapper satisfying TEST."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Like DEFUN, but define a function wrapper.\n"
"   In BODY, the symbol FWRAPPERS:FWRAPPERS refers to the currently\n"
"   executing fwrapper.  FWRAPPERS:CALL-NEXT-FUNCTION can be used\n"
"   in BODY to call the next fwrapper or the primary function.  When\n"
"   called with no arguments, CALL-NEXT-FUNCTION invokes the next\n"
"   function with the original args to the fwrapper, otherwise it\n"
"   invokes the next function with the supplied args."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Return the expansion of a DEFINE-FWRAPPER."
msgstr ""

#: target:code/fwrappers.lisp
msgid "&MORE not supported in fwrapper lambda lists"
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"First value is true if BODY refers to any of the variables in\n"
"     OPTIONALS, KEYS or REST, which are what KERNEL:PARSE-LAMBDA-LIST\n"
"     returns.  Second value is true if BODY refers to REST."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Fwrapper for old-style encapsulations."
msgstr ""

#: target:code/fwrappers.lisp
msgid "This function is deprecated; use fwrappers instead."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Define (NAME ...) to be a valid function name whose syntax is checked\n"
"  by BODY.  In BODY, VAR is bound to an actual function name of the\n"
"  form (NAME ...) to check.  BODY should return two values.\n"
"  First value true means the function name is valid.  Second value\n"
"  is the name, a symbol, of the function for use in the BLOCK of DEFUNs\n"
"  and in similar situations."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"First value is true if NAME has valid function name syntax.\n"
"  Second value is the name, a symbol, to use as a block name in DEFUNs\n"
"  and in similar situations."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Return the fdefn object for NAME.  If it doesn't already exist and CREATE\n"
"   is non-NIL, create a new (unbound) one."
msgstr ""

#: target:code/fdefinition.lisp
msgid "Invalid function name: ~S"
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Return the FDEFN of NAME.  Signal an error if there is none\n"
"   or if it's function is null."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Returns the definition for name, including any encapsulations.  Settable\n"
"   with SETF."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Return FUNCTION-NAME's global function definition.\n"
"   If FUNCTION-NAME is fwrapped, return the primary function definition\n"
"   stored in the innermost fwrapper."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"This holds functions that (SETF FDEFINITION) invokes before storing the\n"
"   new value.  These functions take the function name and the new value."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Set FUNCTION-NAME's global function definition to NEW-VALUE.\n"
"   If FUNCTION-NAME is fwrapped, set the primary function stored\n"
"   in the innermost fwrapper."
msgstr ""

#: target:code/fdefinition.lisp
msgid "Return true if name has a global function definition."
msgstr ""

#: target:code/fdefinition.lisp
msgid "Make Name have no global function definition."
msgstr ""

#: target:code/error.lisp
msgid "&rest keyword is ~:[missing~;misplaced~]."
msgstr ""

#: target:code/error.lisp
msgid ""
"Return a list of all the currently active restarts ordered from most\n"
"   recently established to less recently established.  If Condition is\n"
"   specified, then only restarts associated with Condition (or with no\n"
"   condition) will be returned."
msgstr ""

#: target:code/error.lisp
msgid "Returns the name of the given restart object."
msgstr ""

#: target:code/error.lisp
msgid ""
"WITH-CONDITION-RESTARTS Condition-Form Restarts-Form Form*\n"
"   Evaluates the Forms in a dynamic environment where the restarts in the "
"list\n"
"   Restarts-Form are associated with the condition returned by Condition-"
"Form.\n"
"   This allows FIND-RESTART, etc., to recognize restarts that are not "
"related\n"
"   to the error currently being debugged.  See also RESTART-CASE."
msgstr ""

#: target:code/error.lisp
msgid ""
"Executes forms in a dynamic context where the given restart bindings are\n"
"   in effect.  Users probably want to use RESTART-CASE.  When clauses "
"contain\n"
"   the same restart name, FIND-RESTART will find the first such clause."
msgstr ""

#: target:code/error.lisp
msgid ""
"Unnamed restart does not have a ~\n"
"\t\t\t\t\treport function -- ~S"
msgstr ""

#: target:code/error.lisp
msgid ""
"Returns the first restart named name.  If name is a restart, it is returned\n"
"   if it is currently active.  If no such restart is found, nil is "
"returned.\n"
"   It is an error to supply nil as a name.  If Condition is specified and "
"not\n"
"   NIL, then only restarts associated with that condition (or with no\n"
"   condition) will be returned."
msgstr ""

#: target:code/error.lisp
msgid ""
"Calls the function associated with the given restart, passing any given\n"
"   arguments.  If the argument restart is not a restart or a currently "
"active\n"
"   non-nil restart name, then a control-error is signalled."
msgstr ""

#: target:code/error.lisp
msgid "Restart ~S is not active."
msgstr ""

#: target:code/error.lisp
msgid ""
"Calls the function associated with the given restart, prompting for any\n"
"   necessary arguments.  If the argument restart is not a restart or a\n"
"   currently active non-nil restart name, then a control-error is signalled."
msgstr ""

#: target:code/error.lisp
msgid ""
"(RESTART-CASE form\n"
"   {(case-name arg-list {keyword value}* body)}*)\n"
"   The form is evaluated in a dynamic context where the clauses have "
"special\n"
"   meanings as points to which control may be transferred (see INVOKE-"
"RESTART).\n"
"   When clauses contain the same case-name, FIND-RESTART will find the "
"first\n"
"   such clause.  If Expression is a call to SIGNAL, ERROR, CERROR or WARN "
"(or\n"
"   macroexpands into such) then the signalled condition will be associated "
"with\n"
"   the new restarts."
msgstr ""

#: target:code/error.lisp
msgid ""
"(WITH-SIMPLE-RESTART (restart-name format-string format-arguments)\n"
"   body)\n"
"   If restart-name is not invoked, then all values returned by forms are\n"
"   returned.  If control is transferred to this restart, it immediately\n"
"   returns the values nil and t."
msgstr ""

#: target:code/error.lisp
msgid "Condition ~S was signalled."
msgstr ""

#: target:code/error.lisp
msgid "No REPORT?  Shouldn't happen!"
msgstr ""

#: target:code/error.lisp
msgid "Condition slot is not bound: ~S"
msgstr ""

#: target:code/error.lisp
msgid "Slot ~S of ~S missing."
msgstr ""

#: target:code/error.lisp
msgid "Make an instance of a condition object using the specified initargs."
msgstr ""

#: target:code/error.lisp
msgid "~S is not a condition class."
msgstr ""

#: target:code/error.lisp
msgid "Bad thing for class arg:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "Condition already names a declaration: ~S."
msgstr ""

#: target:code/error.lisp
msgid ""
"DEFINE-CONDITION Name (Parent-Type*) (Slot-Spec*) Option*\n"
"   Define NAME as a condition type.  This new type inherits slots and its\n"
"   report function from the specified PARENT-TYPEs.  A slot spec is either\n"
"   a symbol denoting the name of the slot, or a list of the form:\n"
"\n"
"     (slot-name {slot-option value}*)\n"
"\n"
"   where slot-option is one of :READER, :WRITER, :ACCESSOR, :ALLOCATION,\n"
"   :INITARG, :INITFORM, :DOCUMENTATION, and :TYPE.\n"
"\n"
"   Each overall option is of the form\n"
"\n"
"     (option-name {value}*)\n"
"\n"
"   where option-name is one of :DEFAULT-INITARGS, :DOCUMENTATION,\n"
"   and :REPORT.\n"
"\n"
"   The :REPORT option is peculiar to DEFINE-CONDITION.  Its argument is "
"either\n"
"   a string or a two-argument lambda or function name.  If a function, the\n"
"   function is called with the condition and stream to report the "
"condition.\n"
"   If a string, the string is printed.\n"
"\n"
"   Condition types are classes, but (as allowed by ANSI and not as described "
"in\n"
"   CLtL2) are neither STANDARD-OBJECTs nor STRUCTURE-OBJECTs.  WITH-SLOTS "
"and\n"
"   SLOT-VALUE may not be used on condition objects."
msgstr ""

#: target:code/error.lisp
msgid "Keyword slot name indicates probable syntax error:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "Malformed condition slot spec:~%  ~S."
msgstr ""

#: target:code/error.lisp
msgid "More than one :INITFORM in:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "More than one slot :DOCUMENTATION in~%  ~s"
msgstr ""

#: target:code/error.lisp
msgid "Slot :DOCUMENTATION is not a string in~%  ~s"
msgstr ""

#: target:code/error.lisp
msgid "Unknown slot option:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "Bad option:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "Unknown option: ~S"
msgstr ""

#: target:code/error.lisp
msgid ""
"(HANDLER-BIND ( {(type handler)}* )  body)\n"
"   Executes body in a dynamic context where the given handler bindings are\n"
"   in effect.  Each handler must take the condition being signalled as an\n"
"   argument.  The bindings are searched first to last in the event of a\n"
"   signalled condition."
msgstr ""

#: target:code/error.lisp
msgid "Ill-formed handler bindings."
msgstr ""

#: target:code/error.lisp
msgid "~&~@<Error in function ~S:  ~3i~:_~?~:>"
msgstr ""

#: target:code/error.lisp
msgid "Control stack overflow"
msgstr ""

#: target:code/error.lisp
msgid "Heap (dynamic space) overflow"
msgstr ""

#: target:code/error.lisp
msgid "~@<Type-error in ~S:  ~3i~:_~S is not of type ~S~:>"
msgstr ""

#: target:code/error.lisp
msgid ""
"Layout-invalid error in ~S:~@\n"
"\t\t     Type test of class ~S was passed obsolete instance:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "~@<~S fell through ~S expression.  ~:_Wanted one of ~:S.~:>"
msgstr ""

#: target:code/error.lisp
msgid "End-of-File on ~S"
msgstr ""

#: target:code/error.lisp
msgid "~&~@<File-error in function ~S:  ~3i~:_~?~:>"
msgstr ""

#: target:code/error.lisp
msgid "Error in ~S:  the variable ~S is unbound."
msgstr ""

#: target:code/error.lisp
msgid "Error in ~S:  the function ~S is undefined."
msgstr ""

#: target:code/error.lisp
msgid ""
"~@<Destructive function ~S called on ~\n"
"                         constant data.~@:>"
msgstr ""

#: target:code/error.lisp
msgid "Arithmetic error ~S signalled."
msgstr ""

#: target:code/error.lisp
msgid "~%Operation was ~S, operands ~S."
msgstr ""

#: target:code/error.lisp
msgid ""
"(HANDLER-CASE form\n"
"   { (type ([var]) body) }* )\n"
"   Executes form in a context with handlers established for the condition\n"
"   types.  A peculiar property allows type to be :no-error.  If such a "
"clause\n"
"   occurs, and form returns normally, all its values are passed to this "
"clause\n"
"   as if by MULTIPLE-VALUE-CALL.  The :no-error clause accepts more than "
"one\n"
"   var specification."
msgstr ""

#: target:code/error.lisp
msgid ""
"Executes forms after establishing a handler for all error conditions that\n"
"   returns from this form nil and the condition signalled."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfers control to a restart named abort, signalling a control-error if\n"
"   none exists."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfers control to a restart named muffle-warning, signalling a\n"
"   control-error if none exists."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfer control to a restart named continue, returning nil if none exists."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfer control and value to a restart named store-value, returning nil if\n"
"   none exists."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfer control and value to a restart named use-value, returning nil if\n"
"   none exists."
msgstr ""

#: target:code/class.lisp
msgid "Layout for ~S~@[, Invalid=~S~]"
msgstr ""

#: target:code/class.lisp
msgid "The inclusive upper bound on LAYOUT-HASH values."
msgstr ""

#: target:code/class.lisp
msgid ""
"Layout depth conflict: ~S~%  ~\n"
"\t\t        (~S collides at ~S with ~S)~%"
msgstr ""

#: target:code/class.lisp
msgid "Can't use anonymous or undefined class as constant:~%  ~S"
msgstr ""

#: target:code/class.lisp
msgid "~:[<anonymous>~;~:*~S~]~@[ (~(~A~))~]"
msgstr ""

#: target:code/class.lisp
msgid ""
"Return the class with the specified Name.  If ERRORP is false, then NIL is\n"
"   returned when no such class exists."
msgstr ""

#: target:code/class.lisp
msgid "Class not yet defined:~%  ~S"
msgstr ""

#: target:code/class.lisp
msgid "Illegal to redefine standard type ~S."
msgstr ""

#: target:code/class.lisp
msgid "Changing meta-class of ~S from ~S to ~S."
msgstr ""

#: target:code/class.lisp
msgid "Redefining DEFTYPE type to be a class: ~S."
msgstr ""

#: target:code/class.lisp
msgid ""
"Return the class of the supplied object, which may be any Lisp object, not\n"
"   just a CLOS STANDARD-OBJECT."
msgstr ""

#: target:code/class.lisp
msgid "Modifing ~(~A~) class ~S; making it writable."
msgstr ""

#: target:code/class.lisp
msgid "Subclassing sealed class ~S; unsealing it."
msgstr ""

#: target:code/class.lisp
msgid ""
"Change in superclasses of class ~S:~%  ~\n"
"\t\t  ~A superclasses: ~S~%  ~\n"
"\t\t  ~A superclasses: ~S"
msgstr ""

#: target:code/class.lisp
msgid ""
"In class ~S:~%  ~\n"
"\t\t    ~:(~A~) definition of superclass ~S incompatible with~%  ~\n"
"\t\t    ~A definition."
msgstr ""

#: target:code/class.lisp
msgid ""
"Change in instance length of class ~S:~%  ~\n"
"\t\t   ~A length: ~D~%  ~\n"
"\t\t   ~A length: ~D"
msgstr ""

#: target:code/class.lisp
msgid ""
"Change in the inheritance structure of class ~S~%  ~\n"
"\t\t between the ~A definition and the ~A definition."
msgstr ""

#: target:code/class.lisp
msgid ""
"Loading a reference to class ~S when the compile~\n"
"\t\t       ~%  time definition was incompatible with the current ~\n"
"\t\t       one."
msgstr ""

#: target:code/class.lisp
msgid "New definition of ~S must be loaded eventually."
msgstr ""

#: target:code/class.lisp
msgid ""
"Any old ~S instances will be in a bad way.~@\n"
"\t\t      I hope you know what you're doing..."
msgstr ""

#: target:code/class.lisp
msgid ""
"Assuming the current definition of ~S is correct, and~@\n"
"\t\t      that the loaded code doesn't care about the ~\n"
"\t\t      incompatibility."
msgstr ""

#: target:code/class.lisp
msgid "Topological sort failed due to constraint on ~S."
msgstr ""

#: target:code/class.lisp
msgid "Something strange with forward layout for ~S:~%  ~S"
msgstr ""

#: target:code/pred.lisp
msgid "Return the type of OBJECT."
msgstr ""

#: target:code/pred.lisp
msgid ""
"Return the element type that will actually be used to implement an array\n"
"   with the specifier :ELEMENT-TYPE Spec."
msgstr ""

#: target:code/pred.lisp
msgid ""
"Return two values indicating the relationship between type1 and type2:\n"
"  T and T: type1 definitely is a subtype of type2.\n"
"  NIL and T: type1 definitely is not a subtype of type2.\n"
"  NIL and NIL: who knows?"
msgstr ""

#: target:code/pred.lisp
msgid "Return T iff OBJECT is of type TYPE."
msgstr ""

#: target:code/pred.lisp
msgid "~@<unknown element type in array type: ~2I~_~S~:>"
msgstr ""

#: target:code/pred.lisp
msgid "Unknown type specifier: ~S"
msgstr ""

#: target:code/pred.lisp
msgid "Invalid type specifier: ~S"
msgstr ""

#: target:code/pred.lisp
msgid "Function types are not a legal argument to TYPEP:~%  ~S"
msgstr ""

#: target:code/pred.lisp
msgid "Class has not yet been defined: ~S"
msgstr ""

#: target:code/pred.lisp
msgid "TYPEP on obsolete object (was class ~S)."
msgstr ""

#: target:code/pred.lisp
msgid "Class is currently invalid: ~S"
msgstr ""

#: target:code/pred.lisp
msgid "Return T if OBJ1 and OBJ2 are the same object, otherwise NIL."
msgstr ""

#: target:code/pred.lisp
msgid ""
"Returns T if X and Y are EQL or if they are structured components\n"
"  whose elements are EQUAL.  Strings and bit-vectors are EQUAL if they\n"
"  are the same length and have indentical components.  Other arrays must be\n"
"  EQ to be EQUAL."
msgstr ""

#: target:code/pred.lisp
msgid ""
"Just like EQUAL, but more liberal in several respects.\n"
"  Numbers may be of different types, as long as the values are identical\n"
"  after coercion.  Characters may differ in alphabetic case.  Vectors and\n"
"  arrays must have identical dimensions and EQUALP elements, but may differ\n"
"  in their type restriction."
msgstr ""

#: target:code/alieneval.lisp
msgid "No alien type class ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "No method ~S"
msgstr ""

#: target:compiler/x86/c-call.lisp target:code/alieneval.lisp
msgid "Method ~S not defined for ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Parse the list structure TYPE as an alien type specifier and return\n"
"   the resultant alien-type structure."
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown alien type: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "No translator for primitive alien type ~S?"
msgstr ""

#: target:code/alieneval.lisp
msgid "Definition missing for alien type ~S?"
msgstr ""

#: target:code/alieneval.lisp
msgid "Attempt to multiple define ~A ~S."
msgstr ""

#: target:code/alieneval.lisp
msgid "Attempt to shadow definition of ~A ~S."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Convert the alien-type structure TYPE back into a list specification of\n"
"   the type."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Define the alien type NAME to be equivalent to TYPE.  Name may be NIL for\n"
"   STRUCT and UNION types, in which case the name is taken from the type\n"
"   specifier."
msgstr ""

#: target:code/alieneval.lisp
msgid "Redefining ~A ~S to be:~%  ~S,~%was:~%  ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "~S is a built-in alien type."
msgstr ""

#: target:code/alieneval.lisp
msgid "Redefining ~S to be:~%  ~S,~%was~%  ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Return T iff TYPE1 and TYPE2 describe equivalent alien types."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Return T iff the alien type TYPE1 is a subtype of TYPE2.  Currently, the\n"
"   only supported subtype relationships are that any pointer type is a\n"
"   subtype of (* t), and any array type's first dimension will match \n"
"   (array <eltype> nil ...).  Otherwise, the two types have to be\n"
"   ALIEN-TYPE-=."
msgstr ""

#: target:code/alieneval.lisp
msgid "Return T iff OBJECT is an alien of type TYPE."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot represent ~S typed aliens."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot pass aliens of type ~S as arguments to call-out"
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot return aliens of type ~S from call-out"
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot extract ~D bit integers."
msgstr ""

#: target:code/alieneval.lisp
msgid "Redefining alien enum ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown enum type: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Empty enum type: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "An enumeration must contain at least one element."
msgstr ""

#: target:code/alieneval.lisp
msgid "Enumeration element ~S is not a keyword."
msgstr ""

#: target:code/alieneval.lisp
msgid "Element value ~S is not an integer."
msgstr ""

#: target:code/alieneval.lisp
msgid "Element value ~S used more than once."
msgstr ""

#: target:code/alieneval.lisp
msgid "Enumeration element ~S used more than once."
msgstr ""

#: target:code/alieneval.lisp
msgid "Can't represent enums needing more than 32 bits."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot deposit aliens of type ~S (unknown size)."
msgstr ""

#: target:code/alieneval.lisp
msgid "First dimension is not a non-negative fixnum or NIL: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Dimension is not a non-negative fixnum: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown size: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown alignment: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "A hash table used to detect cycles while comparing record types."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Test if TYPE1 and TYPE2 are in the *MATCH-HISTORY*.\n"
"If so return true; otherwise call ALTERNATIVE."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot use values types here."
msgstr ""

#: target:code/alieneval.lisp
msgid "Badly formed alien name."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Define NAME as an external alien variable of type TYPE.  NAME should be\n"
"   a list of a string holding the alien name and a symbol to use as the "
"Lisp\n"
"   name.  If NAME is just a symbol or string, then the other name is "
"guessed\n"
"   from the one supplied."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Access the alien variable named NAME, assuming it is of type TYPE.  This\n"
"   is SETFable."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Establish some local alien variables.  Each BINDING is of the form:\n"
"     VAR TYPE [ ALLOCATION ] [ INITIAL-VALUE | EXTERNAL-NAME ]\n"
"   ALLOCATION should be one of:\n"
"     :LOCAL (the default)\n"
"       The alien is allocated on the stack, and has dynamic extent.\n"
"     :STATIC\n"
"       The alien is allocated on the heap, and has infinate extent.  The "
"alien\n"
"       is allocated at load time, so the same piece of memory is used each "
"time\n"
"       this form executes.\n"
"     :EXTERN\n"
"       No alien is allocated, but VAR is established as a local name for\n"
"       the external alien given by EXTERNAL-NAME."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Return true if X (which must be an Alien pointer) is null, false otherwise."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Convert the System-Area-Pointer SAP to an Alien of the specified Type (not\n"
"   evaluated.)  Type must be pointer-like."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot make aliens of type ~S out of SAPs"
msgstr ""

#: target:code/alieneval.lisp
msgid "Return a System-Area-Pointer pointing to Alien's data."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Allocate an alien of type TYPE and return an alien pointer to it.  If SIZE\n"
"   is supplied, how it is interpreted depends on TYPE.  If TYPE is an array\n"
"   type, SIZE is used as the first dimension for the allocated array.  If "
"TYPE\n"
"   is not an array, then SIZE is the number of elements to allocate.  The\n"
"   memory is allocated using ``malloc'', so it can be passed to foreign\n"
"   functions which use ``free''."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot override the size of zero-dimensional arrays."
msgstr ""

#: target:code/alieneval.lisp
msgid "Size of ~S unknown."
msgstr ""

#: target:code/alieneval.lisp
msgid "Alignment of ~S unknown."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Dispose of the storage pointed to by ALIEN.  ALIEN must have been allocated\n"
"   by MAKE-ALIEN or ``malloc''."
msgstr ""

#: target:code/alieneval.lisp
msgid "No slot named ~S in ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Extract SLOT from the Alien STRUCT or UNION ALIEN.  May be set with SETF."
msgstr ""

#: target:code/alieneval.lisp
msgid "Incorrect number of indices when derefing ~S: ~D"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"De-reference an Alien pointer or array.  If an array, the indices are used\n"
"   as the indices of the array element to access.  If a pointer, one index "
"can\n"
"   optionally be specified, giving the equivalent of C pointer arithmetic."
msgstr ""

#: target:code/alieneval.lisp
msgid "Something is wrong; local-alien-info not found: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "~S isn't forced to memory.  Something went wrong."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Return an Alien pointer to the data addressed by Expr, which must be a call\n"
"   to SLOT or DEREF, or a reference to an Alien variable."
msgstr ""

#: target:code/alieneval.lisp
msgid "Something is wrong, local-alien-info not found: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "~S is not a valid L-value"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Convert ALIEN to an Alien of the specified TYPE (not evaluated).  Both "
"types\n"
"   must be Alien array, pointer or function types."
msgstr ""

#: target:code/alieneval.lisp
msgid "~S cannot be cast."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot cast to alien type ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Return the size of the alien type TYPE.  UNITS specifies the units to\n"
"   use and can be either :BITS, :BYTES, or :WORDS."
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown size for alien type ~S."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Call the foreign function ALIEN with the specified arguments.  ALIEN's\n"
"   type specifies the argument and result types."
msgstr ""

#: target:code/alieneval.lisp
msgid "Wrong number of arguments for ~S~%Expected ~D, got ~D."
msgstr ""

#: target:code/alieneval.lisp
msgid "~S is not an alien function."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Def-Alien-Routine Name Result-Type\n"
"                    {(Arg-Name Arg-Type [Style])}*\n"
"\n"
"  Define a foreign interface function for the routine with the specified "
"Name,\n"
"  which may be either a string, symbol or list of the form (string symbol).\n"
"  Return-Type is the Alien type for the function return value.  VOID may be\n"
"  used to specify a function with no result.\n"
"\n"
"  The remaining forms specify individual arguments that are passed to the\n"
"  routine.  Arg-Name is a symbol that names the argument, primarily for\n"
"  documentation.  Arg-Type is the C-Type of the argument.  Style specifies "
"the\n"
"  way that the argument is passed.\n"
"\n"
"  :IN\n"
"        An :In argument is simply passed by value.  The value to be passed "
"is\n"
"        obtained from argument(s) to the interface function.  No values are\n"
"        returned for :In arguments.  This is the default mode.\n"
"\n"
"  :OUT\n"
"        The specified argument type must be a pointer to a fixed sized "
"object.\n"
"        A pointer to a preallocated object is passed to the routine, and "
"the\n"
"        the object is accessed on return, with the value being returned "
"from\n"
"        the interface function.  :OUT and :IN-OUT cannot be used with "
"pointers\n"
"        to arrays, records or functions.\n"
"\n"
"  :COPY\n"
"        Similar to :IN, except that the argument values are stored in on\n"
"        the stack, and a pointer to the object is passed instead of\n"
"        the values themselves.\n"
"\n"
"  :IN-OUT\n"
"        A combination of :OUT and :COPY.  A pointer to the argument is "
"passed,\n"
"        with the object being initialized from the supplied argument and\n"
"        the return value being determined by accessing the object on return."
msgstr ""

#: target:code/alieneval.lisp
msgid "Bogus argument style ~S in ~S."
msgstr ""

#: target:code/alieneval.lisp
msgid "Can't use :out or :in-out on pointer-like type:~%  ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"A callback consists of a piece assembly code -- the trampoline --\n"
"and a lisp function.  We store the function type (including return\n"
"type and arg types), so we can detect incompatible redefinitions."
msgstr ""

#: target:code/alieneval.lisp
msgid "Vector of all callbacks."
msgstr ""

#: target:pcl/simple-streams/string.lisp target:compiler/tn.lisp
#: target:compiler/main.lisp target:code/describe.lisp
#: target:code/debug-int.lisp target:code/debug-info.lisp
#: target:code/foreign-linkage.lisp target:code/reader.lisp
#: target:code/stream.lisp target:code/hash-new.lisp target:code/array.lisp
#: target:code/alieneval.lisp
msgid "~S is not an array with a fill-pointer."
msgstr ""

#: target:code/alieneval.lisp
msgid "Unable to mprotect ~S bytes (~S) at ~S (~S).  Callbacks may not work."
msgstr ""

#: target:code/alieneval.lisp
msgid "Return the trampoline pointer for the callback NAME."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"~\n"
"Attempt to redefine callback with incompatible return type.\n"
"   Old type was: ~A \n"
"    New type is: ~A"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"~\n"
"Create new trampoline (old trampoline calls old lisp function)."
msgstr ""

#: target:code/alieneval.lisp
msgid "Unsupported argument type: ~A"
msgstr ""

#: target:code/alieneval.lisp
msgid "Unsupported return type: ~A"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"(defcallback NAME (RETURN-TYPE {(ARG-NAME ARG-TYPE)}*)\n"
"     {doc-string} {decls}* {FORM}*)\n"
"\n"
"Define a function which can be called by foreign code.  The pointer\n"
"returned by (callback NAME), when called by foreign code, invokes the\n"
"lisp function.  The lisp function expects alien arguments of the\n"
"specified ARG-TYPEs and returns an alien of type RETURN-TYPE.\n"
"\n"
"If (callback NAME) is already a callback function pointer, its value\n"
"is not changed (though it's arranged that an updated version of the\n"
"lisp callback function will be called).  This feature allows for\n"
"incremental redefinition of callback functions."
msgstr ""

#: target:code/sap.lisp
msgid "Return T iff the SAP X points to a smaller address then the SAP Y."
msgstr ""

#: target:code/sap.lisp
msgid ""
"Return T iff the SAP X points to a smaller or the same address as\n"
"   the SAP Y."
msgstr ""

#: target:code/sap.lisp
msgid "Return T iff the SAP X points to the same address as the SAP Y."
msgstr ""

#: target:code/sap.lisp
msgid ""
"Return T iff the SAP X points to a larger or the same address as\n"
"   the SAP Y."
msgstr ""

#: target:code/sap.lisp
msgid "Return T iff the SAP X points to a larger address then the SAP Y."
msgstr ""

#: target:code/sap.lisp
msgid "Return a new sap OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Return the byte offset between SAP1 and SAP2."
msgstr ""

#: target:code/sap.lisp
msgid "Converts a System Area Pointer into an integer."
msgstr ""

#: target:code/sap.lisp
msgid "Converts an integer into a System Area Pointer."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the 8-bit byte at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the 16-bit word at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the 32-bit dualword at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the 64-bit quadword at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the 32-bit system-area-pointer at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the 32-bit single-float at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the 64-bit double-float at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the long-float at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the signed 8-bit byte at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the signed 16-bit word at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the signed 32-bit dualword at OFFSET bytes from SAP."
msgstr ""

#: target:code/sap.lisp
msgid "Returns the signed 64-bit quadword at OFFSET bytes from SAP."
msgstr ""

#: target:code/bit-bash.lisp
msgid "The number of bits to process at a time."
msgstr ""

#: target:code/bit-bash.lisp
msgid "The maximum number of bits that can be dealt with during a single call."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Shift NUMBER by COUNT bits, adding zero bits at the ``end'' and removing\n"
"  bits from the ``start.''  On big-endian machines this is a left-shift and\n"
"  on little-endian machines this is a right-shift.  Note: only the low 5/6 "
"bits\n"
"  of count are significant."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Shift NUMBER by COUNT bits, adding zero bits at the ``start'' and removing\n"
"  bits from the ``end.''  On big-endian machines this is a right-shift and\n"
"  on little-endian machines this is a left-shift."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Produce a mask that contains 1's for the COUNT ``start'' bits and 0's for\n"
"  the remaining ``end'' bits.  Only the lower 5 bits of COUNT are "
"significant."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Produce a mask that contains 1's for the COUNT ``end'' bits and 0's for\n"
"  the remaining ``start'' bits.  Only the lower 5 bits of COUNT are\n"
"  significant."
msgstr ""

#: target:code/bit-bash.lisp
msgid "Align the SAP to a word boundry, and update the offset accordingly."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Fill DST with VALUE starting at DST-OFFSET and continuing for LENGTH bits."
msgstr ""

#: target:code/byte-interp.lisp
msgid "This is the interpreter's evaluation stack."
msgstr ""

#: target:code/byte-interp.lisp
msgid "This is the next free element of the interpreter's evaluation stack."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Unknown inline function, id=~D"
msgstr ""

#: target:code/byte-interp.lisp
msgid "Unbound variable: ~S"
msgstr ""

#: target:code/byte-interp.lisp
msgid "Non-list argument to CAR: ~S"
msgstr ""

#: target:code/byte-interp.lisp
msgid "Non-list argument to CDR: ~S"
msgstr ""

#: target:code/byte-interp.lisp
msgid "Undefined XOP."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Wrong number of arguments."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Not enough arguments."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Too many arguments."
msgstr ""

#: target:code/interr.lisp target:code/byte-interp.lisp
msgid "Odd number of keyword arguments."
msgstr ""

#: target:code/interr.lisp target:code/byte-interp.lisp
msgid "Unknown keyword: ~S"
msgstr ""

#: target:code/byte-interp.lisp
msgid "function-end breakpoints not supported."
msgstr ""

#: target:code/array.lisp
msgid "The exclusive upper bound on the rank of an array."
msgstr ""

#: target:code/array.lisp
msgid "The exclusive upper bound any given dimension of an array."
msgstr ""

#: target:code/array.lisp
msgid "The exclusive upper bound on the total number of elements in an array."
msgstr ""

#: target:code/array.lisp
msgid "End ~D is greater than total size ~D."
msgstr ""

#: target:code/array.lisp
msgid "Start ~D is greater than end ~D."
msgstr ""

#: target:code/array.lisp
msgid ""
"List of weak-pointers to static vectors.  Needed for GCing static vectors"
msgstr ""

#: target:code/array.lisp
msgid "Cannot make a static array of element type ~S"
msgstr ""

#: target:code/array.lisp
msgid "Failed to allocate space for static array of length ~S of type ~S"
msgstr ""

#: target:code/array.lisp
msgid ""
"Creates an array of the specified Dimensions and properties.  See the\n"
"  manual for details.\n"
"\n"
"  :Element-type\n"
"      The type of objects that the array can hold \n"
"  :Initial-element\n"
"      Each element of the array is initialized to this value, if supplied.\n"
"      If not supplied, 0 of the appropriate type is used.\n"
"  :Initial-contents\n"
"      The contents of the array are initialized to this.\n"
"  :Adjustable\n"
"      If non-Nil, make an expressly adjustable array.\n"
"  :Fill-pointer\n"
"      For one-dimensional array, set the fill-pointer to the given value.\n"
"      If T, use the actual length of the array.\n"
"  :Displaced-to\n"
"      Create an array that is displaced to the target array specified\n"
"      by :displaced-to.\n"
"  :Displaced-index-offset\n"
"      Index offset to the displaced array.  That is, index 0 of this array "
"is\n"
"      actually index displaced-index-offset of the target displaced array. \n"
"  :Allocation\n"
"      How to allocate the array.  If :MALLOC, a static, nonmovable array is\n"
"      created.  This array is created by calling malloc."
msgstr ""

#: target:code/array.lisp
msgid "Can't specify :displaced-index-offset without :displaced-to"
msgstr ""

#: target:code/array.lisp
msgid "Cannot make an adjustable static array"
msgstr ""

#: target:code/array.lisp
msgid "Cannot make a displaced array static"
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot specify both :initial-element and ~\n"
"\t\t:initial-contents"
msgstr ""

#: target:code/array.lisp
msgid ""
"~D elements in the initial-contents, but the ~\n"
"\t\tvector length is ~D."
msgstr ""

#: target:code/array.lisp
msgid "Only vectors can have fill pointers."
msgstr ""

#: target:code/array.lisp
msgid "Invalid fill-pointer ~D"
msgstr ""

#: target:code/array.lisp
msgid ""
"Neither :initial-element nor :initial-contents ~\n"
"\t\t   can be specified along with :displaced-to"
msgstr ""

#: target:code/array.lisp
msgid ""
"One can't displace an array of type ~S into ~\n"
"                           another of type ~S."
msgstr ""

#: target:code/array.lisp
msgid "~S doesn't have enough elements."
msgstr ""

#: target:code/array.lisp
msgid "~&Freeing foreign vector at #x~X~%"
msgstr ""

#: target:code/array.lisp
msgid "Finalizing static vectors ~S~%"
msgstr ""

#: target:code/array.lisp
msgid "static vector ~A.  header = ~X~%"
msgstr ""

#: target:code/array.lisp
msgid "  static vector ~A in use~%"
msgstr ""

#: target:code/array.lisp
msgid "  Free static vector ~A~%"
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot supply both :initial-contents and :initial-element to\n"
"            either make-array or adjust-array."
msgstr ""

#: target:code/array.lisp
msgid "~S cannot be used to initialize an array of type ~S."
msgstr ""

#: target:code/array.lisp
msgid ""
"Malformed :initial-contents.  ~S is not a ~\n"
"\t\t\t        sequence, but ~D more layer~:P needed."
msgstr ""

#: target:code/array.lisp
msgid ""
"Malformed :initial-contents.  Dimension of ~\n"
"\t\t\t        axis ~D is ~D, but ~S is ~D long."
msgstr ""

#: target:code/array.lisp
msgid "Constructs a simple-vector from the given objects."
msgstr ""

#: target:code/array.lisp
msgid "Wrong number of subscripts, ~D, for array of rank ~D"
msgstr ""

#: target:code/array.lisp
msgid "Invalid index ~D~[~;~:; on axis ~:*~D~] in ~S"
msgstr ""

#: target:code/array.lisp
msgid "Invalid index ~D in ~S"
msgstr ""

#: target:code/array.lisp
msgid "Returns T if the Subscipts are in bounds for the Array, Nil otherwise."
msgstr ""

#: target:code/array.lisp
msgid "Returns the element of the Array specified by the Subscripts."
msgstr ""

#: target:code/array.lisp
msgid ""
"Returns the element of array corressponding to the row-major index.  This "
"is\n"
"   SETF'able."
msgstr ""

#: target:code/array.lisp
msgid "Returns the Index'th element of the given Simple-Vector."
msgstr ""

#: target:code/array.lisp
msgid "Returns the bit from the Bit-Array at the specified Subscripts."
msgstr ""

#: target:code/array.lisp
msgid "Returns the bit from the Simple-Bit-Array at the specified Subscripts."
msgstr ""

#: target:code/array.lisp
msgid "Returns the type of the elements of the array"
msgstr ""

#: target:code/array.lisp
msgid "Returns the number of dimensions of the Array."
msgstr ""

#: target:code/array.lisp
msgid "Returns length of dimension Axis-Number of the Array."
msgstr ""

#: target:code/array.lisp
msgid "Vector axis is not zero: ~S"
msgstr ""

#: target:code/array.lisp
msgid "~D is too big; ~S only has ~D dimension~:P"
msgstr ""

#: target:code/array.lisp
msgid "Returns a list whose elements are the dimensions of the array"
msgstr ""

#: target:code/array.lisp
msgid "Returns the total number of elements in the Array."
msgstr ""

#: target:code/array.lisp
msgid ""
"Returns values of :displaced-to and :displaced-index-offset options to\n"
"   make-array, or the defaults nil and 0 if not a displaced array."
msgstr ""

#: target:code/array.lisp
msgid ""
"Returns T if (adjust-array array...) would return an array identical\n"
"   to the argument, this happens for complex arrays."
msgstr ""

#: target:code/array.lisp
msgid "Returns T if the given Array has a fill pointer, or Nil otherwise."
msgstr ""

#: target:code/array.lisp
msgid "Returns the Fill-Pointer of the given Vector."
msgstr ""

#: target:code/array.lisp
msgid "New fill pointer, ~S, is larger than the length of the vector."
msgstr ""

#: target:code/array.lisp
msgid ""
"Attempts to set the element of Array designated by the fill pointer\n"
"   to New-El and increment fill pointer by one.  If the fill pointer is\n"
"   too large, Nil is returned, otherwise the index of the pushed element "
"is \n"
"   returned."
msgstr ""

#: target:code/array.lisp
msgid ""
"Like Vector-Push except that if the fill pointer gets too large, the\n"
"   Array is extended rather than Nil being returned."
msgstr ""

#: target:code/array.lisp
msgid ""
"Attempts to decrease the fill-pointer by 1 and return the element\n"
"   pointer to by the new fill pointer.  If the original value of the fill\n"
"   pointer is 0, an error occurs."
msgstr ""

#: target:code/array.lisp
msgid "Nothing left to pop."
msgstr ""

#: target:code/array.lisp
msgid "Adjusts the Array's dimensions to the given Dimensions and stuff."
msgstr ""

#: target:code/array.lisp
msgid "Number of dimensions not equal to rank of array."
msgstr ""

#: target:code/array.lisp
msgid "New element type, ~S, is incompatible with old."
msgstr ""

#: target:code/array.lisp
msgid "Static arrays are not adjustable."
msgstr ""

#: target:code/array.lisp
msgid "Multidimensional arrays can't have fill pointers."
msgstr ""

#: target:code/array.lisp
msgid ""
"Initial contents may not be specified with ~\n"
"\t\t the :initial-element or :displaced-to option."
msgstr ""

#: target:code/array.lisp
msgid ""
"The :initial-element option may not be specified ~\n"
"\t       with :displaced-to."
msgstr ""

#: target:code/array.lisp
msgid ""
"One can't displace an array of type ~S into another of ~\n"
"\t               type ~S."
msgstr ""

#: target:code/array.lisp
msgid "The :displaced-to array is too small."
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot adjust-array an array (~S) to a size (~S) that is ~\n"
"\t            smaller than it's fill pointer (~S)."
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot supply a non-NIL value (~S) for :fill-pointer ~\n"
"\t   in adjust-array unless the array (~S) was originally ~\n"
" \t   created with a fill pointer."
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot supply a value for :fill-pointer (~S) that is larger ~\n"
"\t     than the new length of the vector (~S)."
msgstr ""

#: target:code/array.lisp
msgid "Bogus value for :fill-pointer in adjust-array: ~S"
msgstr ""

#: target:code/array.lisp
msgid ""
"Destructively alters the Vector, changing its length to New-Size, which\n"
"   must be less than or equal to its current size."
msgstr ""

#: target:code/array.lisp
msgid "Fills in array header with provided information.  Returns array."
msgstr ""

#: target:code/array.lisp
msgid "~S and ~S do not have the same dimensions."
msgstr "~S  ~S     ."

#: target:code/array.lisp
msgid ""
"Performs a bit-wise logical NOT on the elements of BIT-ARRAY,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array is\n"
"  created.  Both arrays must have the same rank and dimensions."
msgstr ""

#: target:code/hash-new.lisp
msgid "Structure used to implement hash tables."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"Almost-Primify returns an almost prime number greater than or equal\n"
"   to NUM."
msgstr ""

#: target:code/hash-new.lisp
msgid "Define a new kind of hash table test."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"Creates and returns a new hash table.  The keywords are as follows:\n"
"     :TEST -- Indicates what kind of test to use.  Only EQ, EQL, EQUAL,\n"
"       and EQUALP are currently supported.\n"
"     :SIZE -- A hint as to how many elements will be put in this hash\n"
"       table.\n"
"     :REHASH-SIZE -- Indicates how to expand the table when it fills up.\n"
"       If an integer, add space for that many elements.  If a floating\n"
"       point number (which must be greater than 1.0), multiple the size\n"
"       by that amount.\n"
"     :REHASH-THRESHOLD -- Indicates how dense the table can become before\n"
"       forcing a rehash.  Can be any positive number <= to 1, with density\n"
"       approaching zero as the threshold approaches 0.  Density 1 means an\n"
"       average of one entry per bucket.\n"
"   CMUCL Extension:\n"
"     :WEAK-P -- Weak hash table.  Can only be used when the key is 'eq or "
"'eql.\n"
"                An entry in the table is remains if the condition holds:\n"
"\n"
"                :KEY            -- key is referenced elsewhere\n"
"                :VALUE          -- value is referenced elsewhere\n"
"                :KEY-AND-VALUE  -- key and value are referenced elsewhere\n"
"                :KEY-OR-VALUE   -- key or value is referenced elsewhere\n"
"\n"
"                If the condition does not hold, the entry is removed.  For\n"
"                backward compatibility, a value of T is the same as :KEY."
msgstr ""

#: target:code/hash-new.lisp
msgid "Unknown :TEST for MAKE-HASH-TABLE: ~S"
msgstr ""

#: target:code/hash-new.lisp
msgid "Returns the number of entries in the given HASH-TABLE."
msgstr ""

#: target:code/hash-new.lisp
msgid "Return the rehash-size HASH-TABLE was created with."
msgstr ""

#: target:code/hash-new.lisp
msgid "Return the rehash-threshold HASH-TABLE was created with."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"Return a size that can be used with MAKE-HASH-TABLE to create a hash\n"
"   table that can hold however many entries HASH-TABLE can hold without\n"
"   having to be grown."
msgstr ""

#: target:code/hash-new.lisp
msgid "Return the test HASH-TABLE was created with."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"Return T if HASH-TABLE will not keep entries for keys that would\n"
"   otherwise be garbage, and NIL if it will."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"Finds the entry in HASH-TABLE whose key is KEY and returns the associated\n"
"   value and T as multiple values, or returns DEFAULT and NIL if there is "
"no\n"
"   such entry.  Entries can be added using SETF."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"Remove the entry in HASH-TABLE associated with KEY.  Returns T if there\n"
"   was such an entry, and NIL if not."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"This removes all the entries from HASH-TABLE and returns the hash table\n"
"   itself."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"This removes all the entries from HASH-TABLE and returns the hash table\n"
"   itself, shrinking the size to free memory."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"For each entry in HASH-TABLE, calls MAP-FUNCTION on the key and value\n"
"   of the entry; returns NIL."
msgstr ""

#: target:code/hash-new.lisp
msgid ""
"WITH-HASH-TABLE-ITERATOR ((function hash-table) &body body)\n"
"   provides a method of manually looping over the elements of a hash-table.\n"
"   FUNCTION is bound to a generator-macro that, within the scope of the\n"
"   invocation, returns one or three values. The first value tells whether\n"
"   any objects remain in the hash table. When the first value is non-NIL, \n"
"   the second and third values are the key and the value of the next object."
msgstr ""

#: target:code/hash-new.lisp
msgid "What kind of instance is this?"
msgstr ""

#: target:code/hash-new.lisp
msgid "Computes a hash code for S-EXPR and returns it as an integer."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a list of the Nth element of each of the sequences.  Used by MAP\n"
"   and friends."
msgstr ""

#: target:code/seq.lisp
msgid "Returns a sequence of the same type as SEQUENCE and the given LENGTH."
msgstr ""

#: target:code/seq.lisp
msgid "Returns the broad class of which TYPE is a specific subclass."
msgstr ""

#: target:code/seq.lisp
msgid "NIL output type invalid for this sequence function."
msgstr ""

#: target:code/seq.lisp
msgid "~S is too hairy for sequence functions."
msgstr ""

#: target:code/seq.lisp
msgid "~S is a bad type specifier for sequence functions."
msgstr ""

#: target:code/seq.lisp
msgid "Error in ~S: ~S: Index too large."
msgstr ""

#: target:code/seq.lisp
msgid "Returns a sequence of the given TYPE and LENGTH."
msgstr ""

#: target:code/seq.lisp
msgid "Returns the element of SEQUENCE specified by INDEX."
msgstr ""

#: target:code/seq.lisp
msgid "Store NEWVAL as the component of SEQUENCE specified by INDEX."
msgstr ""

#: target:code/seq.lisp
msgid "Returns an integer that is the length of SEQUENCE."
msgstr ""

#: target:code/seq.lisp
msgid "~S is a bad type specifier for sequences"
msgstr ""

#: target:code/seq.lisp
msgid "Shouldn't happen!  Weird type"
msgstr ""

#: target:code/seq.lisp
msgid ""
"The length of ~S does not match the specified ~\n"
"                          length of ~S."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence of the given Type and Length, with elements initialized\n"
"  to :Initial-Element."
msgstr ""

#: target:code/seq.lisp
msgid ""
"The length of ~S does not match the specified ~\n"
"                           length  of ~S."
msgstr ""

#: target:code/seq.lisp
msgid "~S is a bad type specifier for sequences."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a copy of a subsequence of SEQUENCE starting with element number \n"
"   START and continuing to the end of SEQUENCE or the optional END."
msgstr ""

#: target:code/seq.lisp
msgid "Returns a copy of SEQUENCE which is EQUAL to SEQUENCE but not EQ."
msgstr ""

#: target:code/seq.lisp
msgid "Replace the specified elements of SEQUENCE with ITEM."
msgstr ""

#: target:code/seq.lisp
msgid ""
"The target sequence is destructively modified by copying successive\n"
"   elements into it from the source sequence."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a new sequence containing the same elements but in reverse order."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence of the same elements in reverse order; the argument\n"
"   is destroyed."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a new sequence of all the argument sequences concatenated together\n"
"  which shares no structure with the original argument sequences of the\n"
"  specified OUTPUT-TYPE-SPEC."
msgstr ""

#: target:code/seq.lisp
msgid ""
"FUNCTION must take as many arguments as there are sequences provided.  The \n"
"   result is a sequence such that element i is the result of applying "
"FUNCTION\n"
"   to element i of each of the argument sequences."
msgstr ""

#: target:code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then \n"
"   possibly to those with index 1, and so on.  SOME returns the first \n"
"   non-() value encountered, or () if the end of a sequence is reached."
msgstr ""

#: target:code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then\n"
"   possibly to those with index 1, and so on.  EVERY returns () as soon\n"
"   as any invocation of PREDICATE returns (), or T if every invocation\n"
"   is non-()."
msgstr ""

#: target:code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then \n"
"   possibly to those with index 1, and so on.  NOTANY returns () as soon\n"
"   as any invocation of PREDICATE returns a non-() value, or T if the end\n"
"   of a sequence is reached."
msgstr ""

#: target:code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then\n"
"   possibly to those with index 1, and so on.  NOTEVERY returns T as soon\n"
"   as any invocation of PREDICATE returns (), or () if every invocation\n"
"   is non-()."
msgstr ""

#: target:code/seq.lisp
msgid ""
"The specified Sequence is ``reduced'' using the given Function.\n"
"  See manual for details."
msgstr ""

#: target:code/seq.lisp
msgid "Coerces the Object to an object of type Output-Type-Spec."
msgstr ""

#: target:code/seq.lisp
msgid "~S can't be converted to type ~S."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence formed by destructively removing the specified Item from\n"
"  the given Sequence."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence formed by destructively removing the elements satisfying\n"
"  the specified Predicate from the given Sequence."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence formed by destructively removing the elements not\n"
"  satisfying the specified Predicate from the given Sequence."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a copy of SEQUENCE with elements satisfying the test (default is\n"
"   EQL) with ITEM removed."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a copy of sequence with elements such that predicate(element)\n"
"   is non-null are removed"
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a copy of sequence with elements such that predicate(element)\n"
"   is null are removed"
msgstr ""

#: target:code/seq.lisp
msgid ""
"The elements of Sequence are compared pairwise, and if any two match,\n"
"   the one occuring earlier is discarded, unless FROM-END is true, in\n"
"   which case the one later in the sequence is discarded.  The resulting\n"
"   sequence is returned.\n"
"\n"
"   The :TEST-NOT argument is deprecated."
msgstr ""

#: target:code/seq.lisp
msgid ""
"The elements of Sequence are examined, and if any two match, one is\n"
"   discarded.  The resulting sequence, which may be formed by destroying "
"the\n"
"   given sequence, is returned.\n"
"\n"
"   The :TEST-NOT argument is deprecated."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements equal to Old are replaced with New.  See manual\n"
"  for details."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements satisfying the Test are replaced with New.  See\n"
"  manual for details."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements not satisfying the Test are replaced with New.\n"
"  See manual for details."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements equal to Old are replaced with New.  The "
"Sequence\n"
"  may be destroyed.  See manual for details."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"   except that all elements satisfying the Test are replaced with New.  The\n"
"   Sequence may be destroyed.  See manual for details."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"   except that all elements not satisfying the Test are replaced with New.\n"
"   The Sequence may be destroyed.  See manual for details."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns the zero-origin index of the first element in SEQUENCE\n"
"   satisfying the test (default is EQL) with the given ITEM"
msgstr ""

#: target:code/seq.lisp
msgid "Returns the zero-origin index of the first element satisfying test(el)"
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns the zero-origin index of the first element not satisfying test(el)"
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns the first element in SEQUENCE satisfying the test (default\n"
"   is EQL) with the given ITEM"
msgstr ""

#: target:code/seq.lisp
msgid "Returns the first element in SEQUENCE satisfying the test."
msgstr ""

#: target:code/seq.lisp
msgid "Returns the first element in SEQUENCE not satisfying the test."
msgstr ""

#: target:code/seq.lisp
msgid ""
"Returns the number of elements in SEQUENCE satisfying a test with ITEM,\n"
"   which defaults to EQL."
msgstr ""

#: target:code/seq.lisp
msgid ":TEST and :TEST-NOT are both present."
msgstr ""

#: target:code/seq.lisp
msgid "Returns the number of elements in SEQUENCE satisfying TEST(el)."
msgstr ""

#: target:code/seq.lisp
msgid ""
"The specified subsequences of Sequence1 and Sequence2 are compared\n"
"   element-wise.  If they are of equal length and match in every element, "
"the\n"
"   result is NIL.  Otherwise, the result is a non-negative integer, the "
"index\n"
"   within Sequence1 of the leftmost position at which they fail to match; "
"or,\n"
"   if one is shorter than and a matching prefix of the other, the index "
"within\n"
"   Sequence1 beyond the last position tested is returned.  If a non-Nil\n"
"   :From-End keyword argument is given, then one plus the index of the\n"
"   rightmost position in which the sequences differ is returned."
msgstr ""

#: target:code/seq.lisp
msgid ""
"A search is conducted using EQL for the first subsequence of sequence2 \n"
"   which element-wise matches sequence1.  If there is such a subsequence "
"in \n"
"   sequence2, the index of the its leftmost element is returned; \n"
"   otherwise () is returned."
msgstr ""

#: target:code/mipsstrops.lisp
msgid ""
"Compares the substrings specified by String1 and String2 and returns\n"
"NIL if the strings are String=, or the lowest index of String1 in\n"
"which the two differ. If one string is longer than the other and the\n"
"shorter is a prefix of the longer, the length of the shorter + start1 is\n"
"returned. This would be done on the Vax with CMPC3. The arguments must\n"
"be simple strings."
msgstr ""

#: target:code/mipsstrops.lisp
msgid "Like %sp-string-compare, only backwards."
msgstr ""

#: target:code/mipsstrops.lisp
msgid ""
"%SP-Find-Character-With-Attribute  String, Start, End, Table, Mask\n"
"  The codes of the characters of String from Start to End are used as "
"indices\n"
"  into the Table, which is a U-Vector of 8-bit bytes. When the number "
"picked\n"
"  up from the table bitwise ANDed with Mask is non-zero, the current\n"
"  index into the String is returned. The corresponds to SCANC on the Vax."
msgstr ""

#: target:code/mipsstrops.lisp
msgid "Like %SP-Find-Character-With-Attribute, only sdrawkcaB."
msgstr ""

#: target:code/mipsstrops.lisp
msgid ""
"%SP-Find-Character  String, Start, End, Character\n"
"  Searches String for the Character from Start to End.  If the character is\n"
"  found, the corresponding index into String is returned, otherwise NIL is\n"
"  returned."
msgstr ""

#: target:code/mipsstrops.lisp
msgid ""
"%SP-Reverse-Find-Character  String, Start, End, Character\n"
"  Searches String for Character from End to Start.  If the character is\n"
"  found, the corresponding index into String is returned, otherwise NIL is\n"
"  returned."
msgstr ""

#: target:code/mipsstrops.lisp
msgid ""
"%SP-Skip-Character  String, Start, End, Character\n"
"  Returns the index of the first character between Start and End which\n"
"  is not Char=  to Character, or NIL if there is no such character."
msgstr ""

#: target:code/mipsstrops.lisp
msgid ""
"%SP-Skip-Character  String, Start, End, Character\n"
"  Returns the index of the last character between Start and End which\n"
"  is not Char=  to Character, or NIL if there is no such character."
msgstr ""

#: target:code/mipsstrops.lisp
msgid ""
"%SP-String-Search  String1, Start1, End1, String2, Start2, End2\n"
"   Searches for the substring of String1 specified in String2.\n"
"   Returns an index into String2 or NIL if the substring wasn't\n"
"   found."
msgstr ""

#: target:code/bsd-os.lisp
msgid "Unix system call getrusage failed: ~A."
msgstr ""

#: target:code/bsd-os.lisp
msgid "Getpagesize failed: ~A"
msgstr ""

#: target:code/bignum.lisp
msgid ""
"When the bignum pieces are smaller than this many words, we use the\n"
"classical multiplication algorithm instead of recursing all the way\n"
"down to individual words."
msgstr ""

#: target:code/bignum.lisp
msgid "Use Karatsuba if the bignums have at least this many bits"
msgstr ""

#: target:code/bignum.lisp
msgid "WITH-BIGNUM-BUFFERS ({(var size [init])}*) Form*"
msgstr ""

#: target:code/bignum.lisp
msgid "Unexpected zero bignums?"
msgstr ""

#: target:code/bignum.lisp
msgid "Can't represent result of left shift."
msgstr ""

#: target:code/bignum.lisp
msgid "Too large to be represented as a ~S:~%  ~S"
msgstr ""

#: target:code/numbers.lisp
msgid "More types than vars."
msgstr ""

#: target:code/numbers.lisp
msgid "Duplicate case: ~S."
msgstr ""

#: target:code/numbers.lisp
msgid "More vars than types."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"NUMBER-DISPATCH ({(Var Type)}*) {((Type*) Form*) | (Symbol Arg*)}*\n"
"  A vaguely case-like macro that does number cross-product dispatches.  The\n"
"  Vars are the variables we are dispatching off of.  The Type paired with "
"each\n"
"  Var is used in the error message when no case matches.  Each case "
"specifies a\n"
"  Type for each var, and is executed when that signature holds.  A type may "
"be\n"
"  a list (FOREACH Each-Type*), causing that case to be repeatedly "
"instantiated\n"
"  for every Each-Type.  In the body of each case, any list of the form\n"
"  (DISPATCH-TYPE Var-Name) is substituted with the type of that var in that\n"
"  instance of the case.\n"
"\n"
"  As an alternate to a case spec, there may be a form whose CAR is a "
"symbol.\n"
"  In this case, we apply the CAR of the form to the CDR and treat the result "
"of\n"
"  the call as a list of cases.  This process is not applied recursively."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the element type of the most specialized COMPLEX number type that\n"
"   can hold parts of type Spec."
msgstr ""

#: target:code/numbers.lisp
msgid "Assume this is a subtype of REAL anyway."
msgstr ""

#: target:code/numbers.lisp
msgid "Cannot determine if ~S is a subtype of REAL."
msgstr ""

#: target:code/numbers.lisp
msgid "Complex numbers cannot have components of type ~S."
msgstr ""

#: target:code/numbers.lisp
msgid "Builds a complex number from the specified components."
msgstr ""

#: target:code/numbers.lisp
msgid "Extracts the real part of a number."
msgstr ""

#: target:code/numbers.lisp
msgid "Extracts the imaginary part of a number."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the complex conjugate of NUMBER.  For non-complex numbers, this is\n"
"  an identity."
msgstr ""

#: target:code/numbers.lisp
msgid "If NUMBER is zero, return NUMBER, else return (/ NUMBER (ABS NUMBER))."
msgstr ""

#: target:code/numbers.lisp
msgid "Return the numerator of NUMBER, which must be rational."
msgstr ""

#: target:code/numbers.lisp
msgid "Return the denominator of NUMBER, which must be rational."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the sum of its arguments.  With no args, returns 0."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the product of its arguments.  With no args, returns 1."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Subtracts the second and all subsequent arguments from the first.\n"
"  With one arg, negates it."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Divides the first arg by each of the following arguments, in turn.\n"
"  With one arg, returns reciprocal."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns NUMBER + 1."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns NUMBER - 1."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns number (or number/divisor) as an integer, rounded toward 0.\n"
"  The second returned value is the remainder."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the greatest integer not greater than number, or number/divisor.\n"
"  The second returned value is (mod number divisor)."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the smallest integer not less than number, or number/divisor.\n"
"  The second returned value is the remainder."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Rounds number (or number/divisor) to nearest integer.\n"
"  The second returned value is the remainder."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns second result of TRUNCATE."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns second result of FLOOR."
msgstr ""

#: target:code/numbers.lisp
msgid "Same as TRUNCATE, but returns first value as a float."
msgstr ""

#: target:code/numbers.lisp
msgid "Same as FLOOR, but returns first value as a float."
msgstr ""

#: target:code/numbers.lisp
msgid "Same as CEILING, but returns first value as a float."
msgstr ""

#: target:code/numbers.lisp
msgid "Same as ROUND, but returns first value as a float."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns T if all of its arguments are numerically equal, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns T if no two of its arguments are numerically equal, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns T if its arguments are in strictly increasing order, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns T if its arguments are in strictly decreasing order, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns T if arguments are in strictly non-decreasing order, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns T if arguments are in strictly non-increasing order, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the greatest of its arguments."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the least of its arguments."
msgstr ""

#: target:code/numbers.lisp
msgid "Return T if OBJ1 and OBJ2 represent the same object, otherwise NIL."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the bit-wise or of its arguments.  Args must be integers."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the bit-wise exclusive or of its arguments.  Args must be integers."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the bit-wise and of its arguments.  Args must be integers."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the bit-wise equivalence of its arguments.  Args must be integers."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the complement of the logical AND of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the complement of the logical OR of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the logical AND of (LOGNOT integer1) and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the logical AND of integer1 and (LOGNOT integer2)."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the logical OR of (LOGNOT integer1) and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the logical OR of integer1 and (LOGNOT integer2)."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the bit-wise logical not of integer."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Count the number of 1 bits if INTEGER is positive, and the number of 0 bits\n"
"  if INTEGER is negative."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Predicate which returns T if logand of integer1 and integer2 is not zero."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Predicate returns T if bit index of integer is a 1.  The least\n"
"significant bit of INTEGER is bit 0."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Shifts integer left by count places preserving sign.  - count shifts right."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the number of significant bits in the absolute value of integer."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns a byte specifier which may be used by other byte functions."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the size part of the byte specifier bytespec."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns the position part of the byte specifier bytespec."
msgstr ""

#: target:code/numbers.lisp
msgid "Extract the specified byte from integer, and right justify result."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns T if any of the specified bits in integer are 1's."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Extract the specified byte from integer,  but do not right justify result."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns new integer with newbyte in specified position, newbyte is right "
"justified."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns new integer with newbyte in specified position, newbyte is not right "
"justified."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return 0."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return -1."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return integer1."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return complement of integer1."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return complement of integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return logand of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return logior of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return logxor of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return logeqv of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return log nand of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return lognor of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return logandc1 of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return logandc2 of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return logorc1 of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid "Boole function op, makes BOOLE return logorc2 of integer1 and integer2."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Bit-wise boolean function on two integers.  Function chosen by OP:\n"
"\t0\tBOOLE-CLR\n"
"\t1\tBOOLE-SET\n"
"\t2\tBOOLE-1\n"
"  \t3\tBOOLE-2\n"
"\t4\tBOOLE-C1\n"
"\t5\tBOOLE-C2\n"
"\t6\tBOOLE-AND\n"
"\t7\tBOOLE-IOR\n"
" \t8\tBOOLE-XOR\n"
"\t9\tBOOLE-EQV\n"
"\t10\tBOOLE-NAND\n"
"\t11\tBOOLE-NOR\n"
"\t12\tBOOLE-ANDC1\n"
"\t13\tBOOLE-ANDC2\n"
"\t14\tBOOLE-ORC1\n"
"\t15\tBOOLE-ORC2"
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the greatest common divisor of the arguments, which must be\n"
"  integers.  Gcd with no arguments is defined to be 0."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the least common multiple of one or more integers.  LCM of no\n"
"  arguments is defined to be 1."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns T iff X is a positive prime integer."
msgstr ""

#: target:code/numbers.lisp
msgid ""
"Returns the root of the nearest integer less than n which is a perfect\n"
"   square."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns T if number = 0, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns T if number > 0, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns T if number < 0, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns T if number is odd, NIL otherwise."
msgstr ""

#: target:code/numbers.lisp
msgid "Returns T if number is even, NIL otherwise."
msgstr ""

#: target:code/float-trap.lisp
msgid "Unknown float trap kind: ~S."
msgstr ""

#: target:code/float-trap.lisp
msgid ""
"This function sets options controlling the floating-point hardware.  If a\n"
"  keyword is not supplied, then the current value is preserved.  Possible\n"
"  keywords:\n"
"\n"
"   :TRAPS\n"
"       A list of the exception conditions that should cause traps.  "
"Possible\n"
"       exceptions are :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID,\n"
"       :DIVIDE-BY-ZERO, and on the X86 :DENORMALIZED-OPERAND. Initially\n"
"       all traps except :INEXACT are enabled.\n"
"\n"
"   :ROUNDING-MODE\n"
"       The rounding mode to use when the result is not exact.  Possible "
"values\n"
"       are :NEAREST, :POSITIVE-INFINITY, :NEGATIVE-INFINITY and :ZERO.\n"
"       Initially, the rounding mode is :NEAREST.\n"
"\n"
"   :CURRENT-EXCEPTIONS\n"
"   :ACCRUED-EXCEPTIONS\n"
"       These arguments allow setting of the exception flags.  The main use "
"is\n"
"       setting the accrued exceptions to NIL to clear them.\n"
"\n"
"   :FAST-MODE\n"
"       Set the hardware's \"fast mode\" flag, if any.  When set, IEEE\n"
"       conformance or debuggability may be impaired.  Some machines may not\n"
"       have this feature, in which case the value is always NIL.\n"
"\n"
"   GET-FLOATING-POINT-MODES may be used to find the floating point modes\n"
"   currently in effect."
msgstr ""

#: target:code/float-trap.lisp
msgid "Unknown rounding mode: ~S."
msgstr ""

#: target:code/float-trap.lisp
msgid ""
"This function returns a list representing the state of the floating point\n"
"  modes.  The list is in the same format as the keyword arguments to\n"
"  SET-FLOATING-POINT-MODES, i.e. \n"
"      (apply #'set-floating-point-modes (get-floating-point-modes))\n"
"\n"
"  sets the floating point modes to their current values (and thus is a no-"
"op)."
msgstr ""

#: target:code/float-trap.lisp
msgid ""
"Current-Float-Trap Trap-Name*\n"
"  Return true if any of the named traps are currently trapped, false\n"
"  otherwise."
msgstr ""

#: target:code/float-trap.lisp
msgid "SIGFPE with no exceptions currently enabled?"
msgstr ""

#: target:code/float-trap.lisp
msgid ""
"Execute BODY with the floating point exceptions listed in TRAPS\n"
"  masked (disabled).  TRAPS should be a list of possible exceptions\n"
"  which includes :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID and\n"
"  :DIVIDE-BY-ZERO and on the X86 :DENORMALIZED-OPERAND. The respective\n"
"  accrued exceptions are cleared at the start of the body to support\n"
"  their testing within, and restored on exit."
msgstr ""

#: target:code/float.lisp
msgid "Return true if the float X is denormalized."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns a non-negative number of significant digits in it's float argument.\n"
"  Will be less than FLOAT-DIGITS if denormalized or zero."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns a floating-point number that has the same sign as\n"
"   float1 and, if float2 is given, has the same absolute value\n"
"   as float2."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns a non-negative number of radix-b digits used in the\n"
"   representation of it's argument.  See Common Lisp: The Language\n"
"   by Guy Steele for more details."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns (as an integer) the radix b of its floating-point\n"
"   argument."
msgstr ""

#: target:code/irrat.lisp target:code/float.lisp
msgid "Can't decode NAN or infinity: ~S."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns three values:\n"
"   1) an integer representation of the significand.\n"
"   2) the exponent for the power of 2 that the significand must be "
"multiplied\n"
"      by to get the actual value.  This differs from the DECODE-FLOAT "
"exponent\n"
"      by FLOAT-DIGITS, since the significand has been scaled to have all "
"its\n"
"      digits before the radix point.\n"
"   3) -1 or 1 (i.e. the sign of the argument.)"
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns three values:\n"
"   1) a floating-point number representing the significand.  This is always\n"
"      between 0.5 (inclusive) and 1.0 (exclusive).\n"
"   2) an integer representing the exponent.\n"
"   3) -1.0 or 1.0 (i.e. the sign of the argument.)"
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns the value (* f (expt (float 2 f) ex)), but with no unnecessary loss\n"
"  of precision or overflow."
msgstr ""

#: target:code/float.lisp
msgid ""
"Converts any REAL to a float.  If OTHER is not provided, it returns a\n"
"  SINGLE-FLOAT if NUMBER is not already a FLOAT.  If OTHER is provided, the\n"
"  result is the same float format as OTHER."
msgstr ""

#: target:code/float.lisp
msgid ""
"RATIONAL produces a rational number for any real numeric argument.  This is\n"
"  more efficient than RATIONALIZE, but it assumes that floating-point is\n"
"  completely accurate, giving a result that isn't as pretty."
msgstr ""

#: target:code/float.lisp
msgid ""
"Converts any REAL to a RATIONAL.  Floats are converted to a simple rational\n"
"  representation exploiting the assumption that floats are only accurate to\n"
"  their precision.  RATIONALIZE (and also RATIONAL) preserve the invariant:\n"
"      (= x (float (rationalize x) x))"
msgstr ""

#: target:code/irrat.lisp
msgid "Return e raised to the power NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "The absolute value of ~S exceeds limit ~S."
msgstr ""

#: target:code/irrat.lisp
msgid "Returns BASE raised to the POWER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the logarithm of NUMBER in the base BASE, which defaults to e."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the square root of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Returns the absolute value of the number."
msgstr ""

#: target:code/irrat.lisp
msgid ""
"Returns the angle part of the polar representation of a complex number.\n"
"  For complex numbers, this is (atan (imagpart number) (realpart number)).\n"
"  For non-complex positive numbers, this is 0.  For non-complex negative\n"
"  numbers this is PI."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the sine of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the cosine of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the tangent of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return cos(Theta) + i sin(Theta), AKA exp(i Theta)."
msgstr ""

#: target:code/irrat.lisp
msgid "Argument to CIS is complex: ~S"
msgstr ""

#: target:code/irrat.lisp
msgid "Return the arc sine of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the arc cosine of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the arc tangent of Y if X is omitted or Y/X if X is supplied."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the hyperbolic sine of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the hyperbolic cosine of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the hyperbolic tangent of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the hyperbolic arc sine of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the hyperbolic arc cosine of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid "Return the hyperbolic arc tangent of NUMBER."
msgstr ""

#: target:code/irrat.lisp
msgid ""
"Compute 2^N * X without compute 2^N first (use properties of the\n"
"underlying floating-point format"
msgstr ""

#: target:code/irrat.lisp
msgid ""
"Same as logb but X is not infinity and non-zero and not a NaN, so\n"
"that we can always return an integer"
msgstr ""

#: target:code/irrat.lisp
msgid ""
"Compute an integer N such that 1 <= |2^(-N) * x| < 2.\n"
"For the special cases, the following values are used:\n"
"\n"
"    x             logb\n"
"   NaN            NaN\n"
"   +/- infinity   +infinity\n"
"   0              -infinity\n"
msgstr ""

#: target:code/irrat.lisp
msgid ""
"Create complex number with real part X and imaginary part Y such that\n"
"it has the same type as Z.  If Z has type (complex rational), the X\n"
"and Y are coerced to single-float."
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid ""
"Principle square root of Z\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid ""
"Compute log(2^j*z).\n"
"\n"
"This is for use with J /= 0 only when |z| is huge."
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid ""
"Log of Z = log |Z| + i * arg Z\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid "Compute atanh z = (log(1+z) - log(1-z))/2"
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid "Compute tanh z = sinh z / cosh z"
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid ""
"Compute acos z = pi/2 - asin z\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid ""
"Compute acosh z = 2 * log(sqrt((z+1)/2) + sqrt((z-1)/2))\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid ""
"Compute asin z = asinh(i*z)/i\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid ""
"Compute asinh z = log(z + sqrt(1 + z*z))\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid ""
"Compute atan z = atanh (i*z) / i\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: target:code/irrat-dd.lisp target:code/irrat.lisp
msgid ""
"Compute tan z = -i * tanh(i * z)\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: target:code/irrat-dd.lisp
msgid "log(most-positive-double-double-float)"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "log(least-positive-double-double-float"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "log(2)"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "Log base 2 of e"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "log2(e)-1"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "Pi"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "Pi/2"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "Pi/4"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "Sqrt(1/2)"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "exp(x) - 1"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "396 (hex) digits of 2/pi"
msgstr ""

#: target:code/irrat-dd.lisp
msgid "Overflow"
msgstr ""

#: target:code/char.lisp
msgid "The upper exclusive bound on values produced by CHAR-CODE."
msgstr ""

#: target:code/char.lisp
msgid "The upper exclusive bound on the value of a Unicode codepoint"
msgstr ""

#: target:code/char.lisp
msgid ""
"This is the alist of (character-name . character) for characters with\n"
"  long names.  The first name in this list for a given character is used\n"
"  on typeout and is the preferred form for input."
msgstr ""

#: target:code/char.lisp
msgid "Returns the integer code of CHAR."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns the integer code of CHAR.  This is the same as char-code, as\n"
"   CMU Common Lisp does not implement character bits or fonts."
msgstr ""

#: target:code/char.lisp
msgid "Returns the character with the code CODE."
msgstr ""

#: target:code/char.lisp
msgid ""
"Coerces its argument into a character object if possible.  Accepts\n"
"  characters, strings and symbols of length 1."
msgstr ""

#: target:code/char.lisp
msgid "String is not of length one: ~S"
msgstr ""

#: target:code/char.lisp
msgid "Symbol name is not of length one: ~S"
msgstr ""

#: target:code/char.lisp
msgid "~S cannot be coerced to a character."
msgstr ""

#: target:code/char.lisp
msgid ""
"Given a character object, char-name returns the name for that\n"
"  object (a symbol)."
msgstr ""

#: target:code/char.lisp
msgid ""
"Given an argument acceptable to string, name-char returns a character\n"
"  object whose name is that symbol, if one exists, otherwise NIL."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object.  Standard-char-p returns T if the\n"
"   argument is a standard character -- one of the 95 ASCII printing "
"characters\n"
"   or <return>."
msgstr ""

#: target:code/char.lisp
msgid ""
"Return T if and only if THING is a standard-char.  Differs from\n"
"  standard-char-p in that THING doesn't have to be a character."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object.  Graphic-char-p returns T if the\n"
"  argument is a printing character, otherwise returns NIL."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object.  Alpha-char-p returns T if the\n"
"  argument is an alphabetic character; otherwise NIL."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object; upper-case-p returns T if the\n"
"  argument is an upper-case character, NIL otherwise."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object; lower-case-p returns T if the \n"
"  argument is a lower-case character, NIL otherwise."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object; title-case-p returns T if the\n"
"  argument is a title-case character, NIL otherwise."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object.  Both-case-p returns T if the\n"
"  argument is an alphabetic character and if the character exists in\n"
"  both upper and lower case.  For ASCII, this is the same as Alpha-char-p."
msgstr ""

#: target:code/char.lisp
msgid ""
"If char is a digit in the specified radix, returns the fixnum for\n"
"  which that digit stands, else returns NIL.  Radix defaults to 10\n"
"  (decimal)."
msgstr ""

#: target:code/char.lisp
msgid ""
"Given a character-object argument, alphanumericp returns T if the\n"
"  argument is either numeric or alphabetic."
msgstr ""

#: target:code/char.lisp
msgid "Returns T if all of its arguments are the same character."
msgstr ""

#: target:code/char.lisp
msgid "Returns T if no two of its arguments are the same character."
msgstr ""

#: target:code/char.lisp
msgid "Returns T if its arguments are in strictly increasing alphabetic order."
msgstr ""

#: target:code/char.lisp
msgid "Returns T if its arguments are in strictly decreasing alphabetic order."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-decreasing alphabetic order."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-increasing alphabetic order."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if all of its arguments are the same character.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if no two of its arguments are the same character.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly increasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly decreasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-decreasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-increasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid "Returns CHAR converted to upper-case if that is possible."
msgstr ""

#: target:code/char.lisp
msgid "Returns CHAR converted to title-case if that is possible."
msgstr ""

#: target:code/char.lisp
msgid "Returns CHAR converted to lower-case if that is possible."
msgstr ""

#: target:code/char.lisp
msgid ""
"All arguments must be integers.  Returns a character object that\n"
"  represents a digit of the given weight in the specified radix.  Returns\n"
"  NIL if no such character exists."
msgstr ""

#: target:code/misc.lisp
msgid ""
"Returns the documentation string of Doc-Type for X, or NIL if\n"
"  none exists.  System doc-types are VARIABLE, FUNCTION, STRUCTURE, TYPE,\n"
"  SETF, and T."
msgstr ""

#: target:code/misc.lisp
msgid "~S is not the name of a structure type."
msgstr ""

#: target:code/misc.lisp
msgid ""
"If X is an atom, see if it is present in *FEATURES*.  Also\n"
"  handle arbitrary combinations of atoms using NOT, AND, OR."
msgstr ""

#: target:code/misc.lisp
msgid "Unknown operator in feature expression: ~S."
msgstr ""

#: target:code/misc.lisp
msgid "Returns a string describing the implementation type."
msgstr ""

#: target:code/misc.lisp
msgid "Returns a string describing the implementation version."
msgstr ""

#: target:code/misc.lisp
msgid " Unicode"
msgstr ""

#: target:code/misc.lisp
msgid "Returns a string giving the name of the local machine."
msgstr ""

#: target:code/misc.lisp
msgid "The value of SOFTWARE-TYPE.  Set in FOO-os.lisp."
msgstr ""

#: target:code/misc.lisp
msgid "Returns a string describing the supporting software."
msgstr ""

#: target:code/misc.lisp
msgid "Unknown"
msgstr ""

#: target:code/misc.lisp
msgid "The value of SHORT-SITE-NAME.  Set in library:site-init.lisp."
msgstr ""

#: target:code/misc.lisp
msgid "Returns a string with the abbreviated site name."
msgstr ""

#: target:code/misc.lisp
msgid "Site name not initialized"
msgstr ""

#: target:code/misc.lisp
msgid "The value of LONG-SITE-NAME.  Set in library:site-init.lisp."
msgstr ""

#: target:code/misc.lisp
msgid "Returns a string with the long form of the site name."
msgstr ""

#: target:code/misc.lisp
msgid ""
"With a file name as an argument, dribble opens the file and\n"
"   sends a record of further I/O to that file.  Without an\n"
"   argument, it closes the dribble file, and quits logging."
msgstr ""

#: target:code/misc.lisp
msgid "Not currently dribbling."
msgstr ""

#: target:code/misc.lisp
msgid ""
"Default implementation of ed.  This does nothing.  If hemlock is\n"
"  loaded, ed can be used to edit a file"
msgstr ""

#: target:code/extensions.lisp
msgid ""
"This function can be used as the default value for keyword arguments that\n"
"  must be always be supplied.  Since it is known by the compiler to never\n"
"  return, it will avoid any compile-time type warnings that would result "
"from a\n"
"  default value inconsistent with the declared type.  When this function is\n"
"  called, it signals an error indicating that a required keyword argument "
"was\n"
"  not supplied.  This function is also useful for DEFSTRUCT slot defaults\n"
"  corresponding to required arguments."
msgstr ""

#: target:code/extensions.lisp
msgid "A required keyword argument was not supplied."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"FILE-COMMENT String\n"
"  When COMPILE-FILE sees this form at top-level, it places the constant "
"string\n"
"  in the run-time source location information.  DESCRIBE will print the "
"file\n"
"  comment for the file that a function was defined in.  The string is also\n"
"  textually present in the FASL, so the RCS \"ident\" command can find it,\n"
"  etc."
msgstr ""

#: target:code/extensions.lisp
msgid "See listen.  Any whitespace in the input stream will be flushed."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Does what one might expect, saving the old values and setting the "
"generalized\n"
"  variables to the new values in sequence.  Unwind-protects and get-setf-"
"method\n"
"  are used to preserve the semantics one might expect in analogy to let*,\n"
"  and the once-only evaluation of subforms."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Like letf*, but evaluates all the implicit subforms and new values of all\n"
"  the implied setfs before altering any values.  However, the store forms\n"
"  (see get-setf-method) must still be evaluated in sequence.  Uses unwind-\n"
"  protects to protect the environment."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Causes the output of the indenting Stream to indent More spaces.  More is\n"
"  evaluated twice."
msgstr ""

#: target:code/extensions.lisp
msgid "Just like dolist, but with one-dimensional arrays."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Iterate Name ({(Var Initial-Value)}*) Declaration* Form*\n"
"  This is syntactic sugar for Labels.  It creates a local function Name "
"with\n"
"  the specified Vars as its arguments and the Declarations and Forms as its\n"
"  body.  This function is then called with the Initial-Values, and the "
"result\n"
"  of the call is return from the macro."
msgstr ""

#: target:code/extensions.lisp
msgid "Malformed iterate variable spec: ~S."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Collect ({(Name [Initial-Value] [Function])}*) {Form}*\n"
"  Collect some values somehow.  Each of the collections specifies a bunch "
"of\n"
"  things which collected during the evaluation of the body of the form.  "
"The\n"
"  name of the collection is used to define a local macro, a la MACROLET.\n"
"  Within the body, this macro will evaluate each of its arguments and "
"collect\n"
"  the result, returning the current value after the collection is done.  "
"The\n"
"  body is evaluated as a PROGN; to get the final values when you are done, "
"just\n"
"  call the collection macro with no arguments.\n"
"\n"
"  Initial-Value is the value that the collection starts out with, which\n"
"  defaults to NIL.  Function is the function which does the collection.  It "
"is\n"
"  a function which will accept two arguments: the value to be collected and "
"the\n"
"  current collection.  The result of the function is made the new value for "
"the\n"
"  collection.  As a totally magical special-case, the Function may be "
"Collect,\n"
"  which tells us to build a list in forward order; this is the default.  If "
"an\n"
"  Initial-Value is supplied for Collect, the stuff will be rplacd'd onto "
"the\n"
"  end.  Note that Function may be anything that can appear in the "
"functional\n"
"  position, including macros and lambdas."
msgstr ""

#: target:code/extensions.lisp
msgid "Malformed collection specifier: ~S."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Once-Only ({(Var Value-Expression)}*) Form*\n"
"  Create a Let* which evaluates each Value-Expression, binding a temporary\n"
"  variable to the result, and wrapping the Let* around the result of the\n"
"  evaluation of Body.  Within the body, each Var is bound to the "
"corresponding\n"
"  temporary variable."
msgstr ""

#: target:code/extensions.lisp
msgid "Malformed Once-Only binding spec: ~S."
msgstr ""

#: target:code/extensions.lisp
msgid "Ill-formed ~S -- possibly illegal old style DO?"
msgstr ""

#: target:code/extensions.lisp
msgid "~S step variable is not a symbol: ~S"
msgstr ""

#: target:code/extensions.lisp
msgid "~S is an illegal form for a ~S varlist."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"DO-ANONYMOUS ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Like DO, but has no implicit NIL block.  Each Var is initialized in "
"parallel\n"
"  to the value of the specified Init form.  On subsequent iterations, the "
"Vars\n"
"  are assigned the value of the Step form (if any) in paralell.  The Test "
"is\n"
"  evaluated before each evaluation of the body Forms.  When the Test is "
"true,\n"
"  the Exit-Forms are evaluated as a PROGN, with the result being the value\n"
"  of the DO."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"DO-HASH (Key-Var Value-Var Table [Result]) Declaration* Form*\n"
"   Iterate over the entries in a hash-table."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"DEFINE-HASH-CACHE Name ({(Arg-Name Test-Function)}*) {Key Value}*\n"
"  Define a hash cache that associates some number of argument values to a\n"
"  result value.  The Test-Function paired with each Arg-Name is used to "
"compare\n"
"  the value for that arg in a cache entry with a supplied arg.  The\n"
"  Test-Function must not error when passed NIL as its first arg, but need "
"not\n"
"  return any particular value.  Test-Function may be any thing that can be\n"
"  place in CAR position.\n"
"\n"
"  Name is used to define functions these functions:\n"
"\n"
"  <name>-CACHE-LOOKUP Arg*\n"
"      See if there is an entry for the specified Args in the cache.  The if "
"not\n"
"      present, the :DEFAULT keyword (default NIL) determines the result(s).\n"
"\n"
"  <name>-CACHE-ENTER Arg* Value*\n"
"      Encache the association of the specified args with Value.\n"
"\n"
"  <name>-CACHE-FLUSH-<arg-name> Arg\n"
"      Flush all entries from the cache that have the value Arg for the "
"named\n"
"      arg.\n"
"\n"
"  <name>-CACHE-CLEAR\n"
"      Reinitialize the cache, invalidating all entries and allowing the\n"
"      arguments and result values to be GC'd.\n"
"\n"
"  These other keywords are defined:\n"
"\n"
"  :HASH-BITS <n>\n"
"      The size of the cache as a power of 2.\n"
"\n"
"  :HASH-FUNCTION function\n"
"      Some thing that can be placed in CAR position which will compute a "
"value\n"
"      between 0 and (1- (expt 2 <hash-bits>)).\n"
"\n"
"  :VALUES <n>\n"
"      The number of values cached.\n"
"\n"
"   :INIT-FORM <name>\n"
"      The DEFVAR for creating the cache is enclosed in a form with the\n"
"      specified name.  Default PROGN."
msgstr ""

#: target:code/extensions.lisp
msgid "Number of default values ~S differs from :VALUES ~D."
msgstr ""

#: target:code/extensions.lisp
msgid "Bad arg spec: ~S."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"DEFUN-CACHED (Name {Key Value}*) ({(Arg-Name Test-Function)}*) Form*\n"
"  Some syntactic sugar for defining a function whose values are cached by\n"
"  DEFINE-HASH-CACHE."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Return an EQ hash of X.  The value of this hash for any given object can "
"(of\n"
"  course) change at arbitary times."
msgstr ""

#: target:code/commandline.lisp
msgid "A list of all the command line arguments after --"
msgstr ""

#: target:code/commandline.lisp
msgid ""
"A list of cmd-switch's representing the arguments used to invoke\n"
"  this process."
msgstr ""

#: target:code/commandline.lisp
msgid "The string name that was used to invoke this process."
msgstr ""

#: target:code/commandline.lisp
msgid "A list of words between the utility name and the first switch."
msgstr ""

#: target:code/commandline.lisp
msgid ""
"A list of strings obtained from the command line that invoked this process."
msgstr ""

#: target:code/commandline.lisp
msgid "An Alist of (\"argument-name\" . demon-function)"
msgstr ""

#: target:code/commandline.lisp
msgid ""
"When True runs lisp with its input coming from standard-input.\n"
"   If an error is detected returns error code 1, otherwise 0."
msgstr ""

#: target:code/commandline.lisp
msgid ""
"Accepts the name of a switch as a string and returns the value of the\n"
"   switch.  If no value was specified, then any following words are "
"returned.\n"
"   If there are no following words, then t is returned.  If the switch was "
"not\n"
"   specified, then nil is returned."
msgstr ""

#: target:code/commandline.lisp
msgid ""
"When set, invoking switch demons complains about illegal switches that have\n"
"   not been defined with DEFSWITCH."
msgstr ""

#: target:code/commandline.lisp
msgid "~S is an illegal switch"
msgstr ""

#: target:code/commandline.lisp
msgid ""
"Associates function with the switch name in *command-switch-demons*.  Name\n"
"   is a simple-string that does not begin with a hyphen, unless the switch "
"name\n"
"   really does begin with one.  Function is optional, but defining the "
"switch\n"
"   is necessary to keep invoking switch demons from complaining about "
"illegal\n"
"   switches.  This can be inhibited with *complain-about-illegal-switches*."
msgstr ""

#: target:code/commandline.lisp
msgid "a symbol or function"
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Returns information about the symbol VAR in the lexical environment ENV.\n"
"Three values are returned:\n"
"  1) Type or binding of VAR.\n"
"     NIL           No definition or binding\n"
"     :special      VAR is special\n"
"     :lexical      VAR is lexical\n"
"     :symbol-macro VAR refers to a SYMBOL-MACROLET binding\n"
"     :constant     VAR refers to a named constant or VAR is a keyword\n"
"  2) non-NIL if there is a local binding\n"
"  3) An a-list containing information about any declarations that apply."
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Returns information about declarations named by the symbol DECLARATION-"
"NAME.\n"
"Supported DECLARATION-NAMES are\n"
"  1) OPTIMIZE\n"
"     A list whose entries are of the form (QUALITY VALUE) is returned,\n"
"     where QUALITY and VALUE are standard optimization qualities and\n"
"     values.\n"
"  2) EXT:OPTIMIZE-INTERFACE\n"
"     Like OPTIMIZE, but for the EXT:OPTIMIZE-INTERFACE declaration.\n"
"  3) DECLARATION.\n"
"     A list of the declaration names the have been proclaimed as valid."
msgstr ""

#: target:code/env-access.lisp
msgid "Unsupported declaration ~S."
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Process a macro in the same way that DEFMACRO or MACROLET would.\n"
"Three values are returned:\n"
"  1) A lambda-expression that accepts two arguments\n"
"  2) A form\n"
"  3) An environment"
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Returns information about the function name FUNCTION in the lexical "
"environment ENV.\n"
"Three values are returned:\n"
"  1) Type of definition or binding:\n"
"     NIL          No apparent definition\n"
"    :function    FUNCTION refers to a function\n"
"    :macro        FUNCTION refers to a macro\n"
"    :special-form FUNCTION is a special form\n"
"  2) non-NIL if definition is local\n"
"  3) An a-list containing information about the declarations that apply."
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Return a new environment containing information in ENV that is augmented\n"
"by the specified parameters:\n"
"  :VARIABLE     a list of symbols visible as bound variables in the new\n"
"                environemnt\n"
"  :SYMBOL-MACRO a list of symbol macro definitions\n"
"  :FUNCTION     a list of function names that will be visible as local\n"
"                functions\n"
"  :MACRO        a list of local macro definitions\n"
"  :DECLARE      a list of declaration specifiers"
msgstr ""

#: target:code/dfixnum.lisp
msgid "increments dfixnum v by dfixnum i"
msgstr ""

#: target:code/dfixnum.lisp
msgid "dfixnum became too big ~a + ~a"
msgstr ""

#: target:code/dfixnum.lisp
msgid "increments dfixnum v by i (max half fixnum)"
msgstr ""

#: target:code/dfixnum.lisp
msgid "not a half-fixnum: ~a"
msgstr ""

#: target:code/dfixnum.lisp
msgid "decrement dfixnum v by dfixnum i"
msgstr ""

#: target:code/dfixnum.lisp
msgid "dfixnum became negative ~a - ~a (~a/~a)"
msgstr ""

#: target:code/dfixnum.lisp
msgid "decrement dfixnum v by half-fixnum i"
msgstr ""

#: target:code/dfixnum.lisp
msgid ""
"increments dfixnum by an interger which may be bigger than fixnum.\n"
"   May cons"
msgstr ""

#: target:code/dfixnum.lisp
msgid "returns a new dfixnum from number i"
msgstr ""

#: target:code/dfixnum.lisp
msgid "increments a pair of halffixnums by another pair"
msgstr ""

#: target:code/profile.lisp target:code/dfixnum.lisp
msgid "dfixnum became too big ~a/~a + ~a/~a"
msgstr ""

#: target:code/dfixnum.lisp
msgid "decrement dfixnum pair by another pair"
msgstr ""

#: target:code/profile.lisp target:code/dfixnum.lisp
msgid "dfixnum became negative ~a/~a - ~a/~a(~a/~a)"
msgstr ""

#: target:code/room.lisp
msgid "~2&Summary of spaces: ~(~{~A ~}~)~%"
msgstr ""

#: target:code/room.lisp
msgid "~%~A:~%    ~:D bytes, ~:D object~:P"
msgstr ""

#: target:code/room.lisp
msgid "~%Summary total:~%    ~:D bytes, ~:D objects.~%"
msgstr ""

#: target:code/room.lisp
msgid "~2&Breakdown for ~(~A~) space:~%"
msgstr ""

#: target:code/room.lisp
msgid "  ~13:D bytes for ~9:D other object~2:*~P.~%"
msgstr ""

#: target:code/room.lisp
msgid "  ~13:D bytes for ~9:D ~(~A~) object~2:*~P.~%"
msgstr ""

#: target:code/room.lisp
msgid "  ~13:D bytes for ~9:D ~(~A~) object~2:*~P (space total.)~%"
msgstr ""

#: target:code/room.lisp
msgid ""
"Print out information about the heap memory in use.  :Print-Spaces is a "
"list\n"
"  of the spaces to print detailed information for.  :Count-Spaces is a list "
"of\n"
"  the spaces to scan.  For either one, T means all spaces (:Static, :"
"Dyanmic\n"
"  and :Read-Only.)  If :Print-Summary is true, then summary information will "
"be\n"
"  printed.  The defaults print only summary information for dynamic space.\n"
"  If true, Cutoff is a fraction of the usage in a report below which types "
"will\n"
"  be combined as OTHER."
msgstr ""

#: target:code/room.lisp
msgid "Print info about how much code and no-ops there are in Space."
msgstr ""

#: target:code/room.lisp
msgid "~:D code-object bytes, ~:D code words, with ~:D no-ops (~D%).~%"
msgstr ""

#: target:code/room.lisp
msgid "Bogus type: ~D"
msgstr ""

#: target:code/room.lisp
msgid "~:D words allocated for descriptor objects.~%"
msgstr ""

#: target:code/room.lisp
msgid "~:D bytes data/~:D words header for non-descriptor objects.~%"
msgstr ""

#: target:code/room.lisp
msgid ""
"Print a breakdown by instance type of all the instances allocated in\n"
"  Space.  If TOP-N is true, print only information for the the TOP-N types "
"with\n"
"  largest usage."
msgstr ""

#: target:code/room.lisp
msgid "~2&~@[Top ~D ~]~(~A~) instance types:~%"
msgstr ""

#: target:code/room.lisp
msgid "  ~32A: ~7:D bytes, ~5D object~:P.~%"
msgstr ""

#: target:code/room.lisp
msgid "  Other types: ~:D bytes, ~D: object~:P.~%"
msgstr ""

#: target:code/room.lisp
msgid "  ~:(~A~) instance total: ~:D bytes, ~:D object~:P.~%"
msgstr ""

#: target:code/room.lisp
msgid "In ~A space:~%"
msgstr ""

#: target:code/room.lisp
msgid "~D bytes at #x~X~%"
msgstr ""

#: target:code/room.lisp
msgid "No source for ~S"
msgstr ""

#: target:code/room.lisp
msgid "~%Package ~A: ~32T~9:D bytes, ~9:D object~:P.~%"
msgstr ""

#: target:code/room.lisp
msgid "~30@A: ~9:D bytes, ~9:D object~:P.~%"
msgstr ""

#: target:code/room.lisp
msgid ""
"Given a hashtable, print a histogram of the contents.  Function should give\n"
"  the value to plot when applied to the hashtable values."
msgstr ""

#: target:code/room.lisp
msgid ""
"Report the Top-N entries in the hashtable Table, when sorted by Function\n"
"  applied to the hash value.  If Top-N is NIL, report all entries."
msgstr ""

#: target:code/room.lisp
msgid "~8:D: Other~%"
msgstr ""

#: target:code/room.lisp
msgid "~8:D: Total~%"
msgstr ""

#: target:code/room.lisp
msgid ""
"Return a hashtable mapping each function in for which a call appears in\n"
"  Space to the number of times such a call appears."
msgstr ""

#: target:code/room.lisp
msgid ""
"Return a hashtable translating code objects to function constant counts for\n"
"  all code objects in Space with more than Above function constants."
msgstr ""

#: target:code/gc.lisp
#, fuzzy
msgid "Oh no.  The current dynamic space is missing!"
msgstr "   ~D.~%"

#: target:code/gc.lisp
msgid "Dynamic Space Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr "   :    ~13:D  (~4:D ) .~%"

#: target:code/gc.lisp
msgid "Read-Only Space Usage:  ~13:D bytes (out of ~4:D MB).~%"
msgstr "   :    ~13:D  (~4:D ) .~%"

#: target:code/gc.lisp
msgid "Static Space Usage:     ~13:D bytes (out of ~4:D MB).~%"
msgstr "   :    ~13:D  (~4:D ) .~%"

#: target:code/gc.lisp
msgid "Control Stack Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr "  :     ~13:D  (~4:D ) .~%"

#: target:code/gc.lisp
msgid "Binding Stack Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr "  :    ~13:D  (~4:D ) .~%"

#: target:code/gc.lisp
msgid "The current dynamic space is ~D.~%"
msgstr "   ~D.~%"

#: target:code/gc.lisp
msgid "Garbage collection is currently ~:[enabled~;DISABLED~].~%"
msgstr "   ~:[~;~].~%"

#: target:code/gc.lisp
msgid ""
"Prints to *STANDARD-OUTPUT* information about the state of internal\n"
"  storage and its management.  The optional argument controls the\n"
"  verbosity of ROOM.  If it is T, ROOM prints out a maximal amount of\n"
"  information.  If it is NIL, ROOM prints out a minimal amount of\n"
"  information.  If it is :DEFAULT or it is not supplied, ROOM prints out\n"
"  an intermediate amount of information.  See also VM:MEMORY-USAGE and\n"
"  VM:INSTANCE-USAGE for finer report control."
msgstr ""
"     *STANDARD-OUTPUT*   \n"
"  .    ROOM .  T  \n"
"   ROOM .  NIL    ROOM . \n"
"   :DEFAULT     ROOM   \n"
"  .  VM:MEMORY-USAGE    \n"
"  VM:INSTANCE-USAGE."

#: target:code/gc.lisp
msgid ""
"No way man!  The optional argument to ROOM must be T, NIL, ~\n"
"\t\t or :DEFAULT.~%What do you think you are doing?"
msgstr ""
"  ! ROOM   T, NIL, ~\n"
"\t\t :DEFAULT.~%    ?"

#: target:code/gc.lisp
msgid "resetting GC counters"
msgstr ""

#: target:code/gc.lisp
msgid ""
"Returns the number of bytes consed since the first time this function\n"
"  was called.  The first time it is called, it returns zero."
msgstr ""

#: target:code/gc.lisp
msgid ""
"This number specifies the minimum number of bytes of dynamic space\n"
"   that must be consed before the next gc will occur."
msgstr ""
"   consed  \n"
"  .  , 0 ."

#: target:code/gc.lisp
msgid ""
"The total CPU time spend doing garbage collection (as reported by\n"
"   GET-INTERNAL-RUN-TIME.)"
msgstr ""
" CPU  (    \n"
"   GET-INTERNAL-RUN-TIME.)"

#: target:code/gc.lisp
msgid ""
"A list of functions that are called before garbage collection occurs.\n"
"  The functions should take no arguments."
msgstr ""

#: target:code/gc.lisp
msgid ""
"A list of functions that are called after garbage collection occurs.\n"
"  The functions should take no arguments."
msgstr ""

#: target:code/gc.lisp
msgid ""
"Should be bound to a function or NIL.  If it is a function, this\n"
"  function should take one argument, the current amount of dynamic\n"
"  usage.  The function should return NIL if garbage collection should\n"
"  continue and non-NIL if it should be inhibited.  Use with caution."
msgstr ""

#: target:code/gc.lisp
msgid ""
"When non-NIL, causes the functions bound to *GC-NOTIFY-BEFORE* and\n"
"  *GC-NOTIFY-AFTER* to be called before and after a garbage collection\n"
"  occurs respectively.  If :BEEP, causes the default notify functions to "
"beep\n"
"  annoyingly."
msgstr ""

#: target:code/gc.lisp
msgid ""
"~&; [GC threshold exceeded with ~:D bytes in use.  ~\n"
"             Commencing GC.]~%"
msgstr ""
"~&; [GC  ~:D   .  ~\n"
"              GC.]~%"

#: target:code/gc.lisp
msgid ""
"This function bound to this variable is invoked before GC'ing (unless\n"
"  *GC-VERBOSE* is NIL) with the current amount of dynamic usage (in\n"
"  bytes).  It should notify the user that the system is going to GC."
msgstr ""

#: target:code/gc.lisp
msgid "~&; [GC completed with ~:D bytes retained and ~:D bytes freed.]~%"
msgstr "~&; [ ~:D    ~:D   GC.]~%"

#: target:code/gc.lisp
msgid "~&; [GC will next occur when at least ~:D bytes are in use.]~%"
msgstr "~&; [GC   ~:D      .]~%"

#: target:code/gc.lisp
msgid ""
"The function bound to this variable is invoked after GC'ing (unless\n"
"  *GC-VERBOSE* is NIL) with the amount of dynamic usage (in bytes) now\n"
"  free, the number of bytes freed by the GC, and the new GC trigger\n"
"  threshold.  The function should notify the user that the system has\n"
"  finished GC'ing."
msgstr ""

#: target:code/gc.lisp
msgid "Attempt to set GC trigger to something bogus: ~S"
msgstr ""

#: target:code/gc.lisp
msgid "(FUNCALL ~S~{ ~S~}) lost:~%~A"
msgstr ""

#: target:code/gc.lisp
msgid ""
"The value of *BYTES-CONSED-BETWEEN-GCS*, ~S, is not an ~\n"
"\t       integer.  Resetting it to ~D."
msgstr ""

#: target:code/gc.lisp
msgid ""
"Initiates a garbage collection.  The keyword :VERBOSE, which\n"
"   defaults to the value of the variable *GC-VERBOSE* controls whether or\n"
"   not GC statistics are printed. The keyword :GEN defaults to 0, and\n"
"   controls the number of generations to garbage collect."
msgstr ""

#: target:code/gc.lisp
msgid ""
"Return the amount of memory that will be allocated before the next garbage\n"
"   collection is initiated.  This can be set with SETF."
msgstr ""

#: target:code/gc.lisp
msgid "Enables the garbage collector."
msgstr ""

#: target:code/gc.lisp
msgid "Disables the garbage collector."
msgstr ""

#: target:code/gc.lisp
msgid ""
"Return some GC statistics for the specified GENERATION.  The\n"
"  statistics are the number of bytes allocated in this generation; the\n"
"  gc-trigger; the number of bytes consed between GCs; the number of\n"
"  GCs that have occurred; the trigger age; the cumulative number of\n"
"  bytes allocated in this generation; and the average age of this\n"
"  generation.  See the gencgc source code for more info."
msgstr ""

#: target:code/purify.lisp
msgid ""
"This function optimizes garbage collection by moving all currently live\n"
"   objects into non-collected storage.  ROOT-STRUCTURES is an optional list "
"of\n"
"   objects which should be copied first to maximize locality.\n"
"\n"
"   DEFSTRUCT structures defined with the (:PURE T) option are moved into\n"
"   read-only storage, further reducing GC cost.  List and vector slots of "
"pure\n"
"   structures are also moved into read-only storage.\n"
"\n"
"   ENVIRONMENT-NAME is gratuitous documentation for compacted version of "
"the\n"
"   current global environment (as seen in C::*INFO-ENVIRONMENT*.)  If NIL "
"is\n"
"   supplied, then environment compaction is inhibited."
msgstr ""

#: target:code/purify.lisp
msgid "[Doing purification: "
msgstr ""

#: target:code/purify.lisp
msgid "Done.]"
msgstr ""

#: target:code/scavhook.lisp
msgid "Returns T if OBJECT is a scavenger-hook, and NIL if not."
msgstr ""

#: target:code/scavhook.lisp
msgid ""
"Create a new scavenger-hook with the specified VALUE and FUNCTION.  For\n"
"   as long as the scavenger-hook is alive, the scavenger in the garbage\n"
"   collector will note whenever VALUE is moved, and arrange for FUNCTION\n"
"   to be funcalled."
msgstr ""

#: target:code/scavhook.lisp
msgid "Returns the VALUE being monitored by SCAVHOOK.  Can be setf."
msgstr ""

#: target:code/scavhook.lisp
msgid ""
"Returns the FUNCTION invoked when the monitored value is moved.  Can be\n"
"   setf."
msgstr ""

#: target:code/save.lisp
msgid ""
"This is a list of functions which are called before creating a saved core\n"
"  image.  These functions are executed in the child process which has no "
"ports,\n"
"  so they cannot do anything that tries to talk to the outside world."
msgstr ""

#: target:code/save.lisp
msgid ""
"This is a list of functions which are called when a saved core image starts\n"
"  up.  The system itself should be initialized at this point, but "
"applications\n"
"  might not be."
msgstr ""

#: target:code/save.lisp
msgid "An alist mapping environment variables (as keywords) to either values"
msgstr ""

#: target:code/save.lisp
msgid "Non-NIL if environment-init has been called"
msgstr ""

#: target:code/save.lisp
msgid "This is true if and only if the lisp was started with the -edit switch."
msgstr ""

#: target:code/save.lisp
msgid ""
"Saves a CMU Common Lisp core image in the file of the specified name.  The\n"
"  following keywords are defined:\n"
"  \n"
"  :purify\n"
"      If true (the default), do a purifying GC which moves all dynamically\n"
"  allocated objects into static space so that they stay pure.  This takes\n"
"  somewhat longer than the normal GC which is otherwise done, but GC's will\n"
"  be done less often and take less time in the resulting core file.  See\n"
"  EXT:PURIFY.\n"
"\n"
"  :root-structures\n"
"      This should be a list of the main entry points in any newly loaded\n"
"  systems.  This need not be supplied, but locality and/or GC performance\n"
"  will be better if they are.  Meaningless if :purify is NIL.  See EXT:"
"PURIFY.\n"
"\n"
"  :environment-name\n"
"      Also passed to EXT:PURIFY when :PURIFY is T.  Rarely used.\n"
"  \n"
"  :init-function\n"
"      This is the function that starts running when the created core file "
"is\n"
"  resumed.  The default function simply invokes the top level\n"
"  read-eval-print loop.  If the function returns the lisp will exit.\n"
"  \n"
"  :load-init-file\n"
"      If true, then look for an init.lisp or init.fasl file when the core\n"
"  file is resumed.\n"
"\n"
"  :site-init\n"
"      If true, then the name of the site init file to load.  The default is\n"
"      library:site-init.  No error if this does not exist.\n"
"\n"
"  :print-herald\n"
"      If true (the default), print out the lisp system herald when "
"starting.\n"
"\n"
"  :process-command-line\n"
"      If true (the default), process command-line switches via the normal\n"
"  mechanisms, otherwise ignore all switches (except those processed by the\n"
"  C startup code).\n"
"\n"
"  :executable\n"
"      If nil (the default), save-lisp will save using the traditional\n"
"   core-file format.  If true, save-lisp will create an executable\n"
"   file that contains the lisp image built in. \n"
"   (Not all architectures support this yet.)\n"
"\n"
"  :batch-mode\n"
"      If nil (the default), then the presence of the -batch command-line\n"
"  switch will invoke batch-mode processing.  If true, the produced core\n"
"  will always be in batch-mode, regardless of any command-line switches."
msgstr ""

#: target:code/save.lisp
msgid "Directory ~S does not exist"
msgstr ""

#: target:code/save.lisp
msgid "Skip remaining initializations."
msgstr ""

#: target:code/save.lisp
msgid "Error in batch processing:~%~A~%"
msgstr ""

#: target:code/save.lisp
msgid ""
"Determines what PRINT-HERALD prints (the system startup banner.)  This is a\n"
"   database which can be augmented by each loaded system.  The format is a\n"
"   property list which maps from subsystem names to the banner information "
"for\n"
"   that system.  This list can be manipulated with GETF -- entries are "
"printed\n"
"   in, reverse order, so the newest entry is printed last.  Usually the "
"system\n"
"   feature keyword is used as the system name.  A given banner is a list of\n"
"   strings and functions (or function names).  Strings are printed, and\n"
"   functions are called with an output stream argument."
msgstr ""

#: target:code/save.lisp
msgid ", running on "
msgstr ""

#: target:code/save.lisp
msgid "With core: "
msgstr ""

#: target:code/save.lisp
msgid "Dumped on: "
msgstr ""

#: target:code/save.lisp
msgid " on "
msgstr ""

#: target:code/save.lisp
msgid "See <http://www.cons.org/cmucl/> for support information."
msgstr ""

#: target:code/save.lisp
msgid "Loaded subsystems:"
msgstr ""

#: target:code/save.lisp
msgid "    Unicode "
msgstr ""

#: target:code/save.lisp
msgid "with Unicode version "
msgstr ""

#: target:code/save.lisp
msgid ""
"Print some descriptive information about the Lisp system version and\n"
"   configuration."
msgstr ""

#: target:code/save.lisp
msgid "Unrecognized *HERALD-ITEMS* entry: ~S."
msgstr ""

#: target:code/save.lisp
msgid "Change *PACKAGE* to the USER package and try again."
msgstr ""

#: target:code/print.lisp
msgid ""
"If true, all objects will printed readably.  If readably printing is\n"
"  impossible, an error will be signalled.  This overrides the value of\n"
"  *PRINT-ESCAPE*."
msgstr ""

#: target:code/print.lisp
msgid "Flag which indicates that slashification is on.  See the manual"
msgstr ""

#: target:code/print.lisp
msgid "Flag which indicates that pretty printing is to be used"
msgstr ""

#: target:code/print.lisp
msgid "The output base for integers and rationals."
msgstr ""

#: target:code/print.lisp
msgid "This flag requests to verify base when printing rationals."
msgstr ""

#: target:code/print.lisp
msgid "How many levels deep to print.  Unlimited if null."
msgstr ""

#: target:code/print.lisp
msgid "How many elements to print on each level.  Unlimited if null."
msgstr ""

#: target:code/print.lisp
msgid "Whether to worry about circular list structures. See the manual."
msgstr ""

#: target:code/print.lisp
msgid "What kind of case the printer should use by default"
msgstr ""

#: target:code/print.lisp
msgid "Whether the array should print it's guts out"
msgstr ""

#: target:code/print.lisp
msgid ""
"If true, symbols with no home package are printed with a #: prefix.\n"
"  If false, no prefix is printed."
msgstr ""

#: target:code/print.lisp
msgid "The maximum number of lines to print.  If NIL, unlimited."
msgstr ""

#: target:code/print.lisp
msgid ""
"The position of the right margin in ems.  If NIL, try to determine this\n"
"   from the stream in use."
msgstr ""

#: target:code/print.lisp
msgid ""
"If the remaining space between the current column and the right margin\n"
"   is less than this, then print using ``miser-style'' output.  Miser\n"
"   style conditional newlines are turned on, and all indentations are\n"
"   turned off.  If NIL, never use miser mode."
msgstr ""

#: target:code/print.lisp
msgid ""
"The pprint-dispatch-table that controls how to pretty print objects.  See\n"
"   COPY-PPRINT-DISPATH, PPRINT-DISPATCH, and SET-PPRINT-DISPATCH."
msgstr ""

#: target:code/print.lisp
msgid ""
"Bind the reader and printer control variables to values that enable READ\n"
"   to reliably read the results of PRINT.  These values are:\n"
"       *PACKAGE*\t\t\tThe COMMON-LISP-USER package\n"
"       *PRINT-ARRAY*\t\t\tT\n"
"       *PRINT-BASE*\t\t\t10\n"
"       *PRINT-CASE*\t\t\t:UPCASE\n"
"       *PRINT-CIRCLE*\t\t\tNIL\n"
"       *PRINT-ESCAPE*\t\t\tT\n"
"       *PRINT-GENSYM*\t\t\tT\n"
"       *PRINT-LENGTH*\t\t\tNIL\n"
"       *PRINT-LEVEL*\t\t\tNIL\n"
"       *PRINT-LINES*\t\t\tNIL\n"
"       *PRINT-MISER-WIDTH*\t\tNIL\n"
"       *PRINT-PRETTY*\t\t\tNIL\n"
"       *PRINT-RADIX*\t\t\tNIL\n"
"       *PRINT-READABLY*\t\t\tT\n"
"       *PRINT-RIGHT-MARGIN*\t\tNIL\n"
"       *READ-BASE*\t\t\t10\n"
"       *READ-DEFAULT-FLOAT-FORMAT* \tSINGLE-FLOAT\n"
"       *READ-EVAL*\t\t\tT\n"
"       *READ-SUPPRESS*\t\t\tNIL\n"
"       *READTABLE*\t\t\tthe standard readtable."
msgstr ""

#: target:code/print.lisp
msgid "Outputs OBJECT to the specified stream, defaulting to *standard-output*"
msgstr ""

#: target:code/print.lisp
msgid ""
"Outputs a mostly READable printed representation of OBJECT on the specified\n"
"  stream."
msgstr ""

#: target:code/print.lisp
msgid ""
"Outputs an asthetic but not READable printed representation of OBJECT on "
"the\n"
"  specified stream."
msgstr ""

#: target:code/print.lisp
msgid ""
"Outputs a terpri, the mostly READable printed represenation of OBJECT, and \n"
"  space to the stream."
msgstr ""

#: target:code/print.lisp
msgid "Prettily outputs the Object preceded by a newline."
msgstr ""

#: target:code/print.lisp
msgid "Returns the printed representation of OBJECT as a string."
msgstr ""

#: target:code/print.lisp
msgid ""
"Returns the printed representation of OBJECT as a string with \n"
"   slashification on."
msgstr ""

#: target:code/print.lisp
msgid ""
"Returns the printed representation of OBJECT as a string with\n"
"  slashification off."
msgstr ""

#: target:code/print.lisp
msgid "~S cannot be printed readably."
msgstr ""

#: target:code/print.lisp
msgid "Determines whether or not the character is considered whitespace."
msgstr ""

#: target:code/print.lisp
msgid ""
"Check to see if OBJECT is a circular reference, and return something non-"
"NIL\n"
"   if it is.  If ASSIGN is T, then the number to use in the #n= and #n# "
"noise\n"
"   is assigned at this time.  Note: CHECK-FOR-CIRCULARITY must be called\n"
"   *EXACTLY* once with ASSIGN T, or the circularity detection noise will "
"get\n"
"   confused about when to use #n= and when to use #n#.  If this returns\n"
"   non-NIL when ASSIGN is T, then you must call HANDLE-CIRCULARITY on it."
msgstr ""

#: target:code/print.lisp
msgid ""
"Handle the results of CHECK-FOR-CIRCULARITY.  If this returns T then\n"
"   you should go ahead and print the object.  If it returns NIL, then\n"
"   you should blow it off."
msgstr ""

#: target:code/print.lisp
msgid ""
"Attempt to use CHECK-FOR-CIRCULARITY when circularity ~\n"
"\t       checking has not been initiated."
msgstr ""

#: target:code/print.lisp
msgid ""
"The current level we are printing at, to be compared against *PRINT-LEVEL*.\n"
"   See the macro DESCEND-INTO for a handy interface to depth abbreviation."
msgstr ""

#: target:code/print.lisp
msgid ""
"Automatically handle *print-level* abbreviation.  If we are too deep, then\n"
"   a # is printed to STREAM and BODY is ignored."
msgstr ""

#: target:code/print.lisp
msgid ""
"Punt if INDEX is equal or larger then *PRINT-LENGTH* (and *PRINT-READABLY*\n"
"   is NIL) by outputting \"...\" and returning from the block named NIL."
msgstr ""

#: target:code/print.lisp
msgid ""
"The current pretty printer.  Should be either a function that takes two\n"
"   arguments (the object and the stream) or NIL to indicate that there is\n"
"   no pretty printer installed."
msgstr ""

#: target:code/print.lisp
msgid "Output OBJECT to STREAM observing all printer control variables."
msgstr ""

#: target:code/print.lisp
msgid ""
"Output OBJECT to STREAM observing all printer control variables except\n"
"   for *PRINT-PRETTY*.  Note: if *PRINT-PRETTY* is non-NIL, then the pretty\n"
"   printer will be used for any components of OBJECT, just not for OBJECT\n"
"   itself."
msgstr ""

#: target:code/print.lisp
msgid "Invalid *PRINT-CASE* value: ~S"
msgstr ""

#: target:code/print.lisp
msgid "Invalid READTABLE-CASE value: ~S"
msgstr ""

#: target:code/print.lisp
msgid ""
"Outputs the printed representation of any array in either the #< or #A\n"
"   form."
msgstr ""

#: target:code/print.lisp
msgid "Obsolete Instance"
msgstr ""

#: target:code/print.lisp
msgid "Unprintable Instance"
msgstr ""

#: target:code/print.lisp
msgid "~A is not a reasonable value for *Print-Base*."
msgstr ""

#: target:code/print.lisp
msgid ""
"Compute a list of pairs (2^i . r^{2^i}), stopping with the largest r^{2^i}\n"
"greater than n."
msgstr ""

#: target:code/print.lisp
msgid ""
"Convert digit into a character representation.  We use 0..9, a..z for\n"
"10..35, and A..Z for 36..52."
msgstr ""

#: target:code/print.lisp
msgid "overflow in digit-to-char"
msgstr ""

#: target:code/print.lisp
msgid ""
"Print a fixnum N to stream S, maybe with leading zeros.  This isn't\n"
"ever-so efficient, but we probably don't need to care."
msgstr ""

#: target:code/print.lisp
msgid ""
"Use the power list (see power-list) PL to split N roughly in half; then\n"
"print the left and right halves using (cdr PL).  Make sure we count the\n"
"leading zeroes correctly."
msgstr ""

#: target:code/print.lisp
msgid ""
"Primary fast bignum-printing interface.  Prints integer N to stream S in\n"
"radix-R.  If you have a power-list then pass it in as PL."
msgstr ""

#: target:code/print.lisp
msgid ""
"Minimum power of 10 that allows the float printer to use free format,\n"
"   instead of exponential format.  See section 22.1.3.1.3: Printing Floats\n"
"   in the ANSI CL standard."
msgstr ""

#: target:code/print.lisp
msgid ""
"Maximum power of 10 that allows the float printer to use free format,\n"
"   instead of exponential format.  See section 22.1.3.1.3: Printing Floats\n"
"   in the ANSI CL standard."
msgstr ""

#: target:code/print.lisp
msgid "Convert a DD number to a lisp rational"
msgstr ""

#: target:code/print.lisp
msgid "Print out a double-double to a string"
msgstr ""

#: target:code/print.lisp
msgid "Weak Pointer: "
msgstr ""

#: target:code/print.lisp
msgid "Broken Weak Pointer"
msgstr ""

#: target:code/print.lisp
msgid "Bogus Code Object"
msgstr ""

#: target:code/print.lisp
msgid "Code Object"
msgstr ""

#: target:code/print.lisp
msgid "Return PC Object"
msgstr ""

#: target:code/print.lisp
msgid "FDEFINITION object for "
msgstr ""

#: target:code/print.lisp
msgid "Function "
msgstr ""

#: target:code/print.lisp
msgid "Interpreted Function ~S"
msgstr ""

#: target:code/print.lisp
msgid "Byte Compiled Function"
msgstr ""

#: target:code/print.lisp
msgid "Byte Compiled Closure"
msgstr ""

#: target:code/print.lisp
msgid "Closure Over "
msgstr ""

#: target:code/print.lisp
msgid "Unknown Function"
msgstr ""

#: target:code/print.lisp
msgid "Value Cell "
msgstr ""

#: target:code/print.lisp
msgid "Unknown Pointer Object, type="
msgstr ""

#: target:code/print.lisp
msgid "Unbound Marker"
msgstr ""

#: target:code/print.lisp
msgid "Unknown Immediate Object, lowtag="
msgstr ""

#: target:code/print.lisp
msgid ", type="
msgstr ""

#: target:code/print.lisp
msgid "Continue anyway"
msgstr ""

#: target:code/print.lisp
msgid "Cannot find ~S, so unicode support is not available"
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Insert an annotation into the pretty-printing stream STREAM.\n"
"HANDLER is a function, and RECORD is an arbitrary datum.  The\n"
"pretty-printing stream conceptionally queues annotations in sequence\n"
"with the characters that are printed to the stream, until the stream\n"
"has decided on the concrete layout.  When the characters are forwarded\n"
"to the target stream, annotations are invoked at the right position.\n"
"An annotation is invoked by calling the function HANDLER with the\n"
"three arguments RECORD, TARGET-STREAM, and TRUNCATEP.  The argument\n"
"TRUNCATEP is true if the text surrounding the annotation is suppressed\n"
"due to line abbreviation (see *PRINT-LINES*).\n"
"If STREAM is not a pretty-printing stream, simply call HANDLER\n"
"with the arguments RECORD, STREAM and nil."
msgstr ""

#: target:code/pprint.lisp
msgid "Insert ANNOTATION into the queue of annotations in STREAM."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Insert all annotations in STREAM from the queue of pending\n"
"operations into the queue of annotations.  When END is non-nil, \n"
"stop before reaching the queued-op END."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Dequeue the next annotation from the queue of annotations of STREAM\n"
"and return it.  Return nil if there are no more annotations.  When\n"
":END-POSN is given and the next annotation has a posn greater than\n"
"this, also return nil."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Output the buffer of STREAM up to (excluding) the buffer index END.\n"
"When annotations are present, invoke them at the right positions."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Invoke all annotations in STREAM up to (including) the buffer index END."
msgstr ""

#: target:code/pprint.lisp
msgid "Output-partial-line called when nothing can be output."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Group some output into a logical block.  STREAM-SYMBOL should be either a\n"
"   stream, T (for *TERMINAL-IO*), or NIL (for *STANDARD-OUTPUT*).  The "
"printer\n"
"   control variable *PRINT-LEVEL* is automatically handled."
msgstr ""

#: target:code/pprint.lisp
msgid "Cannot specify both a prefix and a per-line-prefix."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Cause the closest enclosing use of PPRINT-LOGICAL-BLOCK to return\n"
"   if it's list argument is exhausted.  Can only be used inside\n"
"   PPRINT-LOGICAL-BLOCK, and only when the LIST argument to\n"
"   PPRINT-LOGICAL-BLOCK is supplied."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"PPRINT-EXIT-IF-LIST-EXHAUSTED must be lexically inside ~\n"
"\t  PPRINT-LOGICAL-BLOCK."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Return the next element from LIST argument to the closest enclosing\n"
"   use of PPRINT-LOGICAL-BLOCK, automatically handling *PRINT-LENGTH*\n"
"   and *PRINT-CIRCLE*.  Can only be used inside PPRINT-LOGICAL-BLOCK.\n"
"   If the LIST argument to PPRINT-LOGICAL-BLOCK was NIL, then nothing\n"
"   is poped, but the *PRINT-LENGTH* testing still happens."
msgstr ""

#: target:code/pprint.lisp
msgid "PPRINT-POP must be lexically inside PPRINT-LOGICAL-BLOCK."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Output a conditional newline to STREAM (which defaults to\n"
"   *STANDARD-OUTPUT*) if it is a pretty-printing stream, and do\n"
"   nothing if not.  KIND can be one of:\n"
"     :LINEAR - A line break is inserted if and only if the immediatly\n"
"        containing section cannot be printed on one line.\n"
"     :MISER - Same as LINEAR, but only if ``miser-style'' is in effect.\n"
"        (See *PRINT-MISER-WIDTH*.)\n"
"     :FILL - A line break is inserted if and only if either:\n"
"       (a) the following section cannot be printed on the end of the\n"
"           current line,\n"
"       (b) the preceding section was not printed on a single line, or\n"
"       (c) the immediately containing section cannot be printed on one\n"
"           line and miser-style is in effect.\n"
"     :MANDATORY - A line break is always inserted.\n"
"   When a line break is inserted by any type of conditional newline, any\n"
"   blanks that immediately precede the conditional newline are ommitted\n"
"   from the output and indentation is introduced at the beginning of the\n"
"   next line.  (See PPRINT-INDENT.)"
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Specify the indentation to use in the current logical block if STREAM\n"
"   (which defaults to *STANDARD-OUTPUT*) is a pretty-printing stream\n"
"   and do nothing if not.  (See PPRINT-LOGICAL-BLOCK.)  N is the indention\n"
"   to use (in ems, the width of an ``m'') and RELATIVE-TO can be either:\n"
"     :BLOCK - Indent relative to the column the current logical block\n"
"        started on.\n"
"     :CURRENT - Indent relative to the current column.\n"
"   The new indention value does not take effect until the following line\n"
"   break.  The indention value is silently truncated to an integer."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"If STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing\n"
"   stream, perform tabbing based on KIND, otherwise do nothing.  KIND can\n"
"   be one of:\n"
"     :LINE - Tab to column COLNUM.  If already past COLNUM tab to the next\n"
"       multiple of COLINC.\n"
"     :SECTION - Same as :LINE, but count from the start of the current\n"
"       section, not the start of the line.\n"
"     :LINE-RELATIVE - Output COLNUM spaces, then tab to the next multiple "
"of\n"
"       COLINC.\n"
"     :SECTION-RELATIVE - Same as :LINE-RELATIVE, but count from the start\n"
"       of the current section, not the start of the line."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Output LIST to STREAM putting :FILL conditional newlines between each\n"
"   element.  If COLON? is NIL (defaults to T), then no parens are printed\n"
"   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-FILL\n"
"   can be used with the ~/.../ format directive."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Output LIST to STREAM putting :LINEAR conditional newlines between each\n"
"   element.  If COLON? is NIL (defaults to T), then no parens are printed\n"
"   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-"
"LINEAR\n"
"   can be used with the ~/.../ format directive."
msgstr ""

#: target:code/pprint.lisp
msgid ""
"Output LIST to STREAM tabbing to the next column that is an even multiple\n"
"   of TABSIZE (which defaults to 16) between each element.  :FILL style\n"
"   conditional newlines are also output between each element.  If COLON? is\n"
"   NIL (defaults to T), then no parens are printed around the output.\n"
"   ATSIGN? is ignored (but allowed so that PPRINT-TABULAR can be used with\n"
"   the ~/.../ format directive."
msgstr ""

#: target:code/pprint.lisp
msgid "CONS PPRINT dispatch ignored w/o compiler loaded:~%  ~S"
msgstr ""

#: target:code/format.lisp
msgid ""
"Provides various facilities for formatting output.\n"
"  CONTROL-STRING contains a string to be output, possibly with embedded\n"
"  directives, which are flagged with the escape character \"~\".  "
"Directives\n"
"  generally expand into additional text to be output, usually consuming one\n"
"  or more of the FORMAT-ARGUMENTS in the process.  A few useful directives\n"
"  are:\n"
"        ~A or ~nA     Prints one argument as if by PRINC\n"
"        ~S or ~nS     Prints one argument as if by PRIN1\n"
"        ~D or ~nD     Prints one argument as a decimal integer\n"
"        ~%            Does a TERPRI\n"
"        ~&            Does a FRESH-LINE\n"
"\n"
"         where n is the width of the field in which the object is printed.\n"
"  \n"
"  DESTINATION controls where the result will go.  If DESTINATION is T, then\n"
"  the output is sent to the standard output stream.  If it is NIL, then the\n"
"  output is returned in a string as the value of the call.  Otherwise,\n"
"  DESTINATION must be a stream to which the output will be sent.\n"
"\n"
"  Example:   (FORMAT NIL \"The answer is ~D.\" 10) => \"The answer is 10.\"\n"
"\n"
"  FORMAT has many additional capabilities not described here.  Consult\n"
"  Section 22.3 (Formatted Output) of the ANSI Common Lisp standard for\n"
"  details."
msgstr ""

#: target:code/format.lisp
msgid "Table of ordinal ones-place digits in English"
msgstr ""

#: target:code/format.lisp
msgid "Table of ordinal tens-place digits in English"
msgstr ""

#: target:code/package.lisp
msgid ""
"The list of packages to use by default of no :USE argument is supplied\n"
"   to MAKE-PACKAGE or other package creation forms."
msgstr ""

#: target:code/package.lisp
msgid ""
"Standard structure for the description of a package.  Consists of \n"
"   a list of all hash tables, the name of the package, the nicknames of\n"
"   the package, the use-list for the package, the used-by- list, hash-\n"
"   tables for the internal and external symbols, and a list of the\n"
"   shadowing symbols."
msgstr ""

#: target:code/package.lisp
msgid "The ~A package, ~D/~D internal, ~D/~D external"
msgstr ""

#: target:code/package.lisp
#, fuzzy
msgid "The ~A package"
msgstr "   ~D.~%"

#: target:code/package.lisp
#, fuzzy
msgid "deleted package"
msgstr "   ~D.~%"

#: target:code/package.lisp
#, fuzzy
msgid "The current package."
msgstr "   ~D.~%"

#: target:code/package.lisp
msgid "~&~@<Attempt to modify the locked package ~A, by ~3i~:_~?~:>"
msgstr ""

#: target:code/package.lisp
msgid "redefining function ~A"
msgstr ""

#: target:code/package.lisp
msgid "Bogus ~A name: ~S"
msgstr ""

#: target:code/package.lisp
msgid "Can't do anything to a deleted package: ~S"
msgstr ""

#: target:code/package.lisp
msgid ""
"Given PACKAGE-SPECIFIER, a package, symbol or string, return the\n"
"  parent package.  If there is not a parent, signal an error."
msgstr ""

#: target:code/package.lisp
msgid "The parent of ~a does not exist."
msgstr ""

#: target:code/package.lisp
msgid "There is no parent of ~a."
msgstr ""

#: target:code/package.lisp
msgid ""
"Given PACKAGE-SPECIFIER, a package, symbol or string, return all the\n"
"  packages which are in the hierarchy 'under' the given package.  If\n"
"  :recurse is nil, then only return the immediate children of the package."
msgstr ""

#: target:code/package.lisp
msgid "Find the package having the specified name."
msgstr ""

#: target:code/package.lisp
#, fuzzy
msgid "Make this package."
msgstr "   ~D.~%"

#: target:code/package.lisp
msgid "#<Package-Hashtable: Size = ~D, Free = ~D, Deleted = ~D>"
msgstr ""

#: target:code/package.lisp
msgid ""
"DO-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECLARATION}* {TAG | FORM}*\n"
"   Executes the FORMs at least once for each symbol accessible in the given\n"
"   PACKAGE with VAR bound to the current symbol."
msgstr ""

#: target:code/package.lisp
msgid ""
"DO-EXTERNAL-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECL}* {TAG | FORM}*\n"
"   Executes the FORMs once for each external symbol in the given PACKAGE "
"with\n"
"   VAR bound to the current symbol."
msgstr ""

#: target:code/package.lisp
msgid ""
"DO-ALL-SYMBOLS (VAR [RESULT-FORM]) {DECLARATION}* {TAG | FORM}*\n"
"   Executes the FORMs once for each symbol in every package with VAR bound\n"
"   to the current symbol."
msgstr ""

#: target:code/package.lisp
msgid ""
"Within the lexical scope of the body forms, MNAME is defined via macrolet\n"
"   such that successive invocations of (mname) will return the symbols,\n"
"   one by one, from the packages in PACKAGE-LIST. SYMBOL-TYPES may be\n"
"   any of :inherited :external :internal."
msgstr ""

#: target:code/package.lisp
msgid "~@<~S does not name a package ~:>"
msgstr ""

#: target:code/package.lisp
msgid ""
"Must supply at least one of :internal, ~\n"
"\t                             :external, or :inherited."
msgstr ""

#: target:code/package.lisp
msgid ""
"~S is not one of :internal, :external, ~\n"
"\t\t                       or :inherited."
msgstr ""

#: target:code/package.lisp
msgid ""
"Defines a new package called PACKAGE.  Each of OPTIONS should be one of the\n"
"   following:\n"
"     (:NICKNAMES {package-name}*)\n"
"     (:SIZE <integer>)\n"
"     (:SHADOW {symbol-name}*)\n"
"     (:SHADOWING-IMPORT-FROM <package-name> {symbol-name}*)\n"
"     (:USE {package-name}*)\n"
"     (:IMPORT-FROM <package-name> {symbol-name}*)\n"
"     (:INTERN {symbol-name}*)\n"
"     (:EXPORT {symbol-name}*)\n"
"     (:DOCUMENTATION doc-string)\n"
"   All options except :SIZE and :DOCUMENTATION can be used multiple times."
msgstr ""

#: target:code/package.lisp
msgid "Bogus DEFPACKAGE option: ~S"
msgstr ""

#: target:code/package.lisp
msgid "Can't specify :SIZE twice."
msgstr ""

#: target:code/package.lisp
msgid "Bogus :SIZE, must be a positive integer: ~S"
msgstr ""

#: target:code/package.lisp
msgid "Can't specify :DOCUMENTATION twice."
msgstr ""

#: target:code/package.lisp
msgid ""
"Parameters ~S and ~S must be disjoint ~\n"
"\t                             but have common elements ~%   ~S"
msgstr ""

#: target:code/package.lisp
msgid "~A is a nick-name for the package ~A"
msgstr ""

#: target:code/package.lisp
msgid "~A also shadows the following symbols:~%  ~S"
msgstr ""

#: target:code/package.lisp
msgid "~A previously used the following packages:~%  ~S"
msgstr ""

#: target:code/package.lisp
msgid "~A also exports the following symbols:~%  ~S"
msgstr ""

#: target:code/package.lisp
msgid "~A does not contain a symbol ~A"
msgstr ""

#: target:code/package.lisp
msgid "Ignore this nickname."
msgstr ""

#: target:code/package.lisp
msgid "~S is a package name, so it cannot be a nickname for ~S."
msgstr ""

#: target:code/package.lisp
msgid "Redefine this nickname."
msgstr ""

#: target:code/package.lisp
msgid "~S is already a nickname for ~S."
msgstr ""

#: target:code/package.lisp
msgid ""
"Makes a new package having the specified Name and Nicknames.  The\n"
"  package will inherit all external symbols from each package in\n"
"  the use list.  :Internal-Symbols and :External-Symbols are\n"
"  estimates for the number of internal and external symbols which\n"
"  will ultimately be present in the package."
msgstr ""

#: target:code/package.lisp
msgid "Leave existing package alone."
msgstr ""

#: target:code/package.lisp
msgid "A package named ~S already exists"
msgstr ""

#: target:code/package.lisp
msgid ""
"Sets *PACKAGE* to package with given NAME, creating the package if\n"
"   it does not exist.  If the package already exists then it is modified\n"
"   to agree with the :USE and :NICKNAMES arguments.  Any new nicknames\n"
"   are added without removing any old ones not specified.  If any package\n"
"   in the :Use list is not currently used, then it is added to the use\n"
"   list."
msgstr ""

#: target:code/package.lisp
msgid "Old-style IN-PACKAGE."
msgstr ""

#: target:code/package.lisp
msgid "The package named ~S doesn't exist."
msgstr ""

#: target:code/package.lisp
msgid "Changes the name and nicknames for a package."
msgstr ""

#: target:code/package.lisp
msgid "A package named ~S already exists."
msgstr ""

#: target:code/package.lisp
msgid "Delete the PACKAGE-OR-NAME from the package system data structures."
msgstr ""

#: target:code/package.lisp
msgid "Return NIL"
msgstr ""

#: target:code/package.lisp
msgid "No package of name ~S."
msgstr ""

#: target:code/package.lisp
msgid "Remove dependency in other packages."
msgstr ""

#: target:code/package.lisp
msgid "Returns a list of all existing packages."
msgstr ""

#: target:code/package.lisp
msgid "Returns a symbol having the specified name, creating it if necessary."
msgstr ""

#: target:code/package.lisp
msgid ""
"Returns the symbol NAME in PACKAGE.  If such a symbol is found\n"
"  then the second value is :internal, :external or :inherited to indicate\n"
"  how the symbol is accessible.  If no symbol is found then both values\n"
"  are NIL."
msgstr ""

#: target:code/package.lisp
msgid "interning symbol ~A"
msgstr ""

#: target:code/package.lisp
msgid ""
"Makes SYMBOL no longer present in PACKAGE.  If SYMBOL was present\n"
"  then T is returned, otherwise NIL.  If PACKAGE is SYMBOL's home\n"
"  package, then it is made uninterned."
msgstr ""

#: target:code/package.lisp
msgid "uninterning symbol ~A"
msgstr ""

#: target:code/package.lisp
msgid "prompt for a symbol to shadowing-import."
msgstr ""

#: target:code/package.lisp
msgid "Uninterning symbol ~S causes name conflict among these symbols:~%~S"
msgstr ""

#: target:code/package.lisp
msgid "Symbol to shadowing-import: "
msgstr ""

#: target:code/package.lisp
msgid "~S is not a symbol."
msgstr ""

#: target:code/package.lisp
msgid "~S is not one of the conflicting symbols."
msgstr ""

#: target:code/package.lisp
msgid "~S is neither a symbol nor a list of symbols."
msgstr ""

#: target:code/package.lisp
msgid "Exports SYMBOLS from PACKAGE, checking that no name conflicts result."
msgstr ""

#: target:code/package.lisp
msgid ""
"Exporting these symbols from the ~A package:~%~S~%~\n"
"\t      results in name conflicts with these packages:~%~{~A ~}"
msgstr ""

#: target:code/package.lisp
msgid "Import these symbols into the ~A package."
msgstr ""

#: target:code/package.lisp
msgid "These symbols are not accessible in the ~A package:~%~S"
msgstr ""

#: target:code/package.lisp
msgid "Makes SYMBOLS no longer exported from PACKAGE."
msgstr ""

#: target:code/package.lisp
msgid "unexporting symbols ~A"
msgstr ""

#: target:code/package.lisp
msgid "~S is not accessible in the ~A package."
msgstr ""

#: target:code/package.lisp
msgid ""
"Make SYMBOLS accessible as internal symbols in PACKAGE.  If a symbol\n"
"  is already accessible then it has no effect.  If a name conflict\n"
"  would result from the importation, then a correctable error is signalled."
msgstr ""

#: target:code/package.lisp
msgid "Import these symbols with Shadowing-Import."
msgstr ""

#: target:code/package.lisp
msgid ""
"Importing these symbols into the ~A package ~\n"
"\t\tcauses a name conflict:~%~S"
msgstr ""

#: target:code/package.lisp
msgid ""
"Import SYMBOLS into PACKAGE, disregarding any name conflict.  If\n"
"  a symbol of the same name is present, then it is uninterned.\n"
"  The symbols are added to the Package-Shadowing-Symbols."
msgstr ""

#: target:code/package.lisp
msgid ""
"Make an internal symbol in PACKAGE with the same name as each of the\n"
"  specified SYMBOLS, adding the new symbols to the Package-Shadowing-"
"Symbols.\n"
"  If a symbol with the given name is already present in PACKAGE, then\n"
"  the existing symbol is placed in the shadowing symbols list if it is\n"
"  not already present."
msgstr ""

#: target:code/package.lisp
msgid ""
"Add all the PACKAGES-TO-USE to the use list for PACKAGE so that\n"
"  the external symbols of the used packages are accessible as internal\n"
"  symbols in PACKAGE."
msgstr ""

#: target:code/package.lisp
msgid "Unintern the conflicting symbols in the ~2*~A package."
msgstr ""

#: target:code/package.lisp
msgid "Use'ing package ~A results in name conflicts for these symbols:~%~S"
msgstr ""

#: target:code/package.lisp
msgid "Remove PACKAGES-TO-UNUSE from the use list for PACKAGE."
msgstr ""

#: target:code/package.lisp
msgid "Return a list of all symbols in the system having the specified name."
msgstr ""

#: target:code/describe.lisp target:code/package.lisp
msgid "special variable"
msgstr ""

#: target:code/describe.lisp target:code/package.lisp
msgid "constant"
msgstr ""

#: target:code/describe.lisp target:code/package.lisp
msgid "undefined variable"
msgstr ""

#: target:code/describe.lisp target:code/package.lisp
msgid "symbol macro"
msgstr ""

#: target:code/package.lisp
msgid "alien variable"
msgstr ""

#: target:code/package.lisp
msgid "value: "
msgstr ""

#: target:code/package.lisp
msgid "macro"
msgstr ""

#: target:code/package.lisp
msgid "special operator"
msgstr ""

#: target:code/package.lisp
msgid "function"
msgstr ""

#: target:code/package.lisp
msgid "class"
msgstr ""

#: target:code/package.lisp
msgid "type"
msgstr ""

#: target:code/package.lisp
msgid ""
"Call FUN with each symbol that contains STRING.\n"
"  If PACKAGE is supplied then only use symbols present in\n"
"  that package.  If EXTERNAL-ONLY is true then only use\n"
"  symbols exported from the specified package."
msgstr ""

#: target:code/package.lisp
msgid ""
"Briefly describe all symbols which contain the specified STRING.\n"
"  If PACKAGE is supplied then only describe symbols present in\n"
"  that package.  If EXTERNAL-ONLY is non-NIL then only describe\n"
"  external symbols in the specified package."
msgstr ""

#: target:code/package.lisp
msgid ""
"Identical to APROPOS, except that it returns a list of the symbols\n"
"  found instead of describing them."
msgstr ""

#: target:code/reader.lisp
msgid "Float format for 1.0E1"
msgstr ""

#: target:code/reader.lisp
msgid "Variable bound to current readtable."
msgstr ""

#: target:code/reader.lisp
msgid "Reader error ~@[at ~D ~]on ~S:~%~?"
msgstr ""

#: target:code/reader.lisp
msgid "Unexpected EOF on ~S ~A."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Standard lisp readtable. This is for recovery from broken\n"
"   read-tables, and should not normally be user-visible."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Readtable is a data structure that maps characters into syntax\n"
"   types for the Common Lisp expression reader."
msgstr ""

#: target:code/reader.lisp
msgid "Value of *package* at the start of the last read or Nil."
msgstr ""

#: target:code/reader.lisp
msgid "Undefined read-macro character ~S"
msgstr ""

#: target:code/reader.lisp
msgid "A copy is made of from-readtable and place into to-readtable."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Causes the syntax of to-char to be the same as from-char in the \n"
"  optional readtable (defaults to the current readtable).  The\n"
"  from-table defaults the standard lisp readtable by being nil."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Causes char to be a macro character which invokes function when\n"
"   seen by the reader.  The non-terminatingp flag can be used to\n"
"   make the macro character non-terminating.  The optional readtable\n"
"   argument defaults to the current readtable.  Set-macro-character\n"
"   returns T."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Returns the function associated with the specified char which is a macro\n"
"  character.  The optional readtable argument defaults to the current\n"
"  readtable."
msgstr ""

#: target:code/reader.lisp
msgid "Bind *read-buffer* to a fresh buffer and execute Body."
msgstr ""

#: target:code/reader.lisp
msgid "If true, only warn when there is an extra close paren, otherwise error."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Reads from stream and returns the object read, preserving the whitespace\n"
"   that followed the object."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Reads in the next object in the stream, which defaults to\n"
"   *standard-input*. For details see the I/O chapter of\n"
"   the manual."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Reads objects from input-stream until the next character after an\n"
"   object's representation is endchar.  A list of those objects read\n"
"   is returned."
msgstr ""

#: target:code/reader.lisp
msgid "Nothing appears before . in list."
msgstr ""

#: target:code/reader.lisp
msgid "Nothing appears after . in list."
msgstr ""

#: target:code/reader.lisp
msgid "More than one object follows . in list."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Ignoring unmatched close parenthesis~\n"
"\t\t  ~@[ at file position ~D~]."
msgstr ""

#: target:code/reader.lisp
msgid "Unmatched close parenthesis."
msgstr ""

#: target:code/reader.lisp
msgid "after escape character"
msgstr ""

#: target:code/reader.lisp
msgid "inside extended token"
msgstr ""

#: target:code/reader.lisp
msgid "invalid constituent"
msgstr ""

#: target:code/reader.lisp
msgid "Suppresses most interpreting of the reader when T"
msgstr ""

#: target:code/reader.lisp
msgid "The radix that Lisp reads numbers in."
msgstr ""

#: target:code/reader.lisp
msgid "This function is just an fsm that recognizes numbers and symbols."
msgstr ""

#: target:code/reader.lisp
msgid "impossible!"
msgstr ""

#: target:code/reader.lisp
msgid "dot context error"
msgstr ""

#: target:code/reader.lisp
msgid "too many dots"
msgstr ""

#: target:code/reader.lisp
msgid "too many colons in ~S"
msgstr ""

#: target:code/reader.lisp
msgid "after reading a colon"
msgstr ""

#: target:code/reader.lisp
msgid "package ~S not found"
msgstr ""

#: target:code/reader.lisp
msgid "Use symbol anyway."
msgstr ""

#: target:code/reader.lisp
msgid "The symbol ~S is not external in the ~A package."
msgstr ""

#: target:code/reader.lisp
msgid "Symbol ~S not found in the ~A package."
msgstr ""

#: target:code/reader.lisp
msgid ""
"For semi-external use: returns 3 values: the string for the token,\n"
"   a flag for whether there was an escape char, and the position of any\n"
"   package delimiter."
msgstr ""

#: target:code/reader.lisp
msgid ""
"For semi-external use: read an extended token with the first character\n"
"  escaped.  Returns the string for the token."
msgstr ""

#: target:code/reader.lisp
msgid "after escape"
msgstr ""

#: target:code/reader.lisp
msgid ""
"Holds the mapping of base to 'safe' number of digits to read for a fixnum."
msgstr ""

#: target:code/reader.lisp
msgid "Holds the largest fixnum power of the base for make-integer."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Minimizes bignum-fixnum multiplies by reading a 'safe' number of digits, \n"
"  then multiplying by a power of the base and adding."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Fast bignum-reading interface.  Reads from stream S an integer in radix\n"
"R.  If we find some kind of error (bad characters, EOF), then NIL is\n"
"returned; otherwise the number.  Reads at least one digit, but may not get "
"to\n"
"the end of the stream."
msgstr ""

#: target:code/reader.lisp
msgid "Internal error in floating point reader."
msgstr ""

#: target:code/reader.lisp
msgid "Underflow"
msgstr ""

#: target:code/reader.lisp
msgid "Floating-point number not representable"
msgstr ""

#: target:code/reader.lisp
msgid "Invalid ratio: ~S/~S"
msgstr ""

#: target:code/reader.lisp
msgid "No dispatch function defined for ~S."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Causes char to become a dispatching macro character in readtable\n"
"   (which defaults to the current readtable).  If the non-terminating-p\n"
"   flag is set to T, the char will be non-terminating.  Make-dispatch-\n"
"   macro-character returns T."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Causes function to be called whenever the reader reads\n"
"   disp-char followed by sub-char. Set-dispatch-macro-character\n"
"   returns T."
msgstr ""

#: target:code/reader.lisp
msgid "Dispatch Sub-Char must not be a decimal digit: ~S"
msgstr ""

#: target:code/reader.lisp
msgid "~S is not a dispatch character."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Returns the macro character function for sub-char under disp-char\n"
"   or nil if there is no associated function."
msgstr ""

#: target:code/reader.lisp
msgid "inside dispatch character"
msgstr ""

#: target:code/reader.lisp
msgid "No dispatch table for dispatch char."
msgstr ""

#: target:code/reader.lisp
msgid "A resource of string streams for Read-From-String."
msgstr ""

#: target:code/reader.lisp
msgid ""
"The characters of string are successively given to the lisp reader\n"
"   and the lisp object built by the reader is returned.  Macro chars\n"
"   will take effect."
msgstr ""

#: target:code/reader.lisp
msgid ""
"Examine the substring of string delimited by start and end\n"
"  (default to the beginning and end of the string)  It skips over\n"
"  whitespace characters and then tries to parse an integer.  The\n"
"  radix parameter must be between 2 and 36."
msgstr ""

#: target:code/reader.lisp
msgid "There are no digits in this string: ~S"
msgstr ""

#: target:code/reader.lisp
msgid "There's junk in this string: ~S."
msgstr ""

#: target:code/sharpm.lisp
msgid "Numeric argument ignored in #~D~A."
msgstr ""

#: target:code/sharpm.lisp
msgid "Unrecognized character name: ~S"
msgstr ""

#: target:code/sharpm.lisp
msgid "Ill-formed vector: #~S"
msgstr ""

#: target:code/sharpm.lisp
msgid "Vector longer than specified length: #~S~S"
msgstr ""

#: target:code/sharpm.lisp
msgid "Escape character appeared after #*"
msgstr ""

#: target:code/sharpm.lisp
msgid "You have to give a little bit for non-zero #* bit-vectors."
msgstr ""

#: target:code/sharpm.lisp
msgid "Illegal element given for bit-vector: ~S"
msgstr ""

#: target:code/sharpm.lisp
msgid "Bit vector is longer than specified length #~A*~A"
msgstr ""

#: target:code/sharpm.lisp
msgid "Symbol following #: contains a package marker: ~S"
msgstr ""

#: target:code/sharpm.lisp
msgid "If false, then the #. read macro is disabled."
msgstr ""

#: target:code/sharpm.lisp
msgid "Attempt to read #. while *READ-EVAL* is bound to NIL."
msgstr ""

#: target:code/sharpm.lisp
msgid "Radix missing in #R."
msgstr ""

#: target:code/sharpm.lisp
msgid "Illegal radix for #R: ~D."
msgstr ""

#: target:code/sharpm.lisp
msgid "#~A (base ~D) value is not a rational: ~S."
msgstr ""

#: target:code/sharpm.lisp
msgid ""
"#~DA axis ~D is empty, but axis ~\n"
"\t\t\t\t          ~D is non-empty."
msgstr ""

#: target:code/sharpm.lisp
msgid "Non-list following #S"
msgstr ""

#: target:code/sharpm.lisp
msgid "Non-list following #S: ~S"
msgstr ""

#: target:code/sharpm.lisp
msgid "Structure type is not a symbol: ~S"
msgstr ""

#: target:code/sharpm.lisp
msgid "~S is not a defined structure type."
msgstr ""

#: target:code/sharpm.lisp
msgid "The ~S structure does not have a default constructor."
msgstr ""

#: target:code/sharpm.lisp
msgid "Missing label for #=."
msgstr ""

#: target:code/sharpm.lisp
msgid "Multiply defined label: #~D="
msgstr ""

#: target:code/sharpm.lisp
msgid "Have to tag something more than just #~D#."
msgstr ""

#: target:code/sharpm.lisp
msgid "Missing label for ##."
msgstr ""

#: target:code/sharpm.lisp
msgid "reference to undefined label #~D#"
msgstr ""

#: target:code/sharpm.lisp
msgid "Illegal complex number format: #C~S"
msgstr ""

#: target:code/sharpm.lisp
msgid "Illegal sharp character ~S"
msgstr ""

#: target:code/backq.lisp
msgid "How deep we are into backquotes"
msgstr ""

#: target:code/backq.lisp
msgid ",@ after backquote in ~S"
msgstr ""

#: target:code/backq.lisp
msgid ",. after backquote in ~S"
msgstr ""

#: target:code/backq.lisp
msgid "Comma not inside a backquote."
msgstr ""

#: target:code/backq.lisp
msgid ",@ after dot in ~S"
msgstr ""

#: target:code/backq.lisp
msgid ",. after dot in ~S"
msgstr ""

#: target:code/backq.lisp
msgid ""
"Given a lisp form containing the magic functions BACKQ-LIST, BACKQ-LIST*,\n"
"  BACKQ-APPEND, etc. produced by the backquote reader macro, will return a\n"
"  corresponding backquote input form.  In this form, `,' `,@' and `,.' are\n"
"  represented by lists whose cars are BACKQ-COMMA, BACKQ-COMMA-AT, and\n"
"  BACKQ-COMMA-DOT respectively, and whose cadrs are the form after the "
"comma.\n"
"  SPLICING indicates whether a comma-escape return should be modified for\n"
"  splicing with other forms: a value of T or :NCONC meaning that an extra\n"
"  level of parentheses should be added."
msgstr ""

#: target:code/backq.lisp
msgid "### illegal dotted backquote form ###"
msgstr ""

#: target:code/serve-event.lisp
msgid ""
"Make an object set for use by a RPC/xevent server.  Name is for\n"
"      descriptive purposes only."
msgstr ""

#: target:code/serve-event.lisp
msgid "You lose, object: ~S"
msgstr ""

#: target:code/serve-event.lisp
msgid ""
"Return the handler function in Object-Set for the operation specified by\n"
"   Message-ID, if none, NIL is returned."
msgstr ""

#: target:code/serve-event.lisp
msgid "Sets the handler function for an object set operation."
msgstr ""

#: target:code/serve-event.lisp
msgid "#<Handler for ~A on ~:[~;BOGUS ~]descriptor ~D: ~S>"
msgstr ""

#: target:code/serve-event.lisp
msgid "List of all the currently active handlers for file descriptors"
msgstr ""

#: target:code/serve-event.lisp
msgid ""
"Arange to call FUNCTION whenever FD is usable. DIRECTION should be\n"
"  either :INPUT or :OUTPUT. The value returned should be passed to\n"
"  SYSTEM:REMOVE-FD-HANDLER when it is no longer needed."
msgstr ""

#: target:code/serve-event.lisp
msgid "Invalid direction ~S, must be either :INPUT or :OUTPUT"
msgstr ""

#: target:code/serve-event.lisp
msgid "Removes HANDLER from the list of active handlers."
msgstr ""

#: target:code/serve-event.lisp
msgid ""
"Remove any handers refering to FD. This should only be used when attempting\n"
"  to recover from a detected inconsistency."
msgstr ""

#: target:code/serve-event.lisp
msgid ""
"Establish a handler with SYSTEM:ADD-FD-HANDLER for the duration of BODY.\n"
"   DIRECTION should be either :INPUT or :OUTPUT, FD is the file descriptor "
"to\n"
"   use, and FUNCTION is the function to call whenever FD is usable."
msgstr ""

#: target:code/serve-event.lisp
msgid "Timeout is not a real number or NIL: ~S"
msgstr ""

#: target:code/serve-event.lisp
msgid ""
"Wait until FD is usable for DIRECTION. DIRECTION should be either :INPUT or\n"
"  :OUTPUT. TIMEOUT, if supplied, is the number of seconds to wait before "
"giving\n"
"  up."
msgstr ""

#: target:code/serve-event.lisp
msgid ""
"This is an alist mapping displays to user functions to be called when\n"
"   SYSTEM:SERVE-EVENT notices input on a display connection.  Do not modify\n"
"   this directly; use EXT:ENABLE-CLX-EVENT-HANDLING.  A given display\n"
"   should be represented here only once."
msgstr ""

#: target:code/serve-event.lisp
msgid ""
"SERVE-ALL-EVENTS calls SERVE-EVENT with the specified timeout.  If\n"
"  SERVE-EVENT does something (returns T) it loops over SERVE-EVENT with "
"timeout\n"
"  0 until all events have been served.  SERVE-ALL-EVENTS returns T if\n"
"  SERVE-EVENT did something and NIL if not."
msgstr ""

#: target:code/serve-event.lisp
msgid ""
"Receive on all ports and Xevents and dispatch to the appropriate handler\n"
"  function.  If timeout is specified, server will wait the specified time "
"(in\n"
"  seconds) and then return, otherwise it will wait until something happens.\n"
"  Server returns T if something happened and NIL otherwise."
msgstr ""

#: target:code/serve-event.lisp
msgid "Event-listen was true, but handler didn't handle: ~%~S"
msgstr ""

#: target:code/extfmts.lisp
msgid "Attempting unimplemented external-format I/O."
msgstr ""

#: target:code/extfmts.lisp
msgid "Nonsensical argument (~S) to DEFINE-EXTERNAL-FORMAT."
msgstr ""

#: target:code/extfmts.lisp
msgid "External-format aliases file ends early."
msgstr ""

#: target:code/extfmts.lisp
msgid "Bad entry in external-format aliases file: ~S => ~S."
msgstr ""

#: target:code/extfmts.lisp
msgid "External-format aliasing depth exceeded."
msgstr ""

#: target:code/extfmts.lisp
msgid "~S is a Composing-External-Format."
msgstr ""

#: target:code/extfmts.lisp
msgid "~S is not a Composing-External-Format."
msgstr ""

#: target:code/extfmts.lisp
msgid "~S is not a valid external format name."
msgstr ""

#: target:code/extfmts.lisp
msgid "External format ~S not found."
msgstr ""

#: target:code/extfmts.lisp
msgid "Attempting I/O through void external-format."
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Convert String to octets using the specified External-format.  The\n"
"   string is bounded by Start (defaulting to 0) and End (defaulting to\n"
"   the end of the string.  If Buffer is given, the octets are stored\n"
"   there.  If not, a new buffer is created."
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Octets-to-string converts an array of octets in Octets to a string\n"
"  according to the specified External-format.  The array of octets is\n"
"  bounded by Start (defaulting ot 0) and End (defaulting to the end of\n"
"  the array.  If String is not given, a new string is created.  If\n"
"  String is given, the converted octets are stored in String, starting\n"
"  at S-Start (defaulting to the 0) and ending at S-End (defaulting to\n"
"  the length of String).  If the string is not large enough to hold\n"
"  all of characters, then some octets will not be converted.  A State\n"
"  may also be specified; this is used as the state of the external\n"
"  format.\n"
"\n"
"  Four values are returned: the string, the number of characters read,\n"
"  the number of octets actually consumed and the new state of the\n"
"  external format."
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Encode the given String using External-Format and return a new\n"
"  string.  The characters of the new string are the octets of the\n"
"  encoded result, with each octet converted to a character via\n"
"  code-char.  This is the inverse to String-Decode"
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Decode String using the given External-Format and return the new\n"
"  string.  The input string is treated as if it were an array of\n"
"  octets, where the char-code of each character is the octet.  This is\n"
"  the inverse of String-Encode."
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Change the external format of the standard streams to Terminal.\n"
"  The standard streams are sys::*stdin*, sys::*stdout*, and\n"
"  sys::*stderr*, which are normally the input and/or output streams\n"
"  for *standard-input* and *standard-output*.  Also sets sys::*tty*\n"
"  (normally *terminal-io* to the given external format.  If the\n"
"  optional argument Filenames is gvien, then the filename encoding is\n"
"  set to the specified format."
msgstr ""

#: target:code/extfmts.lisp
msgid "Can't find external-format ~S."
msgstr ""

#: target:code/extfmts.lisp
msgid "Change it anyway."
msgstr ""

#: target:code/extfmts.lisp
msgid "The external-format for encoding filenames is already set."
msgstr ""

#: target:code/fd-stream.lisp
msgid ""
"List of available buffers.  Each buffer is an sap pointing to\n"
"  bytes-per-buffer of memory."
msgstr ""

#: target:code/fd-stream.lisp
msgid "Number of bytes per buffer."
msgstr ""

#: target:code/fd-stream.lisp
msgid "The maximum supported byte size for a stream element-type."
msgstr ""

#: target:code/fd-stream.lisp
msgid ""
"List of all available output routines. Each element is a list of the\n"
"  element-type output, the kind of buffering, the function name, and the "
"number\n"
"  of bytes per element."
msgstr ""

#: target:code/fd-stream.lisp
msgid "Write would have blocked, but SERVER told us to go."
msgstr ""

#: target:code/fd-stream.lisp
msgid "While writing ~S: ~A"
msgstr ""

#: target:code/fd-stream.lisp
msgid ""
"Output THING to stream.  THING can be any kind of vector or a sap.  If "
"THING\n"
"  is a SAP, END must be supplied (as length won't work)."
msgstr ""

#: target:code/fd-stream.lisp
msgid ""
"List of all available input routines. Each element is a list of the\n"
"  element-type input, the function name, and the number of bytes per element."
msgstr ""

#: target:code/fd-stream.lisp
msgid "Error reading ~S: ~A"
msgstr ""

#: target:code/fd-stream.lisp
msgid "Could not find any input routine for ~S"
msgstr ""

#: target:code/fd-stream.lisp
msgid "Could not find any output routine for ~S buffered ~S."
msgstr ""

#: target:code/fd-stream.lisp
msgid "Element sizes for input (~S:~S) and output (~S:~S) differ?"
msgstr ""

#: target:code/fd-stream.lisp
msgid "Input type (~S) and output type (~S) are unrelated?"
msgstr ""

#: target:code/fd-stream.lisp
msgid "Error lseek'ing ~S: ~A"
msgstr ""

#: target:code/fd-stream.lisp
msgid "Invalid position given to file-position: ~S"
msgstr ""

#: target:code/fd-stream.lisp
msgid ""
"Create a stream for the given unix file descriptor.\n"
"  If input is non-nil, allow input operations.\n"
"  If output is non-nil, allow output operations.\n"
"  If neither input nor output are specified, default to allowing input.\n"
"  Element-type indicates the element type to use (as for open).\n"
"  Buffering indicates the kind of buffering to use.\n"
"  Timeout (if true) is the number of seconds to wait for input.  If NIL "
"(the\n"
"    default), then wait forever.  When we time out, we signal IO-TIMEOUT.\n"
"  File is the name of the file (will be returned by PATHNAME).\n"
"  Name is used to identify the stream when printed."
msgstr ""

#: target:code/fd-stream.lisp
msgid "File descriptor must be opened either for input or output."
msgstr ""

#: target:code/fd-stream.lisp
msgid ""
"This is a string that OPEN tacks on the end of a file namestring to produce\n"
"   a name for the :if-exists :rename-and-delete and :rename options.  Also,\n"
"   this can be a function that takes a namestring and returns a complete\n"
"   namestring."
msgstr ""

#: target:code/fd-stream.lisp
msgid ""
"Return a stream which reads from or writes to Filename.\n"
"  Defined keywords:\n"
"   :direction - one of :input, :output, :io, or :probe\n"
"   :element-type - Type of object to read or write, default BASE-CHAR\n"
"   :if-exists - one of :error, :new-version, :rename, :rename-and-delete,\n"
"                       :overwrite, :append, :supersede or nil\n"
"   :if-does-not-exist - one of :error, :create or nil\n"
"   :external-format - an external format name\n"
"  See the manual for details."
msgstr ""

#: target:code/fd-stream.lisp
msgid "Unable to open streams of class ~S."
msgstr ""

#: target:pcl/std-class.lisp target:pcl/boot.lisp target:pcl/defs.lisp
#: target:pcl/defclass.lisp target:code/macros.lisp target:code/fd-stream.lisp
msgid "Odd-length property list in REMF."
msgstr ""

#: target:code/fd-stream.lisp
msgid ""
"The stream connected to the controlling terminal or NIL if there is none."
msgstr ""

#: target:code/fd-stream.lisp
msgid "The stream connected to the standard input (file descriptor 0)."
msgstr ""

#: target:code/fd-stream.lisp
msgid "The stream connected to the standard output (file descriptor 1)."
msgstr ""

#: target:code/fd-stream.lisp
msgid "The stream connected to the standard error output (file descriptor 2)."
msgstr ""

#: target:code/fd-stream.lisp
msgid "This is called in BEEP to feep the user.  It takes a stream."
msgstr ""

#: target:code/fd-stream.lisp
msgid ""
"Return the delta in Stream's FILE-POSITION that would be caused by writing\n"
"   Object to Stream.  Non-trivial only in implementations that support\n"
"   international character sets."
msgstr ""

#: target:code/fd-stream-extfmt.lisp
msgid "Loading simple-streams should redefine this"
msgstr ""

#: target:code/fd-stream-extfmt.lisp
msgid "Don't know how to set external-format for ~S."
msgstr ""

#: target:code/fd-stream-extfmt.lisp
msgid "Setting external-format on Gray streams not supported."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"When non-nil, attempt to load \"library:<host>.translations\" to resolve\n"
"   an otherwise undefined logical host."
msgstr ""

#: target:code/pathname.lisp
msgid "A path specification, either a string, file-stream or pathname."
msgstr ""

#: target:code/pathname.lisp
msgid "Convert thing (a pathname, string or stream) into a pathname."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Construct a filled in pathname by completing the unspecified components\n"
"   from the defaults."
msgstr ""

#: target:code/pathname.lisp
msgid "~S is not allowed as a directory component."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Makes a new pathname from the component arguments.  Note that host is\n"
"a host-structure or string."
msgstr ""

#: target:code/pathname.lisp
msgid "Silly argument for a unix ~A: ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Silly argument for a unix PATHNAME-NAME: ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Illegal pathname: ~\n"
"                                Directory with ~S immediately followed by ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Accessor for the pathname's host."
msgstr ""

#: target:code/pathname.lisp
msgid "Accessor for pathname's device."
msgstr ""

#: target:code/pathname.lisp
msgid "Accessor for the pathname's directory list."
msgstr ""

#: target:code/pathname.lisp
msgid "Accessor for the pathname's name."
msgstr ""

#: target:code/pathname.lisp
msgid "Accessor for the pathname's version."
msgstr ""

#: target:code/pathname.lisp
msgid "Parse error in namestring: ~?~%  ~A~%  ~V@T^"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"When Host arg is not supplied, Defaults arg must ~\n"
"\t\t  have a non-null PATHNAME-HOST."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Host in namestring: ~S~@\n"
"\t\t    does not match explicit host argument: ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Converts pathname, a pathname designator, into a pathname structure,\n"
"   for a physical pathname, returns the printed representation. Host may be\n"
"   a physical host structure or host namestring."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"A LIST representing a pathname host is not ~\n"
"                              supported in this implementation:~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Hosts do not match: ~S and ~S."
msgstr ""

#: target:code/pathname.lisp
msgid "Can't figure out the file associated with stream:~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Construct the full (name)string form of the pathname."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Cannot determine the namestring for pathnames with no ~\n"
"\t\t  host:~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Returns a string representation of the name of the host in the pathname."
msgstr ""

#: target:code/pathname.lisp
msgid "Cannot determine the namestring for pathnames with no host:~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Returns a string representation of the directories used in the pathname."
msgstr ""

#: target:code/pathname.lisp
msgid "Returns a string representation of the name used in the pathname."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Returns an abbreviated pathname sufficent to identify the pathname relative\n"
"   to the defaults."
msgstr ""

#: target:code/pathname.lisp
msgid "Predicate for determining whether pathname contains any wildcards."
msgstr ""

#: target:code/pathname.lisp
msgid "Pathname matches the wildname template?"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Not enough wildcards in FROM pattern to match ~\n"
"\t\t       TO pattern:~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Can't substitute this into the middle of a word:~\n"
"\t\t\t  ~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Pathname components from Source and From args to TRANSLATE-PATHNAME~@\n"
"\t  did not match:~%  ~S ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
":WILD-INFERIORS not paired in from and to ~\n"
"\t\t\t   patterns:~%  ~S ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Use the source pathname to translate the from-wildname's wild and\n"
"   unspecified elements into a completed to-pathname based on the to-"
"wildname."
msgstr ""

#: target:code/pathname.lisp
msgid "~S doesn't match ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Search-list ~a not defined."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Clear the current definition for the search-list NAME.  Returns T if such\n"
"   a definition existed, and NIL if not."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Clear the definition for all search-lists.  Only use this if you know\n"
"   what you are doing."
msgstr ""

#: target:code/pathname.lisp
msgid "~S doesn't start with a search-list."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Return the expansions for the search-list starting PATHNAME.  If PATHNAME\n"
"   does not start with a search-list, then an error is signaled.  If\n"
"   the search-list has not been defined yet, then an error is signaled.\n"
"   The expansion for a search-list can be set with SETF."
msgstr ""

#: target:code/pathname.lisp
msgid "Search list ~S has not been defined yet."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Returns T if the search-list starting PATHNAME is currently defined, and\n"
"   NIL otherwise.  An error is signaled if PATHNAME does not start with a\n"
"   search-list."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"That would result in a circularity:~%  ~\n"
"\t\t     ~A~{ -> ~A~} -> ~A"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Search-lists cannot expand into pathnames that have ~\n"
"\t\t       a name, type, or ~%version specified:~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Execute BODY with VAR bound to each successive possible expansion for\n"
"   PATHNAME and then return RESULT.  Note: if PATHNAME does not contain a\n"
"   search-list, then BODY is executed exactly once.  Everything is wrapped\n"
"   in a block named NIL, so RETURN can be used to terminate early.  Note:\n"
"   VAR is *not* bound inside of RESULT."
msgstr ""

#: target:code/pathname.lisp
msgid "Undefined search list: ~A"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Logical namestring character ~\n"
"\t\t\t     is not alphanumeric or hyphen:~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Logical host not yet defined: ~S"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Double asterisk inside of logical ~\n"
"\t\t\t\t     word: ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Illegal character for logical pathname:~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Expecting ~A, got ~:[nothing~;~:*~S~]."
msgstr ""

#: target:code/pathname.lisp
msgid "a host name"
msgstr ""

#: target:code/pathname.lisp
msgid "a directory name"
msgstr ""

#: target:code/pathname.lisp
msgid "a file name"
msgstr ""

#: target:code/pathname.lisp
msgid "Expecting a dot, got ~S."
msgstr ""

#: target:code/pathname.lisp
msgid "a file type"
msgstr ""

#: target:code/pathname.lisp
msgid "a positive integer, * or NEWEST"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Expected a positive integer, ~\n"
"\t\t\t\t\t    got ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Extra stuff after end of file name."
msgstr ""

#: target:code/pathname.lisp
msgid "Converts the pathspec argument to a logical-pathname and returns it."
msgstr ""

#: target:code/pathname.lisp
msgid "Logical namestring does not specify a host:~%  ~S"
msgstr ""

#: target:code/filesys.lisp target:code/pathname.lisp
msgid "Invalid directory component: ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Invalid keyword: ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Logical pathname translation is not a two-list:~%  ~S"
msgstr ""

#: target:code/pathname.lisp
msgid "Return the (logical) host object argument's list of translations."
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Set the translations list for the logical host argument.\n"
"   Return translations."
msgstr ""

#: target:code/pathname.lisp
msgid "Clobber search-list host with logical pathname host"
msgstr ""

#: target:code/pathname.lisp
msgid "~S names a CMUCL search-list"
msgstr ""

#: target:code/pathname.lisp
msgid ""
"Search for a logical pathname named host, if not already defined. If "
"already\n"
"   defined no attempt to find or load a definition is attempted and NIL is\n"
"   returned. If host is not already defined, but definition is found and "
"loaded\n"
"   successfully, T is returned, else error."
msgstr ""

#: target:code/pathname.lisp
msgid ";; Loading pathname translations from ~A~%"
msgstr ""

#: target:code/pathname.lisp
msgid "Translates pathname to a physical pathname, which is returned."
msgstr ""

#: target:code/pathname.lisp
msgid "No translation for ~S"
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Remove any occurrences of \\ from the string because we've already\n"
"   checked for whatever may have been backslashed."
msgstr ""

#: target:code/filesys.lisp
msgid "Backslash in bad place."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"If non-NIL, Unix shell-style wildcards are ignored when parsing\n"
"  pathname namestrings.  They are also ignored when computing\n"
"  namestrings for pathname objects.  Thus, *, ?, etc. are not\n"
"  wildcards when parsing a namestring, and are not escaped when\n"
"  printing pathnames."
msgstr ""

#: target:code/filesys.lisp
msgid "``['' with no corresponding ``]''"
msgstr ""

#: target:code/filesys.lisp
msgid "~A already names a logical host"
msgstr ""

#: target:code/filesys.lisp
msgid "Invalid pattern piece: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid ":BACK cannot be represented in namestrings."
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a directory separator in a pathname name: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a dot in a pathname name without a pathname type: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Invalid value for a pathname name: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify the type without a file: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a directory separator in a pathname type: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a dot in a pathname type: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a version without a file: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "~S cannot be represented relative to ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot supply a type without a name:~%  ~S"
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Convert PATHNAME into a string that can be used with UNIX system calls.\n"
"   Search-lists and wild-cards are expanded. If optional argument\n"
"   FOR-INPUT is true and PATHNAME doesn't exist, NIL is returned.\n"
"   If optional argument EXECUTABLE-ONLY is true, NIL is returned\n"
"   unless an executable version of PATHNAME exists."
msgstr ""

#: target:code/filesys.lisp
msgid "~S is ambiguous:~{~%  ~A~}"
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Return the pathname for the actual file described by the pathname\n"
"  An error of type file-error is signalled if no such file exists,\n"
"  or the pathname is wild."
msgstr ""

#: target:code/filesys.lisp
msgid "Bad place for a wild pathname."
msgstr ""

#: target:code/filesys.lisp
msgid "The file ~S does not exist."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Return a pathname which is the truename of the file if it exists, NIL\n"
"  otherwise. An error of type file-error is signalled if pathname is wild."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Rename File to have the specified New-Name.  If file is a stream open to a\n"
"  file, then the associated file is renamed."
msgstr ""

#: target:code/filesys.lisp
msgid "~S can't be created."
msgstr ""

#: target:code/filesys.lisp
msgid "Failed to rename ~A to ~A: ~A"
msgstr ""

#: target:code/filesys.lisp
msgid "Delete the specified file."
msgstr ""

#: target:code/filesys.lisp
msgid "~S doesn't exist."
msgstr ""

#: target:code/filesys.lisp
msgid "Could not delete ~A: ~A."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Delete old versions of files matching the given Pathname,\n"
"optionally keeping some of the most recent old versions."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Returns the home directory of the logged in user as a pathname.\n"
"  This is obtained from the logical name \"home:\"."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Return file's creation date, or NIL if it doesn't exist.\n"
" An error of type file-error is signalled if file is a wild pathname"
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Returns the file author as a string, or nil if the author cannot be\n"
" determined.  Signals an error of type file-error if file doesn't exist,\n"
" or file is a wild pathname."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Returns a list of pathnames, one for each file that matches the given\n"
"   pathname.  Supplying :ALL as nil causes this to ignore Unix dot files.  "
"This\n"
"   never includes Unix dot and dot-dot in the result.  If :TRUENAMEP is "
"NIL,\n"
"   then symbolic links in the result are not expanded, which is not the\n"
"   default because TRUENAME does follow links and the result pathnames are\n"
"   defined to be the TRUENAME of the pathname (the truename of a link may "
"well\n"
"   be in another directory).  If FOLLOW-LINKS is NIL then symbolic links "
"are\n"
"   not followed."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Like Directory, but prints a terse, multi-column directory listing\n"
"   instead of returning a list of pathnames.  When :all is supplied and\n"
"   non-nil, then Unix dot files are included too (as ls -a).  When :verbose\n"
"   is supplied and non-nil, then a long listing of miscellaneous\n"
"   information is output one file per line."
msgstr ""

#: target:code/filesys.lisp
msgid "Directory of ~A:~%"
msgstr ""

#: target:code/filesys.lisp
msgid "Couldn't stat ~A -- ~A.~%"
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Return a list of all files which are possible completions of Pathname.\n"
"   We look in the directory specified by Defaults as well as looking down\n"
"   the search list."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"File-writable accepts a pathname and returns T if the current\n"
"  process can write it, and NIL otherwise."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Returns the pathname for the default directory.  This is the place where\n"
"  a file will be written if no directory is specified.  This may be changed\n"
"  with setf."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Tests whether the directories containing the specified file\n"
"  actually exist, and attempts to create them if they do not.\n"
"  Portable programs should avoid using the :MODE keyword argument."
msgstr ""

#: target:code/filesys.lisp
msgid "~&Creating directory: ~A~%"
msgstr ""

#: target:code/filesys.lisp
msgid "Can't create directory ~A."
msgstr ""

#: target:code/foreign-linkage.lisp
msgid "~A is not defined as a foreign symbol"
msgstr ""

#: target:code/module.lisp
msgid ""
"This is a list of module names that have been loaded into Lisp so far.\n"
"   It is used by PROVIDE and REQUIRE."
msgstr ""

#: target:code/module.lisp
msgid "*load-verbose* is bound to this before loading files."
msgstr ""

#: target:code/module.lisp
msgid "See function documentation for REQUIRE"
msgstr ""

#: target:code/module.lisp
msgid ""
"Defines a module by registering the files that need to be loaded when\n"
"   the module is required.  If name is a symbol, its print name is used\n"
"   after downcasing it."
msgstr ""

#: target:code/module.lisp
msgid ""
"Adds a new module name to *modules* indicating that it has been loaded.\n"
"   Module-name may be any valid string designator.  All comparisons are\n"
"   done using string=, i.e. module names are case-sensitive."
msgstr ""

#: target:code/module.lisp
msgid ""
"Loads a module when it has not been already.  Pathname, if supplied,\n"
"   is a single pathname or list of pathnames to be loaded if the module\n"
"   needs to be.  If pathname is not supplied, then functions from the list\n"
"   *MODULE-PROVIDER-FUNCTIONS* are called in order with the stringified\n"
"   MODULE-NAME as the argument, until one of them returns non-NIL.  By\n"
"   default the functions MODULE-PROVIDE-CMUCL-DEFMODULE and MODULE-PROVIDE-\n"
"   CMUCL-LIBRARY are on this list of functions, in that order.  The first\n"
"   of those looks for a list of files that was registered by a EXT:"
"DEFMODULE\n"
"   form.  If the module has not been defined, then the second function\n"
"   causes a file to be loaded whose name is formed by merging \"modules:\"\n"
"   and the concatenation of module-name with the suffix \"-LIBRARY\".\n"
"   Note that both the module-name and the suffix are each, separately,\n"
"   converted from :case :common to :case :local.  This merged name will be\n"
"   probed with both a .lisp and .fasl extensions, calling LOAD if it "
"exists.\n"
"\n"
"   Note that in all cases covered above, user code is responsible for\n"
"   calling PROVIDE to indicate a successful load of the module.\n"
"\n"
"   While loading any files, *load-verbose* is bound to *require-verbose*\n"
"   which defaults to t."
msgstr ""

#: target:code/module.lisp
msgid "Don't know how to load ~A"
msgstr ""

#: target:code/module.lisp
msgid "Coerce a string designator to a module name."
msgstr ""

#: target:code/module.lisp
msgid ""
"Derive a default pathname to try to load for an undefined module\n"
"named module-name.  The default pathname is constructed from the\n"
"module-name by appending the suffix \"-LIBRARY\" to it, and merging\n"
"with \"modules:\".  Note that both the module-name and the suffix are\n"
"each, separately, converted from :case :common to :case :local."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Keywords that you can put in a lambda-list, supposing you should want\n"
"  to do such a thing."
msgstr ""

#: target:code/eval.lisp
msgid ""
"The exclusive upper bound on the number of arguments which may be passed\n"
"  to a function, including rest args."
msgstr ""

#: target:code/eval.lisp
msgid ""
"The exclusive upper bound on the number of parameters which may be specifed\n"
"  in a given lambda list.  This is actually the limit on required and "
"optional\n"
"  parameters.  With &key and &aux you can get more."
msgstr ""

#: target:code/eval.lisp
msgid ""
"The exclusive upper bound on the number of multiple-values that you can\n"
"  have."
msgstr ""

#: target:code/eval.lisp
msgid ""
"This variable controls whether assignments to unknown variables at top-"
"level\n"
"   (or in any other call to EVAL of SETQ) will implicitly declare the "
"variable\n"
"   SPECIAL.  These values are meaningful:\n"
"     :WARN  -- Print a warning, but declare the variable special (the "
"default.)\n"
"      T     -- Quietly declare the variable special.\n"
"      NIL   -- Never declare the variable, giving warnings on each use."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Evaluates its single arg in a null lexical environment, returns the\n"
"  result or results."
msgstr ""

#: target:code/eval.lisp
msgid "Wrong number of args to FUNCTION:~% ~S."
msgstr ""

#: target:code/eval.lisp
msgid "~S is a macro."
msgstr ""

#: target:code/eval.lisp
msgid "~S is a special operator."
msgstr ""

#: target:code/eval.lisp
msgid "Wrong number of args to QUOTE:~% ~S."
msgstr ""

#: target:code/eval.lisp
msgid "Odd number of args to SETQ:~% ~S."
msgstr ""

#: target:code/eval.lisp
msgid "Declaring ~S special."
msgstr ""

#: target:code/eval.lisp
msgid "Bad Eval-When situation list: ~S."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Attempt to evaluation a complex expression:~%     ~S~@\n"
"\t  This expression must be compiled, but the compiler is not loaded."
msgstr ""

#: target:code/eval.lisp
msgid ""
"EVAL called on #'(lambda (x) ...) when the compiler isn't loaded:~\n"
"\t  ~%     ~S~%"
msgstr ""

#: target:code/eval.lisp
msgid ""
"Given a function, return three values:\n"
"   1] A lambda expression that could be used to define the function, or NIL "
"if\n"
"      the definition isn't available.\n"
"   2] NIL if the function was definitely defined in a null lexical "
"environment,\n"
"      and T otherwise.\n"
"   3] Some object that \"names\" the function.  Although this is allowed to "
"be\n"
"      any object, CMU CL always returns a valid function name or a string."
msgstr ""

#: target:code/eval.lisp
msgid "If the symbol globally names a special form, returns T, otherwise NIL."
msgstr ""

#: target:code/eval.lisp
msgid ""
"The value of this variable must be a function that can take three\n"
"  arguments, a macro expander function, the macro form to be expanded,\n"
"  and the lexical environment to expand in.  The function should\n"
"  return the expanded form.  This function is called by MACROEXPAND-1\n"
"  whenever a runtime expansion is needed.  Initially this is set to\n"
"  FUNCALL."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Invoke *MACROEXPAND-HOOK* on FUN, FORM, and ENV after coercing it to\n"
"   a function."
msgstr ""

#: target:code/eval.lisp
msgid ""
"If SYMBOL names a macro in ENV, returns the expansion function,\n"
"   else returns NIL.  If ENV is unspecified or NIL, use the global\n"
"   environment only."
msgstr ""

#: target:code/eval.lisp
msgid "~S names a special form."
msgstr ""

#: target:code/eval.lisp
msgid "Cannot funcall macro functions."
msgstr ""

#: target:code/eval.lisp
msgid ""
"If form is a macro (or symbol macro), expands it once.  Returns two values,\n"
"   the expanded form and a T-or-NIL flag indicating whether the form was, "
"in\n"
"   fact, a macro.  Env is the lexical environment to expand in, which "
"defaults\n"
"   to the null environment."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Repetitively call MACROEXPAND-1 until the form can no longer be expanded.\n"
"   Returns the final resultant form, and T if it was expanded.  ENV is the\n"
"   lexical environment to expand in, or NIL (the default) for the null\n"
"   environment."
msgstr ""

#: target:code/eval.lisp
msgid ""
"If NAME names a compiler-macro, returns the expansion function,\n"
"   else returns NIL.  Note: if the name is shadowed in ENV by a local\n"
"   definition, or declared NOTINLINE, NIL is returned.  Can be\n"
"   set with SETF."
msgstr ""

#: target:code/eval.lisp
msgid ""
"If FORM is a function call for which a compiler-macro has been defined,\n"
"   invoke the expander function using *macroexpand-hook* and return the\n"
"   results and T.  Otherwise, return the original form and NIL."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Repetitively call COMPILER-MACROEXPAND-1 until the form can no longer be\n"
"   expanded.  ENV is the lexical environment to expand in, or NIL (the\n"
"   default) for the null environment."
msgstr ""

#: target:code/eval.lisp
msgid ""
"True of any Lisp object that has a constant value: types that eval to\n"
"  themselves, keywords, constants, and list whose car is QUOTE."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Applies FUNCTION to a list of arguments produced by evaluating ARGS in\n"
"  the manner of LIST*.  That is, a list is made of the values of all but "
"the\n"
"  last argument, appended to the value of the last argument, which must be "
"a\n"
"  list."
msgstr ""

#: target:code/eval.lisp
msgid "Calls Function with the given Arguments."
msgstr ""

#: target:code/eval.lisp
msgid "Returns all of its arguments, in order, as values."
msgstr ""

#: target:code/eval.lisp
msgid "Returns all of the elements of List, in order, as values."
msgstr ""

#: target:code/signal.lisp
msgid "A list of unix signal structures."
msgstr ""

#: target:code/signal.lisp
msgid "~S is not a valid signal name or number."
msgstr ""

#: target:code/signal.lisp
msgid ""
"Return the name of the signal as a string.  Signal should be a valid\n"
"  signal number or a keyword of the standard UNIX signal name."
msgstr ""

#: target:code/signal.lisp
msgid ""
"Return a string describing signal.  Signal should be a valid signal\n"
"  number or a keyword of the standard UNIX signal name."
msgstr ""

#: target:code/signal.lisp
msgid ""
"Return the number of the given signal.  Signal should be a valid\n"
"  signal number or a keyword of the standard UNIX signal name."
msgstr ""

#: target:code/signal.lisp
msgid "Returns a mask given a set of signals."
msgstr ""

#: target:code/signal.lisp
msgid ""
"Unix-kill sends the signal signal to the process with process \n"
"   id pid.  Signal should be a valid signal number or a keyword of the\n"
"   standard UNIX signal name."
msgstr ""

#: target:code/signal.lisp
msgid ""
"Unix-killpg sends the signal signal to the all the process in process\n"
"  group PGRP.  Signal should be a valid signal number or a keyword of\n"
"  the standard UNIX signal name."
msgstr ""

#: target:code/signal.lisp
msgid ""
"Unix-sigblock cause the signals specified in mask to be\n"
"   added to the set of signals currently being blocked from\n"
"   delivery.  The macro sigmask is provided to create masks."
msgstr ""

#: target:code/signal.lisp
msgid ""
"Unix-sigpause sets the set of masked signals to its argument\n"
"   and then waits for a signal to arrive, restoring the previous\n"
"   mask upon its return."
msgstr ""

#: target:code/signal.lisp
msgid ""
"Unix-sigsetmask sets the current set of masked signals (those\n"
"   being blocked from delivery) to the argument.  The macro sigmask\n"
"   can be used to create the mask.  The previous value of the signal\n"
"   mask is returned."
msgstr ""

#: target:code/signal.lisp
msgid "Enable all the default signals that Lisp knows how to deal with."
msgstr ""

#: target:code/signal.lisp
msgid "Execute BODY in a context impervious to interrupts."
msgstr ""

#: target:code/signal.lisp
msgid ""
"Allow interrupts while executing BODY.  As interrupts are normally allowed,\n"
"  this is only useful inside a WITHOUT-INTERRUPTS."
msgstr ""

#: target:code/signal.lisp
msgid ""
"With-enabled-interrupts ({(interrupt function)}*) {form}*\n"
"   Establish function as a handler for the Unix signal interrupt which\n"
"   should be a number between 1 and 31 inclusive."
msgstr ""

#: target:code/interr.lisp
msgid "Attempt to RETURN-FROM a block or GO to a tag that no longer exists"
msgstr ""

#: target:code/interr.lisp
msgid "Attempt to THROW to a tag that does not exist: ~S"
msgstr ""

#: target:code/interr.lisp
msgid "Function with declared result type NIL returned:~%  ~S"
msgstr ""

#: target:code/interr.lisp
msgid "Undefined foreign symbol: ~S"
msgstr ""

#: target:code/interr.lisp
msgid ""
"The maximum number of nested errors allowed.  Internal errors are\n"
"   double-counted."
msgstr ""

#: target:code/interr.lisp
msgid "The current number of nested errors."
msgstr ""

#: target:code/interr.lisp
msgid "Unknown internal error, ~D?  args=~S"
msgstr ""

#: target:code/interr.lisp
msgid "Internal error ~D: ~A.  args=~S"
msgstr ""

#: target:code/interr.lisp
msgid ""
"~2&~@<A control stack overflow has occurred: ~\n"
"            the program has entered the yellow control stack guard zone.  ~\n"
"            Please note that you will be returned to the Top-Level if you ~\n"
"            enter the red control stack guard zone while debugging.~@:>~2%"
msgstr ""

#: target:code/interr.lisp
msgid ""
"~2&~@<Fatal control stack overflow.  You have entered~%~\n"
"           the red control stack guard zone while debugging.~%~\n"
"           Returning to Top-Level.~@:>~2%"
msgstr ""

#: target:code/interr.lisp
msgid ""
"~2&~@<Imminent dynamic space overflow has occurred:~%~\n"
"            Only a small amount of dynamic space is available now.~%~\n"
"            Please note that you will be returned to the Top-Level without~%"
"~\n"
"            warning if you run out of space while debugging.~@:>~%"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"All debug-conditions inherit from this type.  These are serious conditions\n"
"    that must be handled, but they are not programmer errors."
msgstr ""

#: target:code/debug-int.lisp
msgid "There is absolutely no debugging information available."
msgstr ""

#: target:code/debug-int.lisp
msgid "No debugging information available."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"The system could not return values from a frame with debug-function since\n"
"    it lacked information about returning values."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"~&Cannot return values from ~:[frame~;~:*~S~] since ~\n"
"\t\t\tthe debug information lacks details about returning ~\n"
"\t\t\tvalues here."
msgstr ""

#: target:code/debug-int.lisp
msgid "The debug-function has no debug-block information."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S has no debug-block information."
msgstr ""

#: target:code/debug-int.lisp
msgid "The debug-function has no debug-variable information."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S has no debug-variable information."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"The debug-function has no lambda-list since argument debug-variables are\n"
"    unavailable."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S has no lambda-list information available."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S has :invalid or :unknown value in ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S names more than one valid variable in ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"All programmer errors from using the interface for building debugging\n"
"    tools inherit from this type."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&Unhandled debug-condition:~%~A"
msgstr ""

#: target:code/debug-int.lisp
msgid "~&Invalid use of an unknown code-location -- ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S not in ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "Invalid control stack pointer."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&Form was preprocessed for ~S,~% but called on ~S:~%  ~S"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the name of the debug-variable.  The name is the name of the symbol\n"
"   used as an identifier when writing the code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the package name of the debug-variable.  This is the package name "
"of\n"
"   the symbol used as an identifier when writing the code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the integer that makes debug-variable's name and package name "
"unique\n"
"   with respect to other debug-variable's in the same function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the frame immediately above frame on the stack.  When frame is\n"
"   the top of the stack, this returns nil."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the debug-function for the function whose call frame represents."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the code-location where the frame's debug-function will continue\n"
"   running when program execution returns to this frame.  If someone\n"
"   interrupted this frame, the result could be an unknown code-location."
msgstr ""

#: target:code/debug-int.lisp
msgid "#<Compiled-Frame ~S~:[~;, interrupted~]>"
msgstr ""

#: target:code/debug-int.lisp
msgid "#<~A-Debug-Function ~S>"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the list of possible code-locations where execution may continue\n"
"   when the basic-block represented by debug-block completes its execution."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns whether debug-block represents elsewhere code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the breakpoint's function the system calls when execution "
"encounters\n"
"   the breakpoint, and it is active.  This is SETF'able."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns the breakpoint's what specification."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns the breakpoint's kind specification."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the debug-function representing information about the function\n"
"   corresponding to the code-location."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the number of top-level forms processed by the compiler before\n"
"   compiling this source.  If this source is uncompiled, this is zero.  "
"This\n"
"   may be zero even if the source is compiled since the first form in the "
"first\n"
"   file compiled in one compilation, for example, must have a root number "
"of\n"
"   zero -- the compiler saw no other top-level forms before it."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns an indication of the type of source.  The following are the "
"possible\n"
"   values:\n"
"      :file    from a file (obtained by COMPILE-FILE if compiled).\n"
"      :lisp    from Lisp (obtained by COMPILE if compiled).\n"
"      :stream  from a non-file stream."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the actual source in some sense represented by debug-source, which\n"
"   is related to DEBUG-SOURCE-FROM:\n"
"      :file    the pathname of the file.\n"
"      :lisp    a lambda-expression.\n"
"      :stream  some descriptive string that's otherwise useless."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the universal time someone created the source.  This may be nil if\n"
"   it is unavailable."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the time someone compiled the source.  This is nil if the source\n"
"   is uncompiled."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This function returns the file position of each top-level form as an array\n"
"   if debug-source is from a :file.  If DEBUG-SOURCE-FROM is :lisp or :"
"stream,\n"
"   this returns nil."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns whether object is a debug-source."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the top frame of the control stack as it was before calling this\n"
"   function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Flush all of the frames above FRAME, and renumber all the frames below\n"
"   FRAME."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the frame immediately below frame on the stack.  When frame is\n"
"   the bottom of the stack, this returns nil."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"When set, the debugger foregoes making interpreted-frames, so you can\n"
"   debug the functions that manifest the interpreter."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Zero or more than one ~A variable in ~\n"
"\t\t\t   EVAL::INTERNAL-APPLY-LOOP?"
msgstr ""

#: target:code/debug-int.lisp
msgid "Return a string describing the foreign function near ADDRESS"
msgstr ""

#: target:code/debug-int.lisp
msgid "Foreign function call land"
msgstr ""

#: target:code/debug-int.lisp
msgid "Return t if COMPONENT contains code from assembly routines."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Return the name of the assembly routine at offset PC in COMPONENT.\n"
"The result is a symbol or nil if the routine cannot be found."
msgstr ""

#: target:code/debug-int.lisp
msgid "no debug info: ~A:~A"
msgstr ""

#: target:code/debug-int.lisp
msgid "find the PC"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns an a-list mapping catch tags to code-locations.  These are\n"
"   code-locations at which execution would continue with frame as the top\n"
"   frame if someone threw to the corresponding tag."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Executes the forms in a context with block-var bound to each debug-block in\n"
"   debug-function successively.  Result is an optional form to execute for\n"
"   return values, and DO-DEBUG-FUNCTION-BLOCKS returns nil if there is no\n"
"   result form.  This signals a no-debug-blocks condition when the\n"
"   debug-function lacks debug-block information."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Executes body in a context with var bound to each debug-variable in\n"
"   debug-function.  This returns the value of executing result (defaults to\n"
"   nil).  This may iterate over only some of debug-function's variables or "
"none\n"
"   depending on debug policy; for example, possibly the compilation only\n"
"   preserved argument information."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the Common Lisp function associated with the debug-function.  This\n"
"   returns nil if the function is unavailable or is non-existent as a user\n"
"   callable function object."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the name of the function represented by debug-function.  This may\n"
"   be a string or a cons; do not assume it is a symbol."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns a debug-function that represents debug information for function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the kind of the function which is one of :optional, :external,\n"
"   :top-level, :cleanup, nil."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns whether there is any variable information for debug-function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns a list of debug-variables in debug-function having the same name\n"
"   and package as symbol.  If symbol is uninterned, then this returns a list "
"of\n"
"   debug-variables without package names and with the same name as symbol.  "
"The\n"
"   result of this function is limited to the availability of variable\n"
"   information in debug-function; for example, possibly debug-function only\n"
"   knows about its arguments."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns a list of debug-variables in debug-function whose names contain\n"
"    name-prefix-string as an intial substring.  The result of this function "
"is\n"
"    limited to the availability of variable information in debug-function; "
"for\n"
"    example, possibly debug-function only knows about its arguments."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns a list representing the lambda-list for debug-function.  The list\n"
"   has the following structure:\n"
"      (required-var1 required-var2\n"
"       ...\n"
"       (:optional var3 suppliedp-var4)\n"
"       (:optional var5)\n"
"       ...\n"
"       (:rest var6) (:rest var7)\n"
"       ...\n"
"       (:keyword keyword-symbol var8 suppliedp-var9)\n"
"       (:keyword keyword-symbol var10)\n"
"       ...\n"
"      )\n"
"   Each VARi is a debug-variable; however it may be the symbol :deleted it\n"
"   is unreferenced in debug-function.  This signals a lambda-list-"
"unavaliable\n"
"   condition when there is no argument list information."
msgstr ""

#: target:code/debug-int.lisp
msgid "Malformed arguments description."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns whether basic-code-location is unknown.  It returns nil when the\n"
"   code-location is known."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the debug-block containing code-location if it is available.  Some\n"
"   debug policies inhibit debug-block information, and if none is "
"available,\n"
"   then this signals a no-debug-blocks condition."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns the code-location's debug-source."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the number of top-level forms before the one containing\n"
"   code-location as seen by the compiler in some compilation unit.  A\n"
"   compilation unit is not necessarily a single file, see the section on\n"
"   debug-sources."
msgstr ""

#: target:code/debug-int.lisp
msgid "Unknown code location?  It should be known."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the number of the form corresponding to code-location.  The form\n"
"   number is derived by a walking the subforms of a top-level form in\n"
"   depth-first order."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Return the kind of CODE-LOCATION, one of:\n"
"     :interpreted, :unknown-return, :known-return, :internal-error,\n"
"     :non-local-exit, :block-start, :call-site, :single-value-return,\n"
"     :non-local-entry"
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns whether obj1 and obj2 are the same place in the code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Executes forms in a context with code-var bound to each code-location in\n"
"   debug-block.  This returns the value of executing result (defaults to "
"nil)."
msgstr ""

#: target:code/debug-int.lisp
msgid "??? Can't get name of debug-block's function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the symbol from interning DEBUG-VARIABLE-NAME in the package named\n"
"   by DEBUG-VARIABLE-PACKAGE."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the value stored for debug-variable in frame.  If the value is not\n"
"   :valid, then this signals an invalid-value error."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the value stored for debug-variable in frame.  The value may be\n"
"   invalid.  This is SETF'able."
msgstr ""

#: target:code/debug-int.lisp
msgid "Local non-descriptor register access?"
msgstr ""

#: target:code/debug-int.lisp
msgid "Local interior register access?"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns three values reflecting the validity of debug-variable's value\n"
"   at basic-code-location:\n"
"      :valid    The value is known to be available.\n"
"      :invalid  The value is known to be unavailable.\n"
"      :unknown  The value's availability is unknown."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This returns a table mapping form numbers to source-paths.  A source-path\n"
"   indicates a descent into the top-level-form form, going directly to the\n"
"   subform corressponding to the form number."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Form is a top-level form, and path is a source-path into it.  This returns\n"
"   the form indicated by the source-path.  Context is the number of "
"enclosing\n"
"   forms to return instead of directly returning the source-path form.  "
"When\n"
"   context is non-zero, the form returned contains a marker, #:"
"****HERE****,\n"
"   immediately before the form indicated by path."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Return a function of one argument that evaluates form in the lexical\n"
"   context of the basic-code-location loc.  PREPROCESS-FOR-EVAL signals a\n"
"   no-debug-variables condition when the loc's debug-function has no\n"
"   debug-variable information available.  The returned function takes the "
"frame\n"
"   to get values from as its argument, and it returns the values of form.\n"
"   The returned function signals the following conditions: invalid-value,\n"
"   ambiguous-variable-name, and frame-function-mismatch"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Evaluate Form in the lexical context of Frame's current code location,\n"
"   returning the results of the evaluation."
msgstr ""

#: target:code/debug-int.lisp
msgid "Find and return the debug catch tag for a given frame, if it exists."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Evaluate Form in the lexical context of Frame's current code location,\n"
"   returning from the current frame the results of the evaluation."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This creates and returns a breakpoint.  When program execution encounters\n"
"   the breakpoint, the system calls hook-function.  Hook-function takes the\n"
"   current frame for the function in which the program is running and the\n"
"   breakpoint object.\n"
"      What and kind determine where in a function the system invokes\n"
"   hook-function.  What is either a code-location or a debug-function.  Kind "
"is\n"
"   one of :code-location, :function-start, or :function-end.  Since the "
"starts\n"
"   and ends of functions may not have code-locations representing them,\n"
"   designate these places by supplying what as a debug-function and kind\n"
"   indicating the :function-start or :function-end.  When what is a\n"
"   debug-function and kind is :function-end, then hook-function must take "
"two\n"
"   additional arguments, a list of values returned by the function and a\n"
"   function-end-cookie.\n"
"      Info is information supplied by and used by the user.\n"
"      Function-end-cookie is a function.  To implement :function-end "
"breakpoints,\n"
"   the system uses starter breakpoints to establish the :function-end "
"breakpoint\n"
"   for each invocation of the function.  Upon each entry, the system creates "
"a\n"
"   unique cookie to identify the invocation, and when the user supplies a\n"
"   function for this argument, the system invokes it on the frame and the\n"
"   cookie.  The system later invokes the :function-end breakpoint hook on "
"the\n"
"   same cookie.  The user may save the cookie for comparison in the hook\n"
"   function.\n"
"      This signals an error if what is an unknown code-location."
msgstr ""

#: target:code/debug-int.lisp
msgid "Cannot make a breakpoint at an unknown code location -- ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "Breakpoints in interpreted code are currently unsupported."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
":FUNCTION-END breakpoints are currently unsupported ~\n"
"\t\t       for the known return convention."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
":function-end breakpoints are currently unsupported ~\n"
"\t     for interpreted-debug-functions."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This takes a function-end-cookie and a frame, and it returns whether the\n"
"   cookie is still valid.  A cookie becomes invalid when the frame that\n"
"   established the cookie has exited.  Sometimes cookie holders are unaware\n"
"   of cookie invalidation because their :function-end breakpoint hooks "
"didn't\n"
"   run due to THROW'ing.  This takes a frame as an efficiency hack since "
"the\n"
"   user probably has a frame object in hand when using this routine, and it\n"
"   saves repeated parsing of the stack and consing when asking whether a\n"
"   series of cookies is valid."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This causes the system to invoke the breakpoint's hook-function until the\n"
"   next call to DEACTIVATE-BREAKPOINT or DELETE-BREAKPOINT.  The system "
"invokes\n"
"   breakpoint hook functions in the opposite order that you activate them."
msgstr ""

#: target:code/debug-int.lisp
msgid "Cannot activate a deleted breakpoint -- ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "I don't know how you made this, but they're unsupported -- ~S"
msgstr ""

#: target:code/debug-int.lisp
msgid "This stops the system from invoking the breakpoint's hook-function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This returns the user maintained info associated with breakpoint.  This\n"
"   is SETF'able."
msgstr ""

#: target:code/debug-int.lisp
msgid "This returns whether breakpoint is currently active."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This frees system storage and removes computational overhead associated "
"with\n"
"   breakpoint.  After calling this, breakpoint is completely impotent and "
"can\n"
"   never become active again."
msgstr ""

#: target:code/debug-int.lisp
msgid "Unknown breakpoint in ~S at offset ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "Breakpoint that nobody wants?"
msgstr ""

#: target:code/debug-int.lisp
msgid "BREAKPOINT-DO-DISPLACED-INST returned?"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Make a bogus LRA object that signals a breakpoint trap when returned to.  "
"If\n"
"   the breakpoint trap handler returns, REAL-LRA is returned to.  Three "
"values\n"
"   are returned: the bogus LRA object, the code component it is part of, "
"and\n"
"   the PC offset for the trap instruction."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"The editor calls this remotely in the slave to set breakpoints.  Package is\n"
"   the string name of a package or nil, and name-str is a string "
"representing a\n"
"   function name (for example, \"foo\" or \"(setf foo)\").  After finding\n"
"   package, this READs name-str with *package* bound appropriately.  Path "
"is\n"
"   either a modified source-path or a symbol (:function-start or\n"
"   :function-end).  If it is a modified source-path, it has no top-level-"
"form\n"
"   offset or form-number component, and it is in descent order from the root "
"of\n"
"   the top-level form."
msgstr ""

#: target:code/debug-int.lisp
msgid "Editor installed breakpoint."
msgstr ""

#: target:code/debug-int.lisp
msgid "We don't currently support breakpoints in interpreted code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"~%Cannot set breakpoints for editor when source file no ~\n"
"\t\t    longer exists:~%  ~A."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Cannot set breakpoints for editor when ~\n"
"\t\t\t\t   there is no start positions map."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"~%While setting a breakpoint for the editor, noticed ~\n"
"\t\t\tsource file has been modified since compilation:~%  ~A~@\n"
"\t\t\tUsing form offset instead of character position.~%"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"The editor calls this in the slave with a remote-object representing a\n"
"   code-location to set a breakpoint."
msgstr ""

#: target:code/debug-int.lisp
msgid "The editor calls this remotely in the slave to delete a breakpoint."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This returns a code-location before the body of a function and after all\n"
"   the arguments are in place.  If this cannot determine that location due "
"to\n"
"   a lack of debug information, it returns nil."
msgstr ""

#: target:code/debug-int.lisp
msgid "~S code location at ~D"
msgstr ""

#: target:code/query.lisp
msgid ""
"Y-OR-N-P prints the message, if any, and reads characters from *QUERY-IO*\n"
"   until the user enters y or Y as an affirmative, or either n or N as a\n"
"   negative answer.  It ignores preceding whitespace and asks again if you\n"
"   enter any other characters."
msgstr ""

#: target:code/query.lisp
msgid "Type \"y\" for yes or \"n\" for no. "
msgstr ""

#: target:code/query.lisp
msgid ""
"YES-OR-NO-P is similar to Y-OR-N-P, except that it clears the \n"
"   input buffer, beeps, and uses READ-LINE to get the strings \n"
"   YES or NO."
msgstr ""

#: target:code/query.lisp
msgid "Type \"yes\" for yes or \"no\" for no. "
msgstr ""

#: target:code/rand-mt19937.lisp
msgid ""
"Generate an random state vector from the given SEED.  The seed can be\n"
"  either an integer or a vector of (unsigned-byte 32)"
msgstr ""

#: target:code/rand-mt19937.lisp
msgid ""
"Make a random state object.  If STATE is not supplied, return a copy\n"
"  of the default random state.  If STATE is a random state, then return a\n"
"  copy of it.  If STATE is T then return a random state generated from\n"
"  the universal time or /dev/urandom if available."
msgstr ""

#: target:code/rand-mt19937.lisp
msgid "Argument is not a RANDOM-STATE, T or NIL: ~S"
msgstr ""

#: target:code/rand-mt19937.lisp
msgid ""
"Generate a uniformly distributed pseudo-random number between zero\n"
"  and Arg.  State, if supplied, is the random state to use."
msgstr ""

#: target:code/rand-mt19937.lisp
msgid "Argument is not a positive integer or a positive float: ~S"
msgstr ""

#: target:code/ntrace.lisp
msgid ""
"This is bound to the returned values when evaluating :BREAK-AFTER and\n"
"   :PRINT-AFTER forms."
msgstr ""

#: target:code/ntrace.lisp
msgid ""
"If the trace indentation exceeds this value, then indentation restarts at\n"
"   0."
msgstr ""

#: target:code/ntrace.lisp
msgid "The default value for the :ENCAPSULATE option to trace."
msgstr ""

#: target:code/ntrace.lisp
msgid ""
"List of package names.  Encapsulate functions from these packages\n"
"   by default.  This should at least include the packages of functions\n"
"   used by TRACE, directly or indirectly."
msgstr ""

#: target:code/ntrace.lisp
msgid "Can't trace special form ~S."
msgstr ""

#: target:code/ntrace.lisp
msgid "Breaking ~A traced call to ~S:"
msgstr ""

#: target:code/ntrace.lisp
msgid "~S returned"
msgstr ""

#: target:code/ntrace.lisp
msgid "Function ~S already TRACE'd, retracing it."
msgstr ""

#: target:code/ntrace.lisp
msgid "Tracing shared code for ~S:~%  ~S"
msgstr ""

#: target:code/ntrace.lisp
msgid "~S name is not a defined global function: ~S"
msgstr ""

#: target:code/ntrace.lisp
msgid "Can't use encapsulation to trace anonymous function ~S."
msgstr ""

#: target:code/ntrace.lisp
msgid "Can't use encapsulation to trace local flet/labels function ~S."
msgstr ""

#: target:code/ntrace.lisp
msgid "Missing argument to ~S TRACE option."
msgstr ""

#: target:code/ntrace.lisp
msgid "Unknown TRACE option: ~S"
msgstr ""

#: target:code/ntrace.lisp
msgid ""
"TRACE {Option Global-Value}* {Name {Option Value}*}*\n"
"   TRACE is a debugging tool that prints information when specified "
"functions\n"
"   are called.  In its simplest form:\n"
"       (trace Name-1 Name-2 ...)\n"
"\n"
"   CLOS methods can be traced by specifying a name of the form\n"
"   (METHOD {Qualifier}* ({Specializer}*)).\n"
"\n"
"   Labels and Flet functions can be traced by specifying a name of the form\n"
"   (LABELS <lfun> <fun>) or (FLET <lfun> <fun>) where <lfun> is the Labels/"
"Flet\n"
"   function in <fun>.\n"
"\n"
"   TRACE causes a printout on *TRACE-OUTPUT* each time that one of the "
"named\n"
"   functions is entered or returns (the Names are not evaluated.)  The "
"output\n"
"   is indented according to the number of pending traced calls, and this "
"trace\n"
"   depth is printed at the beginning of each line of output.\n"
"\n"
"   Options allow modification of the default behavior.  Each option is a "
"pair\n"
"   of an option keyword and a value form.  Options may be interspersed with\n"
"   function names.  Options only affect tracing of the function whose name "
"they\n"
"   appear immediately after.  Global options are specified before the first\n"
"   name, and affect all functions traced by a given use of TRACE.\n"
"\n"
"   The following options are defined:\n"
"\n"
"   :CONDITION Form\n"
"   :CONDITION-AFTER Form\n"
"   :CONDITION-ALL Form\n"
"       If :CONDITION is specified, then TRACE does nothing unless Form\n"
"       evaluates to true at the time of the call.  :CONDITION-AFTER is\n"
"       similar, but suppresses the initial printout, and is tested when the\n"
"       function returns.  :CONDITION-ALL tries both before and after.\n"
"\n"
"   :WHEREIN Names\n"
"       If specified, Names is a function name or list of names.  TRACE does\n"
"       nothing unless a call to one of those functions encloses the call to\n"
"       this function (i.e. it would appear in a backtrace.)  Anonymous\n"
"       functions have string names like \"DEFUN FOO\".\n"
"   :WHEREIN-ONLY Names\n"
"       Like :WHEREIN, but only if the immediate caller is one of Names,\n"
"       instead of being any where in a backtrace.\n"
"\n"
"   :BREAK Form\n"
"   :BREAK-AFTER Form\n"
"   :BREAK-ALL Form\n"
"       If specified, and Form evaluates to true, then the debugger is "
"invoked\n"
"       at the start of the function, at the end of the function, or both,\n"
"       according to the respective option.\n"
"\n"
"   :PRINT Form\n"
"   :PRINT-AFTER Form\n"
"   :PRINT-ALL Form\n"
"       In addition to the usual printout, the result of evaluating FORM is\n"
"       printed at the start of the function, at the end of the function, or\n"
"       both, according to the respective option.  Multiple print options "
"cause\n"
"       multiple values to be printed.\n"
"\n"
"   :FUNCTION Function-Form\n"
"       This is a not really an option, but rather another way of specifying\n"
"       what function to trace.  The Function-Form is evaluated immediately,\n"
"       and the resulting function is traced.\n"
"\n"
"   :METHODS Function-Form\n"
"       This is a not really an option, but rather a way of specifying\n"
"       that all methods of a generic functions should be traced.  The\n"
"       Function-Form is evaluated immediately, and the methods of the "
"resulting\n"
"       generic function are traced.\n"
"\n"
"   :ENCAPSULATE {:DEFAULT | T | NIL}\n"
"       If T, the tracing is done via encapsulation (redefining the function\n"
"       name) rather than by modifying the function.  :DEFAULT is the "
"default,\n"
"       and means to use encapsulation for interpreted functions and "
"funcallable\n"
"       instances, breakpoints otherwise.  When encapsulation is used, forms "
"are\n"
"       *not* evaluated in the function's lexical environment, but DEBUG:ARG "
"can\n"
"       still be used.\n"
"\n"
"   :CONDITION, :BREAK and :PRINT forms are evaluated in the lexical "
"environment\n"
"   of the called function; DEBUG:VAR and DEBUG:ARG can be used.  The -AFTER "
"and\n"
"   -ALL forms are evaluated in the null environment."
msgstr ""

#: target:code/ntrace.lisp
msgid "Function is not TRACE'd -- ~S."
msgstr ""

#: target:code/ntrace.lisp
msgid ""
"Removes tracing from the specified functions.  With no args, untraces all\n"
"   functions."
msgstr ""

#: target:code/sort.lisp
msgid ""
"Destructively sorts sequence.  Predicate should returns non-Nil if\n"
"   Arg1 is to precede Arg2."
msgstr ""

#: target:code/sort.lisp
msgid "~S is not a sequence."
msgstr ""

#: target:code/sort.lisp
msgid ""
"The sequences Sequence1 and Sequence2 are destructively merged into\n"
"   a sequence of type Result-Type using the Predicate to order the elements."
msgstr ""

#: target:code/final.lisp
msgid ""
"Arrange for FUNCTION to be called when there are no more references to\n"
"   OBJECT.  FUNCTION takes no arguments."
msgstr ""

#: target:code/final.lisp
msgid "Cancel any finalization registers for OBJECT."
msgstr ""

#: target:code/describe.lisp
msgid "Depth of recursive descriptions allowed."
msgstr "   ."

#: target:code/describe.lisp
msgid ""
"If non-nil, descriptions may provide interpretations of information and\n"
"  pointers to additional information.  Normally nil."
msgstr ""

#: target:code/describe.lisp
msgid ""
"*print-level* gets bound to this inside describe.  If null, use\n"
"  *print-level*"
msgstr ""

#: target:code/describe.lisp
msgid ""
"*print-length* gets bound to this inside describe.  If null, use\n"
"  *print-length*."
msgstr ""

#: target:code/describe.lisp
msgid "Number of spaces that sets off each line of a recursive description."
msgstr ""

#: target:code/describe.lisp
msgid "Used to tell whether we are doing a recursive describe."
msgstr ""

#: target:code/describe.lisp
msgid "Used to implement recursive description cutoff.  Don't touch."
msgstr ""

#: target:code/describe.lisp
msgid "An output stream used by Describe for indenting and stuff."
msgstr ""

#: target:code/describe.lisp
msgid ""
"List of all objects describe within the current top-level call to describe."
msgstr ""

#: target:code/describe.lisp
msgid "The last object passed to describe."
msgstr ""

#: target:code/describe.lisp
msgid "Prints a description of the object X."
msgstr ""

#: target:code/describe.lisp
msgid "*describe-level* should be a nonnegative integer - ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is a ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its code is #x~4,'0x."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its name is ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a ~:[high (leading)~;low (trailing)~] surrogate character."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is a ~(~A~) of type ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is a ~:[~;displaced ~]vector of length ~D."
msgstr ""

#: target:code/describe.lisp
msgid "~&It has a fill pointer, currently ~d"
msgstr ""

#: target:code/describe.lisp
msgid "~&It has no fill pointer."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is ~:[an~;a displaced~] array of rank ~A"
msgstr ""

#: target:code/describe.lisp
msgid "~%Its dimensions are ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its element type is specialized to ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is adjustable."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is static."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a prime number."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a composite number."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its components are ~S and ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is an ~A hash table."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its size is ~D buckets."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its rehash-size is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its rehash-threshold is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It currently holds ~d entries."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is weak ~A table."
msgstr ""

#: target:code/describe.lisp
msgid "~&~d symbols total: ~d internal and ~d external."
msgstr ""

#: target:code/describe.lisp
msgid "~&~@(~A documentation:~)~&  ~A"
msgstr ""

#: target:code/describe.lisp
msgid "~&Its ~(~A~) argument types are:~%  ~S"
msgstr ""

#: target:code/describe.lisp
msgid "~&Its result type is:~%  ~S"
msgstr ""

#: target:code/describe.lisp
msgid ""
"~&It is currently declared ~(~A~);~\n"
"\t\t ~:[no~;~] expansion is available."
msgstr ""

#: target:code/describe.lisp
msgid "~&~@(~@[~A ~]arguments:~%~)"
msgstr ""

#: target:code/describe.lisp
msgid "  There are no arguments."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its closure environment is:"
msgstr ""

#: target:code/describe.lisp
msgid "~&Its definition is:~%  ~S"
msgstr ""

#: target:code/describe.lisp
msgid "~&On ~A it was compiled from:"
msgstr ""

#: target:code/describe.lisp
msgid "~&~A~%  Created: "
msgstr ""

#: target:code/describe.lisp
msgid "~&  Comment: ~A"
msgstr ""

#: target:code/describe.lisp
msgid "  There is no argument information available."
msgstr ""

#: target:code/describe.lisp
msgid "Macro-function: ~S"
msgstr ""

#: target:code/describe.lisp
msgid "Function: ~S"
msgstr ""

#: target:code/describe.lisp
msgid "~S is a function."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is an unknown type of function."
msgstr ""

#: target:code/describe.lisp
msgid "~&~A is an ~A symbol in the ~A package."
msgstr ""

#: target:code/describe.lisp
msgid "~&~A is an uninterned symbol."
msgstr ""

#: target:code/describe.lisp
msgid "~&~@<It is an alien at #x~8,'0X of type ~3I~:_~S.~:>~%"
msgstr ""

#: target:code/describe.lisp
msgid "~@<Its current value is ~3I~:_~S.~:>"
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a ~A with expansion: ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a ~A; its value is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a ~A; no current value."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its declared type is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "Special form"
msgstr ""

#: target:code/describe.lisp
msgid "Structure"
msgstr ""

#: target:code/describe.lisp
msgid "Type"
msgstr ""

#: target:code/describe.lisp
msgid "Setf macro"
msgstr ""

#: target:code/describe.lisp
msgid "~&Documentation on the ~(~A~):~%~A"
msgstr ""

#: target:code/describe.lisp
msgid "~&It names a class ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&It names a PCL class ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&It names a type specifier."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its ~S property is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is defined in:~&~A"
msgstr ""

#: target:code/format-time.lisp
msgid ""
"Format-Universal-Time formats a string containing the time and date\n"
"   given by universal-time in a common manner.  The destination is any\n"
"   destination which can be accepted by the Format function.  The\n"
"   timezone keyword is an integer specifying hours west of Greenwich.\n"
"   The style keyword can be :short (numeric date), :long (months and\n"
"   weekdays expressed as words), :abbreviated (like :long but words\n"
"   are abbreviated), :rfc1123 (conforming to RFC 1123), :government\n"
"   (of the form \"XX Mon XX XX:XX:XX\"), or :iso8601 (conforming to\n"
"   ISO 8601), which is the recommended way of printing date and time.\n"
"   The keyword date-first, if nil, will print the time first instead of\n"
"   the date (the default).  The print- keywords, if nil, inhibit the\n"
"   printing of the obvious part of the time/date."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Not a valid format destination."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Universal-Time should be an integer."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Timezone should be a rational between -24 and 24."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Timezone is not a second (1/3600) multiple."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Unrecognized :style keyword value."
msgstr ""

#: target:code/format-time.lisp
msgid ""
"Format-Decoded-Time formats a string containing decoded-time\n"
"   expressed in a humanly-readable manner.  The destination is any\n"
"   destination which can be accepted by the Format function.  The\n"
"   timezone keyword is an integer specifying hours west of Greenwich.\n"
"   The style keyword can be :short (numeric date), :long (months and\n"
"   weekdays expressed as words), or :abbreviated (like :long but words are\n"
"   abbreviated).  The keyword date-first, if nil, will cause the time\n"
"   to be printed first instead of the date (the default).  The print-\n"
"   keywords, if nil, inhibit the printing of certain semi-obvious\n"
"   parts of the string."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Seconds should be an integer between 0 and 59."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Minutes should be an integer between 0 and 59."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Hours should be an integer between 0 and 23."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Day should be an integer between 1 and 31."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Month should be an integer between 1 and 12."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Hours should be an non-negative integer."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Timezone should be an integer between 0 and 32."
msgstr ""

#: target:code/parse-time.lisp
msgid ""
"If t, an error will be signalled if parse-time is unable\n"
"   to determine the time/date format of the string."
msgstr ""

#: target:code/parse-time.lisp
msgid "\"~A\" is not a recognized word or abbreviation."
msgstr ""

#: target:code/parse-time.lisp
msgid ""
"Can't parse time/date string.~%>>> ~A~\n"
"\t\t\t\t   ~%~VT^-- Bogus character encountered here."
msgstr ""

#: target:code/parse-time.lisp
msgid "Unrecognized symbol: ~A"
msgstr ""

#: target:code/parse-time.lisp
msgid "~D is not an AM hour, dummy."
msgstr ""

#: target:code/parse-time.lisp
msgid "~A isn't AM/PM - this shouldn't happen."
msgstr ""

#: target:code/parse-time.lisp
msgid "Invalid number of days (~D) for month ~D in ~D"
msgstr ""

#: target:code/parse-time.lisp
msgid "Ignore."
msgstr ""

#: target:code/parse-time.lisp
msgid "Specified day (~@(~A~)) doesn't match actual day (~@(~A~))"
msgstr ""

#: target:code/parse-time.lisp
msgid "Unrecognized symbol in form list: ~A."
msgstr ""

#: target:code/parse-time.lisp
msgid ""
"Tries very hard to make sense out of the argument time-string and\n"
"   returns a single integer representing the universal time if\n"
"   successful.  If not, it returns nil.  If the :error-on-mismatch\n"
"   keyword is true, parse-time will signal an error instead of\n"
"   returning nil.  Default values for each part of the time/date\n"
"   can be specified by the appropriate :default- keyword.  These\n"
"   keywords can be given a numeric value or the keyword :current\n"
"   to set them to the current value.  The default-default values\n"
"   are 00:00:00 on the current date, current time-zone."
msgstr ""

#: target:code/parse-time.lisp
msgid "\"~A\" is not a recognized time/date format."
msgstr ""

#: target:code/run-program.lisp
msgid "Return any available status information on child processed. "
msgstr ""

#: target:code/run-program.lisp
msgid "List of process structures for all active processes."
msgstr ""

#: target:code/run-program.lisp
msgid ""
"Return the current status of process.  The result is one of :running,\n"
"   :stopped, :exited, :signaled."
msgstr ""

#: target:code/run-program.lisp
msgid "Wait for PROC to quit running for some reason.  Returns PROC."
msgstr ""

#: target:code/run-program.lisp
msgid "TIOCPGRP ioctl failed: ~S"
msgstr ""

#: target:code/run-program.lisp
msgid ""
"Hand SIGNAL to PROC.  If whom is :pid, use the kill Unix system call.  If\n"
"   whom is :process-group, use the killpg Unix system call.  If whom is\n"
"   :pty-process-group deliver the signal to whichever process group is "
"currently\n"
"   in the foreground."
msgstr ""

#: target:code/run-program.lisp
msgid "Returns T if the process is still alive, NIL otherwise."
msgstr ""

#: target:code/run-program.lisp
msgid ""
"Close all streams connected to PROC and stop maintaining the status slot."
msgstr ""

#: target:code/run-program.lisp
msgid ""
"List of file descriptors to close when RUN-PROGRAM exits due to an error."
msgstr ""

#: target:code/run-program.lisp
msgid ""
"List of file descriptors to close when RUN-PROGRAM returns in the parent."
msgstr ""

#: target:code/run-program.lisp
msgid "List of handlers installed by RUN-PROGRAM."
msgstr ""

#: target:code/run-program.lisp
msgid "Returns the master fd, the slave fd, and the name of the tty"
msgstr ""

#: target:code/run-program.lisp
msgid "Could not find a pty."
msgstr ""

#: target:code/run-program.lisp
msgid "Could not UNIX:UNIX-DUP ~D: ~A"
msgstr ""

#: target:code/run-program.lisp
msgid ""
"RUN-PROGRAM creates a new process and runs the unix program in the\n"
"   file specified by the simple-string PROGRAM.  ARGS are the standard\n"
"   arguments that can be passed to a Unix program, for no arguments\n"
"   use NIL (which means just the name of the program is passed as arg 0).\n"
"\n"
"   RUN-PROGRAM will either return NIL or a PROCESS structure.  See the CMU\n"
"   Common Lisp Users Manual for details about the PROCESS structure.\n"
"\n"
"   The keyword arguments have the following meanings:\n"
"     :env -\n"
"        An A-LIST mapping keyword environment variables to simple-string\n"
"\tvalues.\n"
"     :wait -\n"
"        If non-NIL (default), wait until the created process finishes.  If\n"
"        NIL, continue running Lisp until the program finishes.\n"
"     :pty -\n"
"        Either T, NIL, or a stream.  Unless NIL, the subprocess is "
"established\n"
"\tunder a PTY.  If :pty is a stream, all output to this pty is sent to\n"
"\tthis stream, otherwise the PROCESS-PTY slot is filled in with a stream\n"
"\tconnected to pty that can read output and write input.\n"
"     :input -\n"
"        Either T, NIL, a pathname, a stream, or :STREAM.  If T, the "
"standard\n"
"\tinput for the current process is inherited.  If NIL, /dev/null\n"
"\tis used.  If a pathname, the file so specified is used.  If a stream,\n"
"\tall the input is read from that stream and send to the subprocess.  If\n"
"\t:STREAM, the PROCESS-INPUT slot is filled in with a stream that sends \n"
"\tits output to the process. Defaults to NIL.\n"
"     :if-input-does-not-exist (when :input is the name of a file) -\n"
"        can be one of:\n"
"           :error - generate an error.\n"
"           :create - create an empty file.\n"
"           nil (default) - return nil from run-program.\n"
"     :output -\n"
"        Either T, NIL, a pathname, a stream, or :STREAM.  If T, the "
"standard\n"
"\toutput for the current process is inherited.  If NIL, /dev/null\n"
"\tis used.  If a pathname, the file so specified is used.  If a stream,\n"
"\tall the output from the process is written to this stream. If\n"
"\t:STREAM, the PROCESS-OUTPUT slot is filled in with a stream that can\n"
"\tbe read to get the output. Defaults to NIL.\n"
"     :if-output-exists (when :output is the name of a file) -\n"
"        can be one of:\n"
"           :error (default) - generates an error if the file already "
"exists.\n"
"           :supersede - output from the program supersedes the file.\n"
"           :append - output from the program is appended to the file.\n"
"           nil - run-program returns nil without doing anything.\n"
"     :error and :if-error-exists - \n"
"        Same as :output and :if-output-exists, except that :error can also "
"be\n"
"\tspecified as :output in which case all error output is routed to the\n"
"\tsame place as normal output.\n"
"     :status-hook -\n"
"        This is a function the system calls whenever the status of the\n"
"        process changes.  The function takes the process as an argument."
msgstr ""

#: target:code/run-program.lisp
msgid "All args to program must be simple strings -- ~S."
msgstr ""

#: target:code/run-program.lisp
msgid "No such program: ~S"
msgstr ""

#: target:code/run-program.lisp
msgid "Could not fork child process: ~A"
msgstr ""

#: target:code/run-program.lisp
msgid "Could not select on sub-process: ~A"
msgstr ""

#: target:code/run-program.lisp
msgid "Could not read input from sub-process: ~A"
msgstr ""

#: target:code/run-program.lisp
msgid "Could not open \"/dev/null\": ~A"
msgstr ""

#: target:code/run-program.lisp
msgid "Could not create pipe: ~A"
msgstr ""

#: target:code/run-program.lisp
msgid "Direction must be either :INPUT or :OUTPUT, not ~S"
msgstr ""

#: target:code/run-program.lisp
msgid "Could not duplicate file descriptor: ~A"
msgstr ""

#: target:code/run-program.lisp
msgid "Could not open a temporary file in /tmp"
msgstr ""

#: target:code/run-program.lisp
msgid "Cound not create pipe: ~A"
msgstr ""

#: target:code/run-program.lisp
msgid "Invalid option to run-program: ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "Could not create temporary file ~S: ~A"
msgstr ""

#: target:code/foreign.lisp
msgid "Not enough memory left."
msgstr ""

#: target:code/foreign.lisp
msgid "Make sure the header starts with the ELF magic value."
msgstr ""

#: target:code/foreign.lisp
msgid "Return the `osabi' field in the padding of the ELF file."
msgstr ""

#: target:code/foreign.lisp
msgid "Given a file type number, determine whether the file is executable."
msgstr ""

#: target:code/foreign.lisp
msgid "Make sure the header starts with the mach-o magic value."
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Loading object file...~%"
msgstr ""

#: target:code/foreign.lisp
msgid "Could not open ~S: ~A"
msgstr ""

#: target:code/foreign.lisp
msgid "~A is not an ELF file."
msgstr ""

#: target:code/foreign.lisp
msgid "~A is not a ~A executable, it's a ~A executable."
msgstr ""

#: target:code/foreign.lisp
msgid "~A is not executable."
msgstr ""

#: target:code/foreign.lisp
msgid ""
"Parse symbol table file created by load-foreign script.  Modified\n"
"to skip undefined symbols which don't have an address."
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Parsing symbol table...~%"
msgstr ""

#: target:code/foreign.lisp
msgid ""
"Load-foreign loads a list of C object files into a running Lisp.  The files\n"
"  argument should be a single file or a list of files.  The files may be\n"
"  specified as namestrings or as pathnames.  The libraries argument should "
"be a\n"
"  list of library files as would be specified to ld.  They will be searched "
"in\n"
"  the order given.  The default is just \"-lc\", i.e., the C library.  The\n"
"  base-file argument is used to specify a file to use as the starting place "
"for\n"
"  defined symbols.  The default is the C start up code for Lisp.  The env\n"
"  argument is the Unix environment variable definitions for the invocation "
"of\n"
"  the linker.  The default is the environment passed to Lisp."
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Running library:load-foreign.csh...~%"
msgstr ""

#: target:code/foreign.lisp
msgid ""
"Object file is wrong format, so can't load-foreign:~\n"
"\t\t  ~%  ~S"
msgstr ""

#: target:code/foreign.lisp
msgid ""
"Object file is not relocatable, so can't load-foreign:~\n"
"\t\t  ~%  ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "Could not run library:load-foreign.csh"
msgstr ""

#: target:code/foreign.lisp
msgid "library:load-foreign.csh failed:~%~A"
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Done.~%"
msgstr ""

#: target:code/foreign.lisp
msgid "Lazy function call binding"
msgstr ""

#: target:code/foreign.lisp
msgid "Immediate function call binding"
msgstr ""

#: target:code/foreign.lisp
msgid "Mask of binding time value"
msgstr ""

#: target:code/foreign.lisp
msgid ""
"If set the symbols of the loaded object and its dependencies are\n"
"   made visible as if the object were linked directly into the program"
msgstr ""

#: target:code/foreign.lisp
msgid "Can't open global symbol table: ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "Can't open object ~S: ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "LOAD-OBJECT-FILE: Unresolved symbols in file ~S: ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "Couldn't open library ~S: ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "Reloaded library ~S~%"
msgstr ""

#: target:code/foreign.lisp
msgid "Enter new library path: "
msgstr ""

#: target:code/foreign.lisp
msgid ""
"Load C object files into the running Lisp. The FILES argument\n"
"should be a single file or a list of files. The files may be specified\n"
"as namestrings or as pathnames. The LIBRARIES argument should be a\n"
"list of library files as would be specified to ld. They will be\n"
"searched in the order given. The default is just \"-lc\", i.e., the C\n"
"library. The BASE-FILE argument is used to specify a file to use as\n"
"the starting place for defined symbols. The default is the C start up\n"
"code for Lisp. The ENV argument is the Unix environment variable\n"
"definitions for the invocation of the linker. The default is the\n"
"environment passed to Lisp."
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Opening as shared library ~A ...~%"
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Trying as object file ~A...~%"
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Running ~A...~%"
msgstr ""

#: target:code/foreign.lisp
msgid "File does not exist: ~A."
msgstr ""

#: target:code/foreign.lisp
msgid "Could not run ~A"
msgstr ""

#: target:code/foreign.lisp
msgid "~A failed:~%~A"
msgstr ""

#: target:code/internet.lisp
msgid "AList of socket kinds and protocol values."
msgstr ""

#: target:code/internet.lisp
msgid "Internet protocol :DATA-GRAM is deprecated. Using :DATAGRAM"
msgstr ""

#: target:code/internet.lisp
msgid "Invalid kind (~S) for internet domain sockets."
msgstr ""

#: target:code/internet.lisp
msgid ""
"Return a host-entry for the given host. The host may be an address\n"
"  string or an IP address in host order."
msgstr ""

#: target:code/internet.lisp
msgid "Error creating socket: ~A"
msgstr ""

#: target:code/internet.lisp
msgid "Error connecting socket to [~A]: ~A"
msgstr ""

#: target:code/internet.lisp
msgid "Error binding socket to path ~a: ~a"
msgstr ""

#: target:code/internet.lisp
msgid "Error listening to socket: ~A"
msgstr ""

#: target:code/internet.lisp
msgid "Error accepting a connection: ~A"
msgstr ""

#: target:code/internet.lisp
msgid "bind Socket to (local) Host and Port"
msgstr ""

#: target:code/internet.lisp
msgid "Unknown host: ~S."
msgstr ""

#: target:code/internet.lisp
msgid "Error binding socket to port ~A: ~A"
msgstr ""

#: target:code/internet.lisp
msgid "The host may be an address string or an IP address in host order."
msgstr ""

#: target:code/internet.lisp
msgid "Error connecting socket to [~A:~A]: ~A"
msgstr ""

#: target:code/internet.lisp
msgid "Get an integer value socket option."
msgstr ""

#: target:code/internet.lisp
msgid "Set an integer value socket option."
msgstr ""

#: target:code/internet.lisp
msgid "Error ~S setting socket option on socket ~D."
msgstr ""

#: target:code/internet.lisp
msgid "Error closing socket: ~A"
msgstr ""

#: target:code/internet.lisp
msgid "Return the peer host address and port in host order."
msgstr ""

#: target:code/internet.lisp
msgid "Error ~s getting peer host and port on FD ~d."
msgstr ""

#: target:code/internet.lisp
msgid "Error ~s getting socket host and port on FD ~d."
msgstr ""

#: target:code/internet.lisp
msgid "Ignore it"
msgstr ""

#: target:code/internet.lisp
msgid "Error recving oob data on ~A: ~A"
msgstr ""

#: target:code/internet.lisp
msgid "No oob handler defined for ~S on ~A"
msgstr ""

#: target:code/internet.lisp
msgid "Got a SIGURG, but couldn't find any out-of-band data."
msgstr ""

#: target:code/internet.lisp
msgid "Arrange to funcall HANDLER when CHAR shows up out-of-band on FD."
msgstr ""

#: target:code/internet.lisp
msgid "Remove any handlers for CHAR on FD."
msgstr ""

#: target:code/internet.lisp
msgid "Remove all handlers for FD."
msgstr ""

#: target:code/internet.lisp
msgid "Error sending ~S OOB to across ~A: ~A"
msgstr ""

#: target:code/internet.lisp
msgid ""
"A packaging of the unix recvfrom call.  Returns three values:\n"
"bytecount, source address as integer, and source port.  bytecount\n"
"can of course be negative, to indicate faults."
msgstr ""

#: target:code/internet.lisp
msgid "A packaging of the unix sendto call.  Return value like sendto"
msgstr ""

#: target:code/internet.lisp
msgid ""
"A packaging of the unix shutdown call.  An error is signaled if shutdown "
"fails."
msgstr ""

#: target:code/internet.lisp
msgid "Error on shutdown of socket: ~A"
msgstr ""

#: target:code/internet.lisp
msgid ""
"Return a network stream.  HOST may be an address string or an integer\n"
"IP address."
msgstr ""

#: target:code/internet.lisp
msgid "Unknown host format: ~S."
msgstr ""

#: target:code/internet.lisp
msgid "network connection to ~A"
msgstr ""

#: target:code/internet.lisp
msgid "network connection from ~D.~D.~D.~D:~D"
msgstr ""

#: target:code/remote.lisp
msgid "AList of wire . remote-wait structs"
msgstr ""

#: target:code/remote.lisp
msgid ""
"Evaluates the given forms remotly. No values are returned, as the remote\n"
"evaluation is asyncronus."
msgstr ""

#: target:code/remote.lisp
msgid ""
"Bind VARS to the multiple values of FORM (which is executed remotely). The\n"
"forms in BODY are only executed if the remote function returned (as apposed\n"
"to aborting due to a throw)."
msgstr ""

#: target:code/remote.lisp
msgid "Remote server unwound"
msgstr ""

#: target:code/remote.lisp
msgid ""
"Execute the single form remotly. The value of the form is returned.\n"
"  The optional form on-server-unwind is only evaluated if the server "
"unwinds\n"
"  instead of returning."
msgstr ""

#: target:code/remote.lisp
msgid ""
"Create a request server on the given port.  Whenever anyone connects to it,\n"
"   call the given function with the newly created wire and the address of "
"the\n"
"   connector.  If the function returns NIL, the connection is destroyed;\n"
"   otherwise, it is accepted.  This returns a manifestation of the server "
"that\n"
"   DESTROY-REQUEST-SERVER accepts to kill the request server."
msgstr ""

#: target:code/remote.lisp
msgid "Quit accepting connections to the given request server."
msgstr ""

#: target:code/remote.lisp
msgid ""
"Connect to a remote request server addressed with the given host and port\n"
"   pair.  This returns the created wire."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Return the real time in seconds."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Return the run time in seconds"
msgstr ""

#: target:code/multi-proc.lisp
msgid "Return the process state which is either Run, Killed, or a wait reason."
msgstr ""

#: target:code/multi-proc.lisp
#, fuzzy
msgid "Returns the current process."
msgstr "   ~D.~%"

#: target:code/multi-proc.lisp
msgid "A list of all alive processes."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Return a list of all the live processes."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Execute the body the scheduling disabled."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Increaments the reference by delta in a single atomic operation"
msgstr ""

#: target:code/multi-proc.lisp
msgid "Decrements the reference by delta in a single atomic operation"
msgstr ""

#: target:code/multi-proc.lisp
msgid "Atomically push object onto place."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Atomically pop place."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Make a process which will run FUNCTION when it starts up.  By\n"
"  default the process is created in a runnable (active) state.\n"
"  If FUNCTION is NIL, the process is started in a killed state; it may\n"
"  be restarted later with process-preset.\n"
"\n"
"  :NAME\n"
"\tA name for the process displayed in process listings.\n"
"\n"
"  :RUN-REASONS\n"
"\tInitial value for process-run-reasons; defaults to (:ENABLE).  A\n"
"\tprocess needs a at least one run reason to be runnable.  Together with\n"
"\tarrest reasons, run reasons provide an alternative to process-wait for\n"
"\tcontroling whether or not a process is runnable.  To get the default\n"
"\tbehavior of MAKE-PROCESS in Allegro Common Lisp, which is to create a\n"
"\tprocess which is active but not runnable, initialize RUN-REASONS to\n"
"\tNIL.\n"
"\n"
"  :ARREST-REASONS\n"
"\tInitial value for process-arrest-reasons; defaults to NIL.  A\n"
"\tprocess must have no arrest reasons in order to be runnable.\n"
"\n"
"  :INITIAL-BINDINGS\n"
"\tAn alist of initial special bindings for the process.  At\n"
"\tstartup the new process has a fresh set of special bindings\n"
"\twith a default binding of *package* setup to the CL-USER\n"
"\tpackage.  INITIAL-BINDINGS specifies additional bindings for\n"
"\tthe process.  The cdr of each alist element is evaluated in\n"
"\tthe fresh dynamic environment and then bound to the car of the\n"
"\telement."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Interrupt process and cause it to evaluate function."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Destroy a process. The process is sent a interrupt which throws to\n"
"  the end of the process allowing it to unwind gracefully."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Restart process by unwinding it to its initial state and calling its\n"
"  initial function."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Restart process, unwinding it to its initial state and calls\n"
"  function with args."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Disable process from being runnable until enabled."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Allow process to become runnable again after it has been disabled."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Causes the process to wait until predicate returns True. Processes\n"
"  can only call process-wait when scheduling is enabled, and the predicate\n"
"  can not call process-wait. Since the predicate may be evaluated may\n"
"  times by the scheduler it should be relative fast native compiled code.\n"
"  The single True predicate value is returned."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Causes the process to wait until predicate returns True, or the\n"
"  number of seconds specified by timeout has elapsed. The timeout may\n"
"  be a fixnum or a float in seconds.  The single True predicate value is\n"
"  returned, or NIL if the timeout was reached."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Try to gracefully destroy all the processes giving them some\n"
"  chance to unwinding, before shutting down multi-processing. This is\n"
"  currently necessary before a purify and is performed before a save-lisp.\n"
"  Multi-processing can be restarted by calling init-multi-processing."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"An idle loop to be run by the initial process. The select based event\n"
"  server is called with a timeout calculated from the minimum of the\n"
"  *idle-loop-timeout* and the time to the next process wait timeout.\n"
"  To avoid this delay when there are runnable processes the *idle-process*\n"
"  should be setup to the *initial-process*. If one of the processes quits\n"
"  by throwing to %end-of-the-world then *quitting-lisp* will have been\n"
"  set to the exit value which is noted by the idle loop which tries to\n"
"  exit gracefully destroying all the processes and giving them a chance\n"
"  to unwind."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Allow other processes to run."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Return the accrued real time elapsed while the given process was\n"
"  scheduled. The returned time is a double-float in seconds."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Return the accrued run time elapsed for the given process. The returned\n"
"  time is a double-float in seconds."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Return the real time elapsed since the given process was last\n"
"  descheduled. The returned time is a double-float in seconds."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Start a regular SIGALRM interrupt which calls process-yield. An optional\n"
"  time in seconds and micro seconds may be provided. Note that CMUCL code\n"
"  base is not too interrupt safe so this may cause problems."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Wait until FD is usable for DIRECTION and return True. DIRECTION should be\n"
"  either :INPUT or :OUTPUT. TIMEOUT, if supplied, is the number of seconds "
"to\n"
"  wait before giving up and returing NIL."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"This function causes execution to be suspended for N seconds.  N may\n"
"  be any non-negative, non-complex number."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Executes body and returns the values of the last form in body. However, if\n"
"  the execution takes longer than timeout seconds, abort it and evaluate\n"
"  timeout-forms, returning the values of last form."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Show the all the processes, their whostate, and state. If the optional\n"
"  verbose argument is true then the run, real, and idle times are also\n"
"  shown."
msgstr ""

#: target:code/multi-proc.lisp
msgid "Top-level READ-EVAL-PRINT loop for processes."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Enter the idle loop, starting a new process to run the top level loop.\n"
"  The awaking of sleeping processes is timed better with the idle loop "
"process\n"
"  running, and starting a new process for the top level loop supports a\n"
"  simultaneous interactive session. Such an initialisation will likely be "
"the\n"
"  default when there is better MP debug support etc."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Create a Lisp connection listener, listening on a TCP port for new\n"
"  connections and starting a new top-level loop for each. If a password\n"
"  is not given then one will be generated and reported.  A search is\n"
"  performed for the first free port starting at the given port which\n"
"  defaults to 1025."
msgstr ""

#: target:code/multi-proc.lisp
msgid ""
"Execute the body with the lock held. If the lock is held by another\n"
"  process then the current process waits until the lock is released or\n"
"  an optional timeout is reached. The optional wait timeout is a time in\n"
"  seconds acceptable to process-wait-with-timeout.  The results of the\n"
"  body are return upon success and NIL is return if the timeout is\n"
"  reached. When the wait key is NIL and the lock is held by another\n"
"  process then NIL is return immediately without processing the body."
msgstr ""

#: target:code/setf-funs.lisp
msgid "Hairy setf expander for function ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Controls compiling DEFSTRUCT :print-function and :print-method\n"
"   options according to ANSI spec. MUST be NIL to compile CMUCL & PCL"
msgstr ""

#: target:code/defstruct.lisp
msgid "Allocate a new instance with LENGTH data slots."
msgstr ""

#: target:code/defstruct.lisp
msgid "Given an instance, return its length."
msgstr ""

#: target:code/defstruct.lisp
msgid "Return the value from the INDEXth slot of INSTANCE.  This is SETFable."
msgstr ""

#: target:code/defstruct.lisp
msgid "Set the INDEXth slot of INSTANCE to NEW-VALUE."
msgstr ""

#: target:code/defstruct.lisp
msgid "Class not yet defined or was undefined: ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Class is not a structure class: ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"DEFSTRUCT {Name | (Name Option*)} {Slot | (Slot [Default] {Key Value}*)}\n"
"   Define the structure type Name.  Instances are created by MAKE-<name>, "
"which\n"
"   takes keyword arguments allowing initial slot values to the specified.\n"
"   A SETF'able function <name>-<slot> is defined for each slot to "
"read&write\n"
"   slot values.  <name>-p is a type predicate.\n"
"\n"
"   Popular DEFSTRUCT options (see manual for others):\n"
"\n"
"   (:CONSTRUCTOR Name)\n"
"   (:PREDICATE Name)\n"
"       Specify an alternate name for the constructor or predicate.\n"
"\n"
"   (:CONSTRUCTOR Name Lambda-List)\n"
"       Explicitly specify the name and arguments to create a BOA "
"constructor\n"
"       (which is more efficient when keyword syntax isn't necessary.)\n"
"\n"
"   (:INCLUDE Supertype Slot-Spec*)\n"
"       Make this type a subtype of the structure type Supertype.  The "
"optional\n"
"       Slot-Specs override inherited slot options.\n"
"\n"
"   Slot options:\n"
"\n"
"   :TYPE Type-Spec\n"
"       Asserts that the value of this slot is always of the specified type.\n"
"\n"
"   :READ-ONLY {T | NIL}\n"
"       If true, no setter function is defined for this slot."
msgstr ""

#: target:code/defstruct.lisp
msgid "defining structure ~A"
msgstr ""

#: target:code/defstruct.lisp
msgid "Defstruct already names a declaration: ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid "Can't have more than one :INCLUDE option."
msgstr ""

#: target:code/defstruct.lisp
msgid "~S is a bad :TYPE for Defstruct."
msgstr ""

#: target:code/defstruct.lisp
msgid "The Defstruct option :NAMED takes no arguments."
msgstr ""

#: target:code/defstruct.lisp
msgid "Unknown DEFSTRUCT option~%  ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Unrecognized DEFSTRUCT option: ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Can't specify :OFFSET unless :TYPE is specified."
msgstr ""

#: target:code/defstruct.lisp
msgid "Silly to specify :PRINT-FUNCTION with :TYPE."
msgstr ""

#: target:code/defstruct.lisp
msgid "Silly to specify :MAKE-LOAD-FORM-FUN with :TYPE."
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Keyword slot name indicates probable syntax ~\n"
"\t\t      error in DEFSTRUCT -- ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid "Duplicate slot name ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid "Slot ~S must be read-only in subtype ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid ":TYPE option mismatch between structures ~S and ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid ":TYPE'd defstruct ~S not found for inclusion."
msgstr ""

#: target:code/defstruct.lisp
msgid "(:CONSTRUCTOR NIL) combined with other :CONSTRUCTORs."
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"~@<Non-overwritten accessor ~S does not access ~\n"
"                        slot with name ~S (accessing an inherited slot ~\n"
"                        instead).~:@>"
msgstr ""

#: target:code/defstruct.lisp
msgid "Obsolete structure accessor function called."
msgstr ""

#: target:code/defstruct.lisp
msgid "Structure for accessor ~S is not a ~S:~% ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Structure for setter ~S is not a ~S:~% ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "New-Value for setter ~S is not a ~S:~% ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid "Structure for copier is not a ~S:~% ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Shouldn't happen!  Some strange thing in LAYOUT-INFO:~\n"
"\t\t    ~%  ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Incompatibly redefining slots of structure class ~S~@\n"
"\t  Make sure any uses of affected accessors are recompiled:~@\n"
"\t  ~@[  These slots were moved to new positions:~%    ~S~%~]~\n"
"\t  ~@[  These slots have new incompatible types:~%    ~S~%~]~\n"
"\t  ~@[  These slots were deleted:~%    ~S~%~]"
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Redefining class ~S incompatibly with the current ~\n"
"\t\tdefinition."
msgstr ""

#: target:code/defstruct.lisp
msgid "Previously loaded ~S accessors will no longer work."
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Any old ~S instances will be in a bad way.~@\n"
"\t       I hope you know what you're doing..."
msgstr ""

#: target:code/defstruct.lisp
msgid "Removing old subclasses of ~S:~%  ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Return a copy of Structure with the same (EQL) slot values."
msgstr ""

#: target:code/defstruct.lisp
msgid "Copying an obsolete structure:~%  ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Structures of type ~S cannot be dumped as constants."
msgstr ""

#: target:code/defmacro.lisp
msgid "A list of tests that do argument counting at expansion time."
msgstr ""

#: target:code/defmacro.lisp
msgid "Let bindings that are done to make lambda-list parsing possible."
msgstr ""

#: target:code/defmacro.lisp
msgid "Let bindings that the user has explicitly supplied."
msgstr ""

#: target:code/defmacro.lisp
msgid "Unsupplied optional and keyword arguments get this value defaultly."
msgstr ""

#: target:code/defmacro.lisp
msgid ""
"Returns as multiple-values a parsed body, any local-declarations that\n"
"   should be made where this body is inserted, and a doc-string if there is\n"
"   one."
msgstr ""

#: target:code/defmacro.lisp
msgid "&Whole must appear first in ~S lambda-list."
msgstr ""

#: target:code/defmacro.lisp
msgid "&environment not valid with ~S."
msgstr ""

#: target:code/defmacro.lisp
msgid "&environment only valid at top level of lambda-list."
msgstr ""

#: target:code/defmacro.lisp
msgid "Invalid ~a"
msgstr ""

#: target:code/defmacro.lisp
msgid "Ignore extra noise."
msgstr ""

#: target:code/defmacro.lisp
msgid ""
"More than variable, initform, and suppliedp ~\n"
"\t\t\t    in &optional binding - ~S"
msgstr ""

#: target:code/defmacro.lisp
msgid "Non-symbol in lambda-list - ~S."
msgstr ""

#: target:code/defmacro.lisp
msgid "Illegal optional variable name: ~S"
msgstr ""

#: target:code/defmacro.lisp
msgid ""
"Takes a non-keyword symbol, symbol, and returns the corresponding keyword."
msgstr ""

#: target:code/defmacro.lisp
msgid "Illegal or ill-formed ~A argument in ~A~@[ ~S~]."
msgstr ""

#: target:code/defmacro.lisp
msgid "Error while parsing arguments to ~A in ~S:~%"
msgstr ""

#: target:code/defmacro.lisp
msgid "Error while parsing arguments to ~A ~S:~%"
msgstr ""

#: target:code/defmacro.lisp
msgid "Bogus sublist:~%  ~S~%to satisfy lambda-list:~%  ~:S~%"
msgstr ""

#: target:code/defmacro.lisp
msgid ""
"Invalid number of elements in:~%  ~:S~%~\n"
"\t     to satisfy lambda-list:~%  ~:S~%"
msgstr ""

#: target:code/defmacro.lisp
msgid "Expected at least ~D"
msgstr ""

#: target:code/defmacro.lisp
msgid "Expected exactly ~D"
msgstr ""

#: target:code/defmacro.lisp
msgid "Expected between ~D and ~D"
msgstr ""

#: target:code/defmacro.lisp
msgid ", but got ~D."
msgstr ""

#: target:code/macros.lisp
msgid ""
"This function is to parse the declarations and doc-string out of the body "
"of\n"
"  a defun-like form.  Body is the list of stuff which is to be parsed.\n"
"  Environment is ignored.  If Doc-String-Allowed is true, then a doc string\n"
"  will be parsed out of the body and returned.  If it is false then a "
"string\n"
"  will terminate the search for declarations.  Three values are returned: "
"the\n"
"  tail of Body after the declarations and doc strings, a list of declare "
"forms,\n"
"  and the doc-string, or NIL if none."
msgstr ""

#: target:code/macros.lisp
msgid "defining macro ~A"
msgstr ""

#: target:code/macros.lisp
msgid "Ignore the lock and continue"
msgstr ""

#: target:code/macros.lisp
msgid "Disable the package's definition-lock then continue"
msgstr ""

#: target:code/macros.lisp
msgid "Unlock all packages, then continue"
msgstr ""

#: target:code/macros.lisp
msgid "Define a compiler-macro for NAME."
msgstr ""

#: target:code/macros.lisp
msgid "Symbol macro name is not a symbol: ~S."
msgstr ""

#: target:code/macros.lisp
msgid "Symbol macro name already declared special: ~S."
msgstr ""

#: target:code/macros.lisp
msgid "Symbol macro name already declared constant: ~S."
msgstr ""

#: target:code/macros.lisp
msgid "Syntax like DEFMACRO, but defines a new type."
msgstr ""

#: target:code/macros.lisp
msgid "~S -- Type name not a symbol."
msgstr ""

#: target:code/macros.lisp
msgid "defining type ~A"
msgstr ""

#: target:code/macros.lisp
msgid "Deftype already names a declaration: ~S."
msgstr ""

#: target:code/macros.lisp
msgid "Illegal to redefine standard type: ~S."
msgstr ""

#: target:code/macros.lisp
msgid "Redefining class ~S to be a DEFTYPE."
msgstr ""

#: target:code/macros.lisp
msgid "Setf expander for ~S cannot be called with ~S args."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Syntax like DEFMACRO, but creates a Setf-Expansion generator.  The body\n"
"  must be a form that returns the five magical values."
msgstr ""

#: target:code/macros.lisp
msgid "~S -- Access-function name not a symbol in DEFINE-SETF-EXPANDER."
msgstr ""

#: target:code/macros.lisp
msgid "Obsolete, use define-setf-expander."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Defining setf macro for destruct slot accessor; redefining as ~\n"
"\t        a normal function:~%  ~S"
msgstr ""

#: target:code/macros.lisp
msgid "Defining setf macro for ~S, but ~S is fbound."
msgstr ""

#: target:code/macros.lisp
msgid "Bind the variables in LAMBDA-LIST to the contents of ARG-LIST."
msgstr ""

#: target:code/macros.lisp
msgid ""
"For defining global constants at top level.  The DEFCONSTANT says that the\n"
"  value is constant and may be compiled into code.  If the variable already "
"has\n"
"  a value, and this is not equal to the init, an error is signalled.  The "
"third\n"
"  argument is an optional documentation string for the variable."
msgstr ""

#: target:code/macros.lisp
msgid "Go ahead and change the value."
msgstr ""

#: target:code/macros.lisp
msgid "Constant ~S being redefined."
msgstr ""

#: target:code/macros.lisp
msgid ""
"For defining global variables at top level.  Declares the variable\n"
"  SPECIAL and, optionally, initializes it.  If the variable already has a\n"
"  value, the old value is not clobbered.  The third argument is an optional\n"
"  documentation string for the variable."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Defines a parameter that is not normally changed by the program,\n"
"  but that may be changed without causing an error.  Declares the\n"
"  variable special and sets its value to VAL.  The third argument is\n"
"  an optional documentation string for the parameter."
msgstr ""

#: target:code/macros.lisp
msgid ""
"First arg is a predicate.  If it is non-null, the rest of the forms are\n"
"  evaluated as a PROGN."
msgstr ""

#: target:code/macros.lisp
msgid ""
"First arg is a predicate.  If it is null, the rest of the forms are\n"
"  evaluated as a PROGN."
msgstr ""

#: target:code/macros.lisp
msgid "Cond clause is not a list: ~S."
msgstr ""

#: target:code/macros.lisp
msgid "Varlist is not a list of symbols: ~S."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Evaluates FORM and returns the Nth value (zero based).  This involves no\n"
"  consing when N is a trivial constant integer."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Returns five values needed by the SETF machinery: a list of temporary\n"
"   variables, a list of values with which to fill them, a list of "
"temporaries\n"
"   for the new values, the setting function, and the accessing function."
msgstr ""

#: target:code/macros.lisp
msgid "Obsolete: use GET-SETF-EXPANSION."
msgstr ""

#: target:code/macros.lisp
msgid "Obsolete: use GET-SETF-EXPANSION and handle multiple store values."
msgstr ""

#: target:code/macros.lisp
msgid ""
"GET-SETF-METHOD used for a form with multiple store ~\n"
"\t      variables:~%  ~S"
msgstr ""

#: target:code/macros.lisp
msgid ""
"Associates a SETF update function or macro with the specified access\n"
"  function or macro.  The format is complex.  See the manual for\n"
"  details."
msgstr ""

#: target:code/macros.lisp
msgid "Ill-formed DEFSETF for ~S."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Takes pairs of arguments like SETQ.  The first is a place and the second\n"
"  is the value that is supposed to go into that place.  Returns the last\n"
"  value.  The place argument may be any of the access forms for which SETF\n"
"  knows a corresponding setting form."
msgstr ""

#: target:code/macros.lisp
msgid "Odd number of args to SETF."
msgstr ""

#: target:code/macros.lisp
msgid ""
"This is to SETF as PSETQ is to SETQ.  Args are alternating place\n"
"  expressions and values to go into those places.  All of the subforms and\n"
"  values are determined, left to right, and only then are the locations\n"
"  updated.  Returns NIL."
msgstr ""

#: target:code/macros.lisp
msgid "Odd number of args to PSETF."
msgstr ""

#: target:code/macros.lisp
msgid ""
"One or more SETF-style place expressions, followed by a single\n"
"   value expression.  Evaluates all of the expressions in turn, then\n"
"   assigns the value of each expression to the place on its left,\n"
"   returning the value of the leftmost."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Takes any number of SETF-style place expressions.  Evaluates all of the\n"
"   expressions in turn, then assigns to each place the value of the form to\n"
"   its right.  The rightmost form gets the value of the leftmost.\n"
"   Returns NIL."
msgstr ""

#: target:code/macros.lisp
msgid "Creates a new read-modify-write macro like PUSH or INCF."
msgstr ""

#: target:code/macros.lisp
msgid "Non-symbol &rest arg in definition of ~S."
msgstr ""

#: target:code/macros.lisp
msgid "Illegal stuff after &rest arg in Define-Modify-Macro."
msgstr ""

#: target:code/macros.lisp
msgid "~S not allowed in Define-Modify-Macro lambda list."
msgstr ""

#: target:code/macros.lisp
msgid "Illegal stuff in lambda list of Define-Modify-Macro."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Takes an object and a location holding a list.  Conses the object onto\n"
"  the list, returning the modified list.  OBJ is evaluated before PLACE."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Takes an object and a location holding a list.  If the object is already\n"
"  in the list, does nothing.  Else, conses the object onto the list.  "
"Returns\n"
"  NIL.  If there is a :TEST keyword, this is used for the comparison."
msgstr ""

#: target:code/macros.lisp
msgid ""
"The argument is a location holding a list.  Pops one item off the front\n"
"  of the list and returns it."
msgstr ""

#: target:code/macros.lisp
msgid ""
"The first argument is some location holding a number. This number is\n"
"  incremented by the second argument, DELTA, which defaults to 1."
msgstr ""

#: target:code/macros.lisp
msgid ""
"The first argument is some location holding a number. This number is\n"
"  decremented by the second argument, DELTA, which defaults to 1."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Place may be any place expression acceptable to SETF, and is expected\n"
"  to hold a property list or ().  This list is destructively altered to\n"
"  remove the property specified by the indicator.  Returns T if such a\n"
"  property was present, NIL if not."
msgstr ""

#: target:code/macros.lisp
msgid "Setf of Apply is only defined for function args like #'symbol."
msgstr ""

#: target:code/macros.lisp
msgid ""
"The first argument is a byte specifier.  The second is any place form\n"
"  acceptable to SETF.  Replaces the specified byte of the number in this\n"
"  place with bits from the low-order end of the new value."
msgstr ""

#: target:code/macros.lisp
msgid ""
"The first argument is a byte specifier.  The second is any place form\n"
"  acceptable to SETF.  Replaces the specified byte of the number in this "
"place\n"
"  with bits from the corresponding position in the new value."
msgstr ""

#: target:code/macros.lisp
msgid "~S -- Bad clause in ~S."
msgstr ""

#: target:code/macros.lisp
msgid "No default clause allowed in ~S: ~S"
msgstr ""

#: target:code/macros.lisp
msgid "T and OTHERWISE may not be used as key designators for ~A"
msgstr ""

#: target:code/macros.lisp
msgid "Bad style to use T or OTHERWISE in ECASE or CCASE"
msgstr ""

#: target:code/macros.lisp
msgid "Supply a new value for ~S."
msgstr ""

#: target:code/macros.lisp
msgid ""
"CASE Keyform {({(Key*) | Key} Form*)}*\n"
"  Evaluates the Forms in the first clause with a Key EQL to the value\n"
"  of Keyform.  If a singleton key is T or Otherwise then the clause is\n"
"  a default clause."
msgstr ""

#: target:code/macros.lisp
msgid ""
"CCASE Keyform {({(Key*) | Key} Form*)}*\n"
"  Evaluates the Forms in the first clause with a Key EQL to the value of\n"
"  Keyform.  If none of the keys matches then a correctable error is\n"
"  signalled."
msgstr ""

#: target:code/macros.lisp
msgid ""
"ECASE Keyform {({(Key*) | Key} Form*)}*\n"
"  Evaluates the Forms in the first clause with a Key EQL to the value of\n"
"  Keyform.  If none of the keys matches then an error is signalled."
msgstr ""

#: target:code/macros.lisp
msgid ""
"TYPECASE Keyform {(Type Form*)}*\n"
"  Evaluates the Forms in the first clause for which TYPEP of Keyform\n"
"  and Type is true.  If a singleton key is T or Otherwise then the\n"
"  clause is a default clause."
msgstr ""

#: target:code/macros.lisp
msgid ""
"CTYPECASE Keyform {(Type Form*)}*\n"
"  Evaluates the Forms in the first clause for which TYPEP of Keyform and "
"Type\n"
"  is true.  If no form is satisfied then a correctable error is signalled."
msgstr ""

#: target:code/macros.lisp
msgid ""
"ETYPECASE Keyform {(Type Form*)}*\n"
"  Evaluates the Forms in the first clause for which TYPEP of Keyform and "
"Type\n"
"  is true.  If no form is satisfied then an error is signalled."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Signals an error if the value of test-form is nil.  Continuing from this\n"
"   error using the CONTINUE restart will allow the user to alter the value "
"of\n"
"   some locations known to SETF, starting over with test-form.  Returns nil."
msgstr ""

#: target:code/macros.lisp
msgid "The assertion ~S failed."
msgstr ""

#: target:code/macros.lisp
msgid "Retry assertion"
msgstr ""

#: target:code/macros.lisp
msgid " with new value~P for ~{~S~^, ~}."
msgstr ""

#: target:code/macros.lisp
msgid ""
"The old value of ~S is ~S.~\n"
"\t\t  ~%Do you want to supply a new value? "
msgstr ""

#: target:code/macros.lisp
msgid "~&Type a form to be evaluated:~%"
msgstr ""

#: target:code/macros.lisp
msgid ""
"Signals an error of type type-error if the contents of place are not of the\n"
"   specified type.  If an error is signaled, this can only return if\n"
"   STORE-VALUE is invoked.  It will store into place and start over."
msgstr ""

#: target:code/macros.lisp
msgid "The value of ~S is ~S, which is not ~A."
msgstr ""

#: target:code/macros.lisp
msgid "The value of ~S is ~S, which is not of type ~S."
msgstr ""

#: target:code/macros.lisp
msgid "Supply a new value of ~S."
msgstr ""

#: target:code/macros.lisp
msgid ""
"The file whose name is Filespec is opened using the Open-args and\n"
"  bound to the variable Var. If the call to open is unsuccessful, the\n"
"  forms are not evaluated.  The Forms are executed, and when they\n"
"  terminate, normally or otherwise, the file is closed."
msgstr ""

#: target:code/macros.lisp
msgid ""
"The form stream should evaluate to a stream.  VAR is bound\n"
"   to the stream and the forms are evaluated as an implicit\n"
"   progn.  The stream is closed upon exit."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Binds the Var to an input stream that returns characters from String and\n"
"  executes the body.  See manual for details."
msgstr ""

#: target:code/macros.lisp
msgid ""
"If STRING is specified, it must be a string with a fill pointer;\n"
"   the output is incrementally appended to the string (as if by use of\n"
"   VECTOR-PUSH-EXTEND)."
msgstr ""

#: target:code/macros.lisp
msgid ""
"DO ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Iteration construct.  Each Var is initialized in parallel to the value of "
"the\n"
"  specified Init form.  On subsequent iterations, the Vars are assigned the\n"
"  value of the Step form (if any) in paralell.  The Test is evaluated "
"before\n"
"  each evaluation of the body Forms.  When the Test is true, the Exit-Forms\n"
"  are evaluated as a PROGN, with the result being the value of the DO.  A "
"block\n"
"  named NIL is established around the entire expansion, allowing RETURN to "
"be\n"
"  used as an laternate exit mechanism."
msgstr ""

#: target:code/macros.lisp
msgid ""
"DO* ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Iteration construct.  Each Var is initialized sequentially (like LET*) to "
"the\n"
"  value of the specified Init form.  On subsequent iterations, the Vars are\n"
"  sequentially assigned the value of the Step form (if any).  The Test is\n"
"  evaluated before each evaluation of the body Forms.  When the Test is "
"true,\n"
"  the Exit-Forms are evaluated as a PROGN, with the result being the value\n"
"  of the DO.  A block named NIL is established around the entire expansion,\n"
"  allowing RETURN to be used as an laternate exit mechanism."
msgstr ""

#: target:code/macros.lisp
msgid ""
"PSETQ {var value}*\n"
"   Set the variables to the values, like SETQ, except that assignments\n"
"   happen in parallel, i.e. no assignments take place until all the\n"
"   forms have been evaluated."
msgstr ""

#: target:code/macros.lisp
msgid "variable ~S in PSETQ is not a SYMBOL"
msgstr ""

#: target:code/macros.lisp
msgid "Unknown declaration context: ~S."
msgstr ""

#: target:code/macros.lisp
msgid ""
"Context declaration spec should have context and at ~\n"
"\t  least one DECLARE form:~%  ~S"
msgstr ""

#: target:code/macros.lisp
msgid ""
"WITH-COMPILATION-UNIT ({Key Value}*) Form*\n"
"  This form affects compilations that take place within its dynamic extent.  "
"It\n"
"  is intended to be wrapped around the compilation of all files in the same\n"
"  system.  These keywords are defined:\n"
"    :OVERRIDE Boolean-Form\n"
"        One of the effects of this form is to delay undefined warnings \n"
"        until the end of the form, instead of giving them at the end of "
"each\n"
"        compilation.  If OVERRIDE is NIL (the default), then the outermost\n"
"        WITH-COMPILATION-UNIT form grabs the undefined warnings.  "
"Specifying\n"
"        OVERRIDE true causes that form to grab any enclosed warnings, even "
"if\n"
"        it is enclosed by another WITH-COMPILATION-UNIT.\n"
"    :OPTIMIZE Decl-Form\n"
"        Decl-Form should evaluate to an OPTIMIZE declaration specifier.  "
"This\n"
"        declaration changes the `global' policy for compilations within the\n"
"        body.\n"
"    :OPTIMIZE-INTERFACE Decl-Form\n"
"        Like OPTIMIZE, except that it specifies the value of the CMU "
"extension\n"
"        OPTIMIZE-INTERFACE policy (which controls argument type and syntax\n"
"        checking.)\n"
"    :CONTEXT-DECLARATIONS List-of-Context-Decls-Form\n"
"        This is a CMU extension which allows compilation to be controlled\n"
"        by pattern matching on the context in which a definition appears.  "
"The\n"
"        argument should evaluate to a list of lists of the form:\n"
"            (Context-Spec Declare-Form+)\n"
"        In the indicated context, the specified declare forms are inserted "
"at\n"
"        the head of each definition.  The declare forms for all contexts "
"that\n"
"\tmatch are appended together, with earlier declarations getting\n"
"\tpredecence over later ones.  A simple example:\n"
"            :context-declarations\n"
"            '((:external (declare (optimize (safety 2)))))\n"
"        This will cause all functions that are named by external symbols to "
"be\n"
"        compiled with SAFETY 2.  The full syntax of context specs is:\n"
"\t:INTERNAL, :EXTERNAL\n"
"\t    True if the symbols is internal (external) in its home package.\n"
"\t:UNINTERNED\n"
"\t    True if the symbol has no home package.\n"
"\t:ANONYMOUS\n"
"\t    True if the function doesn't have any interesting name (not\n"
"\t    DEFMACRO, DEFUN, LABELS or FLET).\n"
"\t:MACRO, :FUNCTION\n"
"\t    :MACRO is a global (DEFMACRO) macro.  :FUNCTION is anything else.\n"
"\t:LOCAL, :GLOBAL\n"
"\t    :LOCAL is a LABELS or FLET.  :GLOBAL is anything else.\n"
"\t(:OR Context-Spec*)\n"
"\t    True in any specified context.\n"
"\t(:AND Context-Spec*)\n"
"\t    True only when all specs are true.\n"
"\t(:NOT Context-Spec)\n"
"\t    True when the spec is false.\n"
"        (:MEMBER Name*)\n"
"\t    True when the name is one of these names (EQUAL test.)\n"
"\t(:MATCH Pattern*)\n"
"\t    True when any of the patterns is a substring of the name.  The name\n"
"\t    is wrapped with $'s, so $FOO matches names beginning with FOO,\n"
"\t    etc."
msgstr ""

#: target:code/macros.lisp
msgid "Odd number of key/value pairs: ~S."
msgstr ""

#: target:code/macros.lisp
msgid "Ignoring unknown option: ~S."
msgstr ""

#~ msgid "Read-Only Space Usage:  ~13:D  (~4:D ) .~%"
#~ msgstr "   :  ~13:D  (~4:D ) .~%"

#~ msgid "Static Space Usage:     ~13:D  (~4:D ) .~%"
#~ msgstr "  :     ~13:D  (~4:D ) .~%"
