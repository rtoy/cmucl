# @ cmucl
# SOME DESCRIPTIVE TITLE
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CMUCL 20E\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI +ZONE\n"
"Last-Translator: Automatic translation\n"
"Language-Team: Pig Latin (auto-translated)\n"
"Language: Pig Latin\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: src/code/struct.lisp
msgid "The size of a stream in-buffer."
msgstr "Ethay izesay ofway away eamstray inway-ufferbay."

#: src/pcl/cpl.lisp src/pcl/dfun.lisp src/pcl/vector.lisp src/pcl/boot.lisp
#: src/pcl/cache.lisp src/pcl/fngen.lisp src/pcl/defs.lisp src/pcl/info.lisp
#: src/pcl/defsys.lisp src/compiler/byte-comp.lisp src/compiler/eval-comp.lisp
#: src/compiler/generic/new-genesis.lisp src/compiler/generic/core.lisp
#: src/compiler/dump.lisp src/compiler/dyncount.lisp src/compiler/xref.lisp
#: src/compiler/srctran.lisp src/compiler/ir1util.lisp src/compiler/main.lisp
#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/disassem.lisp src/compiler/meta-vmdef.lisp
#: src/compiler/vop.lisp src/compiler/ctype.lisp src/compiler/node.lisp
#: src/compiler/sset.lisp src/compiler/backend.lisp
#: src/compiler/generic/vm-macs.lisp src/compiler/macros.lisp
#: src/code/intl.lisp src/compiler/globaldb.lisp src/code/defstruct.lisp
#: src/code/remote.lisp src/code/wire.lisp src/code/internet.lisp
#: src/code/loop.lisp src/code/run-program.lisp src/code/parse-time.lisp
#: src/code/profile.lisp src/code/ntrace.lisp src/code/rand-xoroshiro.lisp
#: src/code/debug.lisp src/code/debug-int.lisp src/code/debug-info.lisp
#: src/code/eval.lisp src/code/filesys.lisp src/code/pathname.lisp
#: src/code/fd-stream.lisp src/code/extfmts.lisp src/code/serve-event.lisp
#: src/code/reader.lisp src/code/package.lisp src/code/format.lisp
#: src/code/pprint.lisp src/code/stream.lisp src/code/room.lisp
#: src/code/dfixnum.lisp src/code/commandline.lisp src/code/unidata.lisp
#: src/compiler/proclaim.lisp src/code/hash-new.lisp src/code/byte-interp.lisp
#: src/code/c-call.lisp src/code/alieneval.lisp src/code/type.lisp
#: src/code/class.lisp src/code/typedefs.lisp src/code/error.lisp
#: src/code/fwrappers.lisp src/code/struct.lisp
msgid "Class not yet defined: ~S"
msgstr "Assclay otnay etyay efinedday: ~S"

#: src/code/sysmacs.lisp
#, fuzzy
msgid ""
"Register the feature as having influenced the CMUCL build\n"
"  process. Feature is added to *feature*"
msgstr ""
"Egisterray ethay eaturefay asway avinghay influencedway ethay CMUCL uildbay "
"ocesspray."

#: src/code/sysmacs.lisp
#, fuzzy
msgid ""
"Register the feature as having influenced the CMUCL build process,\n"
"and also the CMUCL C runtime. Feature is added to*features* and\n"
"sys::*runtime-features*."
msgstr ""
"Egisterray ethay eaturefay asway avinghay influencedway ethay CMUCL uildbay "
"ocesspray,\n"
"andway alsoway ethay CMUCL C untimeray."

#: src/code/sysmacs.lisp
msgid ""
"Given any Array, binds Data-Var to the array's data vector and Start-Var "
"and\n"
"  End-Var to the start and end of the designated portion of the data "
"vector.\n"
"  Svalue and Evalue are any start and end specified to the original "
"operation,\n"
"  and are factored into the bindings of Start-Var and End-Var.  Offset-Var "
"is\n"
"  the cumulative offset of all displacements encountered, and does not\n"
"  include Svalue."
msgstr ""
"Ivengay anyway Arrayway, indsbay Ataday-Arvay otay ethay arrayway's ataday "
"ectorvay andway Tartsay-Arvay andway\n"
"  Endway-Arvay otay ethay tartsay andway endway ofway ethay esignatedday "
"ortionpay ofway ethay ataday ectorvay.\n"
"  Valuesay andway Evalueway areway anyway tartsay andway endway ecifiedspay "
"otay ethay originalway operatiowayn,\n"
"  andway areway actoredfay intoway ethay indingsbay ofway Tartsay-Arvay "
"andway Endway-Arvay.  Offsetway-Arvay isway\n"
"  ethay umulativecay offsetway ofway allway isplacementsday encounteredway, "
"andway oesday otnay\n"
"  includeway Valuesay."

#: src/code/sysmacs.lisp
msgid "Executes the forms in the body without doing a garbage collection."
msgstr ""
"Executesway ethay ormsfay inway ethay odybay ithoutway oingday away "
"arbagegay ollectioncay."

#: src/code/kernel.lisp
msgid ""
"Return the 24 bits of data in the header of object X, which must be an\n"
"  other-pointer object."
msgstr ""
"Eturnray ethay 24 itsbay ofway ataday inway ethay eaderhay ofway objectway "
"X, ichwhay ustmay ebay anway\n"
"  otherway-ointerpay objectway."

#: src/code/kernel.lisp
msgid ""
"Sets the 24 bits of data in the header of object X (which must be an\n"
"  other-pointer object) to VAL."
msgstr ""
"Etssay ethay 24 itsbay ofway ataday inway ethay eaderhay ofway objectway X "
"(ichwhay ustmay ebay anway\n"
"  otherway-ointerpay objectway) otay VAL."

#: src/code/kernel.lisp
msgid ""
"Returns the length of the closure X.  This is one more than the number\n"
"  of variables closed over."
msgstr ""
"Eturnsray ethay engthlay ofway ethay osureclay X.  Isthay isway oneway "
"oremay anthay ethay umbernay\n"
"  ofway ariablesvay osedclay overway."

#: src/code/kernel.lisp
msgid "Returns the three-bit lowtag for the object X."
msgstr "Eturnsray ethay reethay-itbay owtaglay orfay ethay objectway X."

#: src/code/kernel.lisp
msgid "Returns the 8-bit header type for the object X."
msgstr "Eturnsray ethay 8-itbay eaderhay ypetay orfay ethay objectway X."

#: src/code/kernel.lisp
msgid ""
"Return a System-Area-Pointer pointing to the data for the vector X, which\n"
"  must be simple."
msgstr ""
"Eturnray away Ystemsay-Areaway-Ointerpay ointingpay otay ethay ataday orfay "
"ethay ectorvay X, ichwhay\n"
"  ustmay ebay implesay."

#: src/code/kernel.lisp
msgid "Return a System-Area-Pointer pointing to the end of the binding stack."
msgstr ""
"Eturnray away Ystemsay-Areaway-Ointerpay ointingpay otay ethay endway ofway "
"ethay indingbay tacksay."

#: src/code/kernel.lisp
msgid ""
"Returns a System-Area-Pointer pointing to the next free work of the current\n"
"  dynamic space."
msgstr ""
"Eturnsray away Ystemsay-Areaway-Ointerpay ointingpay otay ethay extnay "
"eefray orkway ofway ethay urrentcay\n"
"  ynamicday acespay."

#: src/code/kernel.lisp
msgid "Return a System-Area-Pointer pointing to the end of the control stack."
msgstr ""
"Eturnray away Ystemsay-Areaway-Ointerpay ointingpay otay ethay endway ofway "
"ethay ontrolcay tacksay."

#: src/code/kernel.lisp
msgid "Return the header typecode for FUNCTION.  Can be set with SETF."
msgstr ""
"Eturnray ethay eaderhay ypecodetay orfay FUNCTION.  Ancay ebay etsay ithway "
"SETF."

#: src/code/kernel.lisp
msgid "Extracts the arglist from the function header FUNC."
msgstr "Extractsway ethay arglistway omfray ethay unctionfay eaderhay FUNC."

#: src/code/kernel.lisp
msgid "Extracts the name from the function header FUNC."
msgstr "Extractsway ethay amenay omfray ethay unctionfay eaderhay FUNC."

#: src/code/kernel.lisp
msgid "Extracts the type from the function header FUNC."
msgstr "Extractsway ethay ypetay omfray ethay unctionfay eaderhay FUNC."

#: src/code/kernel.lisp
msgid "Extracts the function from CLOSURE."
msgstr "Extractsway ethay unctionfay omfray CLOSURE."

#: src/code/kernel.lisp
msgid ""
"Return the length of VECTOR.  There is no reason to use this, 'cause\n"
"  (length (the vector foo)) is the same."
msgstr ""
"Eturnray ethay engthlay ofway VECTOR.  Erethay isway onay easonray otay "
"useway isthay, 'ausecay\n"
"  (engthlay (ethay ectorvay oofay)) isway ethay amesay."

#: src/code/kernel.lisp
msgid "Return the SXHASH for the simple-string STRING."
msgstr "Eturnray ethay SXHASH orfay ethay implesay-ingstray STRING."

#: src/code/kernel.lisp
msgid ""
"Return the SXHASH for the first LENGTH characters of the simple-string\n"
"  STRING."
msgstr ""
"Eturnray ethay SXHASH orfay ethay irstfay LENGTH aracterschay ofway ethay "
"implesay-ingstray\n"
"  STRING."

#: src/code/kernel.lisp
msgid "Extract the INDEXth slot from CLOSURE."
msgstr "Extractway ethay Indexthway otslay omfray CLOSURE."

#: src/code/kernel.lisp
msgid ""
"Allocate a unboxed, simple vector with type code TYPE, length LENGTH, and\n"
"  WORDS words long.  Note: it is your responsibility to assure that the\n"
"  relation between LENGTH and WORDS is correct."
msgstr ""
"Allocateway away unboxedway, implesay ectorvay ithway ypetay odecay TYPE, "
"engthlay LENGTH, andway\n"
"  WORDS ordsway onglay.  Otenay: itway isway ouryay esponsibilityray otay "
"assureway atthay ethay\n"
"  elationray etweenbay LENGTH andway WORDS isway orrectcay."

#: src/code/kernel.lisp
msgid "Allocate an array header with type code TYPE and rank RANK."
msgstr ""
"Allocateway anway arrayway eaderhay ithway ypetay odecay TYPE andway ankray "
"RANK."

#: src/code/kernel.lisp
msgid "Return a SAP pointing to the instructions part of CODE-OBJ."
msgstr ""
"Eturnray away SAP ointingpay otay ethay instructionsway artpay ofway CODE-"
"OBJ."

#: src/code/kernel.lisp
msgid ""
"Extract the INDEXth element from the header of CODE-OBJ.  Can be set with\n"
"  setf."
msgstr ""
"Extractway ethay Indexthway elementway omfray ethay eaderhay ofway CODE-"
"OBJ.  Ancay ebay etsay ithway\n"
"  etfsay."

#: src/code/format.lisp src/code/print.lisp src/code/irrat-dd.lisp
#: src/code/irrat.lisp src/code/float.lisp src/code/numbers.lisp
#: src/code/kernel.lisp
msgid "Argument ~A is not a ~S: ~S."
msgstr "Argumentway ~Away isway otnay away ~S: ~S."

#: src/code/lispinit.lisp
msgid ""
"Holds a list of symbols that describe features provided by the\n"
"   implementation."
msgstr ""
"Oldshay away istlay ofway ymbolssay atthay escribeday eaturesfay ovidedpray "
"ybay ethay\n"
"   implementationway."

#: src/code/lispinit.lisp
#, fuzzy
msgid "Features affecting the runtime.  These are written to internals.h."
msgstr "Eaturesfay affectingway ethay untimeray"

#: src/code/lispinit.lisp
msgid "The fixnum closest in value to positive infinity."
msgstr "Ethay ixnumfay osestclay inway aluevay otay ositivepay infinityway."

#: src/code/lispinit.lisp
msgid "The fixnum closest in value to negative infinity."
msgstr "Ethay ixnumfay osestclay inway aluevay otay egativenay infinityway."

#: src/code/lispinit.lisp
msgid ""
"When (typep condition *break-on-signals*) is true, then calls to SIGNAL "
"will\n"
"   enter the debugger prior to signalling that condition."
msgstr ""
"Enwhay (ypeptay onditioncay *break-on-signals*) isway uetray, enthay allscay "
"otay SIGNAL illway\n"
"   enterway ethay ebuggerday iorpray otay ignallingsay atthay onditioncay."

#: src/code/lispinit.lisp
msgid ""
"Invokes the signal facility on a condition formed from datum and arguments.\n"
"   If the condition is not handled, nil is returned.  If\n"
"   (TYPEP condition *BREAK-ON-SIGNALS*) is true, the debugger is invoked "
"before\n"
"   any signalling is done."
msgstr ""
"Invokesway ethay ignalsay acilityfay onway away onditioncay ormedfay omfray "
"atumday andway argumentsway.\n"
"   Ifway ethay onditioncay isway otnay andledhay, ilnay isway eturnedray.  "
"Ifway\n"
"   (TYPEP onditioncay *BREAK-ON-SIGNALS*) isway uetray, ethay ebuggerday "
"isway invokedway eforebay\n"
"   anyway ignallingsay isway oneday."

#: src/code/lispinit.lisp
msgid "~A~%Break entered because of *break-on-signals* (now NIL.)"
msgstr ""
"~Away~%Eakbray enteredway ecausebay ofway *break-on-signals* (ownay NIL.)"

#: src/code/lispinit.lisp
msgid "Ignore the additional arguments."
msgstr "Ignoreway ethay additionalway argumentsway."

#: src/code/lispinit.lisp
msgid ""
"You may not supply additional arguments ~\n"
"\t\t\t\t     when giving ~S to ~S."
msgstr ""
"Ouyay aymay otnay upplysay additionalway argumentsway ~\n"
"\t\t\t\t     enwhay ivinggay ~S otay ~S."

#: src/code/lispinit.lisp
msgid "Bad argument to ~S: ~S"
msgstr "Adbay argumentway otay ~S: ~S"

#: src/code/lispinit.lisp
msgid ""
"Invokes the signal facility on a condition formed from datum and arguments.\n"
"   If the condition is not handled, the debugger is invoked."
msgstr ""
"Invokesway ethay ignalsay acilityfay onway away onditioncay ormedfay omfray "
"atumday andway argumentsway.\n"
"   Ifway ethay onditioncay isway otnay andledhay, ethay ebuggerday isway "
"invokedway."

#: src/pcl/dfun.lisp src/code/interr.lisp src/code/lispinit.lisp
msgid "Help! "
msgstr "Elphay! "

#: src/pcl/dfun.lisp src/code/interr.lisp src/code/lispinit.lisp
msgid " nested errors.  "
msgstr " estednay errorsway.  "

#: src/pcl/dfun.lisp src/code/interr.lisp src/code/lispinit.lisp
msgid "KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded."
msgstr "KERNEL:*MAXIMUM-ERROR-DEPTH* exceededway."

#: src/code/lispinit.lisp
msgid ""
"Prints a message and invokes the debugger without allowing any possibility\n"
"   of condition handling occurring."
msgstr ""
"Intspray away essagemay andway invokesway ethay ebuggerday ithoutway "
"allowingway anyway ossibilitypay\n"
"   ofway onditioncay andlinghay occurringway."

#: src/code/lispinit.lisp
msgid "Return from BREAK."
msgstr "Eturnray omfray BREAK."

#: src/code/lispinit.lisp
msgid ""
"Warns about a situation by signalling a condition formed by datum and\n"
"   arguments.  While the condition is being signaled, a muffle-warning "
"restart\n"
"   exists that causes WARN to immediately return nil."
msgstr ""
"Arnsway aboutway away ituationsay ybay ignallingsay away onditioncay "
"ormedfay ybay atumday andway\n"
"   argumentsway.  Ilewhay ethay onditioncay isway eingbay ignaledsay, away "
"ufflemay-arningway estartray\n"
"   existsway atthay ausescay WARN otay immediatelyway eturnray ilnay."

#: src/code/lispinit.lisp
msgid "a warning condition"
msgstr "away arningway onditioncay"

#: src/code/lispinit.lisp
msgid "Skip warning."
msgstr "Kipsay arningway."

#: src/code/lispinit.lisp
msgid "~&~@<Warning:  ~3i~:_~A~:>~%"
msgstr "~&~@<Arningway:  ~3i~:_~Away~:>~%"

#: src/code/lispinit.lisp
msgid ""
"Invokes the signal facility on a condition formed from datum and arguments.\n"
"   If the condition is not handled, the debugger is invoked.  This function\n"
"   is just like error, except that the condition type defaults to the type\n"
"   simple-program-error, instead of program-error."
msgstr ""
"Invokesway ethay ignalsay acilityfay onway away onditioncay ormedfay omfray "
"atumday andway argumentsway.\n"
"   Ifway ethay onditioncay isway otnay andledhay, ethay ebuggerday isway "
"invokedway.  Isthay unctionfay\n"
"   isway ustjay ikelay errorway, exceptway atthay ethay onditioncay ypetay "
"efaultsday otay ethay ypetay\n"
"   implesay-ogrampray-errorway, insteadway ofway ogrampray-errorway."

#: src/code/lispinit.lisp
msgid "Gives the world a shove and hopes it spins."
msgstr "Ivesgay ethay orldway away oveshay andway opeshay itway insspay."

#: src/code/lispinit.lisp
msgid "Functions to be invoked during cleanup at Lisp exit."
msgstr ""
"Unctionsfay otay ebay invokedway uringday eanupclay atway Isplay exitway."

#: src/code/lispinit.lisp
#, fuzzy
msgid ""
"Terminates the current Lisp.  Things are cleaned up unless\n"
"  Recklessly-P is non-Nil.  On quitting, Lisp sets the return code to\n"
"  Code, defaulting to 0."
msgstr ""
"Erminatestay ethay urrentcay Isplay.  Ingsthay areway eanedclay upway "
"unlessway Ecklesslyray-P isway\n"
"  onnay-Ilnay."

#: src/code/lispinit.lisp
msgid ""
"This function causes execution to be suspended for N seconds.  N may\n"
"  be any non-negative, non-complex number."
msgstr ""
"Isthay unctionfay ausescay executionway otay ebay uspendedsay orfay N "
"econdssay.  N aymay\n"
"  ebay anyway onnay-egativenay, onnay-omplexcay umbernay."

#: src/code/lispinit.lisp
msgid ""
"Zero the unused portion of the control stack so that old objects are not\n"
"   kept alive because of uninitialized stack variables."
msgstr ""
"Erozay ethay unusedway ortionpay ofway ethay ontrolcay tacksay osay atthay "
"oldway objectsway areway otnay\n"
"   eptkay aliveway ecausebay ofway uninitializedway tacksay ariablesvay."

#: src/code/lispinit.lisp
msgid ""
"Holds a list of all the values returned by the most recent top-level EVAL."
msgstr ""
"Oldshay away istlay ofway allway ethay aluesvay eturnedray ybay ethay ostmay "
"ecentray optay-evellay EVAL."

#: src/code/lispinit.lisp
msgid "Gets the previous value of / when a new value is computed."
msgstr ""
"Etsgay ethay eviouspray aluevay ofway / enwhay away ewnay aluevay isway "
"omputedcay."

#: src/code/lispinit.lisp
msgid "Gets the previous value of // when a new value is computed."
msgstr ""
"Etsgay ethay eviouspray aluevay ofway // enwhay away ewnay aluevay isway "
"omputedcay."

#: src/code/lispinit.lisp
msgid "Holds the value of the most recent top-level EVAL."
msgstr "Oldshay ethay aluevay ofway ethay ostmay ecentray optay-evellay EVAL."

#: src/code/lispinit.lisp
msgid "Gets the previous value of * when a new value is computed."
msgstr ""
"Etsgay ethay eviouspray aluevay ofway * enwhay away ewnay aluevay isway "
"omputedcay."

#: src/code/lispinit.lisp
msgid "Gets the previous value of ** when a new value is computed."
msgstr ""
"Etsgay ethay eviouspray aluevay ofway ** enwhay away ewnay aluevay isway "
"omputedcay."

#: src/code/lispinit.lisp
msgid "Holds the value of the most recent top-level READ."
msgstr "Oldshay ethay aluevay ofway ethay ostmay ecentray optay-evellay READ."

#: src/code/lispinit.lisp
msgid "Gets the previous value of + when a new value is read."
msgstr ""
"Etsgay ethay eviouspray aluevay ofway + enwhay away ewnay aluevay isway "
"eadray."

#: src/code/lispinit.lisp
msgid "Gets the previous value of ++ when a new value is read."
msgstr ""
"Etsgay ethay eviouspray aluevay ofway ++ enwhay away ewnay aluevay isway "
"eadray."

#: src/code/lispinit.lisp
msgid "Holds the form curently being evaluated."
msgstr "Oldshay ethay ormfay urentlycay eingbay evaluatedway."

#: src/code/lispinit.lisp
msgid ""
"The top-level prompt string.  This also may be a function of no arguments\n"
"   that returns a simple-string."
msgstr ""
"Ethay optay-evellay omptpray ingstray.  Isthay alsoway aymay ebay away "
"unctionfay ofway onay argumentsway\n"
"   atthay eturnsray away implesay-ingstray."

#: src/code/lispinit.lisp
msgid ""
"True if we are within the Top-Level-Catcher.  This is used by interrupt\n"
"  handlers to see whether it is o.k. to throw."
msgstr ""
"Uetray ifway eway areway ithinway ethay Optay-Evellay-Atchercay.  Isthay "
"isway usedway ybay interruptway\n"
"  andlershay otay eesay etherwhay itway isway o.k. otay rowthay."

#: src/code/lispinit.lisp
msgid ""
"Evaluate FORM, returning whatever it returns but adjust ***, **, *, +++, +"
"+,\n"
"  +, ///, //, /, and -."
msgstr ""
"Evaluateway FORM, eturningray ateverwhay itway eturnsray utbay adjustway "
"***, **, *, +++, ++,\n"
"  +, ///, //, /, andway -."

#: src/code/lispinit.lisp
msgid "Go on with * set to NIL."
msgstr "Ogay onway ithway * etsay otay NIL."

#: src/code/lispinit.lisp
msgid "EVAL returned an unbound marker."
msgstr "EVAL eturnedray anway unboundway arkermay."

#: src/code/lispinit.lisp
msgid ""
"How many pages to reserve from the total heap space so we can handle\n"
"heap overflow."
msgstr ""
"Owhay anymay agespay otay eserveray omfray ethay otaltay eaphay acespay osay "
"eway ancay andlehay\n"
"eaphay overflowway."

#: src/code/lispinit.lisp
msgid "Top-level READ-EVAL-PRINT loop.  Do not call this."
msgstr "Optay-evellay READ-EVAL-PRINT ooplay.  Oday otnay allcay isthay."

#: src/code/lispinit.lisp
msgid ""
"~&Received EOF on *standard-input*, ~\n"
"\t\t\t\t\tswitching to *terminal-io*.~%"
msgstr ""
"~&Eceivedray EOF onway *standard-input*, ~\n"
"\t\t\t\t\twitchingsay otay *terminal-io*.~%"

#: src/code/lispinit.lisp
msgid "~&Received more than ~D EOFs; Aborting.~%"
msgstr "~&Eceivedray oremay anthay ~D Eofsway; Abortingway.~%"

#: src/code/lispinit.lisp
msgid "~&Received EOF.~%"
msgstr "~&Eceivedray EOF.~%"

#: src/code/lispinit.lisp
msgid "Return to Top-Level."
msgstr "Eturnray otay Optay-Evellay."

#: src/pcl/walk.lisp
msgid ""
"~@<The evaluator was called to evaluate a form in a macroexpansion ~\n"
"          environment constructed by the PCL portable code walker.  These ~\n"
"          environments are only useful for macroexpansion, they cannot be ~\n"
"          used for evaluation.  ~\n"
"          This error should never occur when using PCL.  ~\n"
"          This most likely source of this error is a program which tries to "
"~\n"
"          to use the PCL portable code walker to build its own evaluator.~@:>"
msgstr ""
"~@<Ethay evaluatorway asway alledcay otay evaluateway away ormfay inway away "
"acroexpansionmay ~\n"
"          environmentway onstructedcay ybay ethay PCL ortablepay odecay "
"alkerway.  Esethay ~\n"
"          environmentsway areway onlyway usefulway orfay acroexpansionmay, "
"eythay annotcay ebay ~\n"
"          usedway orfay evaluationway.  ~\n"
"          Isthay errorway ouldshay evernay occurway enwhay usingway PCL.  ~\n"
"          Isthay ostmay ikelylay ourcesay ofway isthay errorway isway away "
"ogrampray ichwhay iestray otay ~\n"
"          otay useway ethay PCL ortablepay odecay alkerway otay uildbay "
"itsway ownway evaluatorway.~@:>"

#: src/pcl/walk.lisp
msgid "~@<~S is not a recognized variable declaration.~@:>"
msgstr "~@<~S isway otnay away ecognizedray ariablevay eclarationday.~@:>"

#: src/pcl/walk.lisp
msgid "~@<Can't get template for ~S.~@:>"
msgstr "~@<Ancay't etgay emplatetay orfay ~S.~@:>"

#: src/pcl/walk.lisp
msgid ""
"~@<~S is a special form, not defined in the CommonLisp ~\n"
"\t\t      manual.  This code walker doesn't know how to walk it.  ~\n"
"\t\t      Define a template for this special form and try again.~@:>"
msgstr ""
"~@<~S isway away ecialspay ormfay, otnay efinedday inway ethay Ommonlispcay "
"~\n"
"\t\t      anualmay.  Isthay odecay alkerway oesnday't nowkay owhay otay "
"alkway itway.  ~\n"
"\t\t      Efineday away emplatetay orfay isthay ecialspay ormfay andway "
"ytray againway.~@:>"

#: src/pcl/walk.lisp
msgid ""
"~@<While handling repeat: ~\n"
"                     Ran into stop while still in repeat template.~@:>"
msgstr ""
"~@<Ilewhay andlinghay epeatray: ~\n"
"                     Anray intoway topsay ilewhay tillsay inway epeatray "
"emplatetay.~@:>"

#: src/pcl/walk.lisp
msgid ""
"~@<Encountered declare ~S in a place where a ~\n"
"         declare was not expected.~@:>"
msgstr ""
"~@<Encounteredway eclareday ~S inway away aceplay erewhay away ~\n"
"         eclareday asway otnay expectedway.~@:>"

#: src/pcl/walk.lisp
msgid "~@<Can't understand something in the arglist ~S.~@:>"
msgstr "~@<Ancay't understandway omethingsay inway ethay arglistway ~S.~@:>"

#: src/pcl/walk.lisp
msgid ""
"~@<In the form ~S: ~\n"
"                       IF only accepts three arguments, you are using ~D. ~\n"
"                       It is true that some Common Lisps support this, but "
"~\n"
"                       it is not truly legal Common Lisp.  For now, this "
"code ~\n"
"                       walker is interpreting the extra arguments as extra "
"else clauses. ~\n"
"                       Even if this is what you intended, you should fix "
"your source code.~@:>"
msgstr ""
"~@<Inway ethay ormfay ~S: ~\n"
"                       IF onlyway acceptsway reethay argumentsway, ouyay "
"areway usingway ~D. ~\n"
"                       Itway isway uetray atthay omesay Ommoncay Ispslay "
"upportsay isthay, utbay ~\n"
"                       itway isway otnay ulytray egallay Ommoncay Isplay.  "
"Orfay ownay, isthay odecay ~\n"
"                       alkerway isway interpretingway ethay extraway "
"argumentsway asway extraway elseway ausesclay. ~\n"
"                       Evenway ifway isthay isway atwhay ouyay intendedway, "
"ouyay ouldshay ixfay ouryay ourcesay odecay.~@:>"

#: src/code/fwrappers.lisp
msgid ""
"A funcallable instance used to implement fwrappers.\n"
"   The CONSTRUCTOR slot is a function defined with DEFINE-FWRAPPER.\n"
"   This function returns an instance closure closing over an \n"
"   fwrapper object, which is installed as the funcallable-instance\n"
"   function of the fwrapper object."
msgstr ""
"Away uncallablefay instanceway usedway otay implementway wrappersfay.\n"
"   Ethay CONSTRUCTOR otslay isway away unctionfay efinedday ithway DEFINE-"
"FWRAPPER.\n"
"   Isthay unctionfay eturnsray anway instanceway osureclay osingclay overway "
"anway \n"
"   wrapperfay objectway, ichwhay isway installedway asway ethay "
"uncallablefay-instanceway\n"
"   unctionfay ofway ethay wrapperfay objectway."

#: src/code/fwrappers.lisp
msgid "Print-function for struct FWRAPPER."
msgstr "Intpray-unctionfay orfay uctstray FWRAPPER."

#: src/code/fwrappers.lisp
msgid "Return FUN if it is an fwrapper or nil if it isn't."
msgstr ""
"Eturnray FUN ifway itway isway anway wrapperfay orway ilnay ifway itway "
"isnway't."

#: src/code/fwrappers.lisp
msgid ""
"Evaluate BODY with VAR bound to consecutive fwrappers of\n"
"   FDEFN.  Return RESULT at the end."
msgstr ""
"Evaluateway BODY ithway VAR oundbay otay onsecutivecay wrappersfay ofway\n"
"   FDEFN.  Eturnray RESULT atway ethay endway."

#: src/code/fwrappers.lisp
msgid "Return tha last encapsulation of FDEFN or NIL if none."
msgstr ""
"Eturnray athay astlay encapsulationway ofway FDEFN orway NIL ifway onenay."

#: src/code/fwrappers.lisp
msgid ""
"Prepend encapsulation F to the definition of FUNCTION-NAME.\n"
"   Signal an error if FUNCTION-NAME is an undefined function."
msgstr ""
"Ependpray encapsulationway F otay ethay efinitionday ofway FUNCTION-NAME.\n"
"   Ignalsay anway errorway ifway FUNCTION-NAME isway anway undefinedway "
"unctionfay."

#: src/code/fwrappers.lisp
msgid "Remove fwrapper F from the definition of FUNCTION-NAME."
msgstr "Emoveray wrapperfay F omfray ethay efinitionday ofway FUNCTION-NAME."

#: src/code/fwrappers.lisp
msgid ""
"Return a list of all fwrappers of FUNCTION-NAME, ordered\n"
"   from outermost to innermost."
msgstr ""
"Eturnray away istlay ofway allway wrappersfay ofway FUNCTION-NAME, "
"orderedway\n"
"   omfray outermostway otay innermostway."

#: src/code/fwrappers.lisp
msgid ""
"Set FUNCTION-NAMES's fwrappers to elements of the list\n"
"   FWRAPPERS, which is assumed to be ordered from outermost to\n"
"   innermost.  FWRAPPERS null means remove all fwrappers."
msgstr ""
"Etsay FUNCTION-NAMES's wrappersfay otay elementsway ofway ethay istlay\n"
"   FWRAPPERS, ichwhay isway assumedway otay ebay orderedway omfray "
"outermostway otay\n"
"   innermostway.  FWRAPPERS ullnay eansmay emoveray allway wrappersfay."

#: src/code/fwrappers.lisp
msgid ""
"Wrap the function named FUNCTION-NAME in an fwrapper of type TYPE,\n"
"   created by calling CONSTRUCTOR.  CONSTRUCTOR is a function\n"
"   defined with DEFINE-FWRAPPER, or the name of such a function.\n"
"   Return the fwrapper created.  USER-DATA is arbitrary data to be\n"
"   associated with the fwrapper.  It is accessible in wrapper\n"
"   functions defined with DEFINE-FWRAPPER as (FWRAPPER-USER-DATA\n"
"   FWRAPPER)."
msgstr ""
"Apwray ethay unctionfay amednay FUNCTION-NAME inway anway wrapperfay ofway "
"ypetay TYPE,\n"
"   eatedcray ybay allingcay CONSTRUCTOR.  CONSTRUCTOR isway away unctionfay\n"
"   efinedday ithway DEFINE-FWRAPPER, orway ethay amenay ofway uchsay away "
"unctionfay.\n"
"   Eturnray ethay wrapperfay eatedcray.  USER-DATA isway arbitraryway ataday "
"otay ebay\n"
"   associatedway ithway ethay wrapperfay.  Itway isway accessibleway inway "
"apperwray\n"
"   unctionsfay efinedday ithway DEFINE-FWRAPPER asway (FWRAPPER-USER-DATA\n"
"   FWRAPPER)."

#: src/code/fwrappers.lisp
msgid ""
"Remove fwrappers from the function named FUNCTION-NAME.\n"
"   If TYPE is supplied, remove fwrappers whose type is equal to TYPE.\n"
"   If TEST is supplied, remove fwrappers satisfying TEST.\n"
"   If both are not specified, remove all fwrappers."
msgstr ""
"Emoveray wrappersfay omfray ethay unctionfay amednay FUNCTION-NAME.\n"
"   Ifway TYPE isway uppliedsay, emoveray wrappersfay osewhay ypetay isway "
"equalway otay TYPE.\n"
"   Ifway TEST isway uppliedsay, emoveray wrappersfay atisfyingsay TEST.\n"
"   Ifway othbay areway otnay ecifiedspay, emoveray allway wrappersfay."

#: src/code/fwrappers.lisp
msgid ""
"Update the funcallable instance function of fwrapper F from its\n"
"   constructor."
msgstr ""
"Updateway ethay uncallablefay instanceway unctionfay ofway wrapperfay F "
"omfray itsway\n"
"   onstructorcay."

#: src/code/fwrappers.lisp
msgid ""
"Update fwrapper function definitions of FUNCTION-NAME.\n"
"   If TYPE is supplied, update fwrappers whose type is equal to TYPE.\n"
"   If TEST is supplied, update fwrappers satisfying TEST."
msgstr ""
"Updateway wrapperfay unctionfay efinitionsday ofway FUNCTION-NAME.\n"
"   Ifway TYPE isway uppliedsay, updateway wrappersfay osewhay ypetay isway "
"equalway otay TYPE.\n"
"   Ifway TEST isway uppliedsay, updateway wrappersfay atisfyingsay TEST."

#: src/code/fwrappers.lisp
msgid ""
"Find an fwrapper of FUNCTION-NAME.\n"
"   If TYPE is supplied, find an fwrapper whose type is equal to TYPE.\n"
"   If TEST is supplied, find an fwrapper satisfying TEST."
msgstr ""
"Indfay anway wrapperfay ofway FUNCTION-NAME.\n"
"   Ifway TYPE isway uppliedsay, indfay anway wrapperfay osewhay ypetay isway "
"equalway otay TYPE.\n"
"   Ifway TEST isway uppliedsay, indfay anway wrapperfay atisfyingsay TEST."

#: src/code/fwrappers.lisp
msgid ""
"Like DEFUN, but define a function wrapper.\n"
"   In BODY, the symbol FWRAPPERS:FWRAPPERS refers to the currently\n"
"   executing fwrapper.  FWRAPPERS:CALL-NEXT-FUNCTION can be used\n"
"   in BODY to call the next fwrapper or the primary function.  When\n"
"   called with no arguments, CALL-NEXT-FUNCTION invokes the next\n"
"   function with the original args to the fwrapper, otherwise it\n"
"   invokes the next function with the supplied args."
msgstr ""
"Ikelay DEFUN, utbay efineday away unctionfay apperwray.\n"
"   Inway BODY, ethay ymbolsay FWRAPPERS:FWRAPPERS efersray otay ethay "
"urrentlycay\n"
"   executingway wrapperfay.  FWRAPPERS:CALL-NEXT-FUNCTION ancay ebay "
"usedway\n"
"   inway BODY otay allcay ethay extnay wrapperfay orway ethay imarypray "
"unctionfay.  Enwhay\n"
"   alledcay ithway onay argumentsway, CALL-NEXT-FUNCTION invokesway ethay "
"extnay\n"
"   unctionfay ithway ethay originalway argsway otay ethay wrapperfay, "
"otherwiseway itway\n"
"   invokesway ethay extnay unctionfay ithway ethay uppliedsay argsway."

#: src/code/fwrappers.lisp
msgid "Return the expansion of a DEFINE-FWRAPPER."
msgstr "Eturnray ethay expansionway ofway away DEFINE-FWRAPPER."

#: src/code/fwrappers.lisp
msgid ""
"First value is true if BODY refers to any of the variables in\n"
"     OPTIONALS, KEYS or REST, which are what KERNEL:PARSE-LAMBDA-LIST\n"
"     returns.  Second value is true if BODY refers to REST."
msgstr ""
"Irstfay aluevay isway uetray ifway BODY efersray otay anyway ofway ethay "
"ariablesvay inway\n"
"     OPTIONALS, KEYS orway REST, ichwhay areway atwhay KERNEL:PARSE-LAMBDA-"
"LIST\n"
"     eturnsray.  Econdsay aluevay isway uetray ifway BODY efersray otay REST."

#: src/code/fwrappers.lisp
msgid "&MORE not supported in fwrapper lambda lists"
msgstr "&MORE otnay upportedsay inway wrapperfay ambdalay istslay"

#: src/code/fwrappers.lisp
msgid "Fwrapper for old-style encapsulations."
msgstr "Wrapperfay orfay oldway-tylesay encapsulationsway."

#: src/code/fwrappers.lisp
msgid "This function is deprecated; use fwrappers instead."
msgstr "Isthay unctionfay isway eprecatedday; useway wrappersfay insteadway."

#: src/code/fdefinition.lisp
msgid ""
"Define (NAME ...) to be a valid function name whose syntax is checked\n"
"  by BODY.  In BODY, VAR is bound to an actual function name of the\n"
"  form (NAME ...) to check.  BODY should return two values.\n"
"  First value true means the function name is valid.  Second value\n"
"  is the name, a symbol, of the function for use in the BLOCK of DEFUNs\n"
"  and in similar situations."
msgstr ""
"Efineday (NAME ...) otay ebay away alidvay unctionfay amenay osewhay "
"yntaxsay isway eckedchay\n"
"  ybay BODY.  Inway BODY, VAR isway oundbay otay anway actualway unctionfay "
"amenay ofway ethay\n"
"  ormfay (NAME ...) otay eckchay.  BODY ouldshay eturnray wotay aluesvay.\n"
"  Irstfay aluevay uetray eansmay ethay unctionfay amenay isway alidvay.  "
"Econdsay aluevay\n"
"  isway ethay amenay, away ymbolsay, ofway ethay unctionfay orfay useway "
"inway ethay BLOCK ofway Efunsday\n"
"  andway inway imilarsay ituationssay."

#: src/code/fdefinition.lisp
msgid ""
"First value is true if NAME has valid function name syntax.\n"
"  Second value is the name, a symbol, to use as a block name in DEFUNs\n"
"  and in similar situations."
msgstr ""
"Irstfay aluevay isway uetray ifway NAME ashay alidvay unctionfay amenay "
"yntaxsay.\n"
"  Econdsay aluevay isway ethay amenay, away ymbolsay, otay useway asway away "
"ockblay amenay inway Efunsday\n"
"  andway inway imilarsay ituationssay."

#: src/code/fdefinition.lisp
msgid ""
"Return the fdefn object for NAME.  If it doesn't already exist and CREATE\n"
"   is non-NIL, create a new (unbound) one."
msgstr ""
"Eturnray ethay defnfay objectway orfay NAME.  Ifway itway oesnday't "
"alreadyway existway andway CREATE\n"
"   isway onnay-NIL, eatecray away ewnay (unboundway) oneway."

#: src/code/fdefinition.lisp
msgid "Invalid function name: ~S"
msgstr "Invalidway unctionfay amenay: ~S"

#: src/code/fdefinition.lisp
msgid ""
"Return the FDEFN of NAME.  Signal an error if there is none\n"
"   or if it's function is null."
msgstr ""
"Eturnray ethay FDEFN ofway NAME.  Ignalsay anway errorway ifway erethay "
"isway onenay\n"
"   orway ifway itway's unctionfay isway ullnay."

#: src/code/fdefinition.lisp
msgid ""
"Returns the definition for name, including any encapsulations.  Settable\n"
"   with SETF."
msgstr ""
"Eturnsray ethay efinitionday orfay amenay, includingway anyway "
"encapsulationsway.  Ettablesay\n"
"   ithway SETF."

#: src/code/fdefinition.lisp
msgid ""
"Return FUNCTION-NAME's global function definition.\n"
"   If FUNCTION-NAME is fwrapped, return the primary function definition\n"
"   stored in the innermost fwrapper."
msgstr ""
"Eturnray FUNCTION-NAME's obalglay unctionfay efinitionday.\n"
"   Ifway FUNCTION-NAME isway wrappedfay, eturnray ethay imarypray unctionfay "
"efinitionday\n"
"   toredsay inway ethay innermostway wrapperfay."

#: src/code/fdefinition.lisp
msgid ""
"This holds functions that (SETF FDEFINITION) invokes before storing the\n"
"   new value.  These functions take the function name and the new value."
msgstr ""
"Isthay oldshay unctionsfay atthay (SETF FDEFINITION) invokesway eforebay "
"toringsay ethay\n"
"   ewnay aluevay.  Esethay unctionsfay aketay ethay unctionfay amenay andway "
"ethay ewnay aluevay."

#: src/code/fdefinition.lisp
msgid ""
"Set FUNCTION-NAME's global function definition to NEW-VALUE.\n"
"   If FUNCTION-NAME is fwrapped, set the primary function stored\n"
"   in the innermost fwrapper."
msgstr ""
"Etsay FUNCTION-NAME's obalglay unctionfay efinitionday otay NEW-VALUE.\n"
"   Ifway FUNCTION-NAME isway wrappedfay, etsay ethay imarypray unctionfay "
"toredsay\n"
"   inway ethay innermostway wrapperfay."

#: src/code/fdefinition.lisp
msgid "Return true if name has a global function definition."
msgstr ""
"Eturnray uetray ifway amenay ashay away obalglay unctionfay efinitionday."

#: src/code/fdefinition.lisp
msgid "Make Name have no global function definition."
msgstr "Akemay Amenay avehay onay obalglay unctionfay efinitionday."

#: src/code/error.lisp
msgid "&rest keyword is ~:[missing~;misplaced~]."
msgstr "&estray eywordkay isway ~:[issingmay~;isplacedmay~]."

#: src/code/error.lisp
msgid ""
"Return a list of all the currently active restarts ordered from most\n"
"   recently established to less recently established.  If Condition is\n"
"   specified, then only restarts associated with Condition (or with no\n"
"   condition) will be returned."
msgstr ""
"Eturnray away istlay ofway allway ethay urrentlycay activeway estartsray "
"orderedway omfray ostmay\n"
"   ecentlyray establishedway otay esslay ecentlyray establishedway.  Ifway "
"Onditioncay isway\n"
"   ecifiedspay, enthay onlyway estartsray associatedway ithway Onditioncay "
"(orway ithway onay\n"
"   onditioncay) illway ebay eturnedray."

#: src/code/error.lisp
msgid "Returns the name of the given restart object."
msgstr "Eturnsray ethay amenay ofway ethay ivengay estartray objectway."

#: src/code/error.lisp
msgid ""
"WITH-CONDITION-RESTARTS Condition-Form Restarts-Form Form*\n"
"   Evaluates the Forms in a dynamic environment where the restarts in the "
"list\n"
"   Restarts-Form are associated with the condition returned by Condition-"
"Form.\n"
"   This allows FIND-RESTART, etc., to recognize restarts that are not "
"related\n"
"   to the error currently being debugged.  See also RESTART-CASE."
msgstr ""
"WITH-CONDITION-RESTARTS Onditioncay-Ormfay Estartsray-Ormfay Orm*Fay\n"
"   Evaluatesway ethay Ormsfay inway away ynamicday environmentway erewhay "
"ethay estartsray inway ethay istlay\n"
"   Estartsray-Ormfay areway associatedway ithway ethay onditioncay "
"eturnedray ybay Onditioncay-Orfaym.\n"
"   Isthay allowsway FIND-RESTART, etcway., otay ecognizeray estartsray "
"atthay areway otnay elatedray\n"
"   otay ethay errorway urrentlycay eingbay ebuggedday.  Eesay alsoway "
"RESTART-CASE."

#: src/code/error.lisp
msgid ""
"Executes forms in a dynamic context where the given restart bindings are\n"
"   in effect.  Users probably want to use RESTART-CASE.  When clauses "
"contain\n"
"   the same restart name, FIND-RESTART will find the first such clause."
msgstr ""
"Executesway ormsfay inway away ynamicday ontextcay erewhay ethay ivengay "
"estartray indingsbay areway\n"
"   inway effectway.  Usersway obablypray antway otay useway RESTART-CASE.  "
"Enwhay ausesclay ontaincay\n"
"   ethay amesay estartray amenay, FIND-RESTART illway indfay ethay irstfay "
"uchsay auseclay."

#: src/code/error.lisp
msgid ""
"Unnamed restart does not have a ~\n"
"\t\t\t\t\treport function -- ~S"
msgstr ""
"Unnamedway estartray oesday otnay avehay away ~\n"
"\t\t\t\t\teportray unctionfay -- ~S"

#: src/code/error.lisp
msgid ""
"Returns the first restart named name.  If name is a restart, it is returned\n"
"   if it is currently active.  If no such restart is found, nil is "
"returned.\n"
"   It is an error to supply nil as a name.  If Condition is specified and "
"not\n"
"   NIL, then only restarts associated with that condition (or with no\n"
"   condition) will be returned."
msgstr ""
"Eturnsray ethay irstfay estartray amednay amenay.  Ifway amenay isway away "
"estartray, itway isway eturnedray\n"
"   ifway itway isway urrentlycay activeway.  Ifway onay uchsay estartray "
"isway oundfay, ilnay isway eturnedray.\n"
"   Itway isway anway errorway otay upplysay ilnay asway away amenay.  Ifway "
"Onditioncay isway ecifiedspay andway otnay\n"
"   NIL, enthay onlyway estartsray associatedway ithway atthay onditioncay "
"(orway ithway onay\n"
"   onditioncay) illway ebay eturnedray."

#: src/code/error.lisp
msgid ""
"Calls the function associated with the given restart, passing any given\n"
"   arguments.  If the argument restart is not a restart or a currently "
"active\n"
"   non-nil restart name, then a control-error is signalled."
msgstr ""
"Allscay ethay unctionfay associatedway ithway ethay ivengay estartray, "
"assingpay anyway ivengay\n"
"   argumentsway.  Ifway ethay argumentway estartray isway otnay away "
"estartray orway away urrentlycay activeway\n"
"   onnay-ilnay estartray amenay, enthay away ontrolcay-errorway isway "
"ignalledsay."

#: src/code/error.lisp
msgid "Restart ~S is not active."
msgstr "Estartray ~S isway otnay activeway."

#: src/code/error.lisp
msgid ""
"Calls the function associated with the given restart, prompting for any\n"
"   necessary arguments.  If the argument restart is not a restart or a\n"
"   currently active non-nil restart name, then a control-error is signalled."
msgstr ""
"Allscay ethay unctionfay associatedway ithway ethay ivengay estartray, "
"omptingpray orfay anyway\n"
"   ecessarynay argumentsway.  Ifway ethay argumentway estartray isway otnay "
"away estartray orway away\n"
"   urrentlycay activeway onnay-ilnay estartray amenay, enthay away ontrolcay-"
"errorway isway ignalledsay."

#: src/code/error.lisp
msgid ""
"(RESTART-CASE form\n"
"   {(case-name arg-list {keyword value}* body)}*)\n"
"   The form is evaluated in a dynamic context where the clauses have "
"special\n"
"   meanings as points to which control may be transferred (see INVOKE-"
"RESTART).\n"
"   When clauses contain the same case-name, FIND-RESTART will find the "
"first\n"
"   such clause.  If Expression is a call to SIGNAL, ERROR, CERROR or WARN "
"(or\n"
"   macroexpands into such) then the signalled condition will be associated "
"with\n"
"   the new restarts."
msgstr ""
"(RESTART-CASE ormfay\n"
"   {(asecay-amenay argway-istlay {eywordkay aluevay}* odybay)}*)\n"
"   Ethay ormfay isway evaluatedway inway away ynamicday ontextcay erewhay "
"ethay ausesclay avehay ecialspay\n"
"   eaningsmay asway ointspay otay ichwhay ontrolcay aymay ebay ansferredtray "
"(eesay INVOKE-RESTART).\n"
"   Enwhay ausesclay ontaincay ethay amesay asecay-amenay, FIND-RESTART "
"illway indfay ethay irstfay\n"
"   uchsay auseclay.  Ifway Expressionway isway away allcay otay SIGNAL, "
"ERROR, CERROR orway WARN (orway\n"
"   acroexpandsmay intoway uchsay) enthay ethay ignalledsay onditioncay "
"illway ebay associatedway ithway\n"
"   ethay ewnay estartsray."

#: src/code/error.lisp
msgid ""
"(WITH-SIMPLE-RESTART (restart-name format-string format-arguments)\n"
"   body)\n"
"   If restart-name is not invoked, then all values returned by forms are\n"
"   returned.  If control is transferred to this restart, it immediately\n"
"   returns the values nil and t."
msgstr ""
"(WITH-SIMPLE-RESTART (estartray-amenay ormatfay-ingstray ormatfay-"
"argumentsway)\n"
"   odybay)\n"
"   Ifway estartray-amenay isway otnay invokedway, enthay allway aluesvay "
"eturnedray ybay ormsfay areway\n"
"   eturnedray.  Ifway ontrolcay isway ansferredtray otay isthay estartray, "
"itway immediatelyway\n"
"   eturnsray ethay aluesvay ilnay andway t."

#: src/code/error.lisp
msgid "Condition ~S was signalled."
msgstr "Onditioncay ~S asway ignalledsay."

#: src/code/error.lisp
msgid "No REPORT?  Shouldn't happen!"
msgstr "Onay REPORT?  Ouldnshay't appenhay!"

#: src/code/error.lisp
msgid "Condition slot is not bound: ~S"
msgstr "Onditioncay otslay isway otnay oundbay: ~S"

#: src/code/error.lisp
msgid "Slot ~S of ~S missing."
msgstr "Otslay ~S ofway ~S issingmay."

#: src/code/error.lisp
msgid "Make an instance of a condition object using the specified initargs."
msgstr ""
"Akemay anway instanceway ofway away onditioncay objectway usingway ethay "
"ecifiedspay initargsway."

#: src/code/error.lisp
msgid "~S is not a condition class."
msgstr "~S isway otnay away onditioncay assclay."

#: src/code/error.lisp
msgid "Bad thing for class arg:~%  ~S"
msgstr "Adbay ingthay orfay assclay argway:~%  ~S"

#: src/code/error.lisp
msgid "Condition already names a declaration: ~S."
msgstr "Onditioncay alreadyway amesnay away eclarationday: ~S."

#: src/code/error.lisp
msgid ""
"DEFINE-CONDITION Name (Parent-Type*) (Slot-Spec*) Option*\n"
"   Define NAME as a condition type.  This new type inherits slots and its\n"
"   report function from the specified PARENT-TYPEs.  A slot spec is either\n"
"   a symbol denoting the name of the slot, or a list of the form:\n"
"\n"
"     (slot-name {slot-option value}*)\n"
"\n"
"   where slot-option is one of :READER, :WRITER, :ACCESSOR, :ALLOCATION,\n"
"   :INITARG, :INITFORM, :DOCUMENTATION, and :TYPE.\n"
"\n"
"   Each overall option is of the form\n"
"\n"
"     (option-name {value}*)\n"
"\n"
"   where option-name is one of :DEFAULT-INITARGS, :DOCUMENTATION,\n"
"   and :REPORT.\n"
"\n"
"   The :REPORT option is peculiar to DEFINE-CONDITION.  Its argument is "
"either\n"
"   a string or a two-argument lambda or function name.  If a function, the\n"
"   function is called with the condition and stream to report the "
"condition.\n"
"   If a string, the string is printed.\n"
"\n"
"   Condition types are classes, but (as allowed by ANSI and not as described "
"in\n"
"   CLtL2) are neither STANDARD-OBJECTs nor STRUCTURE-OBJECTs.  WITH-SLOTS "
"and\n"
"   SLOT-VALUE may not be used on condition objects."
msgstr ""
"DEFINE-CONDITION Amenay (Arentpay-Ype*Tay) (Otslay-Ec*Spay) Option*Way\n"
"   Efineday NAME asway away onditioncay ypetay.  Isthay ewnay ypetay "
"inheritsway otsslay andway itsway\n"
"   eportray unctionfay omfray ethay ecifiedspay PARENT-Ypestay.  Away otslay "
"ecspay isway eitherway\n"
"   away ymbolsay enotingday ethay amenay ofway ethay otslay, orway away "
"istlay ofway ethay ormfay:\n"
"\n"
"     (otslay-amenay {otslay-optionway aluevay}*)\n"
"\n"
"   erewhay otslay-optionway isway oneway ofway :READER, :WRITER, :ACCESSOR, :"
"ALLOCATION,\n"
"   :INITARG, :INITFORM, :DOCUMENTATION, andway :TYPE.\n"
"\n"
"   Eachway overallway optionway isway ofway ethay ormfay\n"
"\n"
"     (optionway-amenay {aluevay}*)\n"
"\n"
"   erewhay optionway-amenay isway oneway ofway :DEFAULT-INITARGS, :"
"DOCUMENTATION,\n"
"   andway :REPORT.\n"
"\n"
"   Ethay :REPORT optionway isway eculiarpay otay DEFINE-CONDITION.  Itsway "
"argumentway isway eitherway\n"
"   away ingstray orway away wotay-argumentway ambdalay orway unctionfay "
"amenay.  Ifway away unctionfay, ethay\n"
"   unctionfay isway alledcay ithway ethay onditioncay andway eamstray otay "
"eportray ethay onditioncay.\n"
"   Ifway away ingstray, ethay ingstray isway intedpray.\n"
"\n"
"   Onditioncay ypestay areway assesclay, utbay (asway allowedway ybay ANSI "
"andway otnay asway escribedday inway\n"
"   Tlclay2) areway eithernay STANDARD-Objectsway ornay STRUCTURE-"
"Objectsway.  WITH-SLOTS andway\n"
"   SLOT-VALUE aymay otnay ebay usedway onway onditioncay objectsway."

#: src/code/error.lisp
msgid "Keyword slot name indicates probable syntax error:~%  ~S"
msgstr ""
"Eywordkay otslay amenay indicatesway obablepray yntaxsay errorway:~%  ~S"

#: src/code/error.lisp
msgid "Malformed condition slot spec:~%  ~S."
msgstr "Alformedmay onditioncay otslay ecspay:~%  ~S."

#: src/code/error.lisp
msgid "More than one :INITFORM in:~%  ~S"
msgstr "Oremay anthay oneway :INITFORM inway:~%  ~S"

#: src/code/error.lisp
msgid "More than one slot :DOCUMENTATION in~%  ~s"
msgstr "Oremay anthay oneway otslay :DOCUMENTATION inway~%  ~s"

#: src/code/error.lisp
msgid "Slot :DOCUMENTATION is not a string in~%  ~s"
msgstr "Otslay :DOCUMENTATION isway otnay away ingstray inway~%  ~s"

#: src/code/error.lisp
msgid "Unknown slot option:~%  ~S"
msgstr "Unknownway otslay optionway:~%  ~S"

#: src/code/error.lisp
msgid "Bad option:~%  ~S"
msgstr "Adbay optionway:~%  ~S"

#: src/compiler/new-assem.lisp src/code/error.lisp
msgid "Unknown option: ~S"
msgstr "Unknownway optionway: ~S"

#: src/code/error.lisp
msgid ""
"(HANDLER-BIND ( {(type handler)}* )  body)\n"
"   Executes body in a dynamic context where the given handler bindings are\n"
"   in effect.  Each handler must take the condition being signalled as an\n"
"   argument.  The bindings are searched first to last in the event of a\n"
"   signalled condition."
msgstr ""
"(HANDLER-BIND ( {(ypetay andlerhay)}* )  odybay)\n"
"   Executesway odybay inway away ynamicday ontextcay erewhay ethay ivengay "
"andlerhay indingsbay areway\n"
"   inway effectway.  Eachway andlerhay ustmay aketay ethay onditioncay "
"eingbay ignalledsay asway anway\n"
"   argumentway.  Ethay indingsbay areway earchedsay irstfay otay astlay "
"inway ethay eventway ofway away\n"
"   ignalledsay onditioncay."

#: src/code/error.lisp
msgid "Ill-formed handler bindings."
msgstr "Illway-ormedfay andlerhay indingsbay."

#: src/code/error.lisp
msgid "~&~@<Error in function ~S:  ~3i~:_~?~:>"
msgstr "~&~@<Errorway inway unctionfay ~S:  ~3i~:_~?~:>"

#: src/code/error.lisp
msgid "Control stack overflow"
msgstr "Ontrolcay tacksay overflowway"

#: src/code/error.lisp
msgid "Heap (dynamic space) overflow"
msgstr "Eaphay (ynamicday acespay) overflowway"

#: src/code/error.lisp
msgid "~@<Type-error in ~S:  ~3i~:_~S is not of type ~S~:>"
msgstr "~@<Ypetay-errorway inway ~S:  ~3i~:_~S isway otnay ofway ypetay ~S~:>"

#: src/code/error.lisp
msgid ""
"Layout-invalid error in ~S:~@\n"
"\t\t     Type test of class ~S was passed obsolete instance:~%  ~S"
msgstr ""
"Ayoutlay-invalidway errorway inway ~S:~@\n"
"\t\t     Ypetay esttay ofway assclay ~S asway assedpay obsoleteway "
"instanceway:~%  ~S"

#: src/code/error.lisp
msgid "~@<~S fell through ~S expression.  ~:_Wanted one of ~:S.~:>"
msgstr ""
"~@<~S ellfay roughthay ~S expressionway.  ~:_Antedway oneway ofway ~:S.~:>"

#: src/code/error.lisp
msgid "End-of-File on ~S"
msgstr "Endway-ofway-Ilefay onway ~S"

#: src/code/error.lisp
msgid "~&~@<File-error in function ~S:  ~3i~:_~?~:>"
msgstr "~&~@<Ilefay-errorway inway unctionfay ~S:  ~3i~:_~?~:>"

#: src/code/error.lisp
msgid "Error in ~S:  the variable ~S is unbound."
msgstr "Errorway inway ~S:  ethay ariablevay ~S isway unboundway."

#: src/code/error.lisp
msgid "Error in ~S:  the function ~S is undefined."
msgstr "Errorway inway ~S:  ethay unctionfay ~S isway undefinedway."

#: src/code/error.lisp
msgid ""
"~@<Destructive function ~S called on ~\n"
"                         constant data.~@:>"
msgstr ""
"~@<Estructiveday unctionfay ~S alledcay onway ~\n"
"                         onstantcay ataday.~@:>"

#: src/code/error.lisp
msgid "Arithmetic error ~S signalled."
msgstr "Arithmeticway errorway ~S ignalledsay."

#: src/code/error.lisp
msgid "~%Operation was ~S, operands ~S."
msgstr "~%Operationway asway ~S, operandsway ~S."

#: src/code/error.lisp
msgid ""
"(HANDLER-CASE form\n"
"   { (type ([var]) body) }* )\n"
"   Executes form in a context with handlers established for the condition\n"
"   types.  A peculiar property allows type to be :no-error.  If such a "
"clause\n"
"   occurs, and form returns normally, all its values are passed to this "
"clause\n"
"   as if by MULTIPLE-VALUE-CALL.  The :no-error clause accepts more than "
"one\n"
"   var specification."
msgstr ""
"(HANDLER-CASE ormfay\n"
"   { (ypetay ([arvay]) odybay) }* )\n"
"   Executesway ormfay inway away ontextcay ithway andlershay establishedway "
"orfay ethay onditioncay\n"
"   ypestay.  Away eculiarpay opertypray allowsway ypetay otay ebay :onay-"
"errorway.  Ifway uchsay away auseclay\n"
"   occursway, andway ormfay eturnsray ormallynay, allway itsway aluesvay "
"areway assedpay otay isthay auseclay\n"
"   asway ifway ybay MULTIPLE-VALUE-CALL.  Ethay :onay-errorway auseclay "
"acceptsway oremay anthay oneway\n"
"   arvay ecificationspay."

#: src/code/error.lisp
msgid ""
"Executes forms after establishing a handler for all error conditions that\n"
"   returns from this form nil and the condition signalled."
msgstr ""
"Executesway ormsfay afterway establishingway away andlerhay orfay allway "
"errorway onditionscay atthay\n"
"   eturnsray omfray isthay ormfay ilnay andway ethay onditioncay ignalledsay."

#: src/code/error.lisp
msgid "Found an \"abort\" restart that failed to transfer control dynamically."
msgstr ""
"Oundfay anway \"abortway\" estartray atthay ailedfay otay ansfertray "
"ontrolcay ynamicallyday."

#: src/code/error.lisp
msgid ""
"Transfers control to a restart named abort, signalling a control-error if\n"
"   none exists."
msgstr ""
"Ansferstray ontrolcay otay away estartray amednay abortway, ignallingsay "
"away ontrolcay-errorway ifway\n"
"   onenay existsway."

#: src/code/error.lisp
msgid ""
"Transfers control to a restart named muffle-warning, signalling a\n"
"   control-error if none exists."
msgstr ""
"Ansferstray ontrolcay otay away estartray amednay ufflemay-arningway, "
"ignallingsay away\n"
"   ontrolcay-errorway ifway onenay existsway."

#: src/code/error.lisp
msgid ""
"Transfer control to a restart named continue, returning nil if none exists."
msgstr ""
"Ansfertray ontrolcay otay away estartray amednay ontinuecay, eturningray "
"ilnay ifway onenay existsway."

#: src/code/error.lisp
msgid ""
"Transfer control and value to a restart named store-value, returning nil if\n"
"   none exists."
msgstr ""
"Ansfertray ontrolcay andway aluevay otay away estartray amednay toresay-"
"aluevay, eturningray ilnay ifway\n"
"   onenay existsway."

#: src/code/error.lisp
msgid ""
"Transfer control and value to a restart named use-value, returning nil if\n"
"   none exists."
msgstr ""
"Ansfertray ontrolcay andway aluevay otay away estartray amednay useway-"
"aluevay, eturningray ilnay ifway\n"
"   onenay existsway."

#: src/code/typedefs.lisp
msgid "Forms that must happen before top level forms are run."
msgstr ""
"Ormsfay atthay ustmay appenhay eforebay optay evellay ormsfay areway unray."

#: src/code/typedefs.lisp
msgid "Can't cold-load-init other forms along with an eval-when."
msgstr ""
"Ancay't oldcay-oadlay-initway otherway ormsfay alongway ithway anway evalway-"
"enwhay."

#: src/code/typedefs.lisp
msgid "~S is not a defined type class."
msgstr "~S isway otnay away efinedday ypetay assclay."

#: src/code/typedefs.lisp
msgid "Missing type method for ~S"
msgstr "Issingmay ypetay ethodmay orfay ~S"

#: src/code/typedefs.lisp
msgid "~S is not a defined type class method."
msgstr "~S isway otnay away efinedday ypetay assclay ethodmay."

#: src/code/typedefs.lisp
msgid "DEFINE-TYPE-METHOD (Class-Name Method-Name+) Lambda-List Form*"
msgstr ""
"DEFINE-TYPE-METHOD (Assclay-Amenay Ethodmay-Amenay+) Ambdalay-Istlay Orm*Fay"

#: src/code/typedefs.lisp
msgid "DEFINE-TYPE-CLASS Name [Inherits]"
msgstr "DEFINE-TYPE-CLASS Amenay [Inheritsway]"

#: src/code/class.lisp
msgid "Layout for ~S~@[, Invalid=~S~]"
msgstr "Ayoutlay orfay ~S~@[, Invalidway=~S~]"

#: src/code/class.lisp
msgid "The inclusive upper bound on LAYOUT-HASH values."
msgstr "Ethay inclusiveway upperway oundbay onway LAYOUT-HASH aluesvay."

#: src/code/class.lisp
msgid ""
"Layout depth conflict: ~S~%  ~\n"
"\t\t        (~S collides at ~S with ~S)~%"
msgstr ""
"Ayoutlay epthday onflictcay: ~S~%  ~\n"
"\t\t        (~S ollidescay atway ~S ithway ~S)~%"

#: src/code/class.lisp
msgid "Can't use anonymous or undefined class as constant:~%  ~S"
msgstr ""
"Ancay't useway anonymousway orway undefinedway assclay asway onstantcay:~%  "
"~S"

#: src/code/class.lisp
msgid "~:[<anonymous>~;~:*~S~]~@[ (~(~A~))~]"
msgstr "~:[<anonymousway>~;~:*~S~]~@[ (~(~Away~))~]"

#: src/code/class.lisp
msgid ""
"Return the class with the specified Name.  If ERRORP is false, then NIL is\n"
"   returned when no such class exists."
msgstr ""
"Eturnray ethay assclay ithway ethay ecifiedspay Amenay.  Ifway ERRORP isway "
"alsefay, enthay NIL isway\n"
"   eturnedray enwhay onay uchsay assclay existsway."

#: src/code/class.lisp
msgid "Class not yet defined:~%  ~S"
msgstr "Assclay otnay etyay efinedday:~%  ~S"

#: src/code/class.lisp
msgid "Illegal to redefine standard type ~S."
msgstr "Illegalway otay edefineray tandardsay ypetay ~S."

#: src/code/class.lisp
msgid "Changing meta-class of ~S from ~S to ~S."
msgstr "Angingchay etamay-assclay ofway ~S omfray ~S otay ~S."

#: src/code/class.lisp
msgid "Redefining DEFTYPE type to be a class: ~S."
msgstr "Edefiningray DEFTYPE ypetay otay ebay away assclay: ~S."

#: src/code/class.lisp
msgid ""
"Return the class of the supplied object, which may be any Lisp object, not\n"
"   just a CLOS STANDARD-OBJECT."
msgstr ""
"Eturnray ethay assclay ofway ethay uppliedsay objectway, ichwhay aymay ebay "
"anyway Isplay objectway, otnay\n"
"   ustjay away CLOS STANDARD-OBJECT."

#: src/code/class.lisp
msgid "Modifing ~(~A~) class ~S; making it writable."
msgstr "Odifingmay ~(~Away~) assclay ~S; akingmay itway itablewray."

#: src/code/class.lisp
msgid "Subclassing sealed class ~S; unsealing it."
msgstr "Ubclassingsay ealedsay assclay ~S; unsealingway itway."

#: src/code/class.lisp
msgid ""
"Change in the inheritance structure of class ~S~%  ~\n"
"\t\t between the ~A definition and the ~A definition."
msgstr ""
"Angechay inway ethay inheritanceway ucturestray ofway assclay ~S~%  ~\n"
"\t\t etweenbay ethay ~Away efinitionday andway ethay ~Away efinitionday."

#: src/code/class.lisp
msgid ""
"Change in instance length of class ~S:~%  ~\n"
"\t\t   ~A length: ~D~%  ~\n"
"\t\t   ~A length: ~D"
msgstr ""
"Angechay inway instanceway engthlay ofway assclay ~S:~%  ~\n"
"\t\t   ~Away engthlay: ~D~%  ~\n"
"\t\t   ~Away engthlay: ~D"

#: src/code/class.lisp
msgid ""
"In class ~S:~%  ~\n"
"\t\t    ~:(~A~) definition of superclass ~S incompatible with~%  ~\n"
"\t\t    ~A definition."
msgstr ""
"Inway assclay ~S:~%  ~\n"
"\t\t    ~:(~Away~) efinitionday ofway uperclasssay ~S incompatibleway "
"ithway~%  ~\n"
"\t\t    ~Away efinitionday."

#: src/code/class.lisp
msgid ""
"Change in superclasses of class ~S:~%  ~\n"
"\t\t  ~A superclasses: ~S~%  ~\n"
"\t\t  ~A superclasses: ~S"
msgstr ""
"Angechay inway uperclassessay ofway assclay ~S:~%  ~\n"
"\t\t  ~Away uperclassessay: ~S~%  ~\n"
"\t\t  ~Away uperclassessay: ~S"

#: src/code/class.lisp
msgid ""
"Loading a reference to class ~S when the compile~\n"
"\t\t       ~%  time definition was incompatible with the current ~\n"
"\t\t       one."
msgstr ""
"Oadinglay away eferenceray otay assclay ~S enwhay ethay ompilecay~\n"
"\t\t       ~%  imetay efinitionday asway incompatibleway ithway ethay "
"urrentcay ~\n"
"\t\t       oneway."

#: src/code/class.lisp
msgid "Invalidate current definition."
msgstr "Invalidateway urrentcay efinitionday."

#: src/code/class.lisp
msgid "Smash current layout, preserving old code."
msgstr "Mashsay urrentcay ayoutlay, eservingpray oldway odecay."

#: src/code/class.lisp
msgid "Ignore the incompatibility, leave class alone."
msgstr "Ignoreway ethay incompatibilityway, eavelay assclay aloneway."

#: src/code/class.lisp
msgid "New definition of ~S must be loaded eventually."
msgstr "Ewnay efinitionday ofway ~S ustmay ebay oadedlay eventuallyway."

#: src/code/class.lisp
msgid ""
"Any old ~S instances will be in a bad way.~@\n"
"\t\t      I hope you know what you're doing..."
msgstr ""
"Anyway oldway ~S instancesway illway ebay inway away adbay ayway.~@\n"
"\t\t      Iway opehay ouyay nowkay atwhay ouyay'eray oingday..."

#: src/code/class.lisp
msgid ""
"Assuming the current definition of ~S is correct, and~@\n"
"\t\t      that the loaded code doesn't care about the ~\n"
"\t\t      incompatibility."
msgstr ""
"Assumingway ethay urrentcay efinitionday ofway ~S isway orrectcay, andway~@\n"
"\t\t      atthay ethay oadedlay odecay oesnday't arecay aboutway ethay ~\n"
"\t\t      incompatibilityway."

#: src/code/class.lisp
msgid "Topological sort failed due to constraint on ~S."
msgstr "Opologicaltay ortsay ailedfay ueday otay onstraintcay onway ~S."

#: src/code/class.lisp
msgid "Something strange with forward layout for ~S:~%  ~S"
msgstr "Omethingsay angestray ithway orwardfay ayoutlay orfay ~S:~%  ~S"

#: src/code/type.lisp
msgid ""
"*Use-Implementation-Types* is a semi-public flag which determines how\n"
"   restrictive we are in determining type membership.  If two types are the\n"
"   same in the implementation, then we will consider them them the same "
"when\n"
"   this switch is on.  When it is off, we try to be as restrictive as the\n"
"   language allows, allowing us to detect more errors.  Currently, this "
"only\n"
"   affects array types."
msgstr ""
"*Use-Implementation-Types* isway away emisay-ublicpay agflay ichwhay "
"eterminesday owhay\n"
"   estrictiveray eway areway inway eterminingday ypetay embershipmay.  Ifway "
"wotay ypestay areway ethay\n"
"   amesay inway ethay implementationway, enthay eway illway onsidercay "
"emthay emthay ethay amesay enwhay\n"
"   isthay witchsay isway onway.  Enwhay itway isway offway, eway ytray otay "
"ebay asway estrictiveray asway ethay\n"
"   anguagelay allowsway, allowingway usway otay etectday oremay errorsway.  "
"Urrentlycay, isthay onlyway\n"
"   affectsway arrayway ypestay."

#: src/code/type.lisp
msgid ""
"The minimum length of either list argument for subsetp where a\n"
"  hashtable is used to speed up processing instead of using a basic\n"
"  list implementation.  This value was determined by experimentation."
msgstr ""

#: src/code/type.lisp
msgid "Subtypep is illegal on this type:~%  ~S"
msgstr "Ubtypepsay isway illegalway onway isthay ypetay:~%  ~S"

#: src/code/type.lisp
msgid "&Aux in a FUNCTION or VALUES type: ~S."
msgstr "&Auxway inway away FUNCTION orway VALUES ypetay: ~S."

#: src/code/type.lisp
msgid "Keyword type description is not a two-list: ~S."
msgstr "Eywordkay ypetay escriptionday isway otnay away wotay-istlay: ~S."

#: src/code/type.lisp
msgid "Repeated keyword ~S in lambda list: ~S."
msgstr "Epeatedray eywordkay ~S inway ambdalay istlay: ~S."

#: src/code/type.lisp
msgid ""
"The maximum length of a union of integer types before we take a\n"
"  short cut and return a simpler union."
msgstr ""
"Ethay aximummay engthlay ofway away unionway ofway integerway ypestay "
"eforebay eway aketay away\n"
"  ortshay utcay andway eturnray away implersay unionway."

#: src/code/type.lisp
msgid "Bad thing to be a type specifier: ~S."
msgstr "Adbay ingthay otay ebay away ypetay ecifierspay: ~S."

#: src/code/type.lisp
msgid "VALUES type illegal in this context:~%  ~S"
msgstr "VALUES ypetay illegalway inway isthay ontextcay:~%  ~S"

#: src/code/type.lisp
msgid "Bad N specified for MOD type specifier: ~S."
msgstr "Adbay N ecifiedspay orfay MOD ypetay ecifierspay: ~S."

#: src/code/type.lisp
msgid "Bad size specified for SIGNED-BYTE type specifier: ~S."
msgstr "Adbay izesay ecifiedspay orfay SIGNED-BYTE ypetay ecifierspay: ~S."

#: src/code/type.lisp
msgid "Bad size specified for UNSIGNED-BYTE type specifier: ~S."
msgstr "Adbay izesay ecifiedspay orfay UNSIGNED-BYTE ypetay ecifierspay: ~S."

#: src/code/type.lisp
msgid "Bad float format: ~S."
msgstr "Adbay oatflay ormatfay: ~S."

#: src/code/type.lisp
msgid "Arrays can't have a negative number of dimensions: ~D."
msgstr ""
"Arraysway ancay't avehay away egativenay umbernay ofway imensionsday: ~D."

#: src/code/type.lisp
msgid "Array type has too many dimensions: ~S."
msgstr "Arrayway ypetay ashay ootay anymay imensionsday: ~S."

#: src/code/type.lisp
msgid "Bad dimension in array type: ~S."
msgstr "Adbay imensionday inway arrayway ypetay: ~S."

#: src/code/type.lisp
msgid "Array dimensions is not a list, integer or *:~%  ~S"
msgstr ""
"Arrayway imensionsday isway otnay away istlay, integerway orway *:~%  ~S"

#: src/code/type.lisp
msgid "Type of characters that aren't base-char's.  None in CMU CL."
msgstr ""
"Ypetay ofway aracterschay atthay arenway't asebay-archay's.  Onenay inway "
"CMU CL."

#: src/code/type.lisp
msgid "Type corresponding to the charaters required by the standard."
msgstr ""
"Ypetay orrespondingcay otay ethay araterschay equiredray ybay ethay "
"tandardsay."

#: src/code/type.lisp
msgid "Type for any keyword symbol."
msgstr "Ypetay orfay anyway eywordkay ymbolsay."

#: src/code/type.lisp
msgid "&KEY or &ALLOW-OTHER-KEYS in values type: ~s"
msgstr "&KEY orway &ALLOW-OTHER-KEYS inway aluesvay ypetay: ~s"

#: src/code/type.lisp
msgid "The SATISFIES predicate name is not a symbol: ~S"
msgstr "Ethay SATISFIES edicatepray amenay isway otnay away ymbolsay: ~S"

#: src/code/type.lisp
msgid "Weird CONS type ~S"
msgstr "Eirdway CONS ypetay ~S"

#: src/code/type.lisp
msgid "The component type for COMPLEX is not numeric: ~S"
msgstr "Ethay omponentcay ypetay orfay COMPLEX isway otnay umericnay: ~S"

#: src/code/type.lisp
msgid "The component type for COMPLEX is not real: ~S"
msgstr "Ethay omponentcay ypetay orfay COMPLEX isway otnay ealray: ~S"

#: src/code/type.lisp
msgid ""
"The component type for COMPLEX (EQL X) ~\n"
"                                    is complex: ~S"
msgstr ""
"Ethay omponentcay ypetay orfay COMPLEX (EQL X) ~\n"
"                                    isway omplexcay: ~S"

#: src/code/type.lisp
msgid ""
"~@<(known bug #145): The type ~S is too hairy to be \n"
"                         used for a COMPLEX component.~:@>"
msgstr ""
"~@<(nownkay ugbay #145): Ethay ypetay ~S isway ootay airyhay otay ebay \n"
"                         usedway orfay away COMPLEX omponentcay.~:@>"

#: src/code/type.lisp
msgid "Bound is not *, a ~A or a list of a ~A: ~S"
msgstr ""
"Oundbay isway otnay *, away ~Away orway away istlay ofway away ~Away: ~S"

#: src/compiler/generic/vm-type.lisp
msgid "~S isn't an integer type?"
msgstr "~S isnway't anway integerway ypetay?"

#: src/code/pred.lisp
msgid "Return T if OBJECT is an array-header-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway anway arrayway-eaderhay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is an arrayp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway anway arraypway andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is an atom and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway anway atomway andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a base-char-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away asebay-archay-p andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a bignump and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away ignumpbay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a bit-vector-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away itbay-ectorvay-p andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a characterp and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away aracterpchay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a code-component-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away odecay-omponentcay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a consp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away onspcay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a compiled-function-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away ompiledcay-unctionfay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complexp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away omplexpcay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complex-double-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away omplexcay-oubleday-oatflay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complex-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away omplexcay-oatflay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a complex-double-double-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away omplexcay-oubleday-oubleday-oatflay-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complex-rational-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away omplexcay-ationalray-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complex-single-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away omplexcay-inglesay-oatflay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a double-double-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away oubleday-oubleday-oatflay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a double-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away oubleday-oatflay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a fdefn-p and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away defnfay-p andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a fixnump and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away ixnumpfay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a floatp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away oatpflay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a functionp and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away unctionpfay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is an integerp and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway anway integerpway andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a listp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away istplay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a long-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away onglay-oatflay-p andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a lra-p and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away ralay-p andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a not and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away otnay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a null and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away ullnay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a numberp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away umberpnay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a rationalp and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away ationalpray andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a ratiop and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away atiopray andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a realp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away ealpray andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a scavenger-hook-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away avengerscay-ookhay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a short-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away ortshay-oatflay-p andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-array-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-bit-vector-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-itbay-ectorvay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-string-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-ingstray-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-vector-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-ectorvay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a single-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away inglesay-oatflay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a stringp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away ingpstray andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a %instancep and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away %instancepway andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a symbolp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away ymbolpsay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a system-area-pointer-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away ystemsay-areaway-ointerpay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a weak-pointer-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away eakway-ointerpay-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a vectorp and NIL otherwise."
msgstr "Eturnray T ifway OBJECT isway away ectorpvay andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is an unsigned-byte-32-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway anway unsignedway-ytebay-32-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a signed-byte-32-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away ignedsay-ytebay-32-p andway NIL "
"otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-2-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-unsignedway-ytebay-2-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-4-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-unsignedway-ytebay-4-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-8-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-unsignedway-ytebay-8-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-16-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-unsignedway-ytebay-16-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-32-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-unsignedway-ytebay-32-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-array-signed-byte-8-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-ignedsay-ytebay-8-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-signed-byte-16-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-ignedsay-ytebay-16-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-signed-byte-30-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-ignedsay-ytebay-30-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-signed-byte-32-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-ignedsay-ytebay-32-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-array-single-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-inglesay-oatflay-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-array-double-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-oubleday-oatflay-p "
"andway NIL otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-double-double-float-p and NIL otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-oubleday-oubleday-"
"oatflay-p andway NIL otherwiseway."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-complex-single-float-p and NIL "
"otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-omplexcay-inglesay-"
"oatflay-p andway NIL otherwiswaye."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-complex-double-float-p and NIL "
"otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-omplexcay-oubleday-"
"oatflay-p andway NIL otherwiswaye."

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-complex-double-double-float-p and NIL "
"otherwise."
msgstr ""
"Eturnray T ifway OBJECT isway away implesay-arrayway-omplexcay-oubleday-"
"oubleday-oatflay-p andway NIL otherwiseway."

#: src/code/pred.lisp
msgid "Return the type of OBJECT."
msgstr "Eturnray ethay ypetay ofway OBJECT."

#: src/code/pred.lisp
msgid ""
"Return the element type that will actually be used to implement an array\n"
"   with the specifier :ELEMENT-TYPE Spec."
msgstr ""
"Eturnray ethay elementway ypetay atthay illway actuallyway ebay usedway otay "
"implementway anway arrayway\n"
"   ithway ethay ecifierspay :ELEMENT-TYPE Ecspay."

#: src/code/pred.lisp
msgid ""
"Return two values indicating the relationship between type1 and type2:\n"
"  T and T: type1 definitely is a subtype of type2.\n"
"  NIL and T: type1 definitely is not a subtype of type2.\n"
"  NIL and NIL: who knows?"
msgstr ""
"Eturnray wotay aluesvay indicatingway ethay elationshipray etweenbay ypetay1 "
"andway ypetay2:\n"
"  T andway T: ypetay1 efinitelyday isway away ubtypesay ofway ypetay2.\n"
"  NIL andway T: ypetay1 efinitelyday isway otnay away ubtypesay ofway "
"ypetay2.\n"
"  NIL andway NIL: owhay nowskay?"

#: src/code/pred.lisp
msgid "Return T iff OBJECT is of type TYPE."
msgstr "Eturnray T iffway OBJECT isway ofway ypetay TYPE."

#: src/code/pred.lisp
msgid "~@<unknown element type in array type: ~2I~_~S~:>"
msgstr "~@<unknownway elementway ypetay inway arrayway ypetay: ~2Iway~_~S~:>"

#: src/code/pred.lisp
msgid "Unknown type specifier: ~S"
msgstr "Unknownway ypetay ecifierspay: ~S"

#: src/code/pred.lisp
msgid "Invalid type specifier: ~S"
msgstr "Invalidway ypetay ecifierspay: ~S"

#: src/code/pred.lisp
msgid "Function types are not a legal argument to TYPEP:~%  ~S"
msgstr ""
"Unctionfay ypestay areway otnay away egallay argumentway otay TYPEP:~%  ~S"

#: src/code/pred.lisp
msgid "Class has not yet been defined: ~S"
msgstr "Assclay ashay otnay etyay eenbay efinedday: ~S"

#: src/code/pred.lisp
msgid "TYPEP on obsolete object (was class ~S)."
msgstr "TYPEP onway obsoleteway objectway (asway assclay ~S)."

#: src/code/pred.lisp
msgid "Class is currently invalid: ~S"
msgstr "Assclay isway urrentlycay invalidway: ~S"

#: src/code/pred.lisp
msgid "Return T if OBJ1 and OBJ2 are the same object, otherwise NIL."
msgstr ""
"Eturnray T ifway OBJ1 andway OBJ2 areway ethay amesay objectway, "
"otherwiseway NIL."

#: src/code/pred.lisp
#, fuzzy
msgid ""
"Returns T if X and Y are EQL or if they are structured components\n"
"  whose elements are EQUAL.  Strings and bit-vectors are EQUAL if they\n"
"  are the same length and have identical components.  Other arrays\n"
"  must be EQ to be EQUAL."
msgstr ""
"Eturnsray T ifway X andway Y areway EQL orway ifway eythay areway "
"ucturedstray omponentscay\n"
"  osewhay elementsway areway EQUAL.  Ingsstray andway itbay-ectorsvay areway "
"EQUAL ifway eythay\n"
"  areway ethay amesay engthlay andway avehay indenticalway omponentscay.  "
"Otherway arraysway ustmay ebay\n"
"  EQ otay ebay EQUAL."

#: src/code/pred.lisp
msgid ""
"Just like EQUAL, but more liberal in several respects.\n"
"  Numbers may be of different types, as long as the values are identical\n"
"  after coercion.  Characters may differ in alphabetic case.  Vectors and\n"
"  arrays must have identical dimensions and EQUALP elements, but may differ\n"
"  in their type restriction."
msgstr ""
"Ustjay ikelay EQUAL, utbay oremay iberallay inway everalsay espectsray.\n"
"  Umbersnay aymay ebay ofway ifferentday ypestay, asway onglay asway ethay "
"aluesvay areway identicalway\n"
"  afterway oercioncay.  Aracterschay aymay ifferday inway alphabeticway "
"asecay.  Ectorsvay andway\n"
"  arraysway ustmay avehay identicalway imensionsday andway EQUALP "
"elementsway, utbay aymay ifferday\n"
"  inway eirthay ypetay estrictionray."

#: src/code/alieneval.lisp
msgid "No alien type class ~S"
msgstr "Onay alienway ypetay assclay ~S"

#: src/code/alieneval.lisp
msgid "No method ~S"
msgstr "Onay ethodmay ~S"

#: src/code/alieneval.lisp
msgid ""
"Parse the list structure TYPE as an alien type specifier and return\n"
"   the resultant alien-type structure."
msgstr ""
"Arsepay ethay istlay ucturestray TYPE asway anway alienway ypetay "
"ecifierspay andway eturnray\n"
"   ethay esultantray alienway-ypetay ucturestray."

#: src/code/alieneval.lisp
msgid "Unknown alien type: ~S"
msgstr "Unknownway alienway ypetay: ~S"

#: src/code/alieneval.lisp
msgid "No translator for primitive alien type ~S?"
msgstr "Onay anslatortray orfay imitivepray alienway ypetay ~S?"

#: src/code/alieneval.lisp
msgid "Definition missing for alien type ~S?"
msgstr "Efinitionday issingmay orfay alienway ypetay ~S?"

#: src/code/alieneval.lisp
msgid "Attempt to multiple define ~A ~S."
msgstr "Attemptway otay ultiplemay efineday ~Away ~S."

#: src/code/alieneval.lisp
msgid "Attempt to shadow definition of ~A ~S."
msgstr "Attemptway otay adowshay efinitionday ofway ~Away ~S."

#: src/code/alieneval.lisp
msgid ""
"Convert the alien-type structure TYPE back into a list specification of\n"
"   the type."
msgstr ""
"Onvertcay ethay alienway-ypetay ucturestray TYPE ackbay intoway away istlay "
"ecificationspay ofway\n"
"   ethay ypetay."

#: src/code/alieneval.lisp
msgid "Method ~S not defined for ~S"
msgstr "Ethodmay ~S otnay efinedday orfay ~S"

#: src/code/alieneval.lisp
msgid ""
"Define the alien type NAME to be equivalent to TYPE.  Name may be NIL for\n"
"   STRUCT and UNION types, in which case the name is taken from the type\n"
"   specifier."
msgstr ""
"Efineday ethay alienway ypetay NAME otay ebay equivalentway otay TYPE.  "
"Amenay aymay ebay NIL orfay\n"
"   STRUCT andway UNION ypestay, inway ichwhay asecay ethay amenay isway "
"akentay omfray ethay ypetay\n"
"   ecifierspay."

#: src/code/alieneval.lisp
msgid "Redefining ~A ~S to be:~%  ~S,~%was:~%  ~S"
msgstr "Edefiningray ~Away ~S otay ebay:~%  ~S,~%asway:~%  ~S"

#: src/code/alieneval.lisp
msgid "~S is a built-in alien type."
msgstr "~S isway away uiltbay-inway alienway ypetay."

#: src/code/alieneval.lisp
msgid "Redefining ~S to be:~%  ~S,~%was~%  ~S"
msgstr "Edefiningray ~S otay ebay:~%  ~S,~%asway~%  ~S"

#: src/code/alieneval.lisp
msgid "Return T iff TYPE1 and TYPE2 describe equivalent alien types."
msgstr ""
"Eturnray T iffway TYPE1 andway TYPE2 escribeday equivalentway alienway "
"ypestay."

#: src/code/alieneval.lisp
msgid ""
"Return T iff the alien type TYPE1 is a subtype of TYPE2.  Currently, the\n"
"   only supported subtype relationships are that any pointer type is a\n"
"   subtype of (* t), and any array type's first dimension will match \n"
"   (array <eltype> nil ...).  Otherwise, the two types have to be\n"
"   ALIEN-TYPE-=."
msgstr ""
"Eturnray T iffway ethay alienway ypetay TYPE1 isway away ubtypesay ofway "
"TYPE2.  Urrentlycay, ethay\n"
"   onlyway upportedsay ubtypesay elationshipsray areway atthay anyway "
"ointerpay ypetay isway away\n"
"   ubtypesay ofway (* t), andway anyway arrayway ypetay's irstfay "
"imensionday illway atchmay \n"
"   (arrayway <eltypeway> ilnay ...).  Otherwiseway, ethay wotay ypestay "
"avehay otay ebay\n"
"   ALIEN-TYPE-=."

#: src/code/alieneval.lisp
msgid "Return T iff OBJECT is an alien of type TYPE."
msgstr "Eturnray T iffway OBJECT isway anway alienway ofway ypetay TYPE."

#: src/code/alieneval.lisp
msgid "Cannot represent ~S typed aliens."
msgstr "Annotcay epresentray ~S ypedtay aliensway."

#: src/code/alieneval.lisp
msgid "Cannot pass aliens of type ~S as arguments to call-out"
msgstr ""
"Annotcay asspay aliensway ofway ypetay ~S asway argumentsway otay allcay-"
"outway"

#: src/code/alieneval.lisp
msgid "Cannot return aliens of type ~S from call-out"
msgstr "Annotcay eturnray aliensway ofway ypetay ~S omfray allcay-outway"

#: src/code/alieneval.lisp
msgid "Cannot extract ~D bit integers."
msgstr "Annotcay extractway ~D itbay integersway."

#: src/code/alieneval.lisp
msgid "Redefining alien enum ~S"
msgstr "Edefiningray alienway enumway ~S"

#: src/code/alieneval.lisp
msgid "Unknown enum type: ~S"
msgstr "Unknownway enumway ypetay: ~S"

#: src/code/alieneval.lisp
msgid "Empty enum type: ~S"
msgstr "Emptyway enumway ypetay: ~S"

#: src/code/alieneval.lisp
msgid "An enumeration must contain at least one element."
msgstr "Anway enumerationway ustmay ontaincay atway eastlay oneway elementway."

#: src/code/alieneval.lisp
msgid "Enumeration element ~S is not a keyword."
msgstr "Enumerationway elementway ~S isway otnay away eywordkay."

#: src/code/alieneval.lisp
msgid "Element value ~S is not an integer."
msgstr "Elementway aluevay ~S isway otnay anway integerway."

#: src/code/alieneval.lisp
msgid "Element value ~S used more than once."
msgstr "Elementway aluevay ~S usedway oremay anthay onceway."

#: src/code/alieneval.lisp
msgid "Enumeration element ~S used more than once."
msgstr "Enumerationway elementway ~S usedway oremay anthay onceway."

#: src/code/alieneval.lisp
msgid "Can't represent enums needing more than 32 bits."
msgstr "Ancay't epresentray enumsway eedingnay oremay anthay 32 itsbay."

#: src/code/alieneval.lisp
msgid "Cannot deposit aliens of type ~S (unknown size)."
msgstr "Annotcay epositday aliensway ofway ypetay ~S (unknownway izesay)."

#: src/code/alieneval.lisp
msgid "First dimension is not a non-negative fixnum or NIL: ~S"
msgstr ""
"Irstfay imensionday isway otnay away onnay-egativenay ixnumfay orway NIL: ~S"

#: src/code/alieneval.lisp
msgid "Dimension is not a non-negative fixnum: ~S"
msgstr "Imensionday isway otnay away onnay-egativenay ixnumfay: ~S"

#: src/pcl/env.lisp src/pcl/fixup.lisp src/pcl/methods.lisp src/pcl/cpl.lisp
#: src/pcl/seal.lisp src/pcl/dfun.lisp
#: src/pcl/method-slot-access-optimization.lisp src/pcl/boot.lisp
#: src/pcl/dlisp.lisp src/pcl/cache.lisp src/pcl/defclass.lisp src/pcl/low.lisp
#: src/compiler/disassem.lisp src/code/pathname.lisp src/code/pprint-loop.lisp
#: src/code/pprint.lisp src/code/bignum.lisp src/code/alieneval.lisp
msgid "Required argument missing"
msgstr "Equiredray argumentway issingmay"

#: src/compiler/aliencomp.lisp src/code/alieneval.lisp
msgid "Unknown size: ~S"
msgstr "Unknownway izesay: ~S"

#: src/code/alieneval.lisp
msgid "Unknown alignment: ~S"
msgstr "Unknownway alignmentway: ~S"

#: src/code/alieneval.lisp
msgid "A hash table used to detect cycles while comparing record types."
msgstr ""
"Away ashhay abletay usedway otay etectday yclescay ilewhay omparingcay "
"ecordray ypestay."

#: src/code/alieneval.lisp
msgid ""
"Test if TYPE1 and TYPE2 are in the *MATCH-HISTORY*.\n"
"If so return true; otherwise call ALTERNATIVE."
msgstr ""
"Esttay ifway TYPE1 andway TYPE2 areway inway ethay *MATCH-HISTORY*.\n"
"Ifway osay eturnray uetray; otherwiseway allcay ALTERNATIVE."

#: src/code/alieneval.lisp
msgid "Cannot use values types here."
msgstr "Annotcay useway aluesvay ypestay erehay."

#: src/code/alieneval.lisp
msgid "Badly formed alien name."
msgstr "Adlybay ormedfay alienway amenay."

#: src/code/alieneval.lisp
msgid ""
"Define NAME as an external alien variable of type TYPE.  NAME should be\n"
"   a list of a string holding the alien name and a symbol to use as the "
"Lisp\n"
"   name.  If NAME is just a symbol or string, then the other name is "
"guessed\n"
"   from the one supplied."
msgstr ""
"Efineday NAME asway anway externalway alienway ariablevay ofway ypetay "
"TYPE.  NAME ouldshay ebay\n"
"   away istlay ofway away ingstray oldinghay ethay alienway amenay andway "
"away ymbolsay otay useway asway ethay Isplay\n"
"   amenay.  Ifway NAME isway ustjay away ymbolsay orway ingstray, enthay "
"ethay otherway amenay isway uessedgay\n"
"   omfray ethay oneway uppliedsay."

#: src/code/alieneval.lisp
msgid ""
"Access the alien variable named NAME, assuming it is of type TYPE.  This\n"
"   is SETFable."
msgstr ""
"Accessway ethay alienway ariablevay amednay NAME, assumingway itway isway "
"ofway ypetay TYPE.  Isthay\n"
"   isway Etfablesay."

#: src/code/alieneval.lisp
msgid ""
"Establish some local alien variables.  Each BINDING is of the form:\n"
"     VAR TYPE [ ALLOCATION ] [ INITIAL-VALUE | EXTERNAL-NAME ]\n"
"   ALLOCATION should be one of:\n"
"     :LOCAL (the default)\n"
"       The alien is allocated on the stack, and has dynamic extent.\n"
"     :STATIC\n"
"       The alien is allocated on the heap, and has infinate extent.  The "
"alien\n"
"       is allocated at load time, so the same piece of memory is used each "
"time\n"
"       this form executes.\n"
"     :EXTERN\n"
"       No alien is allocated, but VAR is established as a local name for\n"
"       the external alien given by EXTERNAL-NAME."
msgstr ""
"Establishway omesay ocallay alienway ariablesvay.  Eachway BINDING isway "
"ofway ethay ormfay:\n"
"     VAR TYPE [ ALLOCATION ] [ INITIAL-VALUE | EXTERNAL-NAME ]\n"
"   ALLOCATION ouldshay ebay oneway ofway:\n"
"     :LOCAL (ethay efaultday)\n"
"       Ethay alienway isway allocatedway onway ethay tacksay, andway ashay "
"ynamicday extentway.\n"
"     :STATIC\n"
"       Ethay alienway isway allocatedway onway ethay eaphay, andway ashay "
"infinateway extentway.  Ethay alienway\n"
"       isway allocatedway atway oadlay imetay, osay ethay amesay iecepay "
"ofway emorymay isway usedway eachway imetay\n"
"       isthay ormfay executesway.\n"
"     :EXTERN\n"
"       Onay alienway isway allocatedway, utbay VAR isway establishedway "
"asway away ocallay amenay orfay\n"
"       ethay externalway alienway ivengay ybay EXTERNAL-NAME."

#: src/code/alieneval.lisp
msgid ""
"Return true if X (which must be an Alien pointer) is null, false otherwise."
msgstr ""
"Eturnray uetray ifway X (ichwhay ustmay ebay anway Alienway ointerpay) isway "
"ullnay, alsefay otherwiseway."

#: src/code/alieneval.lisp
msgid ""
"Convert the System-Area-Pointer SAP to an Alien of the specified Type (not\n"
"   evaluated.)  Type must be pointer-like."
msgstr ""
"Onvertcay ethay Ystemsay-Areaway-Ointerpay SAP otay anway Alienway ofway "
"ethay ecifiedspay Ypetay (otnay\n"
"   evaluatedway.)  Ypetay ustmay ebay ointerpay-ikelay."

#: src/code/alieneval.lisp
msgid "Cannot make aliens of type ~S out of SAPs"
msgstr "Annotcay akemay aliensway ofway ypetay ~S outway ofway Apssay"

#: src/code/alieneval.lisp
msgid "Return a System-Area-Pointer pointing to Alien's data."
msgstr ""
"Eturnray away Ystemsay-Areaway-Ointerpay ointingpay otay Alienway's ataday."

#: src/code/alieneval.lisp
msgid ""
"Allocate an alien of type TYPE and return an alien pointer to it.  If SIZE\n"
"   is supplied, how it is interpreted depends on TYPE.  If TYPE is an array\n"
"   type, SIZE is used as the first dimension for the allocated array.  If "
"TYPE\n"
"   is not an array, then SIZE is the number of elements to allocate.  The\n"
"   memory is allocated using ``malloc'', so it can be passed to foreign\n"
"   functions which use ``free''."
msgstr ""
"Allocateway anway alienway ofway ypetay TYPE andway eturnray anway alienway "
"ointerpay otay itway.  Ifway SIZE\n"
"   isway uppliedsay, owhay itway isway interpretedway ependsday onway TYPE.  "
"Ifway TYPE isway anway arrayway\n"
"   ypetay, SIZE isway usedway asway ethay irstfay imensionday orfay ethay "
"allocatedway arrayway.  Ifway TYPE\n"
"   isway otnay anway arrayway, enthay SIZE isway ethay umbernay ofway "
"elementsway otay allocateway.  Ethay\n"
"   emorymay isway allocatedway usingway ``allocmay'', osay itway ancay ebay "
"assedpay otay oreignfay\n"
"   unctionsfay ichwhay useway ``eefray''."

#: src/code/alieneval.lisp
msgid "Size of ~S unknown."
msgstr "Izesay ofway ~S unknownway."

#: src/code/alieneval.lisp
msgid "Alignment of ~S unknown."
msgstr "Alignmentway ofway ~S unknownway."

#: src/code/alieneval.lisp
msgid "Cannot override the size of zero-dimensional arrays."
msgstr ""
"Annotcay overrideway ethay izesay ofway erozay-imensionalday arraysway."

#: src/code/alieneval.lisp
msgid ""
"Dispose of the storage pointed to by ALIEN.  ALIEN must have been allocated\n"
"   by MAKE-ALIEN or ``malloc''."
msgstr ""
"Isposeday ofway ethay toragesay ointedpay otay ybay ALIEN.  ALIEN ustmay "
"avehay eenbay allocatedway\n"
"   ybay MAKE-ALIEN orway ``allocmay''."

#: src/code/alieneval.lisp
msgid "No slot named ~S in ~S"
msgstr "Onay otslay amednay ~S inway ~S"

#: src/code/alieneval.lisp
msgid ""
"Extract SLOT from the Alien STRUCT or UNION ALIEN.  May be set with SETF."
msgstr ""
"Extractway SLOT omfray ethay Alienway STRUCT orway UNION ALIEN.  Aymay ebay "
"etsay ithway SETF."

#: src/code/alieneval.lisp
msgid "Too many indices when derefing ~S: ~D"
msgstr "Ootay anymay indicesway enwhay erefingday ~S: ~D"

#: src/code/alieneval.lisp
msgid "Incorrect number of indices when derefing ~S: ~D"
msgstr "Incorrectway umbernay ofway indicesway enwhay erefingday ~S: ~D"

#: src/code/alieneval.lisp
msgid ""
"De-reference an Alien pointer or array.  If an array, the indices are used\n"
"   as the indices of the array element to access.  If a pointer, one index "
"can\n"
"   optionally be specified, giving the equivalent of C pointer arithmetic."
msgstr ""
"Eday-eferenceray anway Alienway ointerpay orway arrayway.  Ifway anway "
"arrayway, ethay indicesway areway usedway\n"
"   asway ethay indicesway ofway ethay arrayway elementway otay accessway.  "
"Ifway away ointerpay, oneway indexway ancay\n"
"   optionallyway ebay ecifiedspay, ivinggay ethay equivalentway ofway C "
"ointerpay arithmeticway."

#: src/code/alieneval.lisp
msgid "Something is wrong; local-alien-info not found: ~S"
msgstr "Omethingsay isway ongwray; ocallay-alienway-infoway otnay oundfay: ~S"

#: src/code/alieneval.lisp
msgid "~S isn't forced to memory.  Something went wrong."
msgstr "~S isnway't orcedfay otay emorymay.  Omethingsay entway ongwray."

#: src/code/alieneval.lisp
msgid ""
"Return an Alien pointer to the data addressed by Expr, which must be a call\n"
"   to SLOT or DEREF, or a reference to an Alien variable."
msgstr ""
"Eturnray anway Alienway ointerpay otay ethay ataday addressedway ybay "
"Exprway, ichwhay ustmay ebay away allcay\n"
"   otay SLOT orway DEREF, orway away eferenceray otay anway Alienway "
"ariablevay."

#: src/code/alieneval.lisp
msgid "~S is not a valid L-value"
msgstr "~S isway otnay away alidvay L-aluevay"

#: src/code/alieneval.lisp
msgid "Something is wrong, local-alien-info not found: ~S"
msgstr "Omethingsay isway ongwray, ocallay-alienway-infoway otnay oundfay: ~S"

#: src/code/alieneval.lisp
msgid ""
"Convert ALIEN to an Alien of the specified TYPE (not evaluated).  Both "
"types\n"
"   must be Alien array, pointer or function types."
msgstr ""
"Onvertcay ALIEN otay anway Alienway ofway ethay ecifiedspay TYPE (otnay "
"evaluatedway).  Othbay ypestay\n"
"   ustmay ebay Alienway arrayway, ointerpay orway unctionfay ypestay."

#: src/code/alieneval.lisp
msgid "~S cannot be cast."
msgstr "~S annotcay ebay astcay."

#: src/compiler/aliencomp.lisp src/code/alieneval.lisp
msgid "Cannot cast to alien type ~S"
msgstr "Annotcay astcay otay alienway ypetay ~S"

#: src/code/alieneval.lisp
msgid ""
"Return the size of the alien type TYPE.  UNITS specifies the units to\n"
"   use and can be either :BITS, :BYTES, or :WORDS."
msgstr ""
"Eturnray ethay izesay ofway ethay alienway ypetay TYPE.  UNITS ecifiesspay "
"ethay unitsway otay\n"
"   useway andway ancay ebay eitherway :BITS, :BYTES, orway :WORDS."

#: src/code/alieneval.lisp
msgid "Unknown size for alien type ~S."
msgstr "Unknownway izesay orfay alienway ypetay ~S."

#: src/code/alieneval.lisp
msgid ""
"Call the foreign function ALIEN with the specified arguments.  ALIEN's\n"
"   type specifies the argument and result types."
msgstr ""
"Allcay ethay oreignfay unctionfay ALIEN ithway ethay ecifiedspay "
"argumentsway.  ALIEN's\n"
"   ypetay ecifiesspay ethay argumentway andway esultray ypestay."

#: src/code/alieneval.lisp
msgid "Wrong number of arguments for ~S~%Expected ~D, got ~D."
msgstr ""
"Ongwray umbernay ofway argumentsway orfay ~S~%Expectedway ~D, otgay ~D."

#: src/code/alieneval.lisp
msgid "~S is not an alien function."
msgstr "~S isway otnay anway alienway unctionfay."

#: src/code/alieneval.lisp
msgid ""
"Def-Alien-Routine Name Result-Type\n"
"                    {(Arg-Name Arg-Type [Style])}*\n"
"\n"
"  Define a foreign interface function for the routine with the specified "
"Name,\n"
"  which may be either a string, symbol or list of the form (string symbol).\n"
"  Return-Type is the Alien type for the function return value.  VOID may be\n"
"  used to specify a function with no result.\n"
"\n"
"  The remaining forms specify individual arguments that are passed to the\n"
"  routine.  Arg-Name is a symbol that names the argument, primarily for\n"
"  documentation.  Arg-Type is the C-Type of the argument.  Style specifies "
"the\n"
"  way that the argument is passed.\n"
"\n"
"  :IN\n"
"        An :In argument is simply passed by value.  The value to be passed "
"is\n"
"        obtained from argument(s) to the interface function.  No values are\n"
"        returned for :In arguments.  This is the default mode.\n"
"\n"
"  :OUT\n"
"        The specified argument type must be a pointer to a fixed sized "
"object.\n"
"        A pointer to a preallocated object is passed to the routine, and "
"the\n"
"        the object is accessed on return, with the value being returned "
"from\n"
"        the interface function.  :OUT and :IN-OUT cannot be used with "
"pointers\n"
"        to arrays, records or functions.\n"
"\n"
"  :COPY\n"
"        Similar to :IN, except that the argument values are stored in on\n"
"        the stack, and a pointer to the object is passed instead of\n"
"        the values themselves.\n"
"\n"
"  :IN-OUT\n"
"        A combination of :OUT and :COPY.  A pointer to the argument is "
"passed,\n"
"        with the object being initialized from the supplied argument and\n"
"        the return value being determined by accessing the object on return."
msgstr ""
"Efday-Alienway-Outineray Amenay Esultray-Ypetay\n"
"                    {(Argway-Amenay Argway-Ypetay [Tylesay])}*\n"
"\n"
"  Efineday away oreignfay interfaceway unctionfay orfay ethay outineray "
"ithway ethay ecifiedspay Amenay,\n"
"  ichwhay aymay ebay eitherway away ingstray, ymbolsay orway istlay ofway "
"ethay ormfay (ingstray ymbolsay).\n"
"  Eturnray-Ypetay isway ethay Alienway ypetay orfay ethay unctionfay "
"eturnray aluevay.  VOID aymay ebay\n"
"  usedway otay ecifyspay away unctionfay ithway onay esultray.\n"
"\n"
"  Ethay emainingray ormsfay ecifyspay individualway argumentsway atthay "
"areway assedpay otay ethay\n"
"  outineray.  Argway-Amenay isway away ymbolsay atthay amesnay ethay "
"argumentway, imarilypray orfay\n"
"  ocumentationday.  Argway-Ypetay isway ethay C-Ypetay ofway ethay "
"argumentway.  Tylesay ecifiesspay ethay\n"
"  ayway atthay ethay argumentway isway assedpay.\n"
"\n"
"  :IN\n"
"        Anway :Inway argumentway isway implysay assedpay ybay aluevay.  "
"Ethay aluevay otay ebay assedpay isway\n"
"        obtainedway omfray argumentway(s) otay ethay interfaceway "
"unctionfay.  Onay aluesvay areway\n"
"        eturnedray orfay :Inway argumentsway.  Isthay isway ethay efaultday "
"odemay.\n"
"\n"
"  :OUT\n"
"        Ethay ecifiedspay argumentway ypetay ustmay ebay away ointerpay otay "
"away ixedfay izedsay objectway.\n"
"        Away ointerpay otay away eallocatedpray objectway isway assedpay "
"otay ethay outineray, andway ethay\n"
"        ethay objectway isway accessedway onway eturnray, ithway ethay "
"aluevay eingbay eturnedray omfray\n"
"        ethay interfaceway unctionfay.  :OUT andway :IN-OUT annotcay ebay "
"usedway ithway ointerspay\n"
"        otay arraysway, ecordsray orway unctionsfay.\n"
"\n"
"  :COPY\n"
"        Imilarsay otay :IN, exceptway atthay ethay argumentway aluesvay "
"areway toredsay inway onway\n"
"        ethay tacksay, andway away ointerpay otay ethay objectway isway "
"assedpay insteadway ofway\n"
"        ethay aluesvay emselvesthay.\n"
"\n"
"  :IN-OUT\n"
"        Away ombinationcay ofway :OUT andway :COPY.  Away ointerpay otay "
"ethay argumentway isway assedpay,\n"
"        ithway ethay objectway eingbay initializedway omfray ethay "
"uppliedsay argumentway andway\n"
"        ethay eturnray aluevay eingbay eterminedday ybay accessingway ethay "
"objectway onway eturnray."

#: src/code/alieneval.lisp
msgid "Bogus argument style ~S in ~S."
msgstr "Ogusbay argumentway tylesay ~S inway ~S."

#: src/code/alieneval.lisp
msgid "Can't use :out or :in-out on pointer-like type:~%  ~S"
msgstr ""
"Ancay't useway :outway orway :inway-outway onway ointerpay-ikelay ypetay:~%  "
"~S"

#: src/code/alien-callback.lisp
msgid "Vector of all callbacks."
msgstr "Ectorvay ofway allway allbackscay."

#: src/compiler/tn.lisp src/compiler/main.lisp src/code/describe.lisp
#: src/code/debug-int.lisp src/code/debug-info.lisp
#: src/code/foreign-linkage.lisp src/code/reader.lisp src/code/stream.lisp
#: src/code/hash-new.lisp src/code/array.lisp src/code/alien-callback.lisp
msgid "~S is not an array with a fill-pointer."
msgstr "~S isway otnay anway arrayway ithway away illfay-ointerpay."

#: src/code/alien-callback.lisp
msgid "Unable to mprotect ~S bytes (~S) at ~S (~S).  Callbacks may not work."
msgstr ""
"Unableway otay protectmay ~S ytesbay (~S) atway ~S (~S).  Allbackscay aymay "
"otnay orkway."

#: src/code/alien-callback.lisp
msgid "Return the trampoline pointer for the callback NAME."
msgstr "Eturnray ethay ampolinetray ointerpay orfay ethay allbackcay NAME."

#: src/code/alien-callback.lisp
msgid ""
"~\n"
"Attempt to redefine callback with incompatible return type.\n"
"   Old type was: ~A \n"
"    New type is: ~A"
msgstr ""
"~\n"
"Attemptway otay edefineray allbackcay ithway incompatibleway eturnray "
"ypetay.\n"
"   Oldway ypetay asway: ~Away \n"
"    Ewnay ypetay isway: ~Away"

#: src/code/alien-callback.lisp
msgid ""
"~\n"
"Create new trampoline (old trampoline calls old lisp function)."
msgstr ""
"~\n"
"Eatecray ewnay ampolinetray (oldway ampolinetray allscay oldway isplay "
"unctionfay)."

#: src/code/alien-callback.lisp
msgid "Unsupported argument type: ~A"
msgstr "Unsupportedway argumentway ypetay: ~Away"

#: src/code/alien-callback.lisp
msgid "Unsupported return type: ~A"
msgstr "Unsupportedway eturnray ypetay: ~Away"

#: src/code/alien-callback.lisp
msgid ""
"(defcallback NAME (RETURN-TYPE {(ARG-NAME ARG-TYPE)}*)\n"
"     {doc-string} {decls}* {FORM}*)\n"
"\n"
"Define a function which can be called by foreign code.  The pointer\n"
"returned by (callback NAME), when called by foreign code, invokes the\n"
"lisp function.  The lisp function expects alien arguments of the\n"
"specified ARG-TYPEs and returns an alien of type RETURN-TYPE.\n"
"\n"
"If (callback NAME) is already a callback function pointer, its value\n"
"is not changed (though it's arranged that an updated version of the\n"
"lisp callback function will be called).  This feature allows for\n"
"incremental redefinition of callback functions."
msgstr ""
"(efcallbackday NAME (RETURN-TYPE {(ARG-NAME ARG-TYPE)}*)\n"
"     {ocday-ingstray} {eclsday}* {FORM}*)\n"
"\n"
"Efineday away unctionfay ichwhay ancay ebay alledcay ybay oreignfay odecay.  "
"Ethay ointerpay\n"
"eturnedray ybay (allbackcay NAME), enwhay alledcay ybay oreignfay odecay, "
"invokesway ethay\n"
"isplay unctionfay.  Ethay isplay unctionfay expectsway alienway argumentsway "
"ofway ethay\n"
"ecifiedspay ARG-Ypestay andway eturnsray anway alienway ofway ypetay RETURN-"
"TYPE.\n"
"\n"
"Ifway (allbackcay NAME) isway alreadyway away allbackcay unctionfay "
"ointerpay, itsway aluevay\n"
"isway otnay angedchay (oughthay itway's arrangedway atthay anway updatedway "
"ersionvay ofway ethay\n"
"isplay allbackcay unctionfay illway ebay alledcay).  Isthay eaturefay "
"allowsway orfay\n"
"incrementalway edefinitionray ofway allbackcay unctionsfay."

#: src/code/sap.lisp
msgid "Return T iff the SAP X points to a smaller address then the SAP Y."
msgstr ""
"Eturnray T iffway ethay SAP X ointspay otay away mallersay addressway enthay "
"ethay SAP Y."

#: src/code/sap.lisp
msgid ""
"Return T iff the SAP X points to a smaller or the same address as\n"
"   the SAP Y."
msgstr ""
"Eturnray T iffway ethay SAP X ointspay otay away mallersay orway ethay "
"amesay addressway asway\n"
"   ethay SAP Y."

#: src/code/sap.lisp
msgid "Return T iff the SAP X points to the same address as the SAP Y."
msgstr ""
"Eturnray T iffway ethay SAP X ointspay otay ethay amesay addressway asway "
"ethay SAP Y."

#: src/code/sap.lisp
msgid ""
"Return T iff the SAP X points to a larger or the same address as\n"
"   the SAP Y."
msgstr ""
"Eturnray T iffway ethay SAP X ointspay otay away argerlay orway ethay amesay "
"addressway asway\n"
"   ethay SAP Y."

#: src/code/sap.lisp
msgid "Return T iff the SAP X points to a larger address then the SAP Y."
msgstr ""
"Eturnray T iffway ethay SAP X ointspay otay away argerlay addressway enthay "
"ethay SAP Y."

#: src/code/sap.lisp
msgid "Return a new sap OFFSET bytes from SAP."
msgstr "Eturnray away ewnay apsay OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Return the byte offset between SAP1 and SAP2."
msgstr "Eturnray ethay ytebay offsetway etweenbay SAP1 andway SAP2."

#: src/code/sap.lisp
msgid "Converts a System Area Pointer into an integer."
msgstr "Onvertscay away Ystemsay Areaway Ointerpay intoway anway integerway."

#: src/code/sap.lisp
msgid "Converts an integer into a System Area Pointer."
msgstr "Onvertscay anway integerway intoway away Ystemsay Areaway Ointerpay."

#: src/code/sap.lisp
msgid "Returns the 8-bit byte at OFFSET bytes from SAP."
msgstr "Eturnsray ethay 8-itbay ytebay atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the 16-bit word at OFFSET bytes from SAP."
msgstr "Eturnsray ethay 16-itbay ordway atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the 32-bit dualword at OFFSET bytes from SAP."
msgstr "Eturnsray ethay 32-itbay ualwordday atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the 64-bit quadword at OFFSET bytes from SAP."
msgstr "Eturnsray ethay 64-itbay adwordquay atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the 32-bit system-area-pointer at OFFSET bytes from SAP."
msgstr ""
"Eturnsray ethay 32-itbay ystemsay-areaway-ointerpay atway OFFSET ytesbay "
"omfray SAP."

#: src/code/sap.lisp
msgid "Returns the 32-bit single-float at OFFSET bytes from SAP."
msgstr ""
"Eturnsray ethay 32-itbay inglesay-oatflay atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the 64-bit double-float at OFFSET bytes from SAP."
msgstr ""
"Eturnsray ethay 64-itbay oubleday-oatflay atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the long-float at OFFSET bytes from SAP."
msgstr "Eturnsray ethay onglay-oatflay atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the signed 8-bit byte at OFFSET bytes from SAP."
msgstr ""
"Eturnsray ethay ignedsay 8-itbay ytebay atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the signed 16-bit word at OFFSET bytes from SAP."
msgstr ""
"Eturnsray ethay ignedsay 16-itbay ordway atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the signed 32-bit dualword at OFFSET bytes from SAP."
msgstr ""
"Eturnsray ethay ignedsay 32-itbay ualwordday atway OFFSET ytesbay omfray SAP."

#: src/code/sap.lisp
msgid "Returns the signed 64-bit quadword at OFFSET bytes from SAP."
msgstr ""
"Eturnsray ethay ignedsay 64-itbay adwordquay atway OFFSET ytesbay omfray SAP."

#: src/code/bit-bash.lisp
msgid "The number of bits to process at a time."
msgstr "Ethay umbernay ofway itsbay otay ocesspray atway away imetay."

#: src/code/bit-bash.lisp
msgid "The number of bytes to process at a time."
msgstr "Ethay umbernay ofway ytesbay otay ocesspray atway away imetay."

#: src/code/bit-bash.lisp
msgid "The maximum number of bits that can be dealt with during a single call."
msgstr ""
"Ethay aximummay umbernay ofway itsbay atthay ancay ebay ealtday ithway "
"uringday away inglesay allcay."

#: src/code/bit-bash.lisp
msgid ""
"Shift NUMBER by COUNT bits, adding zero bits at the ``end'' and removing\n"
"  bits from the ``start.''  On big-endian machines this is a left-shift and\n"
"  on little-endian machines this is a right-shift.  Note: only the low 5/6 "
"bits\n"
"  of count are significant."
msgstr ""
"Iftshay NUMBER ybay COUNT itsbay, addingway erozay itsbay atway ethay "
"``endway'' andway emovingray\n"
"  itsbay omfray ethay ``tartsay.''  Onway igbay-endianway achinesmay isthay "
"isway away eftlay-iftshay andway\n"
"  onway ittlelay-endianway achinesmay isthay isway away ightray-iftshay.  "
"Otenay: onlyway ethay owlay 5/6 itsbay\n"
"  ofway ountcay areway ignificantsay."

#: src/code/bit-bash.lisp
msgid ""
"Shift NUMBER by COUNT bits, adding zero bits at the ``start'' and removing\n"
"  bits from the ``end.''  On big-endian machines this is a right-shift and\n"
"  on little-endian machines this is a left-shift."
msgstr ""
"Iftshay NUMBER ybay COUNT itsbay, addingway erozay itsbay atway ethay "
"``tartsay'' andway emovingray\n"
"  itsbay omfray ethay ``endway.''  Onway igbay-endianway achinesmay isthay "
"isway away ightray-iftshay andway\n"
"  onway ittlelay-endianway achinesmay isthay isway away eftlay-iftshay."

#: src/code/bit-bash.lisp
msgid ""
"Produce a mask that contains 1's for the COUNT ``start'' bits and 0's for\n"
"  the remaining ``end'' bits.  Only the lower 5 bits of COUNT are "
"significant."
msgstr ""
"Oducepray away askmay atthay ontainscay 1's orfay ethay COUNT ``tartsay'' "
"itsbay andway 0's orfay\n"
"  ethay emainingray ``endway'' itsbay.  Onlyway ethay owerlay 5 itsbay ofway "
"COUNT areway ignificansayt."

#: src/code/bit-bash.lisp
msgid ""
"Produce a mask that contains 1's for the COUNT ``end'' bits and 0's for\n"
"  the remaining ``start'' bits.  Only the lower 5 bits of COUNT are\n"
"  significant."
msgstr ""
"Oducepray away askmay atthay ontainscay 1's orfay ethay COUNT ``endway'' "
"itsbay andway 0's orfay\n"
"  ethay emainingray ``tartsay'' itsbay.  Onlyway ethay owerlay 5 itsbay "
"ofway COUNT areway\n"
"  ignificantsay."

#: src/code/bit-bash.lisp
msgid "Align the SAP to a word boundry, and update the offset accordingly."
msgstr ""
"Alignway ethay SAP otay away ordway oundrybay, andway updateway ethay "
"offsetway accordinglyway."

#: src/code/bit-bash.lisp
msgid ""
"Fill DST with VALUE starting at DST-OFFSET and continuing for LENGTH bits."
msgstr ""
"Illfay DST ithway VALUE tartingsay atway DST-OFFSET andway ontinuingcay "
"orfay LENGTH itsbay."

#: src/code/byte-interp.lisp
msgid "This is the interpreter's evaluation stack."
msgstr "Isthay isway ethay interpreterway's evaluationway tacksay."

#: src/code/byte-interp.lisp
msgid "This is the next free element of the interpreter's evaluation stack."
msgstr ""
"Isthay isway ethay extnay eefray elementway ofway ethay interpreterway's "
"evaluationway tacksay."

#: src/code/byte-interp.lisp
msgid "Undefined XOP."
msgstr "Undefinedway XOP."

#: src/code/byte-interp.lisp
msgid "Unbound variable: ~S"
msgstr "Unboundway ariablevay: ~S"

#: src/code/byte-interp.lisp
msgid "Non-list argument to CAR: ~S"
msgstr "Onnay-istlay argumentway otay CAR: ~S"

#: src/code/byte-interp.lisp
msgid "Non-list argument to CDR: ~S"
msgstr "Onnay-istlay argumentway otay CDR: ~S"

#: src/code/byte-interp.lisp
msgid "Unknown inline function, id=~D"
msgstr "Unknownway inlineway unctionfay, idway=~D"

#: src/code/byte-interp.lisp
msgid "Wrong number of arguments."
msgstr "Ongwray umbernay ofway argumentsway."

#: src/code/byte-interp.lisp
msgid "Not enough arguments."
msgstr "Otnay enoughway argumentsway."

#: src/pcl/boot.lisp src/code/byte-interp.lisp
msgid "Too many arguments."
msgstr "Ootay anymay argumentsway."

#: src/pcl/combin.lisp src/code/interr.lisp src/code/byte-interp.lisp
msgid "Odd number of keyword arguments."
msgstr "Oddway umbernay ofway eywordkay argumentsway."

#: src/code/interr.lisp src/code/byte-interp.lisp
msgid "Unknown keyword: ~S"
msgstr "Unknownway eywordkay: ~S"

#: src/code/byte-interp.lisp
msgid "function-end breakpoints not supported."
msgstr "unctionfay-endway eakpointsbray otnay upportedsay."

#: src/code/array.lisp
msgid "The exclusive upper bound on the rank of an array."
msgstr ""
"Ethay exclusiveway upperway oundbay onway ethay ankray ofway anway arrayway."

#: src/code/array.lisp
msgid "The exclusive upper bound any given dimension of an array."
msgstr ""
"Ethay exclusiveway upperway oundbay anyway ivengay imensionday ofway anway "
"arrayway."

#: src/code/array.lisp
msgid "The exclusive upper bound on the total number of elements in an array."
msgstr ""
"Ethay exclusiveway upperway oundbay onway ethay otaltay umbernay ofway "
"elementsway inway anway arrayway."

#: src/code/array.lisp
msgid "Start ~D is greater than end ~D."
msgstr "Tartsay ~D isway eatergray anthay endway ~D."

#: src/code/array.lisp
msgid "End ~D is greater than total size ~D."
msgstr "Endway ~D isway eatergray anthay otaltay izesay ~D."

#: src/code/array.lisp
msgid ""
"List of weak-pointers to static vectors.  Needed for GCing static vectors"
msgstr ""
"Istlay ofway eakway-ointerspay otay taticsay ectorsvay.  Eedednay orfay "
"Cinggay taticsay ectorsvay"

#: src/code/array.lisp
msgid "Cannot make a static array of element type ~S"
msgstr "Annotcay akemay away taticsay arrayway ofway elementway ypetay ~S"

#: src/code/array.lisp
msgid "Failed to allocate space for static array of length ~S of type ~S"
msgstr ""
"Ailedfay otay allocateway acespay orfay taticsay arrayway ofway engthlay ~S "
"ofway ypetay ~S"

#: src/code/array.lisp
msgid ""
"Creates an array of the specified Dimensions and properties.  See the\n"
"  manual for details.\n"
"\n"
"  :Element-type\n"
"      The type of objects that the array can hold \n"
"  :Initial-element\n"
"      Each element of the array is initialized to this value, if supplied.\n"
"      If not supplied, 0 of the appropriate type is used.\n"
"  :Initial-contents\n"
"      The contents of the array are initialized to this.\n"
"  :Adjustable\n"
"      If non-Nil, make an expressly adjustable array.\n"
"  :Fill-pointer\n"
"      For one-dimensional array, set the fill-pointer to the given value.\n"
"      If T, use the actual length of the array.\n"
"  :Displaced-to\n"
"      Create an array that is displaced to the target array specified\n"
"      by :displaced-to.\n"
"  :Displaced-index-offset\n"
"      Index offset to the displaced array.  That is, index 0 of this array "
"is\n"
"      actually index displaced-index-offset of the target displaced array. \n"
"  :Allocation\n"
"      How to allocate the array.  If :MALLOC, a static, nonmovable array is\n"
"      created.  This array is created by calling malloc."
msgstr ""
"Eatescray anway arrayway ofway ethay ecifiedspay Imensionsday andway "
"opertiespray.  Eesay ethay\n"
"  anualmay orfay etailsday.\n"
"\n"
"  :Elementway-ypetay\n"
"      Ethay ypetay ofway objectsway atthay ethay arrayway ancay oldhay \n"
"  :Initialway-elementway\n"
"      Eachway elementway ofway ethay arrayway isway initializedway otay "
"isthay aluevay, ifway uppliedsay.\n"
"      Ifway otnay uppliedsay, 0 ofway ethay appropriateway ypetay isway "
"usedway.\n"
"  :Initialway-ontentscay\n"
"      Ethay ontentscay ofway ethay arrayway areway initializedway otay "
"isthay.\n"
"  :Adjustableway\n"
"      Ifway onnay-Ilnay, akemay anway expresslyway adjustableway arrayway.\n"
"  :Illfay-ointerpay\n"
"      Orfay oneway-imensionalday arrayway, etsay ethay illfay-ointerpay otay "
"ethay ivengay aluevay.\n"
"      Ifway T, useway ethay actualway engthlay ofway ethay arrayway.\n"
"  :Isplacedday-otay\n"
"      Eatecray anway arrayway atthay isway isplacedday otay ethay argettay "
"arrayway ecifiedspay\n"
"      ybay :isplacedday-otay.\n"
"  :Isplacedday-indexway-offsetway\n"
"      Indexway offsetway otay ethay isplacedday arrayway.  Atthay isway, "
"indexway 0 ofway isthay arrayway isway\n"
"      actuallyway indexway isplacedday-indexway-offsetway ofway ethay "
"argettay isplacedday arrayway. \n"
"  :Allocationway\n"
"      Owhay otay allocateway ethay arrayway.  Ifway :MALLOC, away taticsay, "
"onmovablenay arrayway isway\n"
"      eatedcray.  Isthay arrayway isway eatedcray ybay allingcay allocmay."

#: src/code/array.lisp
msgid "Can't specify :displaced-index-offset without :displaced-to"
msgstr ""
"Ancay't ecifyspay :isplacedday-indexway-offsetway ithoutway :isplacedday-otay"

#: src/code/array.lisp
msgid "Cannot make an adjustable static array"
msgstr "Annotcay akemay anway adjustableway taticsay arrayway"

#: src/code/array.lisp
msgid "Cannot make a displaced array static"
msgstr "Annotcay akemay away isplacedday arrayway taticsay"

#: src/code/array.lisp
msgid ""
"Cannot specify both :initial-element and ~\n"
"\t\t:initial-contents"
msgstr ""
"Annotcay ecifyspay othbay :initialway-elementway andway ~\n"
"\t\t:initialway-ontentscay"

#: src/code/array.lisp
msgid ""
"~D elements in the initial-contents, but the ~\n"
"\t\tvector length is ~D."
msgstr ""
"~D elementsway inway ethay initialway-ontentscay, utbay ethay ~\n"
"\t\tectorvay engthlay isway ~D."

#: src/code/array.lisp
msgid "Only vectors can have fill pointers."
msgstr "Onlyway ectorsvay ancay avehay illfay ointerspay."

#: src/code/array.lisp
msgid "Invalid fill-pointer ~D"
msgstr "Invalidway illfay-ointerpay ~D"

#: src/code/array.lisp
msgid ""
"Neither :initial-element nor :initial-contents ~\n"
"\t\t   can be specified along with :displaced-to"
msgstr ""
"Eithernay :initialway-elementway ornay :initialway-ontentscay ~\n"
"\t\t   ancay ebay ecifiedspay alongway ithway :isplacedday-otay"

#: src/code/array.lisp
msgid ""
"One can't displace an array of type ~S into ~\n"
"                           another of type ~S."
msgstr ""
"Oneway ancay't isplaceday anway arrayway ofway ypetay ~S intoway ~\n"
"                           anotherway ofway ypetay ~S."

#: src/code/array.lisp
msgid "~S doesn't have enough elements."
msgstr "~S oesnday't avehay enoughway elementsway."

#: src/code/array.lisp
msgid "If non-NIL, print some debugging information when GC'ing static arrays"
msgstr ""
"Ifway onnay-NIL, intpray omesay ebuggingday informationway enwhay GC'ingway "
"taticsay arraysway"

#: src/code/array.lisp
msgid "~&Freeing foreign vector at #x~X~%"
msgstr "~&Eeingfray oreignfay ectorvay atway #x~X~%"

#: src/code/array.lisp
msgid "Finalizing static vectors ~S~%"
msgstr "Inalizingfay taticsay ectorsvay ~S~%"

#: src/code/array.lisp
msgid "static vector ~A.  header = ~X~%"
msgstr "taticsay ectorvay ~Away.  eaderhay = ~X~%"

#: src/code/array.lisp
msgid "  static vector ~A in use~%"
msgstr "  taticsay ectorvay ~Away inway useway~%"

#: src/code/array.lisp
msgid "  Free static vector ~A~%"
msgstr "  Eefray taticsay ectorvay ~Away~%"

#: src/code/array.lisp
msgid ""
"Cannot supply both :initial-contents and :initial-element to\n"
"            either make-array or adjust-array."
msgstr ""
"Annotcay upplysay othbay :initialway-ontentscay andway :initialway-"
"elementway otay\n"
"            eitherway akemay-arrayway orway adjustway-arrayway."

#: src/code/array.lisp
msgid "~S cannot be used to initialize an array of type ~S."
msgstr ""
"~S annotcay ebay usedway otay initializeway anway arrayway ofway ypetay ~S."

#: src/code/array.lisp
msgid ""
"Malformed :initial-contents.  ~S is not a ~\n"
"\t\t\t                       sequence, but ~D more layer needed."
msgid_plural ""
"Malformed :initial-contents.  ~S is not a ~\n"
"\t\t\t                       sequence, but ~D more layers needed."
msgstr[0] ""
"Alformedmay :initialway-ontentscay.  ~S isway otnay away ~\n"
"\t\t\t                       equencesay, utbay ~D oremay ayerlay eedednay."
msgstr[1] ""
"Alformedmay :initialway-ontentscay.  ~S isway otnay away ~\n"
"\t\t\t                       equencesay, utbay ~D oremay ayerslay eedednay."

#: src/code/array.lisp
msgid ""
"Malformed :initial-contents.  Dimension of ~\n"
"\t\t\t        axis ~D is ~D, but ~S is ~D long."
msgstr ""
"Alformedmay :initialway-ontentscay.  Imensionday ofway ~\n"
"\t\t\t        axisway ~D isway ~D, utbay ~S isway ~D onglay."

#: src/code/array.lisp
msgid "Constructs a simple-vector from the given objects."
msgstr "Onstructscay away implesay-ectorvay omfray ethay ivengay objectsway."

#: src/code/array.lisp
msgid "Wrong number of subscripts, ~D, for array of rank ~D"
msgstr ""
"Ongwray umbernay ofway ubscriptssay, ~D, orfay arrayway ofway ankray ~D"

#: src/code/array.lisp
msgid "Invalid index ~D~[~;~:; on axis ~:*~D~] in ~S"
msgstr "Invalidway indexway ~D~[~;~:; onway axisway ~:*~D~] inway ~S"

#: src/code/array.lisp
msgid "Invalid index ~D in ~S"
msgstr "Invalidway indexway ~D inway ~S"

#: src/code/array.lisp
msgid "Returns T if the Subscipts are in bounds for the Array, Nil otherwise."
msgstr ""
"Eturnsray T ifway ethay Ubsciptssay areway inway oundsbay orfay ethay "
"Arrayway, Ilnay otherwiseway."

#: src/code/array.lisp
msgid "Returns the element of the Array specified by the Subscripts."
msgstr ""
"Eturnsray ethay elementway ofway ethay Arrayway ecifiedspay ybay ethay "
"Ubscriptssay."

#: src/code/array.lisp
msgid ""
"Returns the element of array corressponding to the row-major index.  This "
"is\n"
"   SETF'able."
msgstr ""
"Eturnsray ethay elementway ofway arrayway orresspondingcay otay ethay owray-"
"ajormay indexway.  Isthay isway\n"
"   SETF'ableway."

#: src/code/array.lisp
msgid "Returns the Index'th element of the given Simple-Vector."
msgstr ""
"Eturnsray ethay Indexway'thay elementway ofway ethay ivengay Implesay-"
"Ectorvay."

#: src/code/array.lisp
msgid "Returns the bit from the Bit-Array at the specified Subscripts."
msgstr ""
"Eturnsray ethay itbay omfray ethay Itbay-Arrayway atway ethay ecifiedspay "
"Ubscriptssay."

#: src/code/array.lisp
msgid "Returns the bit from the Simple-Bit-Array at the specified Subscripts."
msgstr ""
"Eturnsray ethay itbay omfray ethay Implesay-Itbay-Arrayway atway ethay "
"ecifiedspay Ubscriptssay."

#: src/code/array.lisp
msgid "Returns the type of the elements of the array"
msgstr "Eturnsray ethay ypetay ofway ethay elementsway ofway ethay arrayway"

#: src/code/array.lisp
msgid "Returns the number of dimensions of the Array."
msgstr "Eturnsray ethay umbernay ofway imensionsday ofway ethay Arrayway."

#: src/code/array.lisp
msgid "Returns length of dimension Axis-Number of the Array."
msgstr ""
"Eturnsray engthlay ofway imensionday Axisway-Umbernay ofway ethay Arrayway."

#: src/code/array.lisp
msgid "Vector axis is not zero: ~S"
msgstr "Ectorvay axisway isway otnay erozay: ~S"

#: src/code/array.lisp
msgid "~D is too big; ~S only has ~D dimension"
msgid_plural "~D is too big; ~S only has ~D dimensions"
msgstr[0] "~D isway ootay igbay; ~S onlyway ashay ~D imensionday"
msgstr[1] "~D isway ootay igbay; ~S onlyway ashay ~D imensionsday"

#: src/code/array.lisp
msgid "Returns a list whose elements are the dimensions of the array"
msgstr ""
"Eturnsray away istlay osewhay elementsway areway ethay imensionsday ofway "
"ethay arrayway"

#: src/code/array.lisp
msgid "Returns the total number of elements in the Array."
msgstr ""
"Eturnsray ethay otaltay umbernay ofway elementsway inway ethay Arrayway."

#: src/code/array.lisp
msgid ""
"Returns values of :displaced-to and :displaced-index-offset options to\n"
"   make-array, or the defaults nil and 0 if not a displaced array."
msgstr ""
"Eturnsray aluesvay ofway :isplacedday-otay andway :isplacedday-indexway-"
"offsetway optionsway otay\n"
"   akemay-arrayway, orway ethay efaultsday ilnay andway 0 ifway otnay away "
"isplacedday arrayway."

#: src/code/array.lisp
msgid ""
"Returns T if (adjust-array array...) would return an array identical\n"
"   to the argument, this happens for complex arrays."
msgstr ""
"Eturnsray T ifway (adjustway-arrayway arrayway...) ouldway eturnray anway "
"arrayway identicalway\n"
"   otay ethay argumentway, isthay appenshay orfay omplexcay arraysway."

#: src/code/array.lisp
msgid "Returns T if the given Array has a fill pointer, or Nil otherwise."
msgstr ""
"Eturnsray T ifway ethay ivengay Arrayway ashay away illfay ointerpay, orway "
"Ilnay otherwiseway."

#: src/code/array.lisp
msgid "Returns the Fill-Pointer of the given Vector."
msgstr "Eturnsray ethay Illfay-Ointerpay ofway ethay ivengay Ectorvay."

#: src/code/array.lisp
msgid "New fill pointer, ~S, is larger than the length of the vector."
msgstr ""
"Ewnay illfay ointerpay, ~S, isway argerlay anthay ethay engthlay ofway ethay "
"ectorvay."

#: src/code/array.lisp
msgid ""
"Attempts to set the element of Array designated by the fill pointer\n"
"   to New-El and increment fill pointer by one.  If the fill pointer is\n"
"   too large, Nil is returned, otherwise the index of the pushed element "
"is \n"
"   returned."
msgstr ""
"Attemptsway otay etsay ethay elementway ofway Arrayway esignatedday ybay "
"ethay illfay ointerpay\n"
"   otay Ewnay-Elway andway incrementway illfay ointerpay ybay oneway.  Ifway "
"ethay illfay ointerpay isway\n"
"   ootay argelay, Ilnay isway eturnedray, otherwiseway ethay indexway ofway "
"ethay ushedpay elementway isway \n"
"   eturnedray."

#: src/code/array.lisp
msgid ""
"Like Vector-Push except that if the fill pointer gets too large, the\n"
"   Array is extended rather than Nil being returned."
msgstr ""
"Ikelay Ectorvay-Ushpay exceptway atthay ifway ethay illfay ointerpay etsgay "
"ootay argelay, ethay\n"
"   Arrayway isway extendedway atherray anthay Ilnay eingbay eturnedray."

#: src/code/array.lisp
msgid ""
"Attempts to decrease the fill-pointer by 1 and return the element\n"
"   pointer to by the new fill pointer.  If the original value of the fill\n"
"   pointer is 0, an error occurs."
msgstr ""
"Attemptsway otay ecreaseday ethay illfay-ointerpay ybay 1 andway eturnray "
"ethay elementway\n"
"   ointerpay otay ybay ethay ewnay illfay ointerpay.  Ifway ethay "
"originalway aluevay ofway ethay illfay\n"
"   ointerpay isway 0, anway errorway occursway."

#: src/code/array.lisp
msgid "Nothing left to pop."
msgstr "Othingnay eftlay otay oppay."

#: src/code/array.lisp
msgid "Adjusts the Array's dimensions to the given Dimensions and stuff."
msgstr ""
"Adjustsway ethay Arrayway's imensionsday otay ethay ivengay Imensionsday "
"andway tuffsay."

#: src/code/array.lisp
msgid "Number of dimensions not equal to rank of array."
msgstr "Umbernay ofway imensionsday otnay equalway otay ankray ofway arrayway."

#: src/code/array.lisp
msgid "New element type, ~S, is incompatible with old."
msgstr "Ewnay elementway ypetay, ~S, isway incompatibleway ithway oldway."

#: src/code/array.lisp
msgid "Static arrays are not adjustable."
msgstr "Taticsay arraysway areway otnay adjustableway."

#: src/code/array.lisp
msgid "Multidimensional arrays can't have fill pointers."
msgstr "Ultidimensionalmay arraysway ancay't avehay illfay ointerspay."

#: src/code/array.lisp
msgid ""
"Initial contents may not be specified with ~\n"
"\t\t the :initial-element or :displaced-to option."
msgstr ""
"Initialway ontentscay aymay otnay ebay ecifiedspay ithway ~\n"
"\t\t ethay :initialway-elementway orway :isplacedday-otay optionway."

#: src/code/array.lisp
msgid ""
"The :initial-element option may not be specified ~\n"
"\t       with :displaced-to."
msgstr ""
"Ethay :initialway-elementway optionway aymay otnay ebay ecifiedspay ~\n"
"\t       ithway :isplacedday-otay."

#: src/code/array.lisp
msgid ""
"One can't displace an array of type ~S into another of ~\n"
"\t               type ~S."
msgstr ""
"Oneway ancay't isplaceday anway arrayway ofway ypetay ~S intoway anotherway "
"ofway ~\n"
"\t               ypetay ~S."

#: src/code/array.lisp
msgid "The :displaced-to array is too small."
msgstr "Ethay :isplacedday-otay arrayway isway ootay mallsay."

#: src/code/array.lisp
msgid ""
"Cannot adjust-array an array (~S) to a size (~S) that is ~\n"
"\t            smaller than it's fill pointer (~S)."
msgstr ""
"Annotcay adjustway-arrayway anway arrayway (~S) otay away izesay (~S) atthay "
"isway ~\n"
"\t            mallersay anthay itway's illfay ointerpay (~S)."

#: src/code/array.lisp
msgid ""
"Cannot supply a non-NIL value (~S) for :fill-pointer ~\n"
"\t   in adjust-array unless the array (~S) was originally ~\n"
" \t   created with a fill pointer."
msgstr ""
"Annotcay upplysay away onnay-NIL aluevay (~S) orfay :illfay-ointerpay ~\n"
"\t   inway adjustway-arrayway unlessway ethay arrayway (~S) asway "
"originallyway ~\n"
" \t   eatedcray ithway away illfay ointerpay."

#: src/code/array.lisp
msgid ""
"Cannot supply a value for :fill-pointer (~S) that is larger ~\n"
"\t     than the new length of the vector (~S)."
msgstr ""
"Annotcay upplysay away aluevay orfay :illfay-ointerpay (~S) atthay isway "
"argerlay ~\n"
"\t     anthay ethay ewnay engthlay ofway ethay ectorvay (~S)."

#: src/code/array.lisp
msgid "Bogus value for :fill-pointer in adjust-array: ~S"
msgstr "Ogusbay aluevay orfay :illfay-ointerpay inway adjustway-arrayway: ~S"

#: src/code/array.lisp
msgid ""
"Destructively alters the Vector, changing its length to New-Size, which\n"
"   must be less than or equal to its current size."
msgstr ""
"Estructivelyday altersway ethay Ectorvay, angingchay itsway engthlay otay "
"Ewnay-Izesay, ichwhay\n"
"   ustmay ebay esslay anthay orway equalway otay itsway urrentcay izesay."

#: src/code/array.lisp
msgid "Fills in array header with provided information.  Returns array."
msgstr ""
"Illsfay inway arrayway eaderhay ithway ovidedpray informationway.  Eturnsray "
"arrayway."

#: src/code/array.lisp
msgid "~S and ~S do not have the same dimensions."
msgstr "~S andway ~S oday otnay avehay ethay amesay imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGAND on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGAND onway ethay elementsway ofway BIT-ARRAY-1 "
"andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGIOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGIOR onway ethay elementsway ofway BIT-ARRAY-1 "
"andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGXOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGXOR onway ethay elementsway ofway BIT-ARRAY-1 "
"andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGEQV on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGEQV onway ethay elementsway ofway BIT-ARRAY-1 "
"andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGNAND on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGNAND onway ethay elementsway ofway BIT-"
"ARRAY-1 andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGNOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGNOR onway ethay elementsway ofway BIT-ARRAY-1 "
"andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGANDC1 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGANDC1 onway ethay elementsway ofway BIT-"
"ARRAY-1 andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGANDC2 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGANDC2 onway ethay elementsway ofway BIT-"
"ARRAY-1 andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGORC1 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGORC1 onway ethay elementsway ofway BIT-"
"ARRAY-1 andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGORC2 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""
"Erformpay away itbay-iseway LOGORC2 onway ethay elementsway ofway BIT-"
"ARRAY-1 andway BIT-ARRAY-2,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY-1 isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Allway ethay arraysway ustmay avehay ethay amesay ankray "
"andway imensionsday."

#: src/code/array.lisp
msgid ""
"Performs a bit-wise logical NOT on the elements of BIT-ARRAY,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array is\n"
"  created.  Both arrays must have the same rank and dimensions."
msgstr ""
"Erformspay away itbay-iseway ogicallay NOT onway ethay elementsway ofway BIT-"
"ARRAY,\n"
"  uttingpay ethay esultsray inway RESULT-BIT-ARRAY.  Ifway RESULT-BIT-ARRAY "
"isway T,\n"
"  BIT-ARRAY isway usedway.  Ifway RESULT-BIT-ARRAY isway NIL orway "
"omittedway, away ewnay arrayway isway\n"
"  eatedcray.  Othbay arraysway ustmay avehay ethay amesay ankray andway "
"imensionsday."

#: src/code/hash-new.lisp
msgid "Structure used to implement hash tables."
msgstr "Ucturestray usedway otay implementway ashhay ablestay."

#: src/code/hash-new.lisp
msgid ""
"Almost-Primify returns an almost prime number greater than or equal\n"
"   to NUM."
msgstr ""
"Almostway-Imifypray eturnsray anway almostway imepray umbernay eatergray "
"anthay orway equalway\n"
"   otay NUM."

#: src/code/hash-new.lisp
msgid "Define a new kind of hash table test."
msgstr "Efineday away ewnay indkay ofway ashhay abletay esttay."

#: src/code/hash-new.lisp
msgid ""
"Creates and returns a new hash table.  The keywords are as follows:\n"
"     :TEST -- Indicates what kind of test to use.  Only EQ, EQL, EQUAL,\n"
"       and EQUALP are currently supported.\n"
"     :SIZE -- A hint as to how many elements will be put in this hash\n"
"       table.\n"
"     :REHASH-SIZE -- Indicates how to expand the table when it fills up.\n"
"       If an integer, add space for that many elements.  If a floating\n"
"       point number (which must be greater than 1.0), multiple the size\n"
"       by that amount.\n"
"     :REHASH-THRESHOLD -- Indicates how dense the table can become before\n"
"       forcing a rehash.  Can be any positive number <= to 1, with density\n"
"       approaching zero as the threshold approaches 0.  Density 1 means an\n"
"       average of one entry per bucket.\n"
"   CMUCL Extension:\n"
"     :WEAK-P -- Weak hash table.  Can only be used when the key is 'eq or "
"'eql.\n"
"                An entry in the table is remains if the condition holds:\n"
"\n"
"                :KEY            -- key is referenced elsewhere\n"
"                :VALUE          -- value is referenced elsewhere\n"
"                :KEY-AND-VALUE  -- key and value are referenced elsewhere\n"
"                :KEY-OR-VALUE   -- key or value is referenced elsewhere\n"
"\n"
"                If the condition does not hold, the entry is removed.  For\n"
"                backward compatibility, a value of T is the same as :KEY."
msgstr ""
"Eatescray andway eturnsray away ewnay ashhay abletay.  Ethay eywordskay "
"areway asway ollowsfay:\n"
"     :TEST -- Indicatesway atwhay indkay ofway esttay otay useway.  Onlyway "
"EQ, EQL, EQUAL,\n"
"       andway EQUALP areway urrentlycay upportedsay.\n"
"     :SIZE -- Away inthay asway otay owhay anymay elementsway illway ebay "
"utpay inway isthay ashhay\n"
"       abletay.\n"
"     :REHASH-SIZE -- Indicatesway owhay otay expandway ethay abletay enwhay "
"itway illsfay upway.\n"
"       Ifway anway integerway, addway acespay orfay atthay anymay "
"elementsway.  Ifway away oatingflay\n"
"       ointpay umbernay (ichwhay ustmay ebay eatergray anthay 1.0), "
"ultiplemay ethay izesay\n"
"       ybay atthay amountway.\n"
"     :REHASH-THRESHOLD -- Indicatesway owhay enseday ethay abletay ancay "
"ecomebay eforebay\n"
"       orcingfay away ehashray.  Ancay ebay anyway ositivepay umbernay <= "
"otay 1, ithway ensityday\n"
"       approachingway erozay asway ethay resholdthay approachesway 0.  "
"Ensityday 1 eansmay anway\n"
"       averageway ofway oneway entryway erpay ucketbay.\n"
"   CMUCL Extensionway:\n"
"     :WEAK-P -- Eakway ashhay abletay.  Ancay onlyway ebay usedway enwhay "
"ethay eykay isway 'eqway orway 'eqlway.\n"
"                Anway entryway inway ethay abletay isway emainsray ifway "
"ethay onditioncay oldshay:\n"
"\n"
"                :KEY            -- eykay isway eferencedray elsewhereway\n"
"                :VALUE          -- aluevay isway eferencedray elsewhereway\n"
"                :KEY-AND-VALUE  -- eykay andway aluevay areway eferencedray "
"elsewhereway\n"
"                :KEY-OR-VALUE   -- eykay orway aluevay isway eferencedray "
"elsewhereway\n"
"\n"
"                Ifway ethay onditioncay oesday otnay oldhay, ethay entryway "
"isway emovedray.  Orfay\n"
"                ackwardbay ompatibilitycay, away aluevay ofway T isway ethay "
"amesay asway :KEY."

#: src/code/hash-new.lisp
msgid "Cannot make a weak ~A hashtable with test: ~S"
msgstr "Annotcay akemay away eakway ~Away ashtablehay ithway esttay: ~S"

#: src/code/hash-new.lisp
msgid "Unknown :TEST for MAKE-HASH-TABLE: ~S"
msgstr "Unknownway :TEST orfay MAKE-HASH-TABLE: ~S"

#: src/code/hash-new.lisp
msgid "Returns the number of entries in the given HASH-TABLE."
msgstr ""
"Eturnsray ethay umbernay ofway entriesway inway ethay ivengay HASH-TABLE."

#: src/code/hash-new.lisp
msgid "Return the rehash-size HASH-TABLE was created with."
msgstr "Eturnray ethay ehashray-izesay HASH-TABLE asway eatedcray ithway."

#: src/code/hash-new.lisp
msgid "Return the rehash-threshold HASH-TABLE was created with."
msgstr "Eturnray ethay ehashray-resholdthay HASH-TABLE asway eatedcray ithway."

#: src/code/hash-new.lisp
msgid ""
"Return a size that can be used with MAKE-HASH-TABLE to create a hash\n"
"   table that can hold however many entries HASH-TABLE can hold without\n"
"   having to be grown."
msgstr ""
"Eturnray away izesay atthay ancay ebay usedway ithway MAKE-HASH-TABLE otay "
"eatecray away ashhay\n"
"   abletay atthay ancay oldhay oweverhay anymay entriesway HASH-TABLE ancay "
"oldhay ithoutway\n"
"   avinghay otay ebay owngray."

#: src/code/hash-new.lisp
msgid "Return the test HASH-TABLE was created with."
msgstr "Eturnray ethay esttay HASH-TABLE asway eatedcray ithway."

#: src/code/hash-new.lisp
msgid ""
"Return T if HASH-TABLE will not keep entries for keys that would\n"
"   otherwise be garbage, and NIL if it will."
msgstr ""
"Eturnray T ifway HASH-TABLE illway otnay eepkay entriesway orfay eyskay "
"atthay ouldway\n"
"   otherwiseway ebay arbagegay, andway NIL ifway itway illway."

#: src/code/hash-new.lisp
msgid ""
"Finds the entry in HASH-TABLE whose key is KEY and returns the associated\n"
"   value and T as multiple values, or returns DEFAULT and NIL if there is "
"no\n"
"   such entry.  Entries can be added using SETF."
msgstr ""
"Indsfay ethay entryway inway HASH-TABLE osewhay eykay isway KEY andway "
"eturnsray ethay associatedway\n"
"   aluevay andway T asway ultiplemay aluesvay, orway eturnsray DEFAULT "
"andway NIL ifway erethay isway onay\n"
"   uchsay entryway.  Entriesway ancay ebay addedway usingway SETF."

#: src/code/hash-new.lisp
msgid ""
"Remove the entry in HASH-TABLE associated with KEY.  Returns T if there\n"
"   was such an entry, and NIL if not."
msgstr ""
"Emoveray ethay entryway inway HASH-TABLE associatedway ithway KEY.  "
"Eturnsray T ifway erethay\n"
"   asway uchsay anway entryway, andway NIL ifway otnay."

#: src/code/hash-new.lisp
msgid ""
"This removes all the entries from HASH-TABLE and returns the hash table\n"
"   itself."
msgstr ""
"Isthay emovesray allway ethay entriesway omfray HASH-TABLE andway eturnsray "
"ethay ashhay abletay\n"
"   itselfway."

#: src/code/hash-new.lisp
msgid ""
"This removes all the entries from HASH-TABLE and returns the hash table\n"
"   itself, shrinking the size to free memory."
msgstr ""
"Isthay emovesray allway ethay entriesway omfray HASH-TABLE andway eturnsray "
"ethay ashhay abletay\n"
"   itselfway, rinkingshay ethay izesay otay eefray emorymay."

#: src/code/hash-new.lisp
msgid ""
"For each entry in HASH-TABLE, calls MAP-FUNCTION on the key and value\n"
"   of the entry; returns NIL."
msgstr ""
"Orfay eachway entryway inway HASH-TABLE, allscay MAP-FUNCTION onway ethay "
"eykay andway aluevay\n"
"   ofway ethay entryway; eturnsray NIL."

#: src/code/hash-new.lisp
msgid ""
"WITH-HASH-TABLE-ITERATOR ((function hash-table) &body body)\n"
"   provides a method of manually looping over the elements of a hash-table.\n"
"   FUNCTION is bound to a generator-macro that, within the scope of the\n"
"   invocation, returns one or three values. The first value tells whether\n"
"   any objects remain in the hash table. When the first value is non-NIL, \n"
"   the second and third values are the key and the value of the next object."
msgstr ""
"WITH-HASH-TABLE-ITERATOR ((unctionfay ashhay-abletay) &odybay odybay)\n"
"   ovidespray away ethodmay ofway anuallymay oopinglay overway ethay "
"elementsway ofway away ashhay-abletay.\n"
"   FUNCTION isway oundbay otay away eneratorgay-acromay atthay, ithinway "
"ethay opescay ofway ethay\n"
"   invocationway, eturnsray oneway orway reethay aluesvay. Ethay irstfay "
"aluevay ellstay etherwhay\n"
"   anyway objectsway emainray inway ethay ashhay abletay. Enwhay ethay "
"irstfay aluevay isway onnay-NIL, \n"
"   ethay econdsay andway irdthay aluesvay areway ethay eykay andway ethay "
"aluevay ofway ethay extnay objectway."

#: src/pcl/slots.lisp src/code/hash-new.lisp
msgid "What kind of instance is this?"
msgstr "Atwhay indkay ofway instanceway isway isthay?"

#: src/code/hash-new.lisp
msgid "Computes a hash code for S-EXPR and returns it as an integer."
msgstr ""
"Omputescay away ashhay odecay orfay S-EXPR andway eturnsray itway asway "
"anway integerway."

#: src/code/list.lisp
msgid "Returns the 1st object in a list."
msgstr "Eturnsray ethay 1tsay objectway inway away istlay."

#: src/code/list.lisp
msgid "Returns all but the first object."
msgstr "Eturnsray allway utbay ethay irstfay objectway."

#: src/code/list.lisp
msgid "Returns the 2nd object in a list."
msgstr "Eturnsray ethay 2dnay objectway inway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the 1st sublist."
msgstr "Eturnsray ethay drcay ofway ethay 1tsay ublistsay."

#: src/code/list.lisp
msgid "Returns the car of the 1st sublist."
msgstr "Eturnsray ethay arcay ofway ethay 1tsay ublistsay."

#: src/code/list.lisp
msgid "Returns all but the 1st two objects of a list."
msgstr "Eturnsray allway utbay ethay 1tsay wotay objectsway ofway away istlay."

#: src/code/list.lisp
msgid "Returns the 1st object in the cddr of a list."
msgstr "Eturnsray ethay 1tsay objectway inway ethay ddrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the 1st object in the cadr of a list."
msgstr "Eturnsray ethay 1tsay objectway inway ethay adrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the 1st object in the caar of a list."
msgstr "Eturnsray ethay 1tsay objectway inway ethay aarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the caar of a list."
msgstr "Eturnsray ethay drcay ofway ethay aarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the cdar of a list."
msgstr "Eturnsray ethay drcay ofway ethay darcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the cddr of a list."
msgstr "Eturnsray ethay drcay ofway ethay ddrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the car of the cdar of a list."
msgstr "Eturnsray ethay arcay ofway ethay darcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the cadr of a list."
msgstr "Eturnsray ethay drcay ofway ethay adrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the car of the caaar of a list."
msgstr "Eturnsray ethay arcay ofway ethay aaarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the car of the caadr of a list."
msgstr "Eturnsray ethay arcay ofway ethay aadrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the car of the caddr of a list."
msgstr "Eturnsray ethay arcay ofway ethay addrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the car of the cdddr of a list."
msgstr "Eturnsray ethay arcay ofway ethay dddrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the cdddr of a list."
msgstr "Eturnsray ethay drcay ofway ethay dddrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the caaar of a list."
msgstr "Eturnsray ethay drcay ofway ethay aaarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the cdaar of a list."
msgstr "Eturnsray ethay drcay ofway ethay daarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the cddar of a list."
msgstr "Eturnsray ethay drcay ofway ethay ddarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the car of the cadar of a list."
msgstr "Eturnsray ethay arcay ofway ethay adarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the car of the cdaar of a list."
msgstr "Eturnsray ethay arcay ofway ethay daarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the car of the cdadr of a list."
msgstr "Eturnsray ethay arcay ofway ethay dadrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the car of the cddar of a list."
msgstr "Eturnsray ethay arcay ofway ethay ddarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the caadr of a list."
msgstr "Eturnsray ethay drcay ofway ethay aadrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the cadar of a list."
msgstr "Eturnsray ethay drcay ofway ethay adarcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the caddr of a list."
msgstr "Eturnsray ethay drcay ofway ethay addrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns the cdr of the cdadr of a list."
msgstr "Eturnsray ethay drcay ofway ethay dadrcay ofway away istlay."

#: src/code/list.lisp
msgid "Returns a list with se1 as the car and se2 as the cdr."
msgstr ""
"Eturnsray away istlay ithway esay1 asway ethay arcay andway esay2 asway "
"ethay drcay."

#: src/code/list.lisp
msgid "Returns T if X and Y are isomorphic trees with identical leaves."
msgstr ""
"Eturnsray T ifway X andway Y areway isomorphicway eestray ithway "
"identicalway eaveslay."

#: src/code/list.lisp
msgid ""
"The recommended way to test for the end of a list.  True if Object is nil,\n"
"   false if Object is a cons, and an error for any other types of arguments."
msgstr ""
"Ethay ecommendedray ayway otay esttay orfay ethay endway ofway away istlay.  "
"Uetray ifway Objectway isway ilnay,\n"
"   alsefay ifway Objectway isway away onscay, andway anway errorway orfay "
"anyway otherway ypestay ofway argumentsway."

#: src/code/list.lisp
msgid "Returns the length of the given List, or Nil if the List is circular."
msgstr ""
"Eturnsray ethay engthlay ofway ethay ivengay Istlay, orway Ilnay ifway ethay "
"Istlay isway ircularcay."

#: src/code/list.lisp
msgid "Returns the nth object in a list where the car is the zero-th element."
msgstr ""
"Eturnsray ethay thnay objectway inway away istlay erewhay ethay arcay isway "
"ethay erozay-thay elementway."

#: src/code/list.lisp
msgid "Returns the 1st object in a list or NIL if the list is empty."
msgstr ""
"Eturnsray ethay 1tsay objectway inway away istlay orway NIL ifway ethay "
"istlay isway emptyway."

#: src/code/list.lisp
msgid "Returns the 2nd object in a list or NIL if there is no 2nd object."
msgstr ""
"Eturnsray ethay 2dnay objectway inway away istlay orway NIL ifway erethay "
"isway onay 2dnay objectway."

#: src/code/list.lisp
msgid "Returns the 3rd object in a list or NIL if there is no 3rd object."
msgstr ""
"Eturnsray ethay 3dray objectway inway away istlay orway NIL ifway erethay "
"isway onay 3dray objectway."

#: src/code/list.lisp
msgid "Returns the 4th object in a list or NIL if there is no 4th object."
msgstr ""
"Eturnsray ethay 4thay objectway inway away istlay orway NIL ifway erethay "
"isway onay 4thay objectway."

#: src/code/list.lisp
msgid "Returns the 5th object in a list or NIL if there is no 5th object."
msgstr ""
"Eturnsray ethay 5thay objectway inway away istlay orway NIL ifway erethay "
"isway onay 5thay objectway."

#: src/code/list.lisp
msgid "Returns the 6th object in a list or NIL if there is no 6th object."
msgstr ""
"Eturnsray ethay 6thay objectway inway away istlay orway NIL ifway erethay "
"isway onay 6thay objectway."

#: src/code/list.lisp
msgid "Returns the 7th object in a list or NIL if there is no 7th object."
msgstr ""
"Eturnsray ethay 7thay objectway inway away istlay orway NIL ifway erethay "
"isway onay 7thay objectway."

#: src/code/list.lisp
msgid "Returns the 8th object in a list or NIL if there is no 8th object."
msgstr ""
"Eturnsray ethay 8thay objectway inway away istlay orway NIL ifway erethay "
"isway onay 8thay objectway."

#: src/code/list.lisp
msgid "Returns the 9th object in a list or NIL if there is no 9th object."
msgstr ""
"Eturnsray ethay 9thay objectway inway away istlay orway NIL ifway erethay "
"isway onay 9thay objectway."

#: src/code/list.lisp
msgid "Returns the 10th object in a list or NIL if there is no 10th object."
msgstr ""
"Eturnsray ethay 10thay objectway inway away istlay orway NIL ifway erethay "
"isway onay 10thay objectway."

#: src/code/list.lisp
msgid "Means the same as the cdr of a list."
msgstr "Eansmay ethay amesay asway ethay drcay ofway away istlay."

#: src/code/list.lisp
msgid "Performs the cdr function n times on a list."
msgstr "Erformspay ethay drcay unctionfay n imestay onway away istlay."

#: src/code/list.lisp
msgid "Returns the last N conses (not the last element!) of a list."
msgstr ""
"Eturnsray ethay astlay N onsescay (otnay ethay astlay elementway!) ofway "
"away istlay."

#: src/code/list.lisp
msgid "Returns constructs and returns a list of its arguments."
msgstr ""
"Eturnsray onstructscay andway eturnsray away istlay ofway itsway "
"argumentsway."

#: src/code/list.lisp
msgid "Returns a list of the arguments with last cons a dotted pair"
msgstr ""
"Eturnsray away istlay ofway ethay argumentsway ithway astlay onscay away "
"ottedday airpay"

#: src/code/list.lisp
msgid "Constructs a list with size elements each set to value"
msgstr ""
"Onstructscay away istlay ithway izesay elementsway eachway etsay otay aluevay"

#: src/code/list.lisp
msgid "~S is not a proper list"
msgstr "~S isway otnay away operpray istlay"

#: src/code/list.lisp
msgid ""
"Typically, returns a new list that is the concatenation of Args.\n"
"\n"
"  Each Arg in Args must be a proper list except the last one, which\n"
"  may be any object.  The function is not destructive: for all but the\n"
"  last Arg, its list structure is copied.  The last argument is not\n"
"  copied; it becomes the cdr of the final dotted pair of the\n"
"  concatenation of the preceding lists, or is returned directly if\n"
"  there are no preceding non-empty lists.  In the latter case, if the\n"
"  last Arg is not a list, the returned value is not a list either."
msgstr ""
"Ypicallytay, eturnsray away ewnay istlay atthay isway ethay oncatenationcay "
"ofway Argsway.\n"
"\n"
"  Eachway Argway inway Argsway ustmay ebay away operpray istlay exceptway "
"ethay astlay oneway, ichwhay\n"
"  aymay ebay anyway objectway.  Ethay unctionfay isway otnay estructiveday: "
"orfay allway utbay ethay\n"
"  astlay Argway, itsway istlay ucturestray isway opiedcay.  Ethay astlay "
"argumentway isway otnay\n"
"  opiedcay; itway ecomesbay ethay drcay ofway ethay inalfay ottedday airpay "
"ofway ethay\n"
"  oncatenationcay ofway ethay ecedingpray istslay, orway isway eturnedray "
"irectlyday ifway\n"
"  erethay areway onay ecedingpray onnay-emptyway istslay.  Inway ethay "
"atterlay asecay, ifway ethay\n"
"  astlay Argway isway otnay away istlay, ethay eturnedray aluevay isway "
"otnay away istlay eitherway."

#: src/code/list.lisp
msgid "~S is not a list."
msgstr "~S isway otnay away istlay."

#: src/code/list.lisp
msgid "Returns a new list EQUAL but not EQ to list"
msgstr "Eturnsray away ewnay istlay EQUAL utbay otnay EQ otay istlay"

#: src/code/list.lisp
msgid "Returns a new association list equal to alist, constructed in space"
msgstr ""
"Eturnsray away ewnay associationway istlay equalway otay alistway, "
"onstructedcay inway acespay"

#: src/code/list.lisp
msgid "Copy-Tree recursively copys trees of conses."
msgstr "Opycay-Eetray ecursivelyray opyscay eestray ofway onsescay."

#: src/code/list.lisp
msgid "Returns (append (reverse x) y)"
msgstr "Eturnsray (appendway (everseray x) y)"

#: src/code/list.lisp
msgid "Concatenates the lists given as arguments (by changing them)"
msgstr ""
"Oncatenatescay ethay istslay ivengay asway argumentsway (ybay angingchay "
"emthay)"

#: src/code/list.lisp
msgid "Argument is not a list -- ~S."
msgstr "Argumentway isway otnay away istlay -- ~S."

#: src/code/list.lisp
msgid "Returns (nconc (nreverse x) y)"
msgstr "Eturnsray (concnay (reversenay x) y)"

#: src/code/list.lisp
msgid "First argument is not a proper list."
msgstr "Irstfay argumentway isway otnay away operpray istlay."

#: src/code/list.lisp
msgid ""
"Returns a new list the same as List without the last N conses.\n"
"   List must not be circular."
msgstr ""
"Eturnsray away ewnay istlay ethay amesay asway Istlay ithoutway ethay astlay "
"N onsescay.\n"
"   Istlay ustmay otnay ebay ircularcay."

#: src/code/list.lisp
msgid "Modifies List to remove the last N conses. List must not be circular."
msgstr ""
"Odifiesmay Istlay otay emoveray ethay astlay N onsescay. Istlay ustmay otnay "
"ebay ircularcay."

#: src/code/list.lisp
msgid ""
"Returns a new list, whose elements are those of List that appear before\n"
"   Object.  If Object is not a tail of List, a copy of List is returned.\n"
"   List must be a proper list or a dotted list."
msgstr ""
"Eturnsray away ewnay istlay, osewhay elementsway areway osethay ofway Istlay "
"atthay appearway eforebay\n"
"   Objectway.  Ifway Objectway isway otnay away ailtay ofway Istlay, away "
"opycay ofway Istlay isway eturnedray.\n"
"   Istlay ustmay ebay away operpray istlay orway away ottedday istlay."

#: src/code/list.lisp
msgid "Changes the car of x to y and returns the new x."
msgstr "Angeschay ethay arcay ofway x otay y andway eturnsray ethay ewnay x."

#: src/code/list.lisp
msgid "Changes the cdr of x to y and returns the new x."
msgstr "Angeschay ethay drcay ofway x otay y andway eturnsray ethay ewnay x."

#: src/code/list.lisp
msgid "Sets the Nth element of List (zero based) to Newval."
msgstr ""
"Etssay ethay Thnay elementway ofway Istlay (erozay asedbay) otay Ewvalnay."

#: src/code/list.lisp
msgid "~S is too large an index for SETF of NTH."
msgstr "~S isway ootay argelay anway indexway orfay SETF ofway NTH."

#: src/code/list.lisp
msgid "Returns what was passed to it."
msgstr "Eturnsray atwhay asway assedpay otay itway."

#: src/code/list.lisp
msgid ""
"Builds a new function that returns T whenever FUNCTION returns NIL and\n"
"   NIL whenever FUNCTION returns T."
msgstr ""
"Uildsbay away ewnay unctionfay atthay eturnsray T eneverwhay FUNCTION "
"eturnsray NIL andway\n"
"   NIL eneverwhay FUNCTION eturnsray T."

#: src/code/list.lisp
msgid "Builds a function that always returns VALUE, and posisbly MORE-VALUES."
msgstr ""
"Uildsbay away unctionfay atthay alwaysway eturnsray VALUE, andway osisblypay "
"MORE-VALUES."

#: src/code/list.lisp
msgid "Substitutes new for subtrees matching old."
msgstr "Ubstitutessay ewnay orfay ubtreessay atchingmay oldway."

#: src/code/list.lisp
msgid "Substitutes new for subtrees for which test is true."
msgstr ""
"Ubstitutessay ewnay orfay ubtreessay orfay ichwhay esttay isway uetray."

#: src/code/list.lisp
msgid "Substitutes new for subtrees for which test is false."
msgstr ""
"Ubstitutessay ewnay orfay ubtreessay orfay ichwhay esttay isway alsefay."

#: src/code/list.lisp
msgid "Substitutes new for subtrees of tree for which test is true."
msgstr ""
"Ubstitutessay ewnay orfay ubtreessay ofway eetray orfay ichwhay esttay isway "
"uetray."

#: src/code/list.lisp
msgid "Substitutes new for subtrees of tree for which test is false."
msgstr ""
"Ubstitutessay ewnay orfay ubtreessay ofway eetray orfay ichwhay esttay isway "
"alsefay."

#: src/code/list.lisp
msgid "Substitutes from alist into tree nondestructively."
msgstr "Ubstitutessay omfray alistway intoway eetray ondestructivelynay."

#: src/code/list.lisp
msgid ""
"Returns tail of list beginning with first element satisfying EQLity,\n"
"   :test, or :test-not with a given item."
msgstr ""
"Eturnsray ailtay ofway istlay eginningbay ithway irstfay elementway "
"atisfyingsay Eqlityway,\n"
"   :esttay, orway :esttay-otnay ithway away ivengay itemway."

#: src/code/list.lisp
msgid ""
"Returns tail of list beginning with first element satisfying test(element)"
msgstr ""
"Eturnsray ailtay ofway istlay eginningbay ithway irstfay elementway "
"atisfyingsay esttay(elementway)"

#: src/code/list.lisp
msgid ""
"Returns tail of list beginning with first element not satisfying test(el)"
msgstr ""
"Eturnsray ailtay ofway istlay eginningbay ithway irstfay elementway otnay "
"atisfyingsay esttay(elway)"

#: src/code/list.lisp
msgid ""
"Returns true if Object is the same as some tail of List, otherwise\n"
"   returns false. List must be a proper list or a dotted list."
msgstr ""
"Eturnsray uetray ifway Objectway isway ethay amesay asway omesay ailtay "
"ofway Istlay, otherwiseway\n"
"   eturnsray alsefay. Istlay ustmay ebay away operpray istlay orway away "
"ottedday istlay."

#: src/code/list.lisp
msgid "Add item to list unless it is already a member"
msgstr ""
"Addway itemway otay istlay unlessway itway isway alreadyway away embermay"

#: src/code/list.lisp
msgid "Returns the union of list1 and list2."
msgstr "Eturnsray ethay unionway ofway istlay1 andway istlay2."

#: src/code/list.lisp
msgid "Test and test-not both supplied."
msgstr "Esttay andway esttay-otnay othbay uppliedsay."

#: src/code/list.lisp
msgid "Returns the intersection of list1 and list2."
msgstr "Eturnsray ethay intersectionway ofway istlay1 andway istlay2."

#: src/code/list.lisp
msgid "Returns the elements of list1 which are not in list2."
msgstr ""
"Eturnsray ethay elementsway ofway istlay1 ichwhay areway otnay inway istlay2."

#: src/code/list.lisp
msgid "Destructively returns the union list1 and list2."
msgstr "Estructivelyday eturnsray ethay unionway istlay1 andway istlay2."

#: src/code/list.lisp
msgid "Destructively returns the intersection of list1 and list2."
msgstr ""
"Estructivelyday eturnsray ethay intersectionway ofway istlay1 andway istlay2."

#: src/code/list.lisp
msgid "Destructively returns the elements of list1 which are not in list2."
msgstr ""
"Estructivelyday eturnsray ethay elementsway ofway istlay1 ichwhay areway "
"otnay inway istlay2."

#: src/code/list.lisp
#, fuzzy
msgid "Return new list of elements appearing exactly one of LIST1 and LIST2."
msgstr ""
"Eturnray ewnay istlay ofway elementsway appearingway exactlyway onceway "
"inway LIST1 andway LIST2."

#: src/code/list.lisp
msgid ""
"Destructively return a list with elements which appear but once in LIST1\n"
"   and LIST2."
msgstr ""
"Estructivelyday eturnray away istlay ithway elementsway ichwhay appearway "
"utbay onceway inway LIST1\n"
"   andway LIST2."

#: src/code/list.lisp
msgid "Returns T if every element in list1 is also in list2."
msgstr ""
"Eturnsray T ifway everyway elementway inway istlay1 isway alsoway inway "
"istlay2."

#: src/code/list.lisp
msgid "Construct a new alist by adding the pair (key . datum) to alist"
msgstr ""
"Onstructcay away ewnay alistway ybay addingway ethay airpay (eykay . "
"atumday) otay alistway"

#: src/code/list.lisp
msgid "Construct an association list from keys and data (adding to alist)"
msgstr ""
"Onstructcay anway associationway istlay omfray eyskay andway ataday "
"(addingway otay alistway)"

#: src/code/list.lisp
msgid "The lists of keys and data are of unequal length."
msgstr ""
"Ethay istslay ofway eyskay andway ataday areway ofway unequalway engthlay."

#: src/code/list.lisp
msgid ""
"Returns the cons in alist whose car is equal (by a given test or EQL) to\n"
"   the Item."
msgstr ""
"Eturnsray ethay onscay inway alistway osewhay arcay isway equalway (ybay "
"away ivengay esttay orway EQL) otay\n"
"   ethay Itemway."

#: src/code/list.lisp
msgid ""
"Returns the first cons in alist whose car satisfies the Predicate.  If\n"
"   key is supplied, apply it to the car of each cons before testing."
msgstr ""
"Eturnsray ethay irstfay onscay inway alistway osewhay arcay atisfiessay "
"ethay Edicatepray.  Ifway\n"
"   eykay isway uppliedsay, applyway itway otay ethay arcay ofway eachway "
"onscay eforebay estingtay."

#: src/code/list.lisp
msgid ""
"Returns the first cons in alist whose car does not satisfiy the Predicate.\n"
"  If key is supplied, apply it to the car of each cons before testing."
msgstr ""
"Eturnsray ethay irstfay onscay inway alistway osewhay arcay oesday otnay "
"atisfiysay ethay Edicatepray.\n"
"  Ifway eykay isway uppliedsay, applyway itway otay ethay arcay ofway "
"eachway onscay eforebay estingtay."

#: src/code/list.lisp
msgid ""
"Returns the cons in alist whose cdr is equal (by a given test or EQL) to\n"
"   the Item."
msgstr ""
"Eturnsray ethay onscay inway alistway osewhay drcay isway equalway (ybay "
"away ivengay esttay orway EQL) otay\n"
"   ethay Itemway."

#: src/code/list.lisp
msgid ""
"Returns the first cons in alist whose cdr satisfies the Predicate.  If key\n"
"  is supplied, apply it to the cdr of each cons before testing."
msgstr ""
"Eturnsray ethay irstfay onscay inway alistway osewhay drcay atisfiessay "
"ethay Edicatepray.  Ifway eykay\n"
"  isway uppliedsay, applyway itway otay ethay drcay ofway eachway onscay "
"eforebay estingtay."

#: src/code/list.lisp
msgid ""
"Returns the first cons in alist whose cdr does not satisfy the Predicate.\n"
"  If key is supplied, apply it to the cdr of each cons before testing."
msgstr ""
"Eturnsray ethay irstfay onscay inway alistway osewhay drcay oesday otnay "
"atisfysay ethay Edicatepray.\n"
"  Ifway eykay isway uppliedsay, applyway itway otay ethay drcay ofway "
"eachway onscay eforebay estingtay."

#: src/code/list.lisp
msgid ""
"This function is called by mapc, mapcar, mapcan, mapl, maplist, and mapcon.\n"
"  It Maps function over the arglists in the appropriate way. It is done when "
"any\n"
"  of the arglists runs out.  Until then, it CDRs down the arglists calling "
"the\n"
"  function and accumulating results as desired."
msgstr ""
"Isthay unctionfay isway alledcay ybay apcmay, apcarmay, apcanmay, aplmay, "
"aplistmay, andway apconmay.\n"
"  Itway Apsmay unctionfay overway ethay arglistsway inway ethay "
"appropriateway ayway. Itway isway oneday enwhay anyway\n"
"  ofway ethay arglistsway unsray outway.  Untilway enthay, itway Drscay "
"ownday ethay arglistsway allingcay ethay\n"
"  unctionfay andway accumulatingway esultsray asway esiredday."

#: src/code/list.lisp
msgid ""
"Applies Function to successive elements of each List, and returns\n"
"  its second argument."
msgstr ""
"Appliesway Unctionfay otay uccessivesay elementsway ofway eachway Istlay, "
"andway eturnsray\n"
"  itsway econdsay argumentway."

#: src/code/list.lisp
msgid ""
"Applies Function to successive elements of each List, and returns a\n"
"  list of results."
msgstr ""
"Appliesway Unctionfay otay uccessivesay elementsway ofway eachway Istlay, "
"andway eturnsray away\n"
"  istlay ofway esultsray."

#: src/code/list.lisp
msgid ""
"Applies Function to successive elements of each List, and returns\n"
"  NCONC of results."
msgstr ""
"Appliesway Unctionfay otay uccessivesay elementsway ofway eachway Istlay, "
"andway eturnsray\n"
"  NCONC ofway esultsray."

#: src/code/list.lisp
msgid "Applies Function to successive CDRs of each List, and returns ()."
msgstr ""
"Appliesway Unctionfay otay uccessivesay Drscay ofway eachway Istlay, andway "
"eturnsray ()."

#: src/code/list.lisp
msgid ""
"Applies Function to successive CDRs of each List, and returns list\n"
"  of results."
msgstr ""
"Appliesway Unctionfay otay uccessivesay Drscay ofway eachway Istlay, andway "
"eturnsray istlay\n"
"  ofway esultsray."

#: src/code/list.lisp
msgid ""
"Applies Function to successive CDRs of each List, and returns NCONC\n"
"  of results."
msgstr ""
"Appliesway Unctionfay otay uccessivesay Drscay ofway eachway Istlay, andway "
"eturnsray NCONC\n"
"  ofway esultsray."

#: src/code/list.lisp
msgid "Returns tail of list beginning with first element eq to item"
msgstr ""
"Eturnsray ailtay ofway istlay eginningbay ithway irstfay elementway eqway "
"otay itemway"

#: src/code/list.lisp
msgid "Return the first pair of alist where item EQ the key of pair"
msgstr ""
"Eturnray ethay irstfay airpay ofway alistway erewhay itemway EQ ethay eykay "
"ofway airpay"

#: src/code/list.lisp
msgid "Returns list with all elements with all elements EQ to ITEM deleted."
msgstr ""
"Eturnsray istlay ithway allway elementsway ithway allway elementsway EQ otay "
"ITEM eletedday."

#: src/code/seq.lisp
msgid ""
"Returns a list of the Nth element of each of the sequences.  Used by MAP\n"
"   and friends."
msgstr ""
"Eturnsray away istlay ofway ethay Thnay elementway ofway eachway ofway ethay "
"equencessay.  Usedway ybay MAP\n"
"   andway iendsfray."

#: src/code/seq.lisp
msgid "Returns a sequence of the same type as SEQUENCE and the given LENGTH."
msgstr ""
"Eturnsray away equencesay ofway ethay amesay ypetay asway SEQUENCE andway "
"ethay ivengay LENGTH."

#: src/code/seq.lisp
msgid "Returns the broad class of which TYPE is a specific subclass."
msgstr ""
"Eturnsray ethay oadbray assclay ofway ichwhay TYPE isway away ecificspay "
"ubclasssay."

#: src/code/seq.lisp
msgid "NIL output type invalid for this sequence function."
msgstr "NIL outputway ypetay invalidway orfay isthay equencesay unctionfay."

#: src/code/seq.lisp
msgid "~S is too hairy for sequence functions."
msgstr "~S isway ootay airyhay orfay equencesay unctionsfay."

#: src/code/seq.lisp
msgid "~S is a bad type specifier for sequence functions."
msgstr "~S isway away adbay ypetay ecifierspay orfay equencesay unctionsfay."

#: src/code/seq.lisp
msgid "Error in ~S: ~S: Index too large."
msgstr "Errorway inway ~S: ~S: Indexway ootay argelay."

#: src/code/seq.lisp
msgid "Returns a sequence of the given TYPE and LENGTH."
msgstr "Eturnsray away equencesay ofway ethay ivengay TYPE andway LENGTH."

#: src/code/seq.lisp
msgid "Returns the element of SEQUENCE specified by INDEX."
msgstr "Eturnsray ethay elementway ofway SEQUENCE ecifiedspay ybay INDEX."

#: src/code/seq.lisp
msgid "Store NEWVAL as the component of SEQUENCE specified by INDEX."
msgstr ""
"Toresay NEWVAL asway ethay omponentcay ofway SEQUENCE ecifiedspay ybay INDEX."

#: src/code/seq.lisp
msgid "Returns an integer that is the length of SEQUENCE."
msgstr "Eturnsray anway integerway atthay isway ethay engthlay ofway SEQUENCE."

#: src/code/seq.lisp
msgid "~S is a bad type specifier for sequences"
msgstr "~S isway away adbay ypetay ecifierspay orfay equencessay"

#: src/code/seq.lisp
msgid "Shouldn't happen!  Weird type"
msgstr "Ouldnshay't appenhay!  Eirdway ypetay"

#: src/code/seq.lisp
msgid ""
"The length of ~S does not match the specified ~\n"
"                          length of ~S."
msgstr ""
"Ethay engthlay ofway ~S oesday otnay atchmay ethay ecifiedspay ~\n"
"                          engthlay ofway ~S."

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the given Type and Length, with elements initialized\n"
"  to :Initial-Element."
msgstr ""
"Eturnsray away equencesay ofway ethay ivengay Ypetay andway Engthlay, ithway "
"elementsway initializedway\n"
"  otay :Initialway-Elementway."

#: src/code/seq.lisp
msgid ""
"The length of ~S does not match the specified ~\n"
"                           length  of ~S."
msgstr ""
"Ethay engthlay ofway ~S oesday otnay atchmay ethay ecifiedspay ~\n"
"                           engthlay  ofway ~S."

#: src/code/seq.lisp
msgid "~S is a bad type specifier for sequences."
msgstr "~S isway away adbay ypetay ecifierspay orfay equencessay."

#: src/code/seq.lisp
msgid ""
"Returns a copy of a subsequence of SEQUENCE starting with element number \n"
"   START and continuing to the end of SEQUENCE or the optional END."
msgstr ""
"Eturnsray away opycay ofway away ubsequencesay ofway SEQUENCE tartingsay "
"ithway elementway umbernay \n"
"   START andway ontinuingcay otay ethay endway ofway SEQUENCE orway ethay "
"optionalway END."

#: src/code/seq.lisp
msgid "Returns a copy of SEQUENCE which is EQUAL to SEQUENCE but not EQ."
msgstr ""
"Eturnsray away opycay ofway SEQUENCE ichwhay isway EQUAL otay SEQUENCE utbay "
"otnay EQ."

#: src/code/seq.lisp
msgid "Replace the specified elements of SEQUENCE with ITEM."
msgstr "Eplaceray ethay ecifiedspay elementsway ofway SEQUENCE ithway ITEM."

#: src/code/seq.lisp
msgid ""
"The target sequence is destructively modified by copying successive\n"
"   elements into it from the source sequence."
msgstr ""
"Ethay argettay equencesay isway estructivelyday odifiedmay ybay opyingcay "
"uccessivesay\n"
"   elementsway intoway itway omfray ethay ourcesay equencesay."

#: src/code/seq.lisp
msgid ""
"Returns a new sequence containing the same elements but in reverse order."
msgstr ""
"Eturnsray away ewnay equencesay ontainingcay ethay amesay elementsway utbay "
"inway everseray orderway."

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same elements in reverse order; the argument\n"
"   is destroyed."
msgstr ""
"Eturnsray away equencesay ofway ethay amesay elementsway inway everseray "
"orderway; ethay argumentway\n"
"   isway estroyedday."

#: src/code/seq.lisp
msgid ""
"Returns a new sequence of all the argument sequences concatenated together\n"
"  which shares no structure with the original argument sequences of the\n"
"  specified OUTPUT-TYPE-SPEC."
msgstr ""
"Eturnsray away ewnay equencesay ofway allway ethay argumentway equencessay "
"oncatenatedcay ogethertay\n"
"  ichwhay aresshay onay ucturestray ithway ethay originalway argumentway "
"equencessay ofway ethay\n"
"  ecifiedspay OUTPUT-TYPE-SPEC."

#: src/code/seq.lisp
msgid ""
"FUNCTION must take as many arguments as there are sequences provided.  The \n"
"   result is a sequence such that element i is the result of applying "
"FUNCTION\n"
"   to element i of each of the argument sequences."
msgstr ""
"FUNCTION ustmay aketay asway anymay argumentsway asway erethay areway "
"equencessay ovidedpray.  Ethay \n"
"   esultray isway away equencesay uchsay atthay elementway i isway ethay "
"esultray ofway applyingway FUNCTION\n"
"   otay elementway i ofway eachway ofway ethay argumentway equencessay."

#: src/code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then \n"
"   possibly to those with index 1, and so on.  SOME returns the first \n"
"   non-() value encountered, or () if the end of a sequence is reached."
msgstr ""
"PREDICATE isway appliedway otay ethay elementsway ithway indexway 0 ofway "
"ethay equencessay, enthay \n"
"   ossiblypay otay osethay ithway indexway 1, andway osay onway.  SOME "
"eturnsray ethay irstfay \n"
"   onnay-() aluevay encounteredway, orway () ifway ethay endway ofway away "
"equencesay isway eachedray."

#: src/code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then\n"
"   possibly to those with index 1, and so on.  EVERY returns () as soon\n"
"   as any invocation of PREDICATE returns (), or T if every invocation\n"
"   is non-()."
msgstr ""
"PREDICATE isway appliedway otay ethay elementsway ithway indexway 0 ofway "
"ethay equencessay, enthay\n"
"   ossiblypay otay osethay ithway indexway 1, andway osay onway.  EVERY "
"eturnsray () asway oonsay\n"
"   asway anyway invocationway ofway PREDICATE eturnsray (), orway T ifway "
"everyway invocationway\n"
"   isway onnay-()."

#: src/code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then \n"
"   possibly to those with index 1, and so on.  NOTANY returns () as soon\n"
"   as any invocation of PREDICATE returns a non-() value, or T if the end\n"
"   of a sequence is reached."
msgstr ""
"PREDICATE isway appliedway otay ethay elementsway ithway indexway 0 ofway "
"ethay equencessay, enthay \n"
"   ossiblypay otay osethay ithway indexway 1, andway osay onway.  NOTANY "
"eturnsray () asway oonsay\n"
"   asway anyway invocationway ofway PREDICATE eturnsray away onnay-() "
"aluevay, orway T ifway ethay endway\n"
"   ofway away equencesay isway eachedray."

#: src/code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then\n"
"   possibly to those with index 1, and so on.  NOTEVERY returns T as soon\n"
"   as any invocation of PREDICATE returns (), or () if every invocation\n"
"   is non-()."
msgstr ""
"PREDICATE isway appliedway otay ethay elementsway ithway indexway 0 ofway "
"ethay equencessay, enthay\n"
"   ossiblypay otay osethay ithway indexway 1, andway osay onway.  NOTEVERY "
"eturnsray T asway oonsay\n"
"   asway anyway invocationway ofway PREDICATE eturnsray (), orway () ifway "
"everyway invocationway\n"
"   isway onnay-()."

#: src/code/seq.lisp
msgid ""
"The specified Sequence is ``reduced'' using the given Function.\n"
"  See manual for details."
msgstr ""
"Ethay ecifiedspay Equencesay isway ``educedray'' usingway ethay ivengay "
"Unctionfay.\n"
"  Eesay anualmay orfay etailsday."

#: src/code/seq.lisp
msgid "Coerces the Object to an object of type Output-Type-Spec."
msgstr ""
"Oercescay ethay Objectway otay anway objectway ofway ypetay Outputway-Ypetay-"
"Ecspay."

#: src/code/seq.lisp
msgid "~S can't be converted to type ~S."
msgstr "~S ancay't ebay onvertedcay otay ypetay ~S."

#: src/code/seq.lisp
msgid ""
"Returns a sequence formed by destructively removing the specified Item from\n"
"  the given Sequence."
msgstr ""
"Eturnsray away equencesay ormedfay ybay estructivelyday emovingray ethay "
"ecifiedspay Itemway omfray\n"
"  ethay ivengay Equencesay."

#: src/code/seq.lisp
msgid ""
"Returns a sequence formed by destructively removing the elements satisfying\n"
"  the specified Predicate from the given Sequence."
msgstr ""
"Eturnsray away equencesay ormedfay ybay estructivelyday emovingray ethay "
"elementsway atisfyingsay\n"
"  ethay ecifiedspay Edicatepray omfray ethay ivengay Equencesay."

#: src/code/seq.lisp
msgid ""
"Returns a sequence formed by destructively removing the elements not\n"
"  satisfying the specified Predicate from the given Sequence."
msgstr ""
"Eturnsray away equencesay ormedfay ybay estructivelyday emovingray ethay "
"elementsway otnay\n"
"  atisfyingsay ethay ecifiedspay Edicatepray omfray ethay ivengay Equencesay."

#: src/code/seq.lisp
msgid ""
"Returns a copy of SEQUENCE with elements satisfying the test (default is\n"
"   EQL) with ITEM removed."
msgstr ""
"Eturnsray away opycay ofway SEQUENCE ithway elementsway atisfyingsay ethay "
"esttay (efaultday isway\n"
"   EQL) ithway ITEM emovedray."

#: src/code/seq.lisp
msgid ""
"Returns a copy of sequence with elements such that predicate(element)\n"
"   is non-null are removed"
msgstr ""
"Eturnsray away opycay ofway equencesay ithway elementsway uchsay atthay "
"edicatepray(elementway)\n"
"   isway onnay-ullnay areway emovedray"

#: src/code/seq.lisp
msgid ""
"Returns a copy of sequence with elements such that predicate(element)\n"
"   is null are removed"
msgstr ""
"Eturnsray away opycay ofway equencesay ithway elementsway uchsay atthay "
"edicatepray(elementway)\n"
"   isway ullnay areway emovedray"

#: src/code/seq.lisp
msgid ""
"The elements of Sequence are compared pairwise, and if any two match,\n"
"   the one occuring earlier is discarded, unless FROM-END is true, in\n"
"   which case the one later in the sequence is discarded.  The resulting\n"
"   sequence is returned.\n"
"\n"
"   The :TEST-NOT argument is deprecated."
msgstr ""
"Ethay elementsway ofway Equencesay areway omparedcay airwisepay, andway "
"ifway anyway wotay atchmay,\n"
"   ethay oneway occuringway earlierway isway iscardedday, unlessway FROM-END "
"isway uetray, inway\n"
"   ichwhay asecay ethay oneway aterlay inway ethay equencesay isway "
"iscardedday.  Ethay esultingray\n"
"   equencesay isway eturnedray.\n"
"\n"
"   Ethay :TEST-NOT argumentway isway eprecatedday."

#: src/code/seq.lisp
msgid ""
"The elements of Sequence are examined, and if any two match, one is\n"
"   discarded.  The resulting sequence, which may be formed by destroying "
"the\n"
"   given sequence, is returned.\n"
"\n"
"   The :TEST-NOT argument is deprecated."
msgstr ""
"Ethay elementsway ofway Equencesay areway examinedway, andway ifway anyway "
"wotay atchmay, oneway isway\n"
"   iscardedday.  Ethay esultingray equencesay, ichwhay aymay ebay ormedfay "
"ybay estroyingday ethay\n"
"   ivengay equencesay, isway eturnedray.\n"
"\n"
"   Ethay :TEST-NOT argumentway isway eprecatedday."

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements equal to Old are replaced with New.  See manual\n"
"  for details."
msgstr ""
"Eturnsray away equencesay ofway ethay amesay indkay asway Equencesay ithway "
"ethay amesay elementsway\n"
"  exceptway atthay allway elementsway equalway otay Oldway areway eplacedray "
"ithway Ewnay.  Eesay anualmay\n"
"  orfay etailsday."

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements satisfying the Test are replaced with New.  See\n"
"  manual for details."
msgstr ""
"Eturnsray away equencesay ofway ethay amesay indkay asway Equencesay ithway "
"ethay amesay elementsway\n"
"  exceptway atthay allway elementsway atisfyingsay ethay Esttay areway "
"eplacedray ithway Ewnay.  Eesay\n"
"  anualmay orfay etailsday."

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements not satisfying the Test are replaced with New.\n"
"  See manual for details."
msgstr ""
"Eturnsray away equencesay ofway ethay amesay indkay asway Equencesay ithway "
"ethay amesay elementsway\n"
"  exceptway atthay allway elementsway otnay atisfyingsay ethay Esttay areway "
"eplacedray ithway Ewnay.\n"
"  Eesay anualmay orfay etailsday."

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements equal to Old are replaced with New.  The "
"Sequence\n"
"  may be destroyed.  See manual for details."
msgstr ""
"Eturnsray away equencesay ofway ethay amesay indkay asway Equencesay ithway "
"ethay amesay elementsway\n"
"  exceptway atthay allway elementsway equalway otay Oldway areway eplacedray "
"ithway Ewnay.  Ethay Equencesay\n"
"  aymay ebay estroyedday.  Eesay anualmay orfay etailsday."

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"   except that all elements satisfying the Test are replaced with New.  The\n"
"   Sequence may be destroyed.  See manual for details."
msgstr ""
"Eturnsray away equencesay ofway ethay amesay indkay asway Equencesay ithway "
"ethay amesay elementsway\n"
"   exceptway atthay allway elementsway atisfyingsay ethay Esttay areway "
"eplacedray ithway Ewnay.  Ethay\n"
"   Equencesay aymay ebay estroyedday.  Eesay anualmay orfay etailsday."

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"   except that all elements not satisfying the Test are replaced with New.\n"
"   The Sequence may be destroyed.  See manual for details."
msgstr ""
"Eturnsray away equencesay ofway ethay amesay indkay asway Equencesay ithway "
"ethay amesay elementsway\n"
"   exceptway atthay allway elementsway otnay atisfyingsay ethay Esttay "
"areway eplacedray ithway Ewnay.\n"
"   Ethay Equencesay aymay ebay estroyedday.  Eesay anualmay orfay etailsday."

#: src/code/seq.lisp
msgid ""
"Returns the zero-origin index of the first element in SEQUENCE\n"
"   satisfying the test (default is EQL) with the given ITEM"
msgstr ""
"Eturnsray ethay erozay-originway indexway ofway ethay irstfay elementway "
"inway SEQUENCE\n"
"   atisfyingsay ethay esttay (efaultday isway EQL) ithway ethay ivengay ITEM"

#: src/code/seq.lisp
msgid "Returns the zero-origin index of the first element satisfying test(el)"
msgstr ""
"Eturnsray ethay erozay-originway indexway ofway ethay irstfay elementway "
"atisfyingsay esttay(elway)"

#: src/code/seq.lisp
msgid ""
"Returns the zero-origin index of the first element not satisfying test(el)"
msgstr ""
"Eturnsray ethay erozay-originway indexway ofway ethay irstfay elementway "
"otnay atisfyingsay esttay(elway)"

#: src/code/seq.lisp
msgid ""
"Returns the first element in SEQUENCE satisfying the test (default\n"
"   is EQL) with the given ITEM"
msgstr ""
"Eturnsray ethay irstfay elementway inway SEQUENCE atisfyingsay ethay esttay "
"(efaultday\n"
"   isway EQL) ithway ethay ivengay ITEM"

#: src/code/seq.lisp
msgid "Returns the first element in SEQUENCE satisfying the test."
msgstr ""
"Eturnsray ethay irstfay elementway inway SEQUENCE atisfyingsay ethay esttay."

#: src/code/seq.lisp
msgid "Returns the first element in SEQUENCE not satisfying the test."
msgstr ""
"Eturnsray ethay irstfay elementway inway SEQUENCE otnay atisfyingsay ethay "
"esttay."

#: src/code/seq.lisp
msgid ""
"Returns the number of elements in SEQUENCE satisfying a test with ITEM,\n"
"   which defaults to EQL."
msgstr ""
"Eturnsray ethay umbernay ofway elementsway inway SEQUENCE atisfyingsay away "
"esttay ithway ITEM,\n"
"   ichwhay efaultsday otay EQL."

#: src/code/seq.lisp
msgid ":TEST and :TEST-NOT are both present."
msgstr ":TEST andway :TEST-NOT areway othbay esentpray."

#: src/code/seq.lisp
msgid "Returns the number of elements in SEQUENCE satisfying TEST(el)."
msgstr ""
"Eturnsray ethay umbernay ofway elementsway inway SEQUENCE atisfyingsay "
"TEST(elway)."

#: src/code/seq.lisp
msgid ""
"The specified subsequences of Sequence1 and Sequence2 are compared\n"
"   element-wise.  If they are of equal length and match in every element, "
"the\n"
"   result is NIL.  Otherwise, the result is a non-negative integer, the "
"index\n"
"   within Sequence1 of the leftmost position at which they fail to match; "
"or,\n"
"   if one is shorter than and a matching prefix of the other, the index "
"within\n"
"   Sequence1 beyond the last position tested is returned.  If a non-Nil\n"
"   :From-End keyword argument is given, then one plus the index of the\n"
"   rightmost position in which the sequences differ is returned."
msgstr ""
"Ethay ecifiedspay ubsequencessay ofway Equencesay1 andway Equencesay2 areway "
"omparedcay\n"
"   elementway-iseway.  Ifway eythay areway ofway equalway engthlay andway "
"atchmay inway everyway elementway, ethay\n"
"   esultray isway NIL.  Otherwiseway, ethay esultray isway away onnay-"
"egativenay integerway, ethay indexway\n"
"   ithinway Equencesay1 ofway ethay eftmostlay ositionpay atway ichwhay "
"eythay ailfay otay atchmay; orway,\n"
"   ifway oneway isway ortershay anthay andway away atchingmay efixpray ofway "
"ethay otherway, ethay indexway ithinway\n"
"   Equencesay1 eyondbay ethay astlay ositionpay estedtay isway eturnedray.  "
"Ifway away onnay-Ilnay\n"
"   :Omfray-Endway eywordkay argumentway isway ivengay, enthay oneway usplay "
"ethay indexway ofway ethay\n"
"   ightmostray ositionpay inway ichwhay ethay equencessay ifferday isway "
"eturnedray."

#: src/code/seq.lisp
msgid ""
"A search is conducted using EQL for the first subsequence of sequence2 \n"
"   which element-wise matches sequence1.  If there is such a subsequence "
"in \n"
"   sequence2, the index of the its leftmost element is returned; \n"
"   otherwise () is returned."
msgstr ""
"Away earchsay isway onductedcay usingway EQL orfay ethay irstfay "
"ubsequencesay ofway equencesay2 \n"
"   ichwhay elementway-iseway atchesmay equencesay1.  Ifway erethay isway "
"uchsay away ubsequencesay inway \n"
"   equencesay2, ethay indexway ofway ethay itsway eftmostlay elementway "
"isway eturnedray; \n"
"   otherwiseway () isway eturnedray."

#: src/code/string.lisp
msgid ""
"Test if C is a surrogate.  C may be either an integer or a\n"
"  character. Surrogate-type indicates what kind of surrogate to test\n"
"  for.  :High means to test for the high (leading) surrogate; :Low\n"
"  tests for the low (trailing surrogate).  A value of :Any or Nil\n"
"  tests for any surrogate value (high or low)."
msgstr ""
"Esttay ifway C isway away urrogatesay.  C aymay ebay eitherway anway "
"integerway orway away\n"
"  aracterchay. Urrogatesay-ypetay indicatesway atwhay indkay ofway "
"urrogatesay otay esttay\n"
"  orfay.  :Ighhay eansmay otay esttay orfay ethay ighhay (eadinglay) "
"urrogatesay; :Owlay\n"
"  eststay orfay ethay owlay (ailingtray urrogatesay).  Away aluevay ofway :"
"Anyway orway Ilnay\n"
"  eststay orfay anyway urrogatesay aluevay (ighhay orway owlay)."

#: src/code/string.lisp
msgid ""
"Convert the given Hi and Lo surrogate characters to the\n"
"  corresponding codepoint value"
msgstr ""
"Onvertcay ethay ivengay Ihay andway Olay urrogatesay aracterschay otay "
"ethay\n"
"  orrespondingcay odepointcay aluevay"

#: src/code/string.lisp
msgid ""
"Return the codepoint value from String at position I.  If that\n"
"  position is a surrogate, it is combined with either the previous or\n"
"  following character (when possible) to compute the codepoint.  The\n"
"  second return value is NIL if the position is not a surrogate pair.\n"
"  Otherwise +1 or -1 is returned if the position is the high or low\n"
"  surrogate value, respectively."
msgstr ""
"Eturnray ethay odepointcay aluevay omfray Ingstray atway ositionpay Iway.  "
"Ifway atthay\n"
"  ositionpay isway away urrogatesay, itway isway ombinedcay ithway eitherway "
"ethay eviouspray orway\n"
"  ollowingfay aracterchay (enwhay ossiblepay) otay omputecay ethay "
"odepointcay.  Ethay\n"
"  econdsay eturnray aluevay isway NIL ifway ethay ositionpay isway otnay "
"away urrogatesay airpay.\n"
"  Otherwiseway +1 orway -1 isway eturnedray ifway ethay ositionpay isway "
"ethay ighhay orway owlay\n"
"  urrogatesay aluevay, espectivelyray."

#: src/code/string.lisp
#, fuzzy
msgid ""
"WITH-STRING-CODEPOINT-ITERATOR ((next string) &body body)\n"
"  provides a method of looping through a string from the beginning to\n"
"  the end of the string prodcucing successive codepoints from the\n"
"  string.  NEXT is bound to a generator macro that, within the scope\n"
"  of the invocation, returns one or two values. The first value tells\n"
"  whether any objects remain in the string. When the first value is\n"
"  non-NIL, the second value is the codepoint of the next object."
msgstr ""
"WITH-HASH-TABLE-ITERATOR ((unctionfay ashhay-abletay) &odybay odybay)\n"
"   ovidespray away ethodmay ofway anuallymay oopinglay overway ethay "
"elementsway ofway away ashhay-abletay.\n"
"   FUNCTION isway oundbay otay away eneratorgay-acromay atthay, ithinway "
"ethay opescay ofway ethay\n"
"   invocationway, eturnsray oneway orway reethay aluesvay. Ethay irstfay "
"aluevay ellstay etherwhay\n"
"   anyway objectsway emainray inway ethay ashhay abletay. Enwhay ethay "
"irstfay aluevay isway onnay-NIL, \n"
"   ethay econdsay andway irdthay aluesvay areway ethay eykay andway ethay "
"aluevay ofway ethay extnay objectway."

#: src/code/string.lisp
msgid ""
"Return the high and low surrogate characters for Codepoint.  If\n"
"  Codepoint is in the BMP, the first return value is the corresponding\n"
"  character and the second is NIL."
msgstr ""
"Eturnray ethay ighhay andway owlay urrogatesay aracterschay orfay "
"Odepointcay.  Ifway\n"
"  Odepointcay isway inway ethay BMP, ethay irstfay eturnray aluevay isway "
"ethay orrespondingcay\n"
"  aracterchay andway ethay econdsay isway NIL."

#: src/code/string.lisp
msgid ""
"Set the codepoint at string position I to the Codepoint.  If the\n"
"  codepoint requires a surrogate pair, the high (leading surrogate) is\n"
"  stored at position I and the low (trailing) surrogate is stored at\n"
"  I+1"
msgstr ""
"Etsay ethay odepointcay atway ingstray ositionpay Iway otay ethay "
"Odepointcay.  Ifway ethay\n"
"  odepointcay equiresray away urrogatesay airpay, ethay ighhay (eadinglay "
"urrogatesay) isway\n"
"  toredsay atway ositionpay Iway andway ethay owlay (ailingtray) urrogatesay "
"isway toredsay atway\n"
"  Iway+1"

#: src/code/string.lisp
msgid ""
"Check if String is a valid UTF-16 string.  If the string is valid,\n"
"  T is returned.  If the string is not valid, NIL is returned, and the\n"
"  second value is the index into the string of the invalid character.\n"
"  A string is also invalid if it contains any unassigned codepoints."
msgstr ""
"Eckchay ifway Ingstray isway away alidvay UTF-16 ingstray.  Ifway ethay "
"ingstray isway alidvay,\n"
"  T isway eturnedray.  Ifway ethay ingstray isway otnay alidvay, NIL isway "
"eturnedray, andway ethay\n"
"  econdsay aluevay isway ethay indexway intoway ethay ingstray ofway ethay "
"invalidway aracterchay.\n"
"  Away ingstray isway alsoway invalidway ifway itway ontainscay anyway "
"unassignedway odepointscay."

#: src/code/string.lisp
msgid ""
"Coerces X into a string.  If X is a string, X is returned.  If X is a\n"
"  symbol, X's pname is returned.  If X is a character then a one element\n"
"  string containing that character is returned.  If X cannot be coerced\n"
"  into a string, an error occurs."
msgstr ""
"Oercescay X intoway away ingstray.  Ifway X isway away ingstray, X isway "
"eturnedray.  Ifway X isway away\n"
"  ymbolsay, X's namepay isway eturnedray.  Ifway X isway away aracterchay "
"enthay away oneway elementway\n"
"  ingstray ontainingcay atthay aracterchay isway eturnedray.  Ifway X "
"annotcay ebay oercedcay\n"
"  intoway away ingstray, anway errorway occursway."

#: src/code/string.lisp
msgid "~S cannot be coerced to a string."
msgstr "~S annotcay ebay oercedcay otay away ingstray."

#: src/code/string.lisp
msgid ""
"Given a string and a non-negative integer index less than the length of\n"
"  the string, returns the character object representing the character at\n"
"  that position in the string."
msgstr ""
"Ivengay away ingstray andway away onnay-egativenay integerway indexway "
"esslay anthay ethay engthlay ofway\n"
"  ethay ingstray, eturnsray ethay aracterchay objectway epresentingray ethay "
"aracterchay atway\n"
"  atthay ositionpay inway ethay ingstray."

#: src/code/string.lisp
msgid ""
"SCHAR returns the character object at an indexed position in a string\n"
"  just as CHAR does, except the string must be a simple-string."
msgstr ""
"SCHAR eturnsray ethay aracterchay objectway atway anway indexedway "
"ositionpay inway away ingstray\n"
"  ustjay asway CHAR oesday, exceptway ethay ingstray ustmay ebay away "
"implesay-ingstray."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically less than\n"
"  the second string, returns the longest common prefix (using char=)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway "
"exicographicallylay esslay anthay\n"
"  ethay econdsay ingstray, eturnsray ethay ongestlay ommoncay efixpray "
"(usingway archay=)\n"
"  ofway ethay wotay ingsstray. Otherwiseway, eturnsray ()."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically greater than\n"
"  the second string, returns the longest common prefix (using char=)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway "
"exicographicallylay eatergray anthay\n"
"  ethay econdsay ingstray, eturnsray ethay ongestlay ommoncay efixpray "
"(usingway archay=)\n"
"  ofway ethay wotay ingsstray. Otherwiseway, eturnsray ()."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically less than\n"
"  or equal to the second string, returns the longest common prefix\n"
"  (using char=) of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway "
"exicographicallylay esslay anthay\n"
"  orway equalway otay ethay econdsay ingstray, eturnsray ethay ongestlay "
"ommoncay efixpray\n"
"  (usingway archay=) ofway ethay wotay ingsstray. Otherwiseway, eturnsray ()."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically greater\n"
"  than or equal to the second string, returns the longest common prefix\n"
"  (using char=) of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway "
"exicographicallylay eatergray\n"
"  anthay orway equalway otay ethay econdsay ingstray, eturnsray ethay "
"ongestlay ommoncay efixpray\n"
"  (usingway archay=) ofway ethay wotay ingsstray. Otherwiseway, eturnsray ()."

#: src/code/string.lisp
msgid ""
"Given two strings (string1 and string2), and optional integers start1,\n"
"  start2, end1 and end2, compares characters in string1 to characters in\n"
"  string2 (using char=)."
msgstr ""
"Ivengay wotay ingsstray (ingstray1 andway ingstray2), andway optionalway "
"integersway tartsay1,\n"
"  tartsay2, endway1 andway endway2, omparescay aracterschay inway ingstray1 "
"otay aracterschay inway\n"
"  ingstray2 (usingway archay=)."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is not lexicographically equal\n"
"  to the second string, returns the longest common prefix (using char=)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway otnay "
"exicographicallylay equalway\n"
"  otay ethay econdsay ingstray, eturnsray ethay ongestlay ommoncay efixpray "
"(usingway archay=)\n"
"  ofway ethay wotay ingsstray. Otherwiseway, eturnsray ()."

#: src/code/string.lisp
msgid ""
"Return a new string with the case folded according to Casing as follows:\n"
"\n"
"  :SIMPLE  Unicode simple case folding (preserving length)\n"
"  :FULL    Unicode full case folding (possibly changing length)\n"
"\n"
"  Default Casing is :SIMPLE."
msgstr ""
"Eturnray away ewnay ingstray ithway ethay asecay oldedfay accordingway otay "
"Asingcay asway ollowsfay:\n"
"\n"
"  :SIMPLE  Unicodeway implesay asecay oldingfay (eservingpray engthlay)\n"
"  :FULL    Unicodeway ullfay asecay oldingfay (ossiblypay angingchay "
"engthlay)\n"
"\n"
"  Efaultday Asingcay isway :SIMPLE."

#: src/code/string.lisp
msgid ""
"Given two strings (string1 and string2), and optional integers start1,\n"
"  start2, end1 and end2, compares characters in string1 to characters in\n"
"  string2 (using char-equal)."
msgstr ""
"Ivengay wotay ingsstray (ingstray1 andway ingstray2), andway optionalway "
"integersway tartsay1,\n"
"  tartsay2, endway1 andway endway2, omparescay aracterschay inway ingstray1 "
"otay aracterschay inway\n"
"  ingstray2 (usingway archay-equalway)."

#: src/code/string.lisp
msgid "Improper bounds for string comparison."
msgstr "Improperway oundsbay orfay ingstray omparisoncay."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is not lexicographically equal\n"
"  to the second string, returns the longest common prefix (using char-"
"equal)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway otnay "
"exicographicallylay equalway\n"
"  otay ethay econdsay ingstray, eturnsray ethay ongestlay ommoncay efixpray "
"(usingway archay-equalway)\n"
"  ofway ethay wotay ingsstray. Otherwiseway, eturnsray ()."

#: src/code/string.lisp
msgid "Improper substring for comparison."
msgstr "Improperway ubstringsay orfay omparisoncay."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically less than\n"
"  the second string, returns the longest common prefix (using char-equal)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway "
"exicographicallylay esslay anthay\n"
"  ethay econdsay ingstray, eturnsray ethay ongestlay ommoncay efixpray "
"(usingway archay-equalway)\n"
"  ofway ethay wotay ingsstray. Otherwiseway, eturnsray ()."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically greater than\n"
"  the second string, returns the longest common prefix (using char-equal)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway "
"exicographicallylay eatergray anthay\n"
"  ethay econdsay ingstray, eturnsray ethay ongestlay ommoncay efixpray "
"(usingway archay-equalway)\n"
"  ofway ethay wotay ingsstray. Otherwiseway, eturnsray ()."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically greater\n"
"  than or equal to the second string, returns the longest common prefix\n"
"  (using char-equal) of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway "
"exicographicallylay eatergray\n"
"  anthay orway equalway otay ethay econdsay ingstray, eturnsray ethay "
"ongestlay ommoncay efixpray\n"
"  (usingway archay-equalway) ofway ethay wotay ingsstray. Otherwiseway, "
"eturnsray ()."

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically less than\n"
"  or equal to the second string, returns the longest common prefix\n"
"  (using char-equal) of the two strings. Otherwise, returns ()."
msgstr ""
"Ivengay wotay ingsstray, ifway ethay irstfay ingstray isway "
"exicographicallylay esslay anthay\n"
"  orway equalway otay ethay econdsay ingstray, eturnsray ethay ongestlay "
"ommoncay efixpray\n"
"  (usingway archay-equalway) ofway ethay wotay ingsstray. Otherwiseway, "
"eturnsray ()."

#: src/code/string.lisp
msgid ""
"Given a character count and an optional fill character, makes and returns\n"
"  a new string Count long filled with the fill character."
msgstr ""
"Ivengay away aracterchay ountcay andway anway optionalway illfay "
"aracterchay, akesmay andway eturnsray\n"
"  away ewnay ingstray Ountcay onglay illedfay ithway ethay illfay "
"aracterchay."

#: src/code/unicode.lisp src/code/string.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with all\n"
"  lower case alphabetic characters converted to uppercase."
msgstr ""
"Ivengay away ingstray, eturnsray away ewnay ingstray atthay isway away "
"opycay ofway itway ithway allway\n"
"  owerlay asecay alphabeticway aracterschay onvertedcay otay uppercaseway."

#: src/code/unicode.lisp src/code/string.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with all\n"
"  upper case alphabetic characters converted to lowercase."
msgstr ""
"Ivengay away ingstray, eturnsray away ewnay ingstray atthay isway away "
"opycay ofway itway ithway allway\n"
"  upperway asecay alphabeticway aracterschay onvertedcay otay owercaselay."

#: src/code/unicode.lisp src/code/string.lisp
msgid ""
"Given a string, returns a copy of the string with the first\n"
"  character of each ``word'' converted to upper-case, and remaining\n"
"  chars in the word converted to lower case. A ``word'' is defined\n"
"  to be a string of case-modifiable characters delimited by\n"
"  non-case-modifiable chars."
msgstr ""
"Ivengay away ingstray, eturnsray away opycay ofway ethay ingstray ithway "
"ethay irstfay\n"
"  aracterchay ofway eachway ``ordway'' onvertedcay otay upperway-asecay, "
"andway emainingray\n"
"  arschay inway ethay ordway onvertedcay otay owerlay asecay. Away "
"``ordway'' isway efinedday\n"
"  otay ebay away ingstray ofway asecay-odifiablemay aracterschay elimitedday "
"ybay\n"
"  onnay-asecay-odifiablemay arschay."

#: src/code/string.lisp
msgid ""
"Given a string, returns that string with all lower case alphabetic\n"
"  characters converted to uppercase."
msgstr ""
"Ivengay away ingstray, eturnsray atthay ingstray ithway allway owerlay "
"asecay alphabeticway\n"
"  aracterschay onvertedcay otay uppercaseway."

#: src/code/string.lisp
msgid ""
"Given a string, returns that string with all upper case alphabetic\n"
"  characters converted to lowercase."
msgstr ""
"Ivengay away ingstray, eturnsray atthay ingstray ithway allway upperway "
"asecay alphabeticway\n"
"  aracterschay onvertedcay otay owercaselay."

#: src/code/string.lisp
msgid ""
"Given a string, returns that string with the first\n"
"  character of each ``word'' converted to upper-case, and remaining\n"
"  chars in the word converted to lower case. A ``word'' is defined\n"
"  to be a string of case-modifiable characters delimited by\n"
"  non-case-modifiable chars."
msgstr ""
"Ivengay away ingstray, eturnsray atthay ingstray ithway ethay irstfay\n"
"  aracterchay ofway eachway ``ordway'' onvertedcay otay upperway-asecay, "
"andway emainingray\n"
"  arschay inway ethay ordway onvertedcay otay owerlay asecay. Away "
"``ordway'' isway efinedday\n"
"  otay ebay away ingstray ofway asecay-odifiablemay aracterschay elimitedday "
"ybay\n"
"  onnay-asecay-odifiablemay arschay."

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns\n"
"  a copy of the string with the characters in the set removed from the\n"
"  left end.  If the set of characters is a string, surrogates will be\n"
"  properly handled."
msgstr ""
"Ivengay away etsay ofway aracterschay (away istlay orway ingstray) andway "
"away ingstray, eturnsray\n"
"  away opycay ofway ethay ingstray ithway ethay aracterschay inway ethay "
"etsay emovedray omfray ethay\n"
"  eftlay endway.  Ifway ethay etsay ofway aracterschay isway away ingstray, "
"urrogatessay illway ebay\n"
"  operlypray andledhay."

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns\n"
"  a copy of the string with the characters in the set removed from the\n"
"  right end.  If the set of characters is a string, surrogates will be\n"
"  properly handled."
msgstr ""
"Ivengay away etsay ofway aracterschay (away istlay orway ingstray) andway "
"away ingstray, eturnsray\n"
"  away opycay ofway ethay ingstray ithway ethay aracterschay inway ethay "
"etsay emovedray omfray ethay\n"
"  ightray endway.  Ifway ethay etsay ofway aracterschay isway away ingstray, "
"urrogatessay illway ebay\n"
"  operlypray andledhay."

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns a\n"
"  copy of the string with the characters in the set removed from both\n"
"  ends.  If the set of characters is a string, surrogates will be\n"
"  properly handled."
msgstr ""
"Ivengay away etsay ofway aracterschay (away istlay orway ingstray) andway "
"away ingstray, eturnsray away\n"
"  opycay ofway ethay ingstray ithway ethay aracterschay inway ethay etsay "
"emovedray omfray othbay\n"
"  endsway.  Ifway ethay etsay ofway aracterschay isway away ingstray, "
"urrogatessay illway ebay\n"
"  operlypray andledhay."

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns\n"
"  a copy of the string with the characters in the set removed from the\n"
"  left end."
msgstr ""
"Ivengay away etsay ofway aracterschay (away istlay orway ingstray) andway "
"away ingstray, eturnsray\n"
"  away opycay ofway ethay ingstray ithway ethay aracterschay inway ethay "
"etsay emovedray omfray ethay\n"
"  eftlay endway."

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns\n"
"  a copy of the string with the characters in the set removed from the\n"
"  right end."
msgstr ""
"Ivengay away etsay ofway aracterschay (away istlay orway ingstray) andway "
"away ingstray, eturnsray\n"
"  away opycay ofway ethay ingstray ithway ethay aracterschay inway ethay "
"etsay emovedray omfray ethay\n"
"  ightray endway."

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns a\n"
"  copy of the string with the characters in the set removed from both\n"
"  ends."
msgstr ""
"Ivengay away etsay ofway aracterschay (away istlay orway ingstray) andway "
"away ingstray, eturnsray away\n"
"  opycay ofway ethay ingstray ithway ethay aracterschay inway ethay etsay "
"emovedray omfray othbay\n"
"  endsway."

#: src/code/string.lisp
msgid ""
"GLYPH returns the glyph at the indexed position in a string, and the\n"
"  position of the next glyph (or NIL) as a second value.  A glyph is\n"
"  a substring consisting of the character at INDEX followed by all\n"
"  subsequent combining characters."
msgstr ""
"GLYPH eturnsray ethay yphglay atway ethay indexedway ositionpay inway away "
"ingstray, andway ethay\n"
"  ositionpay ofway ethay extnay yphglay (orway NIL) asway away econdsay "
"aluevay.  Away yphglay isway\n"
"  away ubstringsay onsistingcay ofway ethay aracterchay atway INDEX "
"ollowedfay ybay allway\n"
"  ubsequentsay ombiningcay aracterschay."

#: src/code/string.lisp
msgid ""
"SGLYPH returns the glyph at the indexed position, the same as GLYPH,\n"
"  except that the string must be a simple-string"
msgstr ""
"SGLYPH eturnsray ethay yphglay atway ethay indexedway ositionpay, ethay "
"amesay asway GLYPH,\n"
"  exceptway atthay ethay ingstray ustmay ebay away implesay-ingstray"

#: src/code/string.lisp
#, fuzzy
msgid ""
"WITH-STRING-GLYPH-ITERATOR ((next string) &body body)\n"
"  provides a method of looping through a string from the beginning to\n"
"  the end of the string prodcucing successive glyphs from the string.\n"
"  NEXT is bound to a generator macro that, within the scope of the\n"
"  invocation, returns one or three values. The first value tells\n"
"  whether any objects remain in the string. When the first value is\n"
"  non-NIL, the second value is the index into the string of the glyph\n"
"  and the third value is index of the next glyph."
msgstr ""
"WITH-HASH-TABLE-ITERATOR ((unctionfay ashhay-abletay) &odybay odybay)\n"
"   ovidespray away ethodmay ofway anuallymay oopinglay overway ethay "
"elementsway ofway away ashhay-abletay.\n"
"   FUNCTION isway oundbay otay away eneratorgay-acromay atthay, ithinway "
"ethay opescay ofway ethay\n"
"   invocationway, eturnsray oneway orway reethay aluesvay. Ethay irstfay "
"aluevay ellstay etherwhay\n"
"   anyway objectsway emainray inway ethay ashhay abletay. Enwhay ethay "
"irstfay aluevay isway onnay-NIL, \n"
"   ethay econdsay andway irdthay aluesvay areway ethay eykay andway ethay "
"aluevay ofway ethay extnay objectway."

#: src/code/string.lisp
msgid ""
"Convert String to Unicode Normalization Form D (NFD) using the\n"
"  canonical decomposition.  The NFD string is returned"
msgstr ""
"Onvertcay Ingstray otay Unicodeway Ormalizationnay Ormfay D (NFD) usingway "
"ethay\n"
"  anonicalcay ecompositionday.  Ethay NFD ingstray isway eturnedray"

#: src/code/string.lisp
msgid ""
"Convert String to Unicode Normalization Form KD (NFKD) uisng the\n"
"  compatible decomposition form.  The NFKD string is returned."
msgstr ""
"Onvertcay Ingstray otay Unicodeway Ormalizationnay Ormfay KD (NFKD) uisngway "
"ethay\n"
"  ompatiblecay ecompositionday ormfay.  Ethay NFKD ingstray isway eturnedray."

#: src/code/string.lisp
msgid ""
"Convert String to Unicode Normalization Form C (NFC).  If the\n"
"  string a simple string and is already normalized, the original\n"
"  string is returned."
msgstr ""
"Onvertcay Ingstray otay Unicodeway Ormalizationnay Ormfay C (NFC).  Ifway "
"ethay\n"
"  ingstray away implesay ingstray andway isway alreadyway ormalizednay, "
"ethay originalway\n"
"  ingstray isway eturnedray."

#: src/code/string.lisp
msgid ""
"Convert String to Unicode Normalization Form KC (NFKC).  If the\n"
"  string is a simple string and is already normalized, the original\n"
"  string is returned."
msgstr ""
"Onvertcay Ingstray otay Unicodeway Ormalizationnay Ormfay KC (NFKC).  Ifway "
"ethay\n"
"  ingstray isway away implesay ingstray andway isway alreadyway "
"ormalizednay, ethay originalway\n"
"  ingstray isway eturnedray."

#: src/code/string.lisp
msgid ""
"Convert STRING to NFD (or NFKD).  If :darwinp is non-NIL, then\n"
"  characters in the ranges U2000-U2FFF, UF900-UFA6A, and U2F800-U2FA1D\n"
"  are not decomposed, as specified for Darwin pathnames."
msgstr ""

#: src/code/string.lisp
msgid ""
"Convert a sequence of codepoints to a string.  Codepoints outside\n"
"  the basic multilingual plane (BMP) are converted into the\n"
"  corresponding surrogate pairs."
msgstr ""
"Onvertcay away equencesay ofway odepointscay otay away ingstray.  "
"Odepointscay outsideway\n"
"  ethay asicbay ultilingualmay aneplay (BMP) areway onvertedcay intoway "
"ethay\n"
"  orrespondingcay urrogatesay airspay."

#: src/code/string.lisp
msgid ""
"Convert a string to a list of corresponding code points.  Surrogate\n"
"  pairs in the string are converted into the correspoinding\n"
"  codepoint."
msgstr ""
"Onvertcay away ingstray otay away istlay ofway orrespondingcay odecay "
"ointspay.  Urrogatesay\n"
"  airspay inway ethay ingstray areway onvertedcay intoway ethay "
"orrespoindingcay\n"
"  odepointcay."

#: src/code/mipsstrops.lisp
msgid ""
"Compares the substrings specified by String1 and String2 and returns\n"
"NIL if the strings are String=, or the lowest index of String1 in\n"
"which the two differ. If one string is longer than the other and the\n"
"shorter is a prefix of the longer, the length of the shorter + start1 is\n"
"returned. This would be done on the Vax with CMPC3. The arguments must\n"
"be simple strings."
msgstr ""
"Omparescay ethay ubstringssay ecifiedspay ybay Ingstray1 andway Ingstray2 "
"andway eturnsray\n"
"NIL ifway ethay ingsstray areway Ingstray=, orway ethay owestlay indexway "
"ofway Ingstray1 inway\n"
"ichwhay ethay wotay ifferday. Ifway oneway ingstray isway ongerlay anthay "
"ethay otherway andway ethay\n"
"ortershay isway away efixpray ofway ethay ongerlay, ethay engthlay ofway "
"ethay ortershay + tartsay1 isway\n"
"eturnedray. Isthay ouldway ebay oneday onway ethay Axvay ithway CMPC3. Ethay "
"argumentsway ustmay\n"
"ebay implesay ingsstray."

#: src/code/mipsstrops.lisp
msgid "Like %sp-string-compare, only backwards."
msgstr "Ikelay %spay-ingstray-omparecay, onlyway ackwardsbay."

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Find-Character-With-Attribute  String, Start, End, Table, Mask\n"
"  The codes of the characters of String from Start to End are used as "
"indices\n"
"  into the Table, which is a U-Vector of 8-bit bytes. When the number "
"picked\n"
"  up from the table bitwise ANDed with Mask is non-zero, the current\n"
"  index into the String is returned. The corresponds to SCANC on the Vax."
msgstr ""
"%SP-Indfay-Aracterchay-Ithway-Attributeway  Ingstray, Tartsay, Endway, "
"Abletay, Askmay\n"
"  Ethay odescay ofway ethay aracterschay ofway Ingstray omfray Tartsay otay "
"Endway areway usedway asway indicesway\n"
"  intoway ethay Abletay, ichwhay isway away U-Ectorvay ofway 8-itbay "
"ytesbay. Enwhay ethay umbernay ickedpay\n"
"  upway omfray ethay abletay itwisebay Andedway ithway Askmay isway onnay-"
"erozay, ethay urrentcay\n"
"  indexway intoway ethay Ingstray isway eturnedray. Ethay orrespondscay otay "
"SCANC onway ethay Axvay."

#: src/code/mipsstrops.lisp
msgid "Like %SP-Find-Character-With-Attribute, only sdrawkcaB."
msgstr ""
"Ikelay %SP-Indfay-Aracterchay-Ithway-Attributeway, onlyway drawkcabsay."

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Find-Character  String, Start, End, Character\n"
"  Searches String for the Character from Start to End.  If the character is\n"
"  found, the corresponding index into String is returned, otherwise NIL is\n"
"  returned."
msgstr ""
"%SP-Indfay-Aracterchay  Ingstray, Tartsay, Endway, Aracterchay\n"
"  Earchessay Ingstray orfay ethay Aracterchay omfray Tartsay otay Endway.  "
"Ifway ethay aracterchay isway\n"
"  oundfay, ethay orrespondingcay indexway intoway Ingstray isway eturnedray, "
"otherwiseway NIL isway\n"
"  eturnedray."

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Reverse-Find-Character  String, Start, End, Character\n"
"  Searches String for Character from End to Start.  If the character is\n"
"  found, the corresponding index into String is returned, otherwise NIL is\n"
"  returned."
msgstr ""
"%SP-Everseray-Indfay-Aracterchay  Ingstray, Tartsay, Endway, Aracterchay\n"
"  Earchessay Ingstray orfay Aracterchay omfray Endway otay Tartsay.  Ifway "
"ethay aracterchay isway\n"
"  oundfay, ethay orrespondingcay indexway intoway Ingstray isway eturnedray, "
"otherwiseway NIL isway\n"
"  eturnedray."

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Skip-Character  String, Start, End, Character\n"
"  Returns the index of the first character between Start and End which\n"
"  is not Char=  to Character, or NIL if there is no such character."
msgstr ""
"%SP-Kipsay-Aracterchay  Ingstray, Tartsay, Endway, Aracterchay\n"
"  Eturnsray ethay indexway ofway ethay irstfay aracterchay etweenbay Tartsay "
"andway Endway ichwhay\n"
"  isway otnay Archay=  otay Aracterchay, orway NIL ifway erethay isway onay "
"uchsay aracterchay."

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Skip-Character  String, Start, End, Character\n"
"  Returns the index of the last character between Start and End which\n"
"  is not Char=  to Character, or NIL if there is no such character."
msgstr ""
"%SP-Kipsay-Aracterchay  Ingstray, Tartsay, Endway, Aracterchay\n"
"  Eturnsray ethay indexway ofway ethay astlay aracterchay etweenbay Tartsay "
"andway Endway ichwhay\n"
"  isway otnay Archay=  otay Aracterchay, orway NIL ifway erethay isway onay "
"uchsay aracterchay."

#: src/code/mipsstrops.lisp
msgid ""
"%SP-String-Search  String1, Start1, End1, String2, Start2, End2\n"
"   Searches for the substring of String1 specified in String2.\n"
"   Returns an index into String2 or NIL if the substring wasn't\n"
"   found."
msgstr ""
"%SP-Ingstray-Earchsay  Ingstray1, Tartsay1, Endway1, Ingstray2, Tartsay2, "
"Endway2\n"
"   Earchessay orfay ethay ubstringsay ofway Ingstray1 ecifiedspay inway "
"Ingstray2.\n"
"   Eturnsray anway indexway intoway Ingstray2 orway NIL ifway ethay "
"ubstringsay asnway't\n"
"   oundfay."

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  This symbol's current special\n"
"  value is returned."
msgstr ""
"VARIABLE ustmay evaluateway otay away ymbolsay.  Isthay ymbolsay's urrentcay "
"ecialspay\n"
"  aluevay isway eturnedray."

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  Return NIL if this symbol is\n"
"  unbound, T if it has a value."
msgstr ""
"VARIABLE ustmay evaluateway otay away ymbolsay.  Eturnray NIL ifway isthay "
"ymbolsay isway\n"
"  unboundway, T ifway itway ashay away aluevay."

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  This symbol's special value cell is\n"
"  set to the specified new value."
msgstr ""
"VARIABLE ustmay evaluateway otay away ymbolsay.  Isthay ymbolsay's ecialspay "
"aluevay ellcay isway\n"
"  etsay otay ethay ecifiedspay ewnay aluevay."

#: src/code/symbol.lisp
msgid "Nihil ex nihil, can't set NIL."
msgstr "Ihilnay exway ihilnay, ancay't etsay NIL."

#: src/code/symbol.lisp
msgid "Veritas aeterna, can't set T."
msgstr "Eritasvay aeternaway, ancay't etsay T."

#: src/code/symbol.lisp
msgid "Can't set keywords."
msgstr "Ancay't etsay eywordskay."

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  This symbol is made unbound,\n"
"  removing any value it may currently have."
msgstr ""
"VARIABLE ustmay evaluateway otay away ymbolsay.  Isthay ymbolsay isway "
"ademay unboundway,\n"
"  emovingray anyway aluevay itway aymay urrentlycay avehay."

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  This symbol's current definition\n"
"   is returned.  Settable with SETF."
msgstr ""
"VARIABLE ustmay evaluateway otay away ymbolsay.  Isthay ymbolsay's urrentcay "
"efinitionday\n"
"   isway eturnedray.  Ettablesay ithway SETF."

#: src/code/symbol.lisp
msgid "VARIABLE must evaluate to a symbol.  Return its property list."
msgstr ""
"VARIABLE ustmay evaluateway otay away ymbolsay.  Eturnray itsway opertypray "
"istlay."

#: src/code/symbol.lisp
msgid "VARIABLE must evaluate to a symbol.  Return its print name."
msgstr ""
"VARIABLE ustmay evaluateway otay away ymbolsay.  Eturnray itsway intpray "
"amenay."

#: src/code/symbol.lisp
msgid "VARIABLE must evaluate to a symbol.  Return its package."
msgstr ""
"VARIABLE ustmay evaluateway otay away ymbolsay.  Eturnray itsway ackagepay."

#: src/code/symbol.lisp
msgid "Make and return a new symbol with the STRING as its print name."
msgstr ""
"Akemay andway eturnray away ewnay ymbolsay ithway ethay STRING asway itsway "
"intpray amenay."

#: src/code/symbol.lisp
msgid "Return the hash value for symbol."
msgstr "Eturnray ethay ashhay aluevay orfay ymbolsay."

#: src/code/symbol.lisp
msgid ""
"Look on the property list of SYMBOL for the specified INDICATOR.  If this\n"
"  is found, return the associated value, else return DEFAULT."
msgstr ""
"Ooklay onway ethay opertypray istlay ofway SYMBOL orfay ethay ecifiedspay "
"INDICATOR.  Ifway isthay\n"
"  isway oundfay, eturnray ethay associatedway aluevay, elseway eturnray "
"DEFAULT."

#: src/code/symbol.lisp
msgid "~S has an odd number of items in its property list."
msgstr ""
"~S ashay anway oddway umbernay ofway itemsway inway itsway opertypray istlay."

#: src/code/symbol.lisp
msgid ""
"The VALUE is added as a property of SYMBOL under the specified INDICATOR.\n"
"  Returns VALUE."
msgstr ""
"Ethay VALUE isway addedway asway away opertypray ofway SYMBOL underway ethay "
"ecifiedspay INDICATOR.\n"
"  Eturnsray VALUE."

#: src/code/symbol.lisp
msgid ""
"Look on property list of SYMBOL for property with specified\n"
"  INDICATOR.  If found, splice this indicator and its value out of\n"
"  the plist, and return the tail of the original list starting with\n"
"  INDICATOR.  If not found, return () with no side effects.\n"
"\n"
"  NOTE: The ANSI specification requires REMPROP to return true (not false)\n"
"  or false (the symbol NIL). Portable code should not rely on any other "
"value."
msgstr ""
"Ooklay onway opertypray istlay ofway SYMBOL orfay opertypray ithway "
"ecifiedspay\n"
"  INDICATOR.  Ifway oundfay, licespay isthay indicatorway andway itsway "
"aluevay outway ofway\n"
"  ethay istplay, andway eturnray ethay ailtay ofway ethay originalway istlay "
"tartingsay ithway\n"
"  INDICATOR.  Ifway otnay oundfay, eturnray () ithway onay idesay "
"effectsway.\n"
"\n"
"  NOTE: Ethay ANSI ecificationspay equiresray REMPROP otay eturnray uetray "
"(otnay alsefay)\n"
"  orway alsefay (ethay ymbolsay NIL). Ortablepay odecay ouldshay otnay "
"elyray onway anyway otherway aluevay."

#: src/code/symbol.lisp
msgid ""
"Searches the property list stored in Place for an indicator EQ to "
"Indicator.\n"
"  If one is found, the corresponding value is returned, else the Default is\n"
"  returned."
msgstr ""
"Earchessay ethay opertypray istlay toredsay inway Aceplay orfay anway "
"indicatorway EQ otay Indicatorway.\n"
"  Ifway oneway isway oundfay, ethay orrespondingcay aluevay isway "
"eturnedray, elseway ethay Efaultday isway\n"
"  eturnedray."

#: src/code/symbol.lisp
msgid "Malformed property list: ~S"
msgstr "Alformedmay opertypray istlay: ~S"

#: src/code/symbol.lisp
msgid ""
"Like GETF, except that Indicator-List is a list of indicators which will\n"
"  be looked for in the property list stored in Place.  Three values are\n"
"  returned, see manual for details."
msgstr ""
"Ikelay GETF, exceptway atthay Indicatorway-Istlay isway away istlay ofway "
"indicatorsway ichwhay illway\n"
"  ebay ookedlay orfay inway ethay opertypray istlay toredsay inway Aceplay.  "
"Reethay aluesvay areway\n"
"  eturnedray, eesay anualmay orfay etailsday."

#: src/code/symbol.lisp
msgid ""
"Make and return a new uninterned symbol with the same print name\n"
"  as SYMBOL.  If COPY-PROPS is false, the new symbol is neither bound\n"
"  nor fbound and has no properties, else it has a copy of SYMBOL's\n"
"  function, value and property list."
msgstr ""
"Akemay andway eturnray away ewnay uninternedway ymbolsay ithway ethay amesay "
"intpray amenay\n"
"  asway SYMBOL.  Ifway COPY-PROPS isway alsefay, ethay ewnay ymbolsay isway "
"eithernay oundbay\n"
"  ornay boundfay andway ashay onay opertiespray, elseway itway ashay away "
"opycay ofway SYMBOL's\n"
"  unctionfay, aluevay andway opertypray istlay."

#: src/code/symbol.lisp
msgid "Returns true if Object is a symbol in the keyword package."
msgstr ""
"Eturnsray uetray ifway Objectway isway away ymbolsay inway ethay eywordkay "
"ackagepay."

#: src/code/symbol.lisp
msgid "Counter for generating unique GENSYM symbols."
msgstr "Ountercay orfay eneratinggay uniqueway GENSYM ymbolssay."

#: src/code/symbol.lisp
msgid ""
"Creates a new uninterned symbol whose name is a prefix string (defaults\n"
"   to \"G\"), followed by a decimal number.  Thing, when supplied, will\n"
"   alter the prefix if it is a string, or be used for the decimal number\n"
"   if it is a number, of this symbol. The default value of the number is\n"
"   the current value of *gensym-counter* which is incremented each time\n"
"   it is used."
msgstr ""
"Eatescray away ewnay uninternedway ymbolsay osewhay amenay isway away "
"efixpray ingstray (efaultsday\n"
"   otay \"G\"), ollowedfay ybay away ecimalday umbernay.  Ingthay, enwhay "
"uppliedsay, illway\n"
"   alterway ethay efixpray ifway itway isway away ingstray, orway ebay "
"usedway orfay ethay ecimalday umbernay\n"
"   ifway itway isway away umbernay, ofway isthay ymbolsay. Ethay efaultday "
"aluevay ofway ethay umbernay isway\n"
"   ethay urrentcay aluevay ofway *gensym-counter* ichwhay isway "
"incrementedway eachway imetay\n"
"   itway isway usedway."

#: src/code/symbol.lisp
msgid "Creates a new symbol interned in package Package with the given Prefix."
msgstr ""
"Eatescray away ewnay ymbolsay internedway inway ackagepay Ackagepay ithway "
"ethay ivengay Efixpray."

#: src/code/bignum.lisp
msgid ""
"When the bignum pieces are smaller than this many words, we use the\n"
"classical multiplication algorithm instead of recursing all the way\n"
"down to individual words."
msgstr ""
"Enwhay ethay ignumbay iecespay areway mallersay anthay isthay anymay "
"ordsway, eway useway ethay\n"
"assicalclay ultiplicationmay algorithmway insteadway ofway ecursingray "
"allway ethay ayway\n"
"ownday otay individualway ordsway."

#: src/code/bignum.lisp
msgid "Use Karatsuba if the bignums have at least this many bits"
msgstr ""
"Useway Aratsubakay ifway ethay ignumsbay avehay atway eastlay isthay anymay "
"itsbay"

#: src/code/bignum.lisp
msgid "WITH-BIGNUM-BUFFERS ({(var size [init])}*) Form*"
msgstr "WITH-BIGNUM-BUFFERS ({(arvay izesay [initway])}*) Orm*Fay"

#: src/code/bignum.lisp
msgid "Unexpected zero bignums?"
msgstr "Unexpectedway erozay ignumsbay?"

#: src/code/bignum.lisp
msgid "Can't represent result of left shift."
msgstr "Ancay't epresentray esultray ofway eftlay iftshay."

#: src/code/bignum.lisp
msgid "Too large to be represented as a ~S:~%  ~S"
msgstr "Ootay argelay otay ebay epresentedray asway away ~S:~%  ~S"

#: src/code/numbers.lisp
msgid "More types than vars."
msgstr "Oremay ypestay anthay arsvay."

#: src/code/numbers.lisp
msgid "Duplicate case: ~S."
msgstr "Uplicateday asecay: ~S."

#: src/code/numbers.lisp
msgid "More vars than types."
msgstr "Oremay arsvay anthay ypestay."

#: src/code/numbers.lisp
msgid ""
"NUMBER-DISPATCH ({(Var Type)}*) {((Type*) Form*) | (Symbol Arg*)}*\n"
"  A vaguely case-like macro that does number cross-product dispatches.  The\n"
"  Vars are the variables we are dispatching off of.  The Type paired with "
"each\n"
"  Var is used in the error message when no case matches.  Each case "
"specifies a\n"
"  Type for each var, and is executed when that signature holds.  A type may "
"be\n"
"  a list (FOREACH Each-Type*), causing that case to be repeatedly "
"instantiated\n"
"  for every Each-Type.  In the body of each case, any list of the form\n"
"  (DISPATCH-TYPE Var-Name) is substituted with the type of that var in that\n"
"  instance of the case.\n"
"\n"
"  As an alternate to a case spec, there may be a form whose CAR is a "
"symbol.\n"
"  In this case, we apply the CAR of the form to the CDR and treat the result "
"of\n"
"  the call as a list of cases.  This process is not applied recursively."
msgstr ""
"NUMBER-DISPATCH ({(Arvay Ypetay)}*) {((Ype*Tay) Orm*Fay) | (Ymbolsay "
"Arg*Way)}*\n"
"  Away aguelyvay asecay-ikelay acromay atthay oesday umbernay osscray-"
"oductpray ispatchesday.  Ethay\n"
"  Arsvay areway ethay ariablesvay eway areway ispatchingday offway ofway.  "
"Ethay Ypetay airedpay ithway eachway\n"
"  Arvay isway usedway inway ethay errorway essagemay enwhay onay asecay "
"atchesmay.  Eachway asecay ecifiespays away\n"
"  Ypetay orfay eachway arvay, andway isway executedway enwhay atthay "
"ignaturesay oldshay.  Away ypetay aymay ebay\n"
"  away istlay (FOREACH Eachway-Ype*Tay), ausingcay atthay asecay otay ebay "
"epeatedlyray instantiatwayedway\n"
"  orfay everyway Eachway-Ypetay.  Inway ethay odybay ofway eachway asecay, "
"anyway istlay ofway ethay ormfay\n"
"  (DISPATCH-TYPE Arvay-Amenay) isway ubstitutedsay ithway ethay ypetay ofway "
"atthay arvay inway atthay\n"
"  instanceway ofway ethay asecay.\n"
"\n"
"  Asway anway alternateway otay away asecay ecspay, erethay aymay ebay away "
"ormfay osewhay CAR isway away ymbolsay.\n"
"  Inway isthay asecay, eway applyway ethay CAR ofway ethay ormfay otay ethay "
"CDR andway eattray ethay esultray ofway\n"
"  ethay allcay asway away istlay ofway asescay.  Isthay ocesspray isway "
"otnay appliedway ecursivelyray."

#: src/code/numbers.lisp
msgid ""
"Returns the element type of the most specialized COMPLEX number type that\n"
"   can hold parts of type Spec."
msgstr ""
"Eturnsray ethay elementway ypetay ofway ethay ostmay ecializedspay COMPLEX "
"umbernay ypetay atthay\n"
"   ancay oldhay artspay ofway ypetay Ecspay."

#: src/code/numbers.lisp
msgid "Assume this is a subtype of REAL anyway."
msgstr "Assumeway isthay isway away ubtypesay ofway REAL anywayway."

#: src/code/numbers.lisp
msgid "Cannot determine if ~S is a subtype of REAL."
msgstr "Annotcay etermineday ifway ~S isway away ubtypesay ofway REAL."

#: src/code/numbers.lisp
msgid "Complex numbers cannot have components of type ~S."
msgstr "Omplexcay umbersnay annotcay avehay omponentscay ofway ypetay ~S."

#: src/code/numbers.lisp
msgid "Builds a complex number from the specified components."
msgstr ""
"Uildsbay away omplexcay umbernay omfray ethay ecifiedspay omponentscay."

#: src/code/numbers.lisp
msgid "Extracts the real part of a number."
msgstr "Extractsway ethay ealray artpay ofway away umbernay."

#: src/code/numbers.lisp
msgid "Extracts the imaginary part of a number."
msgstr "Extractsway ethay imaginaryway artpay ofway away umbernay."

#: src/code/numbers.lisp
msgid ""
"Returns the complex conjugate of NUMBER.  For non-complex numbers, this is\n"
"  an identity."
msgstr ""
"Eturnsray ethay omplexcay onjugatecay ofway NUMBER.  Orfay onnay-omplexcay "
"umbersnay, isthay isway\n"
"  anway identityway."

#: src/code/numbers.lisp
msgid "If NUMBER is zero, return NUMBER, else return (/ NUMBER (ABS NUMBER))."
msgstr ""
"Ifway NUMBER isway erozay, eturnray NUMBER, elseway eturnray (/ NUMBER (ABS "
"NUMBER))."

#: src/code/numbers.lisp
msgid "Return the numerator of NUMBER, which must be rational."
msgstr ""
"Eturnray ethay umeratornay ofway NUMBER, ichwhay ustmay ebay ationalray."

#: src/code/numbers.lisp
msgid "Return the denominator of NUMBER, which must be rational."
msgstr ""
"Eturnray ethay enominatorday ofway NUMBER, ichwhay ustmay ebay ationalray."

#: src/code/numbers.lisp
msgid "Returns the sum of its arguments.  With no args, returns 0."
msgstr ""
"Eturnsray ethay umsay ofway itsway argumentsway.  Ithway onay argsway, "
"eturnsray 0."

#: src/code/numbers.lisp
msgid "Returns the product of its arguments.  With no args, returns 1."
msgstr ""
"Eturnsray ethay oductpray ofway itsway argumentsway.  Ithway onay argsway, "
"eturnsray 1."

#: src/code/numbers.lisp
msgid ""
"Subtracts the second and all subsequent arguments from the first.\n"
"  With one arg, negates it."
msgstr ""
"Ubtractssay ethay econdsay andway allway ubsequentsay argumentsway omfray "
"ethay irstfay.\n"
"  Ithway oneway argway, egatesnay itway."

#: src/code/numbers.lisp
msgid ""
"Divides the first arg by each of the following arguments, in turn.\n"
"  With one arg, returns reciprocal."
msgstr ""
"Ividesday ethay irstfay argway ybay eachway ofway ethay ollowingfay "
"argumentsway, inway urntay.\n"
"  Ithway oneway argway, eturnsray eciprocalray."

#: src/code/numbers.lisp
msgid "Returns NUMBER + 1."
msgstr "Eturnsray NUMBER + 1."

#: src/code/numbers.lisp
msgid "Returns NUMBER - 1."
msgstr "Eturnsray NUMBER - 1."

#: src/code/numbers.lisp
msgid ""
"Returns number (or number/divisor) as an integer, rounded toward 0.\n"
"  The second returned value is the remainder."
msgstr ""
"Eturnsray umbernay (orway umbernay/ivisorday) asway anway integerway, "
"oundedray owardtay 0.\n"
"  Ethay econdsay eturnedray aluevay isway ethay emainderray."

#: src/code/numbers.lisp
msgid ""
"Returns the greatest integer not greater than number, or number/divisor.\n"
"  The second returned value is (mod number divisor)."
msgstr ""
"Eturnsray ethay eatestgray integerway otnay eatergray anthay umbernay, orway "
"umbernay/ivisorday.\n"
"  Ethay econdsay eturnedray aluevay isway (odmay umbernay ivisorday)."

#: src/code/numbers.lisp
msgid ""
"Returns the smallest integer not less than number, or number/divisor.\n"
"  The second returned value is the remainder."
msgstr ""
"Eturnsray ethay mallestsay integerway otnay esslay anthay umbernay, orway "
"umbernay/ivisorday.\n"
"  Ethay econdsay eturnedray aluevay isway ethay emainderray."

#: src/code/numbers.lisp
msgid ""
"Rounds number (or number/divisor) to nearest integer.\n"
"  The second returned value is the remainder."
msgstr ""
"Oundsray umbernay (orway umbernay/ivisorday) otay earestnay integerway.\n"
"  Ethay econdsay eturnedray aluevay isway ethay emainderray."

#: src/code/numbers.lisp
msgid "Returns second result of TRUNCATE."
msgstr "Eturnsray econdsay esultray ofway TRUNCATE."

#: src/code/numbers.lisp
msgid "Returns second result of FLOOR."
msgstr "Eturnsray econdsay esultray ofway FLOOR."

#: src/code/numbers.lisp
msgid "Same as TRUNCATE, but returns first value as a float."
msgstr ""
"Amesay asway TRUNCATE, utbay eturnsray irstfay aluevay asway away oatflay."

#: src/code/numbers.lisp
msgid "Same as FLOOR, but returns first value as a float."
msgstr ""
"Amesay asway FLOOR, utbay eturnsray irstfay aluevay asway away oatflay."

#: src/code/numbers.lisp
msgid "Same as CEILING, but returns first value as a float."
msgstr ""
"Amesay asway CEILING, utbay eturnsray irstfay aluevay asway away oatflay."

#: src/code/numbers.lisp
msgid "Same as ROUND, but returns first value as a float."
msgstr ""
"Amesay asway ROUND, utbay eturnsray irstfay aluevay asway away oatflay."

#: src/code/numbers.lisp
msgid "Returns T if all of its arguments are numerically equal, NIL otherwise."
msgstr ""
"Eturnsray T ifway allway ofway itsway argumentsway areway umericallynay "
"equalway, NIL otherwiseway."

#: src/code/numbers.lisp
msgid ""
"Returns T if no two of its arguments are numerically equal, NIL otherwise."
msgstr ""
"Eturnsray T ifway onay wotay ofway itsway argumentsway areway umericallynay "
"equalway, NIL otherwiseway."

#: src/code/numbers.lisp
msgid ""
"Returns T if its arguments are in strictly increasing order, NIL otherwise."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray increasingway "
"orderway, NIL otherwiseway."

#: src/code/numbers.lisp
msgid ""
"Returns T if its arguments are in strictly decreasing order, NIL otherwise."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray ecreasingday "
"orderway, NIL otherwiseway."

#: src/code/numbers.lisp
msgid ""
"Returns T if arguments are in strictly non-decreasing order, NIL otherwise."
msgstr ""
"Eturnsray T ifway argumentsway areway inway ictlystray onnay-ecreasingday "
"orderway, NIL otherwiseway."

#: src/code/numbers.lisp
msgid ""
"Returns T if arguments are in strictly non-increasing order, NIL otherwise."
msgstr ""
"Eturnsray T ifway argumentsway areway inway ictlystray onnay-increasingway "
"orderway, NIL otherwiseway."

#: src/code/numbers.lisp
msgid "Returns the greatest of its arguments."
msgstr "Eturnsray ethay eatestgray ofway itsway argumentsway."

#: src/code/numbers.lisp
msgid "Returns the least of its arguments."
msgstr "Eturnsray ethay eastlay ofway itsway argumentsway."

#: src/code/numbers.lisp
msgid "Return T if OBJ1 and OBJ2 represent the same object, otherwise NIL."
msgstr ""
"Eturnray T ifway OBJ1 andway OBJ2 epresentray ethay amesay objectway, "
"otherwiseway NIL."

#: src/code/numbers.lisp
msgid "Returns the bit-wise or of its arguments.  Args must be integers."
msgstr ""
"Eturnsray ethay itbay-iseway orway ofway itsway argumentsway.  Argsway "
"ustmay ebay integersway."

#: src/code/numbers.lisp
msgid ""
"Returns the bit-wise exclusive or of its arguments.  Args must be integers."
msgstr ""
"Eturnsray ethay itbay-iseway exclusiveway orway ofway itsway argumentsway.  "
"Argsway ustmay ebay integersway."

#: src/code/numbers.lisp
msgid "Returns the bit-wise and of its arguments.  Args must be integers."
msgstr ""
"Eturnsray ethay itbay-iseway andway ofway itsway argumentsway.  Argsway "
"ustmay ebay integersway."

#: src/code/numbers.lisp
msgid ""
"Returns the bit-wise equivalence of its arguments.  Args must be integers."
msgstr ""
"Eturnsray ethay itbay-iseway equivalenceway ofway itsway argumentsway.  "
"Argsway ustmay ebay integersway."

#: src/code/numbers.lisp
msgid "Returns the complement of the logical AND of integer1 and integer2."
msgstr ""
"Eturnsray ethay omplementcay ofway ethay ogicallay AND ofway integerway1 "
"andway integerway2."

#: src/code/numbers.lisp
msgid "Returns the complement of the logical OR of integer1 and integer2."
msgstr ""
"Eturnsray ethay omplementcay ofway ethay ogicallay OR ofway integerway1 "
"andway integerway2."

#: src/code/numbers.lisp
msgid "Returns the logical AND of (LOGNOT integer1) and integer2."
msgstr ""
"Eturnsray ethay ogicallay AND ofway (LOGNOT integerway1) andway integerway2."

#: src/code/numbers.lisp
msgid "Returns the logical AND of integer1 and (LOGNOT integer2)."
msgstr ""
"Eturnsray ethay ogicallay AND ofway integerway1 andway (LOGNOT integerway2)."

#: src/code/numbers.lisp
msgid "Returns the logical OR of (LOGNOT integer1) and integer2."
msgstr ""
"Eturnsray ethay ogicallay OR ofway (LOGNOT integerway1) andway integerway2."

#: src/code/numbers.lisp
msgid "Returns the logical OR of integer1 and (LOGNOT integer2)."
msgstr ""
"Eturnsray ethay ogicallay OR ofway integerway1 andway (LOGNOT integerway2)."

#: src/code/numbers.lisp
msgid "Returns the bit-wise logical not of integer."
msgstr "Eturnsray ethay itbay-iseway ogicallay otnay ofway integerway."

#: src/code/numbers.lisp
msgid "Returns the complement of the AND of integer1 and integer2"
msgstr ""
"Eturnsray ethay omplementcay ofway ethay AND ofway integerway1 andway "
"integerway2"

#: src/code/numbers.lisp
msgid "Returns the complement of the OR of integer1 and integer2"
msgstr ""
"Eturnsray ethay omplementcay ofway ethay OR ofway integerway1 andway "
"integerway2"

#: src/code/numbers.lisp
msgid "Returns the AND of (LOGNOT integer1) and integer2"
msgstr "Eturnsray ethay AND ofway (LOGNOT integerway1) andway integerway2"

#: src/code/numbers.lisp
msgid "Returns the AND of integer1 and (LOGNOT integer2)"
msgstr "Eturnsray ethay AND ofway integerway1 andway (LOGNOT integerway2)"

#: src/code/numbers.lisp
msgid "Returns the OR of (LOGNOT integer1) and integer2"
msgstr "Eturnsray ethay OR ofway (LOGNOT integerway1) andway integerway2"

#: src/code/numbers.lisp
msgid "Returns the OR of integer1 and (LOGNOT integer2)"
msgstr "Eturnsray ethay OR ofway integerway1 andway (LOGNOT integerway2)"

#: src/code/numbers.lisp
msgid ""
"Count the number of 1 bits if INTEGER is positive, and the number of 0 bits\n"
"  if INTEGER is negative."
msgstr ""
"Ountcay ethay umbernay ofway 1 itsbay ifway INTEGER isway ositivepay, andway "
"ethay umbernay ofway 0 itsbay\n"
"  ifway INTEGER isway egativenay."

#: src/code/numbers.lisp
msgid ""
"Predicate which returns T if logand of integer1 and integer2 is not zero."
msgstr ""
"Edicatepray ichwhay eturnsray T ifway ogandlay ofway integerway1 andway "
"integerway2 isway otnay erozay."

#: src/code/numbers.lisp
msgid ""
"Predicate returns T if bit index of integer is a 1.  The least\n"
"significant bit of INTEGER is bit 0."
msgstr ""
"Edicatepray eturnsray T ifway itbay indexway ofway integerway isway away 1.  "
"Ethay eastlay\n"
"ignificantsay itbay ofway INTEGER isway itbay 0."

#: src/code/numbers.lisp
msgid ""
"Shifts integer left by count places preserving sign.  - count shifts right."
msgstr ""
"Iftsshay integerway eftlay ybay ountcay acesplay eservingpray ignsay.  - "
"ountcay iftsshay ightray."

#: src/code/numbers.lisp
msgid ""
"Returns the number of significant bits in the absolute value of integer."
msgstr ""
"Eturnsray ethay umbernay ofway ignificantsay itsbay inway ethay absoluteway "
"aluevay ofway integerway."

#: src/code/numbers.lisp
msgid "Returns a byte specifier which may be used by other byte functions."
msgstr ""
"Eturnsray away ytebay ecifierspay ichwhay aymay ebay usedway ybay otherway "
"ytebay unctionsfay."

#: src/code/numbers.lisp
msgid "Returns the size part of the byte specifier bytespec."
msgstr ""
"Eturnsray ethay izesay artpay ofway ethay ytebay ecifierspay ytespecbay."

#: src/code/numbers.lisp
msgid "Returns the position part of the byte specifier bytespec."
msgstr ""
"Eturnsray ethay ositionpay artpay ofway ethay ytebay ecifierspay ytespecbay."

#: src/code/numbers.lisp
msgid "Extract the specified byte from integer, and right justify result."
msgstr ""
"Extractway ethay ecifiedspay ytebay omfray integerway, andway ightray "
"ustifyjay esultray."

#: src/code/numbers.lisp
msgid "Returns T if any of the specified bits in integer are 1's."
msgstr ""
"Eturnsray T ifway anyway ofway ethay ecifiedspay itsbay inway integerway "
"areway 1's."

#: src/code/numbers.lisp
msgid ""
"Extract the specified byte from integer,  but do not right justify result."
msgstr ""
"Extractway ethay ecifiedspay ytebay omfray integerway,  utbay oday otnay "
"ightray ustifyjay esultray."

#: src/code/numbers.lisp
msgid ""
"Returns new integer with newbyte in specified position, newbyte is right "
"justified."
msgstr ""
"Eturnsray ewnay integerway ithway ewbytenay inway ecifiedspay ositionpay, "
"ewbytenay isway ightray ustifiedjay."

#: src/code/numbers.lisp
msgid ""
"Returns new integer with newbyte in specified position, newbyte is not right "
"justified."
msgstr ""
"Eturnsray ewnay integerway ithway ewbytenay inway ecifiedspay ositionpay, "
"ewbytenay isway otnay ightray ustifiedjay."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return 0."
msgstr "Oolebay unctionfay opway, akesmay BOOLE eturnray 0."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return -1."
msgstr "Oolebay unctionfay opway, akesmay BOOLE eturnray -1."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return integer1."
msgstr "Oolebay unctionfay opway, akesmay BOOLE eturnray integerway1."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return integer2."
msgstr "Oolebay unctionfay opway, akesmay BOOLE eturnray integerway2."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return complement of integer1."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray omplementcay ofway "
"integerway1."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return complement of integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray omplementcay ofway "
"integerway2."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logand of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray ogandlay ofway integerway1 "
"andway integerway2."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logior of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray ogiorlay ofway integerway1 "
"andway integerway2."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logxor of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray ogxorlay ofway integerway1 "
"andway integerway2."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logeqv of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray ogeqvlay ofway integerway1 "
"andway integerway2."

#: src/code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return log nand of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray oglay andnay ofway "
"integerway1 andway integerway2."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return lognor of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray ognorlay ofway integerway1 "
"andway integerway2."

#: src/code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return logandc1 of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray ogandclay1 ofway "
"integerway1 andway integerway2."

#: src/code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return logandc2 of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray ogandclay2 ofway "
"integerway1 andway integerway2."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logorc1 of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray ogorclay1 ofway integerway1 "
"andway integerway2."

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logorc2 of integer1 and integer2."
msgstr ""
"Oolebay unctionfay opway, akesmay BOOLE eturnray ogorclay2 ofway integerway1 "
"andway integerway2."

#: src/code/numbers.lisp
msgid ""
"Bit-wise boolean function on two integers.  Function chosen by OP:\n"
"\t0\tBOOLE-CLR\n"
"\t1\tBOOLE-SET\n"
"\t2\tBOOLE-1\n"
"  \t3\tBOOLE-2\n"
"\t4\tBOOLE-C1\n"
"\t5\tBOOLE-C2\n"
"\t6\tBOOLE-AND\n"
"\t7\tBOOLE-IOR\n"
" \t8\tBOOLE-XOR\n"
"\t9\tBOOLE-EQV\n"
"\t10\tBOOLE-NAND\n"
"\t11\tBOOLE-NOR\n"
"\t12\tBOOLE-ANDC1\n"
"\t13\tBOOLE-ANDC2\n"
"\t14\tBOOLE-ORC1\n"
"\t15\tBOOLE-ORC2"
msgstr ""
"Itbay-iseway ooleanbay unctionfay onway wotay integersway.  Unctionfay "
"osenchay ybay OP:\n"
"\t0\tBOOLE-CLR\n"
"\t1\tBOOLE-SET\n"
"\t2\tBOOLE-1\n"
"  \t3\tBOOLE-2\n"
"\t4\tBOOLE-C1\n"
"\t5\tBOOLE-C2\n"
"\t6\tBOOLE-AND\n"
"\t7\tBOOLE-IOR\n"
" \t8\tBOOLE-XOR\n"
"\t9\tBOOLE-EQV\n"
"\t10\tBOOLE-NAND\n"
"\t11\tBOOLE-NOR\n"
"\t12\tBOOLE-ANDC1\n"
"\t13\tBOOLE-ANDC2\n"
"\t14\tBOOLE-ORC1\n"
"\t15\tBOOLE-ORC2"

#: src/code/numbers.lisp
msgid ""
"Returns the greatest common divisor of the arguments, which must be\n"
"  integers.  Gcd with no arguments is defined to be 0."
msgstr ""
"Eturnsray ethay eatestgray ommoncay ivisorday ofway ethay argumentsway, "
"ichwhay ustmay ebay\n"
"  integersway.  Cdgay ithway onay argumentsway isway efinedday otay ebay 0."

#: src/code/numbers.lisp
msgid ""
"Returns the least common multiple of one or more integers.  LCM of no\n"
"  arguments is defined to be 1."
msgstr ""
"Eturnsray ethay eastlay ommoncay ultiplemay ofway oneway orway oremay "
"integersway.  LCM ofway onay\n"
"  argumentsway isway efinedday otay ebay 1."

#: src/code/numbers.lisp
msgid "Returns T iff X is a positive prime integer."
msgstr "Eturnsray T iffway X isway away ositivepay imepray integerway."

#: src/code/numbers.lisp
msgid ""
"Returns the root of the nearest integer less than n which is a perfect\n"
"   square."
msgstr ""
"Eturnsray ethay ootray ofway ethay earestnay integerway esslay anthay n "
"ichwhay isway away erfectpay\n"
"   quaresay."

#: src/code/numbers.lisp
msgid "Returns T if number = 0, NIL otherwise."
msgstr "Eturnsray T ifway umbernay = 0, NIL otherwiseway."

#: src/code/numbers.lisp
msgid "Returns T if number > 0, NIL otherwise."
msgstr "Eturnsray T ifway umbernay > 0, NIL otherwiseway."

#: src/code/numbers.lisp
msgid "Returns T if number < 0, NIL otherwise."
msgstr "Eturnsray T ifway umbernay < 0, NIL otherwiseway."

#: src/code/numbers.lisp
msgid "Returns T if number is odd, NIL otherwise."
msgstr "Eturnsray T ifway umbernay isway oddway, NIL otherwiseway."

#: src/code/numbers.lisp
msgid "Returns T if number is even, NIL otherwise."
msgstr "Eturnsray T ifway umbernay isway evenway, NIL otherwiseway."

#: src/code/float-trap.lisp
msgid "Unknown float trap kind: ~S."
msgstr "Unknownway oatflay aptray indkay: ~S."

#: src/code/float-trap.lisp
#, fuzzy
msgid ""
"Encode the floating-point modes according to the give options and the\n"
"  specified mode, Floating-Point-Modes.  The resulting new mode is\n"
"  returned.  If a keyword is not supplied, then the current value is\n"
"  preserved.  Possible keywords:\n"
"\n"
"   :TRAPS\n"
"       A list of the exception conditions that should cause traps.  "
"Possible\n"
"       exceptions are :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID,\n"
"       :DIVIDE-BY-ZERO, and on the X86 :DENORMALIZED-OPERAND. Initially\n"
"       all traps except :INEXACT are enabled.\n"
"\n"
"   :ROUNDING-MODE\n"
"       The rounding mode to use when the result is not exact.  Possible "
"values\n"
"       are :NEAREST, :POSITIVE-INFINITY, :NEGATIVE-INFINITY and :ZERO.\n"
"       Initially, the rounding mode is :NEAREST.\n"
"\n"
"   :CURRENT-EXCEPTIONS\n"
"   :ACCRUED-EXCEPTIONS\n"
"       These arguments allow setting of the exception flags.  The main use "
"is\n"
"       setting the accrued exceptions to NIL to clear them.\n"
"\n"
"   :FAST-MODE\n"
"       Set the hardware's \"fast mode\" flag, if any.  When set, IEEE\n"
"       conformance or debuggability may be impaired.  Some machines may not\n"
"       have this feature, in which case the value is always NIL.\n"
"\n"
"   GET-FLOATING-POINT-MODES may be used to find the floating point modes\n"
"   currently in effect."
msgstr ""
"Isthay unctionfay etssay optionsway ontrollingcay ethay oatingflay-ointpay "
"ardwarehay.  Ifway away\n"
"  eywordkay isway otnay uppliedsay, enthay ethay urrentcay aluevay isway "
"eservedpray.  Ossiblepay\n"
"  eywordskay:\n"
"\n"
"   :TRAPS\n"
"       Away istlay ofway ethay exceptionway onditionscay atthay ouldshay "
"ausecay apstray.  Ossiblepay\n"
"       exceptionsway areway :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID,\n"
"       :DIVIDE-BY-ZERO, andway onway ethay X86 :DENORMALIZED-OPERAND. "
"Initiallyway\n"
"       allway apstray exceptway :INEXACT areway enabledway.\n"
"\n"
"   :ROUNDING-MODE\n"
"       Ethay oundingray odemay otay useway enwhay ethay esultray isway otnay "
"exactway.  Ossiblepay aluesvay\n"
"       areway :NEAREST, :POSITIVE-INFINITY, :NEGATIVE-INFINITY andway :"
"ZERO.\n"
"       Initiallyway, ethay oundingray odemay isway :NEAREST.\n"
"\n"
"   :CURRENT-EXCEPTIONS\n"
"   :ACCRUED-EXCEPTIONS\n"
"       Esethay argumentsway allowway ettingsay ofway ethay exceptionway "
"agsflay.  Ethay ainmay useway isway\n"
"       ettingsay ethay accruedway exceptionsway otay NIL otay earclay "
"emthay.\n"
"\n"
"   :FAST-MODE\n"
"       Etsay ethay ardwarehay's \"astfay odemay\" agflay, ifway anyway.  "
"Enwhay etsay, IEEE\n"
"       onformancecay orway ebuggabilityday aymay ebay impairedway.  Omesay "
"achinesmay aymay otnay\n"
"       avehay isthay eaturefay, inway ichwhay asecay ethay aluevay isway "
"alwaysway NIL.\n"
"\n"
"   GET-FLOATING-POINT-MODES aymay ebay usedway otay indfay ethay oatingflay "
"ointpay odesmay\n"
"   urrentlycay inway effectway."

#: src/code/float-trap.lisp
msgid "Unknown rounding mode: ~S."
msgstr "Unknownway oundingray odemay: ~S."

#: src/code/float-trap.lisp
msgid ""
"This function sets options controlling the floating-point hardware.  If a\n"
"  keyword is not supplied, then the current value is preserved.  Possible\n"
"  keywords:\n"
"\n"
"   :TRAPS\n"
"       A list of the exception conditions that should cause traps.  "
"Possible\n"
"       exceptions are :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID,\n"
"       :DIVIDE-BY-ZERO, and on the X86 :DENORMALIZED-OPERAND. Initially\n"
"       all traps except :INEXACT are enabled.\n"
"\n"
"   :ROUNDING-MODE\n"
"       The rounding mode to use when the result is not exact.  Possible "
"values\n"
"       are :NEAREST, :POSITIVE-INFINITY, :NEGATIVE-INFINITY and :ZERO.\n"
"       Initially, the rounding mode is :NEAREST.\n"
"\n"
"   :CURRENT-EXCEPTIONS\n"
"   :ACCRUED-EXCEPTIONS\n"
"       These arguments allow setting of the exception flags.  The main use "
"is\n"
"       setting the accrued exceptions to NIL to clear them.\n"
"\n"
"   :FAST-MODE\n"
"       Set the hardware's \"fast mode\" flag, if any.  When set, IEEE\n"
"       conformance or debuggability may be impaired.  Some machines may not\n"
"       have this feature, in which case the value is always NIL.\n"
"\n"
"   GET-FLOATING-POINT-MODES may be used to find the floating point modes\n"
"   currently in effect."
msgstr ""
"Isthay unctionfay etssay optionsway ontrollingcay ethay oatingflay-ointpay "
"ardwarehay.  Ifway away\n"
"  eywordkay isway otnay uppliedsay, enthay ethay urrentcay aluevay isway "
"eservedpray.  Ossiblepay\n"
"  eywordskay:\n"
"\n"
"   :TRAPS\n"
"       Away istlay ofway ethay exceptionway onditionscay atthay ouldshay "
"ausecay apstray.  Ossiblepay\n"
"       exceptionsway areway :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID,\n"
"       :DIVIDE-BY-ZERO, andway onway ethay X86 :DENORMALIZED-OPERAND. "
"Initiallyway\n"
"       allway apstray exceptway :INEXACT areway enabledway.\n"
"\n"
"   :ROUNDING-MODE\n"
"       Ethay oundingray odemay otay useway enwhay ethay esultray isway otnay "
"exactway.  Ossiblepay aluesvay\n"
"       areway :NEAREST, :POSITIVE-INFINITY, :NEGATIVE-INFINITY andway :"
"ZERO.\n"
"       Initiallyway, ethay oundingray odemay isway :NEAREST.\n"
"\n"
"   :CURRENT-EXCEPTIONS\n"
"   :ACCRUED-EXCEPTIONS\n"
"       Esethay argumentsway allowway ettingsay ofway ethay exceptionway "
"agsflay.  Ethay ainmay useway isway\n"
"       ettingsay ethay accruedway exceptionsway otay NIL otay earclay "
"emthay.\n"
"\n"
"   :FAST-MODE\n"
"       Etsay ethay ardwarehay's \"astfay odemay\" agflay, ifway anyway.  "
"Enwhay etsay, IEEE\n"
"       onformancecay orway ebuggabilityday aymay ebay impairedway.  Omesay "
"achinesmay aymay otnay\n"
"       avehay isthay eaturefay, inway ichwhay asecay ethay aluevay isway "
"alwaysway NIL.\n"
"\n"
"   GET-FLOATING-POINT-MODES aymay ebay usedway otay indfay ethay oatingflay "
"ointpay odesmay\n"
"   urrentlycay inway effectway."

#: src/code/float-trap.lisp
#, fuzzy
msgid ""
"This function returns a list representing the state of the floating point\n"
"  modes given in Modes.  The list is in the same format as the keyword "
"arguments to\n"
"  SET-FLOATING-POINT-MODES."
msgstr ""
"Isthay unctionfay eturnsray away istlay epresentingray ethay tatesay ofway "
"ethay oatingflay ointpay\n"
"  odesmay.  Ethay istlay isway inway ethay amesay ormatfay asway ethay "
"eywordkay argumentsway otay\n"
"  SET-FLOATING-POINT-MODES, i.e. \n"
"      (applyway #'etsay-oatingflay-ointpay-odesmay (etgay-oatingflay-ointpay-"
"odesmay))\n"
"\n"
"  etssay ethay oatingflay ointpay odesmay otay eirthay urrentcay aluesvay "
"(andway usthay isway away onay-opway)."

#: src/code/float-trap.lisp
msgid ""
"This function returns a list representing the state of the floating point\n"
"  modes.  The list is in the same format as the keyword arguments to\n"
"  SET-FLOATING-POINT-MODES, i.e. \n"
"      (apply #'set-floating-point-modes (get-floating-point-modes))\n"
"\n"
"  sets the floating point modes to their current values (and thus is a no-"
"op)."
msgstr ""
"Isthay unctionfay eturnsray away istlay epresentingray ethay tatesay ofway "
"ethay oatingflay ointpay\n"
"  odesmay.  Ethay istlay isway inway ethay amesay ormatfay asway ethay "
"eywordkay argumentsway otay\n"
"  SET-FLOATING-POINT-MODES, i.e. \n"
"      (applyway #'etsay-oatingflay-ointpay-odesmay (etgay-oatingflay-ointpay-"
"odesmay))\n"
"\n"
"  etssay ethay oatingflay ointpay odesmay otay eirthay urrentcay aluesvay "
"(andway usthay isway away onay-opway)."

#: src/code/float-trap.lisp
msgid ""
"Current-Float-Trap Trap-Name*\n"
"  Return true if any of the named traps are currently trapped, false\n"
"  otherwise."
msgstr ""
"Urrentcay-Oatflay-Aptray Aptray-Ame*Nay\n"
"  Eturnray uetray ifway anyway ofway ethay amednay apstray areway "
"urrentlycay appedtray, alsefay\n"
"  otherwiseway."

#: src/code/float-trap.lisp
msgid "SIGFPE with no exceptions currently enabled? (si-code = ~D)"
msgstr ""
"SIGFPE ithway onay exceptionsway urrentlycay enabledway? (isay-odecay = ~D)"

#: src/code/float-trap.lisp
msgid ""
"Execute BODY with the floating point exceptions listed in TRAPS\n"
"  masked (disabled).  TRAPS should be a list of possible exceptions\n"
"  which includes :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID and\n"
"  :DIVIDE-BY-ZERO and on the X86 :DENORMALIZED-OPERAND. The respective\n"
"  accrued exceptions are cleared at the start of the body to support\n"
"  their testing within, and restored on exit."
msgstr ""
"Executeway BODY ithway ethay oatingflay ointpay exceptionsway istedlay inway "
"TRAPS\n"
"  askedmay (isabledday).  TRAPS ouldshay ebay away istlay ofway ossiblepay "
"exceptionsway\n"
"  ichwhay includesway :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID andway\n"
"  :DIVIDE-BY-ZERO andway onway ethay X86 :DENORMALIZED-OPERAND. Ethay "
"espectiveray\n"
"  accruedway exceptionsway areway earedclay atway ethay tartsay ofway ethay "
"odybay otay upportsay\n"
"  eirthay estingtay ithinway, andway estoredray onway exitway."

#: src/code/float-trap.lisp
#, fuzzy
msgid ""
"Execute BODY with the floating point exceptions listed in TRAPS\n"
"  enabled.  TRAPS should be a list of possible exceptions which\n"
"  includes :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID and\n"
"  :DIVIDE-BY-ZERO and on the X86 :DENORMALIZED-OPERAND. The respective\n"
"  accrued exceptions are cleared at the start of the body to support\n"
"  their testing within, and restored on exit."
msgstr ""
"Executeway BODY ithway ethay oatingflay ointpay exceptionsway istedlay inway "
"TRAPS\n"
"  askedmay (isabledday).  TRAPS ouldshay ebay away istlay ofway ossiblepay "
"exceptionsway\n"
"  ichwhay includesway :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID andway\n"
"  :DIVIDE-BY-ZERO andway onway ethay X86 :DENORMALIZED-OPERAND. Ethay "
"espectiveray\n"
"  accruedway exceptionsway areway earedclay atway ethay tartsay ofway ethay "
"odybay otay upportsay\n"
"  eirthay estingtay ithinway, andway estoredray onway exitway."

#: src/code/float-trap.lisp
msgid ""
"Execute BODY with the floating-point rounding mode set to\n"
"  ROUNDING-MODE.  ROUNDING-MODE must be a one:\n"
"\n"
"   :NEAREST\n"
"       the default mode of round to nearest even.\n"
"   :ZERO\n"
"       round numbers down towards zero.  Positive numbers round down\n"
"       and negative numbers round up.\n"
"   :POSITIVE-INFINITY\n"
"       round numbers up towards positive infinity.\n"
"   :NEGATIVE-INFINITY\n"
"       round numbers down towards negative infinity.\n"
"\n"
"  These are the same as the possible values for the rounding mode in\n"
"  SET-FLOATING-POINT-MODES.\n"
"\n"
"  Only the rounding mode is restored on exit; other floating-point\n"
"  modes are not modified."
msgstr ""

#: src/code/float.lisp
msgid "Return true if the float X is denormalized."
msgstr "Eturnray uetray ifway ethay oatflay X isway enormalizedday."

#: src/code/float.lisp
msgid "Return true if the float X is an infinity (+ or -)."
msgstr ""
"Eturnray uetray ifway ethay oatflay X isway anway infinityway (+ orway -)."

#: src/code/float.lisp
#, fuzzy
msgid "Return true if the float X is a quiet or signaling NaN (Not a Number)."
msgstr ""
"Eturnray uetray ifway ethay oatflay X isway away appingtray Annay (Otnay "
"away Umbernay)."

#: src/code/float.lisp
#, fuzzy
msgid "Return true if the float X is a signaling NaN (Not a Number)."
msgstr ""
"Eturnray uetray ifway ethay oatflay X isway away appingtray Annay (Otnay "
"away Umbernay)."

#: src/code/float.lisp
msgid "Deprecated.  Use FLOAT-SIGNALING-NAN-P instead."
msgstr ""

#: src/code/float.lisp
msgid ""
"Returns a non-negative number of significant digits in it's float argument.\n"
"  Will be less than FLOAT-DIGITS if denormalized or zero."
msgstr ""
"Eturnsray away onnay-egativenay umbernay ofway ignificantsay igitsday inway "
"itway's oatflay argumentway.\n"
"  Illway ebay esslay anthay FLOAT-DIGITS ifway enormalizedday orway erozay."

#: src/code/float.lisp
msgid ""
"Returns a floating-point number that has the same sign as\n"
"   float1 and, if float2 is given, has the same absolute value\n"
"   as float2."
msgstr ""
"Eturnsray away oatingflay-ointpay umbernay atthay ashay ethay amesay ignsay "
"asway\n"
"   oatflay1 andway, ifway oatflay2 isway ivengay, ashay ethay amesay "
"absoluteway aluevay\n"
"   asway oatflay2."

#: src/code/float.lisp
msgid ""
"Returns a non-negative number of radix-b digits used in the\n"
"   representation of it's argument.  See Common Lisp: The Language\n"
"   by Guy Steele for more details."
msgstr ""
"Eturnsray away onnay-egativenay umbernay ofway adixray-b igitsday usedway "
"inway ethay\n"
"   epresentationray ofway itway's argumentway.  Eesay Ommoncay Isplay: Ethay "
"Anguagelay\n"
"   ybay Uygay Teelesay orfay oremay etailsday."

#: src/code/float.lisp
msgid ""
"Returns (as an integer) the radix b of its floating-point\n"
"   argument."
msgstr ""
"Eturnsray (asway anway integerway) ethay adixray b ofway itsway oatingflay-"
"ointpay\n"
"   argumentway."

#: src/code/irrat.lisp src/code/float.lisp
msgid "Can't decode NAN or infinity: ~S."
msgstr "Ancay't ecodeday NAN orway infinityway: ~S."

#: src/code/float.lisp
msgid ""
"Returns three values:\n"
"   1) an integer representation of the significand.\n"
"   2) the exponent for the power of 2 that the significand must be "
"multiplied\n"
"      by to get the actual value.  This differs from the DECODE-FLOAT "
"exponent\n"
"      by FLOAT-DIGITS, since the significand has been scaled to have all "
"its\n"
"      digits before the radix point.\n"
"   3) -1 or 1 (i.e. the sign of the argument.)"
msgstr ""
"Eturnsray reethay aluesvay:\n"
"   1) anway integerway epresentationray ofway ethay ignificandsay.\n"
"   2) ethay exponentway orfay ethay owerpay ofway 2 atthay ethay "
"ignificandsay ustmay ebay ultipliemayd\n"
"      ybay otay etgay ethay actualway aluevay.  Isthay iffersday omfray "
"ethay DECODE-FLOAT exponentway\n"
"      ybay FLOAT-DIGITS, incesay ethay ignificandsay ashay eenbay aledscay "
"otay avehay allway itsway\n"
"      igitsday eforebay ethay adixray ointpay.\n"
"   3) -1 orway 1 (i.e. ethay ignsay ofway ethay argumentway.)"

#: src/code/float.lisp
msgid ""
"Returns three values:\n"
"   1) a floating-point number representing the significand.  This is always\n"
"      between 0.5 (inclusive) and 1.0 (exclusive).\n"
"   2) an integer representing the exponent.\n"
"   3) -1.0 or 1.0 (i.e. the sign of the argument.)"
msgstr ""
"Eturnsray reethay aluesvay:\n"
"   1) away oatingflay-ointpay umbernay epresentingray ethay ignificandsay.  "
"Isthay isway alwaysway\n"
"      etweenbay 0.5 (inclusiveway) andway 1.0 (exclusiveway).\n"
"   2) anway integerway epresentingray ethay exponentway.\n"
"   3) -1.0 orway 1.0 (i.e. ethay ignsay ofway ethay argumentway.)"

#: src/code/float.lisp
msgid ""
"Returns the value (* f (expt (float 2 f) ex)), but with no unnecessary loss\n"
"  of precision or overflow."
msgstr ""
"Eturnsray ethay aluevay (* f (exptway (oatflay 2 f) exway)), utbay ithway "
"onay unnecessaryway osslay\n"
"  ofway ecisionpray orway overflowway."

#: src/code/float.lisp
msgid ""
"Converts any REAL to a float.  If OTHER is not provided, it returns a\n"
"  SINGLE-FLOAT if NUMBER is not already a FLOAT.  If OTHER is provided, the\n"
"  result is the same float format as OTHER."
msgstr ""
"Onvertscay anyway REAL otay away oatflay.  Ifway OTHER isway otnay "
"ovidedpray, itway eturnsray away\n"
"  SINGLE-FLOAT ifway NUMBER isway otnay alreadyway away FLOAT.  Ifway OTHER "
"isway ovidedpray, ethay\n"
"  esultray isway ethay amesay oatflay ormatfay asway OTHER."

#: src/code/float.lisp
msgid ""
"RATIONAL produces a rational number for any real numeric argument.  This is\n"
"  more efficient than RATIONALIZE, but it assumes that floating-point is\n"
"  completely accurate, giving a result that isn't as pretty."
msgstr ""
"RATIONAL oducespray away ationalray umbernay orfay anyway ealray umericnay "
"argumentway.  Isthay isway\n"
"  oremay efficientway anthay RATIONALIZE, utbay itway assumesway atthay "
"oatingflay-ointpay isway\n"
"  ompletelycay accurateway, ivinggay away esultray atthay isnway't asway "
"ettypray."

#: src/code/float.lisp
msgid ""
"Converts any REAL to a RATIONAL.  Floats are converted to a simple rational\n"
"  representation exploiting the assumption that floats are only accurate to\n"
"  their precision.  RATIONALIZE (and also RATIONAL) preserve the invariant:\n"
"      (= x (float (rationalize x) x))"
msgstr ""
"Onvertscay anyway REAL otay away RATIONAL.  Oatsflay areway onvertedcay otay "
"away implesay ationalray\n"
"  epresentationray exploitingway ethay assumptionway atthay oatsflay areway "
"onlyway accurateway otay\n"
"  eirthay ecisionpray.  RATIONALIZE (andway alsoway RATIONAL) eservepray "
"ethay invariantway:\n"
"      (= x (oatflay (ationalizeray x) x))"

#: src/code/irrat.lisp
msgid "Return e raised to the power NUMBER."
msgstr "Eturnray e aisedray otay ethay owerpay NUMBER."

#: src/code/irrat.lisp
msgid "The absolute value of ~S exceeds limit ~S."
msgstr "Ethay absoluteway aluevay ofway ~S exceedsway imitlay ~S."

#: src/code/irrat.lisp
msgid "Continue with calculation"
msgstr "Ontinuecay ithway alculationcay"

#: src/code/irrat.lisp
msgid "Continue with calculation, update limit"
msgstr "Ontinuecay ithway alculationcay, updateway imitlay"

#: src/code/irrat.lisp
msgid "Returns BASE raised to the POWER."
msgstr "Eturnsray BASE aisedray otay ethay POWER."

#: src/code/irrat.lisp
msgid "Return the logarithm of NUMBER in the base BASE, which defaults to e."
msgstr ""
"Eturnray ethay ogarithmlay ofway NUMBER inway ethay asebay BASE, ichwhay "
"efaultsday otay e."

#: src/code/irrat.lisp
msgid "Return the square root of NUMBER."
msgstr "Eturnray ethay quaresay ootray ofway NUMBER."

#: src/code/irrat.lisp
msgid "Returns the absolute value of the number."
msgstr "Eturnsray ethay absoluteway aluevay ofway ethay umbernay."

#: src/code/irrat.lisp
msgid ""
"Returns the angle part of the polar representation of a complex number.\n"
"  For complex numbers, this is (atan (imagpart number) (realpart number)).\n"
"  For non-complex positive numbers, this is 0.  For non-complex negative\n"
"  numbers this is PI."
msgstr ""
"Eturnsray ethay angleway artpay ofway ethay olarpay epresentationray ofway "
"away omplexcay umbernay.\n"
"  Orfay omplexcay umbersnay, isthay isway (atanway (imagpartway umbernay) "
"(ealpartray umbernay)).\n"
"  Orfay onnay-omplexcay ositivepay umbersnay, isthay isway 0.  Orfay onnay-"
"omplexcay egativenay\n"
"  umbersnay isthay isway PI."

#: src/code/irrat.lisp
msgid "Return the sine of NUMBER."
msgstr "Eturnray ethay inesay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return the cosine of NUMBER."
msgstr "Eturnray ethay osinecay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return the tangent of NUMBER."
msgstr "Eturnray ethay angenttay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return cos(Theta) + i sin(Theta), AKA exp(i Theta)."
msgstr "Eturnray oscay(Etathay) + i insay(Etathay), AKA expway(i Etathay)."

#: src/code/irrat.lisp
msgid "Argument to CIS is complex: ~S"
msgstr "Argumentway otay CIS isway omplexcay: ~S"

#: src/code/irrat.lisp
msgid "Return the arc sine of NUMBER."
msgstr "Eturnray ethay arcway inesay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return the arc cosine of NUMBER."
msgstr "Eturnray ethay arcway osinecay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return the arc tangent of Y if X is omitted or Y/X if X is supplied."
msgstr ""
"Eturnray ethay arcway angenttay ofway Y ifway X isway omittedway orway Y/X "
"ifway X isway uppliedsay."

#: src/code/irrat.lisp
msgid "Return the hyperbolic sine of NUMBER."
msgstr "Eturnray ethay yperbolichay inesay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return the hyperbolic cosine of NUMBER."
msgstr "Eturnray ethay yperbolichay osinecay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return the hyperbolic tangent of NUMBER."
msgstr "Eturnray ethay yperbolichay angenttay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return the hyperbolic arc sine of NUMBER."
msgstr "Eturnray ethay yperbolichay arcway inesay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return the hyperbolic arc cosine of NUMBER."
msgstr "Eturnray ethay yperbolichay arcway osinecay ofway NUMBER."

#: src/code/irrat.lisp
msgid "Return the hyperbolic arc tangent of NUMBER."
msgstr "Eturnray ethay yperbolichay arcway angenttay ofway NUMBER."

#: src/code/irrat.lisp
msgid ""
"Compute 2^N * X without compute 2^N first (use properties of the\n"
"underlying floating-point format"
msgstr ""
"Omputecay 2^N * X ithoutway omputecay 2^N irstfay (useway opertiespray ofway "
"ethay\n"
"underlyingway oatingflay-ointpay ormatfay"

#: src/code/irrat.lisp
msgid ""
"Same as logb but X is not infinity and non-zero and not a NaN, so\n"
"that we can always return an integer"
msgstr ""
"Amesay asway ogblay utbay X isway otnay infinityway andway onnay-erozay "
"andway otnay away Annay, osay\n"
"atthay eway ancay alwaysway eturnray anway integerway"

#: src/code/irrat.lisp
msgid ""
"Compute an integer N such that 1 <= |2^(-N) * x| < 2.\n"
"For the special cases, the following values are used:\n"
"\n"
"    x             logb\n"
"   NaN            NaN\n"
"   +/- infinity   +infinity\n"
"   0              -infinity\n"
msgstr ""
"Omputecay anway integerway N uchsay atthay 1 <= |2^(-N) * x| < 2.\n"
"Orfay ethay ecialspay asescay, ethay ollowingfay aluesvay areway usedway:\n"
"\n"
"    x             ogblay\n"
"   Annay            Annay\n"
"   +/- infinityway   +infinityway\n"
"   0              -infinityway\n"

#: src/code/irrat.lisp
msgid ""
"Create complex number with real part X and imaginary part Y such that\n"
"it has the same type as Z.  If Z has type (complex rational), the X\n"
"and Y are coerced to single-float."
msgstr ""
"Eatecray omplexcay umbernay ithway ealray artpay X andway imaginaryway "
"artpay Y uchsay atthay\n"
"itway ashay ethay amesay ypetay asway Z.  Ifway Z ashay ypetay (omplexcay "
"ationalray), ethay X\n"
"andway Y areway oercedcay otay inglesay-oatflay."

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Principle square root of Z\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""
"Inciplepray quaresay ootray ofway Z\n"
"\n"
"Z aymay ebay anyway umbernay, utbay ethay esultray isway alwaysway away "
"omplexcay."

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute log(2^j*z).\n"
"\n"
"This is for use with J /= 0 only when |z| is huge."
msgstr ""
"Omputecay oglay(2^*zjay).\n"
"\n"
"Isthay isway orfay useway ithway J /= 0 onlyway enwhay |z| isway ugehay."

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Log of Z = log |Z| + i * arg Z\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""
"Oglay ofway Z = oglay |Z| + i * argway Z\n"
"\n"
"Z aymay ebay anyway umbernay, utbay ethay esultray isway alwaysway away "
"omplexcay."

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid "Compute atanh z = (log(1+z) - log(1-z))/2"
msgstr "Omputecay atanhway z = (oglay(1+z) - oglay(1-z))/2"

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid "Compute tanh z = sinh z / cosh z"
msgstr "Omputecay anhtay z = inhsay z / oshcay z"

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute acos z = pi/2 - asin z\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""
"Omputecay acosway z = ipay/2 - asinway z\n"
"\n"
"Z aymay ebay anyway umbernay, utbay ethay esultray isway alwaysway away "
"omplexcay."

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute acosh z = 2 * log(sqrt((z+1)/2) + sqrt((z-1)/2))\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""
"Omputecay acoshway z = 2 * oglay(qrtsay((z+1)/2) + qrtsay((z-1)/2))\n"
"\n"
"Z aymay ebay anyway umbernay, utbay ethay esultray isway alwaysway away "
"omplexcay."

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute asin z = -i*log(i*z + sqrt(1-z^2))\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""
"Omputecay asinway z = -i*logway(i*zway + qrtsay(1-z^2))\n"
"\n"
"Z aymay ebay anyway umbernay, utbay ethay esultray isway alwaysway away "
"omplexcay."

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute asinh z = log(z + sqrt(1 + z*z))\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""
"Omputecay asinhway z = oglay(z + qrtsay(1 + *zzay))\n"
"\n"
"Z aymay ebay anyway umbernay, utbay ethay esultray isway alwaysway away "
"omplexcay."

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute atan z = (log(1+i*z) - log(1-i*z))/(2*i)\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""
"Omputecay atanway z = (oglay(1+i*zway) - oglay(1-i*zway))/(2i*ay)\n"
"\n"
"Z aymay ebay anyway umbernay, utbay ethay esultray isway alwaysway away "
"omplexcay."

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute tan z = -i * tanh(i * z)\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""
"Omputecay antay z = -i * anhtay(i * z)\n"
"\n"
"Z aymay ebay anyway umbernay, utbay ethay esultray isway alwaysway away "
"omplexcay."

#: src/code/irrat-dd.lisp
msgid "log(most-positive-double-double-float)"
msgstr "oglay(ostmay-ositivepay-oubleday-oubleday-oatflay)"

#: src/code/irrat-dd.lisp
msgid "log(least-positive-double-double-float"
msgstr "oglay(eastlay-ositivepay-oubleday-oubleday-oatflay"

#: src/code/irrat-dd.lisp
msgid "log(2)"
msgstr "oglay(2)"

#: src/code/irrat-dd.lisp
msgid "Log base 2 of e"
msgstr "Oglay asebay 2 ofway e"

#: src/code/irrat-dd.lisp
msgid "log2(e)-1"
msgstr "oglay2(e)-1"

#: src/code/irrat-dd.lisp
msgid "Pi"
msgstr "Ipay"

#: src/code/irrat-dd.lisp
msgid "Pi/2"
msgstr "Ipay/2"

#: src/code/irrat-dd.lisp
msgid "Pi/4"
msgstr "Ipay/4"

#: src/code/irrat-dd.lisp
msgid "Sqrt(1/2)"
msgstr "Qrtsay(1/2)"

#: src/code/irrat-dd.lisp
msgid "exp(x) - 1"
msgstr "expway(x) - 1"

#: src/code/irrat-dd.lisp
msgid "396 (hex) digits of 2/pi"
msgstr "396 (exhay) igitsday ofway 2/ipay"

#: src/code/irrat-dd.lisp
msgid "Overflow"
msgstr "Overflowway"

#: src/compiler/proclaim.lisp
msgid ""
"~S uses lambda-list keyword naming convention, but is not a recognized "
"lambda-list keyword."
msgstr ""
"~S usesway ambdalay-istlay eywordkay amingnay onventioncay, utbay isway "
"otnay away ecognizedray ambdalay-istlay eywordkay."

#: src/compiler/proclaim.lisp
msgid "Misplaced &optional in lambda-list: ~S."
msgstr "Isplacedmay &optionalway inway ambdalay-istlay: ~S."

#: src/compiler/proclaim.lisp
msgid "Misplaced &rest in lambda-list: ~S."
msgstr "Isplacedmay &estray inway ambdalay-istlay: ~S."

#: src/compiler/proclaim.lisp
msgid "Misplaced &more in lambda-list: ~S."
msgstr "Isplacedmay &oremay inway ambdalay-istlay: ~S."

#: src/compiler/proclaim.lisp
msgid "Misplaced &key in lambda-list: ~S."
msgstr "Isplacedmay &eykay inway ambdalay-istlay: ~S."

#: src/compiler/proclaim.lisp
msgid "Misplaced &allow-other-keys in lambda-list: ~S."
msgstr "Isplacedmay &allowway-otherway-eyskay inway ambdalay-istlay: ~S."

#: src/compiler/proclaim.lisp
msgid "Misplaced &aux in lambda-list: ~S."
msgstr "Isplacedmay &auxway inway ambdalay-istlay: ~S."

#: src/compiler/proclaim.lisp
msgid "Found garbage in lambda-list when expecting a keyword: ~S."
msgstr ""
"Oundfay arbagegay inway ambdalay-istlay enwhay expectingway away eywordkay: "
"~S."

#: src/compiler/proclaim.lisp
msgid "&rest not followed by required variable."
msgstr "&estray otnay ollowedfay ybay equiredray ariablevay."

#: src/compiler/proclaim.lisp
msgid "Illegal function name: ~S."
msgstr "Illegalway unctionfay amenay: ~S."

#: src/compiler/proclaim.lisp
msgid "Special form is an illegal function name: ~S."
msgstr "Ecialspay ormfay isway anway illegalway unctionfay amenay: ~S."

#: src/compiler/proclaim.lisp
msgid ""
"Defining as a SETF function a name that already has a SETF macro:~\n"
"       ~%  ~S"
msgstr ""
"Efiningday asway away SETF unctionfay away amenay atthay alreadyway ashay "
"away SETF acromay:~\n"
"       ~%  ~S"

#: src/compiler/proclaim.lisp
msgid "Assume redefinition is compatible and allow it"
msgstr "Assumeway edefinitionray isway ompatiblecay andway allowway itway"

#: src/compiler/proclaim.lisp
msgid "Redefining slot accessor ~S for structure type ~S"
msgstr "Edefiningray otslay accessorway ~S orfay ucturestray ypetay ~S"

#: src/compiler/proclaim.lisp
msgid "~S previously defined as a macro."
msgstr "~S eviouslypray efinedday asway away acromay."

#: src/compiler/proclaim.lisp
msgid "Unknown optimization quality ~S in ~S."
msgstr "Unknownway optimizationway alityquay ~S inway ~S."

#: src/compiler/proclaim.lisp
msgid "Malformed optimization quality specifier ~S in ~S."
msgstr "Alformedmay optimizationway alityquay ecifierspay ~S inway ~S."

#: src/compiler/proclaim.lisp
msgid ""
"DECLAIM Declaration*\n"
"  Do a declaration for the global environment."
msgstr ""
"DECLAIM Eclaration*Day\n"
"  Oday away eclarationday orfay ethay obalglay environmentway."

#: src/compiler/ir1tran.lisp src/compiler/proclaim.lisp
msgid "Malformed PROCLAIM spec: ~S."
msgstr "Alformedmay PROCLAIM ecspay: ~S."

#: src/compiler/ir1tran.lisp src/compiler/proclaim.lisp
msgid "Variable name is not a symbol: ~S."
msgstr "Ariablevay amenay isway otnay away ymbolsay: ~S."

#: src/compiler/proclaim.lisp
msgid "Nihil ex nihil, can't declare ~S special."
msgstr "Ihilnay exway ihilnay, ancay't eclareday ~S ecialspay."

#: src/compiler/proclaim.lisp
msgid "Veritas aeterna, can't declare ~S special."
msgstr "Eritasvay aeternaway, ancay't eclareday ~S ecialspay."

#: src/compiler/proclaim.lisp
msgid "Can't declare ~S special, it is a keyword."
msgstr "Ancay't eclareday ~S ecialspay, itway isway away eywordkay."

#: src/compiler/proclaim.lisp
msgid "Proceed anyway."
msgstr "Oceedpray anywayway."

#: src/compiler/proclaim.lisp
msgid "Trying to declare ~S special, which is ~A."
msgstr "Yingtray otay eclareday ~S ecialspay, ichwhay isway ~Away."

#: src/compiler/proclaim.lisp
msgid "a constant"
msgstr "away onstantcay"

#: src/compiler/proclaim.lisp
msgid "an alien variable"
msgstr "anway alienway ariablevay"

#: src/compiler/proclaim.lisp
msgid "a symbol macro"
msgstr "away ymbolsay acromay"

#: src/compiler/ir1tran.lisp src/compiler/proclaim.lisp
msgid "Declared functional type is not a function type: ~S."
msgstr "Eclaredday unctionalfay ypetay isway otnay away unctionfay ypetay: ~S."

#: src/compiler/proclaim.lisp
msgid "Ignoring FTYPE declaration for slot accesor:~%  ~S"
msgstr "Ignoringway FTYPE eclarationday orfay otslay accesorway:~%  ~S"

#: src/compiler/proclaim.lisp
msgid "Declaration to be RECOGNIZED is not a symbol: ~S."
msgstr "Eclarationday otay ebay RECOGNIZED isway otnay away ymbolsay: ~S."

#: src/compiler/proclaim.lisp
msgid "Declaration already names a type: ~S."
msgstr "Eclarationday alreadyway amesnay away ypetay: ~S."

#: src/compiler/ir1tran.lisp src/compiler/proclaim.lisp
msgid "Unrecognized proclamation: ~S."
msgstr "Unrecognizedway oclamationpray: ~S."

#: src/code/unidata.lisp
msgid ""
"Search the Unicode name dictionary for the longest entry that\n"
"  matches STRING.  STRING must be in Unicode name format.  That is, it\n"
"  must be upper case with spaces separating each word.\n"
"\n"
"  Two values are returned.  The first value is index into the codebook\n"
"  that continues the string..  The second value is the length of the\n"
"  substring of string that matches the codebook. "
msgstr ""
"Earchsay ethay Unicodeway amenay ictionaryday orfay ethay ongestlay entryway "
"atthay\n"
"  atchesmay STRING.  STRING ustmay ebay inway Unicodeway amenay ormatfay.  "
"Atthay isway, itway\n"
"  ustmay ebay upperway asecay ithway acesspay eparatingsay eachway ordway.\n"
"\n"
"  Wotay aluesvay areway eturnedray.  Ethay irstfay aluevay isway indexway "
"intoway ethay odebookcay\n"
"  atthay ontinuescay ethay ingstray..  Ethay econdsay aluevay isway ethay "
"engthlay ofway ethay\n"
"  ubstringsay ofway ingstray atthay atchesmay ethay odebookcay. "

#: src/code/unidata.lisp
msgid "The Unicode data file is broken."
msgstr "Ethay Unicodeway ataday ilefay isway okenbray."

#: src/code/unidata.lisp
msgid "Unicode data file is for Unicode ~D.~D.~D"
msgstr "Unicodeway ataday ilefay isway orfay Unicodeway ~D.~D.~D"

#: src/code/unidata.lisp
msgid "No data in file."
msgstr "Onay ataday inway ilefay."

#: src/code/unidata.lisp
msgid "Dictionary of Hangul syllables"
msgstr "Ictionaryday ofway Angulhay yllablessay"

#: src/code/unidata.lisp
msgid "Dictionary of CJK Unified ideographs"
msgstr "Ictionaryday ofway CJK Unifiedway ideographsway"

#: src/code/unidata.lisp
msgid ""
"Try to complete the string Prefix using the dictionary in Dict.\n"
"  Three values are returned: (1) The best match of prefix, (2) a list\n"
"  of possible completions, (3) a boolean indicating whether the best\n"
"  match is a complete unicode name. "
msgstr ""
"Ytray otay ompletecay ethay ingstray Efixpray usingway ethay ictionaryday "
"inway Ictday.\n"
"  Reethay aluesvay areway eturnedray: (1) Ethay estbay atchmay ofway "
"efixpray, (2) away istlay\n"
"  ofway ossiblepay ompletionscay, (3) away ooleanbay indicatingway etherwhay "
"ethay estbay\n"
"  atchmay isway away ompletecay unicodeway amenay. "

#: src/code/unidata.lisp
msgid ""
"Search the dictionary in Dict and return a list of the possible\n"
"  completions starting with Prefix.  If there is no match, NIL is\n"
"  returned."
msgstr ""
"Earchsay ethay ictionaryday inway Ictday andway eturnray away istlay ofway "
"ethay ossiblepay\n"
"  ompletionscay tartingsay ithway Efixpray.  Ifway erethay isway onay "
"atchmay, NIL isway\n"
"  eturnedray."

#: src/code/unidata.lisp
msgid "Build the dictionary for Hangul syllables"
msgstr "Uildbay ethay ictionaryday orfay Angulhay yllablessay"

#: src/code/unidata.lisp
msgid "Build the dictionary for CJK Unified Ideographs"
msgstr "Uildbay ethay ictionaryday orfay CJK Unifiedway Ideographsway"

#: src/code/unidata.lisp
msgid ""
"Load all unicode data and set *UNIDATA-PATH* to NIL.\n"
"Normally, the unicode data is loaded as needed.  This loads all of the\n"
"data, which is useful for creating a core that no longer needs\n"
"unidata.bin."
msgstr ""
"Oadlay allway unicodeway ataday andway etsay *UNIDATA-PATH* otay NIL.\n"
"Ormallynay, ethay unicodeway ataday isway oadedlay asway eedednay.  Isthay "
"oadslay allway ofway ethay\n"
"ataday, ichwhay isway usefulway orfay eatingcray away orecay atthay onay "
"ongerlay eedsnay\n"
"unidataway.inbay."

#: src/code/char.lisp
msgid "The upper exclusive bound on values produced by CHAR-CODE."
msgstr ""
"Ethay upperway exclusiveway oundbay onway aluesvay oducedpray ybay CHAR-CODE."

#: src/code/char.lisp
msgid "The upper exclusive bound on the value of a Unicode codepoint"
msgstr ""
"Ethay upperway exclusiveway oundbay onway ethay aluevay ofway away "
"Unicodeway odepointcay"

#: src/code/char.lisp
msgid ""
"A character code strictly larger than this is handled using Unicode\n"
"  rules."
msgstr ""

#: src/code/char.lisp
#, fuzzy
msgid ""
"Number of bits used for the index of the second stage table of the\n"
"  case mapping table."
msgstr ""
"Umbernay ofway itsbay usedway inway ethay eaderhay ordway ofway away ataday "
"ockblay orfay ypeingtay."

#: src/code/char.lisp
msgid ""
"For the character code, CODE, the 32-bit value from the\n"
"  case mapping table that indicates the delta between CODE and the\n"
"  corresponding upper or lower case character for CODE."
msgstr ""

#: src/code/char.lisp
msgid ""
"Compute the lower-case character code for the given character CODE.\n"
"  If no lower-case code exists, just return CODE."
msgstr ""

#: src/code/char.lisp
msgid ""
"Compute the upper-case character code for the given character CODE.\n"
"  If no upper-case code exists, just return CODE."
msgstr ""

#: src/code/char.lisp
msgid ""
"This is the alist of (character-name . character) for characters with\n"
"  long names.  The first name in this list for a given character is used\n"
"  on typeout and is the preferred form for input."
msgstr ""
"Isthay isway ethay alistway ofway (aracterchay-amenay . aracterchay) orfay "
"aracterschay ithway\n"
"  onglay amesnay.  Ethay irstfay amenay inway isthay istlay orfay away "
"ivengay aracterchay isway usedway\n"
"  onway ypeouttay andway isway ethay eferredpray ormfay orfay inputway."

#: src/code/char.lisp
msgid "Returns the integer code of CHAR."
msgstr "Eturnsray ethay integerway odecay ofway CHAR."

#: src/code/char.lisp
msgid ""
"Returns the integer code of CHAR.  This is the same as char-code, as\n"
"   CMU Common Lisp does not implement character bits or fonts."
msgstr ""
"Eturnsray ethay integerway odecay ofway CHAR.  Isthay isway ethay amesay "
"asway archay-odecay, asway\n"
"   CMU Ommoncay Isplay oesday otnay implementway aracterchay itsbay orway "
"ontsfay."

#: src/code/char.lisp
msgid "Returns the character with the code CODE."
msgstr "Eturnsray ethay aracterchay ithway ethay odecay CODE."

#: src/code/char.lisp
msgid ""
"Coerces its argument into a character object if possible.  Accepts\n"
"  characters, strings and symbols of length 1."
msgstr ""
"Oercescay itsway argumentway intoway away aracterchay objectway ifway "
"ossiblepay.  Acceptsway\n"
"  aracterschay, ingsstray andway ymbolssay ofway engthlay 1."

#: src/code/char.lisp
msgid "String is not of length one: ~S"
msgstr "Ingstray isway otnay ofway engthlay oneway: ~S"

#: src/code/char.lisp
msgid "Symbol name is not of length one: ~S"
msgstr "Ymbolsay amenay isway otnay ofway engthlay oneway: ~S"

#: src/code/char.lisp
msgid "~S cannot be coerced to a character."
msgstr "~S annotcay ebay oercedcay otay away aracterchay."

#: src/code/char.lisp
msgid ""
"Given a character object, char-name returns the name for that\n"
"  object (a symbol)."
msgstr ""
"Ivengay away aracterchay objectway, archay-amenay eturnsray ethay amenay "
"orfay atthay\n"
"  objectway (away ymbolsay)."

#: src/code/char.lisp
msgid ""
"Given an argument acceptable to string, name-char returns a character\n"
"  object whose name is that symbol, if one exists, otherwise NIL."
msgstr ""
"Ivengay anway argumentway acceptableway otay ingstray, amenay-archay "
"eturnsray away aracterchay\n"
"  objectway osewhay amenay isway atthay ymbolsay, ifway oneway existsway, "
"otherwiseway NIL."

#: src/code/char.lisp
msgid ""
"The argument must be a character object.  Standard-char-p returns T if the\n"
"   argument is a standard character -- one of the 95 ASCII printing "
"characters\n"
"   or <return>."
msgstr ""
"Ethay argumentway ustmay ebay away aracterchay objectway.  Tandardsay-archay-"
"p eturnsray T ifway ethay\n"
"   argumentway isway away tandardsay aracterchay -- oneway ofway ethay 95 "
"ASCII intingpray aractechaysray\n"
"   orway <eturnray>."

#: src/code/char.lisp
msgid ""
"Return T if and only if THING is a standard-char.  Differs from\n"
"  standard-char-p in that THING doesn't have to be a character."
msgstr ""
"Eturnray T ifway andway onlyway ifway THING isway away tandardsay-archay.  "
"Iffersday omfray\n"
"  tandardsay-archay-p inway atthay THING oesnday't avehay otay ebay away "
"aracterchay."

#: src/code/char.lisp
msgid ""
"The argument must be a character object.  Graphic-char-p returns T if the\n"
"  argument is a printing character, otherwise returns NIL."
msgstr ""
"Ethay argumentway ustmay ebay away aracterchay objectway.  Aphicgray-archay-"
"p eturnsray T ifway ethay\n"
"  argumentway isway away intingpray aracterchay, otherwiseway eturnsray NIL."

#: src/code/char.lisp
msgid ""
"The argument must be a character object.  Alpha-char-p returns T if the\n"
"  argument is an alphabetic character; otherwise NIL."
msgstr ""
"Ethay argumentway ustmay ebay away aracterchay objectway.  Alphaway-archay-p "
"eturnsray T ifway ethay\n"
"  argumentway isway anway alphabeticway aracterchay; otherwiseway NIL."

#: src/code/char.lisp
msgid ""
"The argument must be a character object; upper-case-p returns T if the\n"
"  argument is an upper-case character, NIL otherwise."
msgstr ""
"Ethay argumentway ustmay ebay away aracterchay objectway; upperway-asecay-p "
"eturnsray T ifway ethay\n"
"  argumentway isway anway upperway-asecay aracterchay, NIL otherwiseway."

#: src/code/char.lisp
msgid ""
"The argument must be a character object; lower-case-p returns T if the \n"
"  argument is a lower-case character, NIL otherwise."
msgstr ""
"Ethay argumentway ustmay ebay away aracterchay objectway; owerlay-asecay-p "
"eturnsray T ifway ethay \n"
"  argumentway isway away owerlay-asecay aracterchay, NIL otherwiseway."

#: src/code/char.lisp
msgid ""
"The argument must be a character object.  Both-case-p returns T if the\n"
"  argument is an alphabetic character and if the character exists in\n"
"  both upper and lower case.  For ASCII, this is the same as Alpha-char-p."
msgstr ""
"Ethay argumentway ustmay ebay away aracterchay objectway.  Othbay-asecay-p "
"eturnsray T ifway ethay\n"
"  argumentway isway anway alphabeticway aracterchay andway ifway ethay "
"aracterchay existsway inway\n"
"  othbay upperway andway owerlay asecay.  Orfay ASCII, isthay isway ethay "
"amesay asway Alphaway-archay-p."

#: src/code/char.lisp
msgid ""
"If char is a digit in the specified radix, returns the fixnum for\n"
"  which that digit stands, else returns NIL.  Radix defaults to 10\n"
"  (decimal)."
msgstr ""
"Ifway archay isway away igitday inway ethay ecifiedspay adixray, eturnsray "
"ethay ixnumfay orfay\n"
"  ichwhay atthay igitday tandssay, elseway eturnsray NIL.  Adixray "
"efaultsday otay 10\n"
"  (ecimalday)."

#: src/code/char.lisp
msgid ""
"Given a character-object argument, alphanumericp returns T if the\n"
"  argument is either numeric or alphabetic."
msgstr ""
"Ivengay away aracterchay-objectway argumentway, alphanumericpway eturnsray T "
"ifway ethay\n"
"  argumentway isway eitherway umericnay orway alphabeticway."

#: src/code/char.lisp
msgid "Returns T if all of its arguments are the same character."
msgstr ""
"Eturnsray T ifway allway ofway itsway argumentsway areway ethay amesay "
"aracterchay."

#: src/code/char.lisp
msgid "Returns T if no two of its arguments are the same character."
msgstr ""
"Eturnsray T ifway onay wotay ofway itsway argumentsway areway ethay amesay "
"aracterchay."

#: src/code/char.lisp
msgid "Returns T if its arguments are in strictly increasing alphabetic order."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray increasingway "
"alphabeticway orderway."

#: src/code/char.lisp
msgid "Returns T if its arguments are in strictly decreasing alphabetic order."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray ecreasingday "
"alphabeticway orderway."

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-decreasing alphabetic order."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray onnay-"
"ecreasingday alphabeticway orderway."

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-increasing alphabetic order."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray onnay-"
"increasingway alphabeticway orderway."

#: src/code/char.lisp
msgid ""
"Returns T if all of its arguments are the same character.\n"
"   Case is ignored."
msgstr ""
"Eturnsray T ifway allway ofway itsway argumentsway areway ethay amesay "
"aracterchay.\n"
"   Asecay isway ignoredway."

#: src/code/char.lisp
msgid ""
"Returns T if no two of its arguments are the same character.\n"
"   Case is ignored."
msgstr ""
"Eturnsray T ifway onay wotay ofway itsway argumentsway areway ethay amesay "
"aracterchay.\n"
"   Asecay isway ignoredway."

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly increasing alphabetic order.\n"
"   Case is ignored."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray increasingway "
"alphabeticway orderway.\n"
"   Asecay isway ignoredway."

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly decreasing alphabetic order.\n"
"   Case is ignored."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray ecreasingday "
"alphabeticway orderway.\n"
"   Asecay isway ignoredway."

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-decreasing alphabetic order.\n"
"   Case is ignored."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray onnay-"
"ecreasingday alphabeticway orderway.\n"
"   Asecay isway ignoredway."

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-increasing alphabetic order.\n"
"   Case is ignored."
msgstr ""
"Eturnsray T ifway itsway argumentsway areway inway ictlystray onnay-"
"increasingway alphabeticway orderway.\n"
"   Asecay isway ignoredway."

#: src/code/char.lisp
msgid "Returns CHAR converted to upper-case if that is possible."
msgstr ""
"Eturnsray CHAR onvertedcay otay upperway-asecay ifway atthay isway "
"ossiblepay."

#: src/code/char.lisp
msgid "Returns CHAR converted to lower-case if that is possible."
msgstr ""
"Eturnsray CHAR onvertedcay otay owerlay-asecay ifway atthay isway ossiblepay."

#: src/code/char.lisp
msgid ""
"All arguments must be integers.  Returns a character object that\n"
"  represents a digit of the given weight in the specified radix.  Returns\n"
"  NIL if no such character exists."
msgstr ""
"Allway argumentsway ustmay ebay integersway.  Eturnsray away aracterchay "
"objectway atthay\n"
"  epresentsray away igitday ofway ethay ivengay eightway inway ethay "
"ecifiedspay adixray.  Eturnsray\n"
"  NIL ifway onay uchsay aracterchay existsway."

#: src/code/misc.lisp
msgid ""
"If X is an atom, see if it is present in *FEATURES*.  Also\n"
"  handle arbitrary combinations of atoms using NOT, AND, OR."
msgstr ""
"Ifway X isway anway atomway, eesay ifway itway isway esentpray inway "
"*FEATURES*.  Alsoway\n"
"  andlehay arbitraryway ombinationscay ofway atomsway usingway NOT, AND, OR."

#: src/code/misc.lisp
msgid "Unknown operator in feature expression: ~S."
msgstr "Unknownway operatorway inway eaturefay expressionway: ~S."

#: src/code/misc.lisp
msgid "Returns a string describing the implementation type."
msgstr "Eturnsray away ingstray escribingday ethay implementationway ypetay."

#: src/code/misc.lisp
msgid " Unicode"
msgstr " Unicodeway"

#: src/code/misc.lisp
msgid "Returns a string describing the implementation version."
msgstr ""
"Eturnsray away ingstray escribingday ethay implementationway ersionvay."

#: src/code/misc.lisp
msgid "Returns a string giving the name of the local machine."
msgstr ""
"Eturnsray away ingstray ivinggay ethay amenay ofway ethay ocallay achinemay."

#: src/code/misc.lisp
msgid "The value of SOFTWARE-TYPE.  Set in FOO-os.lisp."
msgstr "Ethay aluevay ofway SOFTWARE-TYPE.  Etsay inway FOO-osway.isplay."

#: src/code/misc.lisp
msgid "Returns a string describing the supporting software."
msgstr "Eturnsray away ingstray escribingday ethay upportingsay oftwaresay."

#: src/code/misc.lisp
#, fuzzy
msgid "Version string for supporting software"
msgstr "Eturnsray away ingstray escribingday ethay upportingsay oftwaresay."

#: src/code/misc.lisp
#, fuzzy
msgid "Returns a string describing version of the supporting software."
msgstr "Eturnsray away ingstray escribingday ethay upportingsay oftwaresay."

#: src/code/misc.lisp
msgid "The value of SHORT-SITE-NAME.  Set in library:site-init.lisp."
msgstr ""
"Ethay aluevay ofway SHORT-SITE-NAME.  Etsay inway ibrarylay:itesay-initway."
"isplay."

#: src/code/misc.lisp
msgid "Returns a string with the abbreviated site name."
msgstr "Eturnsray away ingstray ithway ethay abbreviatedway itesay amenay."

#: src/code/misc.lisp
msgid "The value of LONG-SITE-NAME.  Set in library:site-init.lisp."
msgstr ""
"Ethay aluevay ofway LONG-SITE-NAME.  Etsay inway ibrarylay:itesay-initway."
"isplay."

#: src/code/misc.lisp
msgid "Returns a string with the long form of the site name."
msgstr ""
"Eturnsray away ingstray ithway ethay onglay ormfay ofway ethay itesay amenay."

#: src/code/misc.lisp
msgid ""
"With a file name as an argument, dribble opens the file and\n"
"   sends a record of further I/O to that file.  Without an\n"
"   argument, it closes the dribble file, and quits logging."
msgstr ""
"Ithway away ilefay amenay asway anway argumentway, ibbledray opensway ethay "
"ilefay andway\n"
"   endssay away ecordray ofway urtherfay Iway/O otay atthay ilefay.  "
"Ithoutway anway\n"
"   argumentway, itway osesclay ethay ibbledray ilefay, andway itsquay "
"ogginglay."

#: src/code/misc.lisp
msgid "Not currently dribbling."
msgstr "Otnay urrentlycay ibblingdray."

#: src/code/misc.lisp
msgid ""
"Default implementation of ed.  This does nothing.  If hemlock is\n"
"  loaded, ed can be used to edit a file"
msgstr ""
"Efaultday implementationway ofway edway.  Isthay oesday othingnay.  Ifway "
"emlockhay isway\n"
"  oadedlay, edway ancay ebay usedway otay editway away ilefay"

#: src/code/misc.lisp
#, fuzzy
msgid ""
"Disassemble the machine code associated with OBJECT, which can be a\n"
"  function, a lambda expression, or a symbol with a function definition.  "
"If\n"
"  it is not already compiled, the compiler is called to produce something "
"to\n"
"  disassemble.\n"
"\n"
"  Also see disassem:disassemble for finer control of disassembly."
msgstr ""
"Isassembleday ethay achinemay odecay associatedway ithway OBJECT, ichwhay "
"ancay ebay away\n"
"  unctionfay, away ambdalay expressionway, orway away ymbolsay ithway away "
"unctionfay efinitionday.  Ifway\n"
"  itway isway otnay alreadyway ompiledcay, ethay ompilercay isway alledcay "
"otay oducepray omethingsay otay\n"
"  isassembleday."

#: src/code/misc-doc.lisp
msgid ""
"Returns the documentation string of Doc-Type for X, or NIL if\n"
"  none exists.  System doc-types are VARIABLE, FUNCTION, STRUCTURE, TYPE,\n"
"  SETF, and T."
msgstr ""
"Eturnsray ethay ocumentationday ingstray ofway Ocday-Ypetay orfay X, orway "
"NIL ifway\n"
"  onenay existsway.  Ystemsay ocday-ypestay areway VARIABLE, FUNCTION, "
"STRUCTURE, TYPE,\n"
"  SETF, andway T."

#: src/code/misc-doc.lisp
msgid "~S is not the name of a structure type."
msgstr "~S isway otnay ethay amenay ofway away ucturestray ypetay."

#: src/code/extensions.lisp
msgid ""
"This function can be used as the default value for keyword arguments that\n"
"  must be always be supplied.  Since it is known by the compiler to never\n"
"  return, it will avoid any compile-time type warnings that would result "
"from a\n"
"  default value inconsistent with the declared type.  When this function is\n"
"  called, it signals an error indicating that a required keyword argument "
"was\n"
"  not supplied.  This function is also useful for DEFSTRUCT slot defaults\n"
"  corresponding to required arguments."
msgstr ""
"Isthay unctionfay ancay ebay usedway asway ethay efaultday aluevay orfay "
"eywordkay argumentsway atthay\n"
"  ustmay ebay alwaysway ebay uppliedsay.  Incesay itway isway nownkay ybay "
"ethay ompilercay otay evernay\n"
"  eturnray, itway illway avoidway anyway ompilecay-imetay ypetay arningsway "
"atthay ouldway esultray omfray away\n"
"  efaultday aluevay inconsistentway ithway ethay eclaredday ypetay.  Enwhay "
"isthay unctionfay isway\n"
"  alledcay, itway ignalssay anway errorway indicatingway atthay away "
"equiredray eywordkay argumentway asway\n"
"  otnay uppliedsay.  Isthay unctionfay isway alsoway usefulway orfay "
"DEFSTRUCT otslay efaultsday\n"
"  orrespondingcay otay equiredray argumentsway."

#: src/code/extensions.lisp
msgid "A required keyword argument was not supplied."
msgstr "Away equiredray eywordkay argumentway asway otnay uppliedsay."

#: src/code/extensions.lisp
msgid ""
"FILE-COMMENT String\n"
"  When COMPILE-FILE sees this form at top-level, it places the constant "
"string\n"
"  in the run-time source location information.  DESCRIBE will print the "
"file\n"
"  comment for the file that a function was defined in.  The string is also\n"
"  textually present in the FASL, so the RCS \"ident\" command can find it,\n"
"  etc."
msgstr ""
"FILE-COMMENT Ingstray\n"
"  Enwhay COMPILE-FILE eessay isthay ormfay atway optay-evellay, itway "
"acesplay ethay onstantcay ingstray\n"
"  inway ethay unray-imetay ourcesay ocationlay informationway.  DESCRIBE "
"illway intpray ethay ilefay\n"
"  ommentcay orfay ethay ilefay atthay away unctionfay asway efinedday "
"inway.  Ethay ingstray isway alsoway\n"
"  extuallytay esentpray inway ethay FASL, osay ethay RCS \"identway\" "
"ommandcay ancay indfay itway,\n"
"  etcway."

#: src/code/extensions.lisp
msgid "See listen.  Any whitespace in the input stream will be flushed."
msgstr ""
"Eesay istenlay.  Anyway itespacewhay inway ethay inputway eamstray illway "
"ebay ushedflay."

#: src/code/extensions.lisp
msgid ""
"Does what one might expect, saving the old values and setting the "
"generalized\n"
"  variables to the new values in sequence.  Unwind-protects and get-setf-"
"method\n"
"  are used to preserve the semantics one might expect in analogy to let*,\n"
"  and the once-only evaluation of subforms."
msgstr ""
"Oesday atwhay oneway ightmay expectway, avingsay ethay oldway aluesvay "
"andway ettingsay ethay eneralizegayd\n"
"  ariablesvay otay ethay ewnay aluesvay inway equencesay.  Unwindway-"
"otectspray andway etgay-etfsay-etmayodhay\n"
"  areway usedway otay eservepray ethay emanticssay oneway ightmay expectway "
"inway analogyway otay et*lay,\n"
"  andway ethay onceway-onlyway evaluationway ofway ubformssay."

#: src/code/extensions.lisp
msgid ""
"Like letf*, but evaluates all the implicit subforms and new values of all\n"
"  the implied setfs before altering any values.  However, the store forms\n"
"  (see get-setf-method) must still be evaluated in sequence.  Uses unwind-\n"
"  protects to protect the environment."
msgstr ""
"Ikelay etf*lay, utbay evaluatesway allway ethay implicitway ubformssay "
"andway ewnay aluesvay ofway allway\n"
"  ethay impliedway etfssay eforebay alteringway anyway aluesvay.  Oweverhay, "
"ethay toresay ormsfay\n"
"  (eesay etgay-etfsay-ethodmay) ustmay tillsay ebay evaluatedway inway "
"equencesay.  Usesway unwindway-\n"
"  otectspray otay otectpray ethay environmentway."

#: src/code/extensions.lisp
msgid ""
"Causes the output of the indenting Stream to indent More spaces.  More is\n"
"  evaluated twice."
msgstr ""
"Ausescay ethay outputway ofway ethay indentingway Eamstray otay indentway "
"Oremay acesspay.  Oremay isway\n"
"  evaluatedway wicetay."

#: src/code/extensions.lisp
msgid "Just like dolist, but with one-dimensional arrays."
msgstr "Ustjay ikelay olistday, utbay ithway oneway-imensionalday arraysway."

#: src/code/extensions.lisp
msgid ""
"Iterate Name ({(Var Initial-Value)}*) Declaration* Form*\n"
"  This is syntactic sugar for Labels.  It creates a local function Name "
"with\n"
"  the specified Vars as its arguments and the Declarations and Forms as its\n"
"  body.  This function is then called with the Initial-Values, and the "
"result\n"
"  of the call is return from the macro."
msgstr ""
"Iterateway Amenay ({(Arvay Initialway-Aluevay)}*) Eclaration*Day Orm*Fay\n"
"  Isthay isway yntacticsay ugarsay orfay Abelslay.  Itway eatescray away "
"ocallay unctionfay Amenay ithway\n"
"  ethay ecifiedspay Arsvay asway itsway argumentsway andway ethay "
"Eclarationsday andway Ormsfay asway itsway\n"
"  odybay.  Isthay unctionfay isway enthay alledcay ithway ethay Initialway-"
"Aluesvay, andway ethay esultray\n"
"  ofway ethay allcay isway eturnray omfray ethay acromay."

#: src/code/extensions.lisp
msgid "Malformed iterate variable spec: ~S."
msgstr "Alformedmay iterateway ariablevay ecspay: ~S."

#: src/code/extensions.lisp
msgid ""
"Collect ({(Name [Initial-Value] [Function])}*) {Form}*\n"
"  Collect some values somehow.  Each of the collections specifies a bunch "
"of\n"
"  things which collected during the evaluation of the body of the form.  "
"The\n"
"  name of the collection is used to define a local macro, a la MACROLET.\n"
"  Within the body, this macro will evaluate each of its arguments and "
"collect\n"
"  the result, returning the current value after the collection is done.  "
"The\n"
"  body is evaluated as a PROGN; to get the final values when you are done, "
"just\n"
"  call the collection macro with no arguments.\n"
"\n"
"  Initial-Value is the value that the collection starts out with, which\n"
"  defaults to NIL.  Function is the function which does the collection.  It "
"is\n"
"  a function which will accept two arguments: the value to be collected and "
"the\n"
"  current collection.  The result of the function is made the new value for "
"the\n"
"  collection.  As a totally magical special-case, the Function may be "
"Collect,\n"
"  which tells us to build a list in forward order; this is the default.  If "
"an\n"
"  Initial-Value is supplied for Collect, the stuff will be rplacd'd onto "
"the\n"
"  end.  Note that Function may be anything that can appear in the "
"functional\n"
"  position, including macros and lambdas."
msgstr ""
"Ollectcay ({(Amenay [Initialway-Aluevay] [Unctionfay])}*) {Ormfay}*\n"
"  Ollectcay omesay aluesvay omehowsay.  Eachway ofway ethay ollectionscay "
"ecifiesspay away unchbay ofway\n"
"  ingsthay ichwhay ollectedcay uringday ethay evaluationway ofway ethay "
"odybay ofway ethay ormfay.  Ethay\n"
"  amenay ofway ethay ollectioncay isway usedway otay efineday away ocallay "
"acromay, away alay MACROLET.\n"
"  Ithinway ethay odybay, isthay acromay illway evaluateway eachway ofway "
"itsway argumentsway andway ollectcay\n"
"  ethay esultray, eturningray ethay urrentcay aluevay afterway ethay "
"ollectioncay isway oneday.  Ethay\n"
"  odybay isway evaluatedway asway away PROGN; otay etgay ethay inalfay "
"aluesvay enwhay ouyay areway oneday, ustjay\n"
"  allcay ethay ollectioncay acromay ithway onay argumentsway.\n"
"\n"
"  Initialway-Aluevay isway ethay aluevay atthay ethay ollectioncay tartssay "
"outway ithway, ichwhay\n"
"  efaultsday otay NIL.  Unctionfay isway ethay unctionfay ichwhay oesday "
"ethay ollectioncay.  Itway isway\n"
"  away unctionfay ichwhay illway acceptway wotay argumentsway: ethay aluevay "
"otay ebay ollectedcay andway ethay\n"
"  urrentcay ollectioncay.  Ethay esultray ofway ethay unctionfay isway "
"ademay ethay ewnay aluevay orfay ethay\n"
"  ollectioncay.  Asway away otallytay agicalmay ecialspay-asecay, ethay "
"Unctionfay aymay ebay Ollectcay,\n"
"  ichwhay ellstay usway otay uildbay away istlay inway orwardfay orderway; "
"isthay isway ethay efaultday.  Ifway anway\n"
"  Initialway-Aluevay isway uppliedsay orfay Ollectcay, ethay tuffsay illway "
"ebay placdray'd ontoway ethay\n"
"  endway.  Otenay atthay Unctionfay aymay ebay anythingway atthay ancay "
"appearway inway ethay unctionalfay\n"
"  ositionpay, includingway acrosmay andway ambdaslay."

#: src/code/extensions.lisp
msgid "Malformed collection specifier: ~S."
msgstr "Alformedmay ollectioncay ecifierspay: ~S."

#: src/code/extensions.lisp
msgid ""
"Once-Only ({(Var Value-Expression)}*) Form*\n"
"  Create a Let* which evaluates each Value-Expression, binding a temporary\n"
"  variable to the result, and wrapping the Let* around the result of the\n"
"  evaluation of Body.  Within the body, each Var is bound to the "
"corresponding\n"
"  temporary variable."
msgstr ""
"Onceway-Onlyway ({(Arvay Aluevay-Expressionway)}*) Orm*Fay\n"
"  Eatecray away Et*Lay ichwhay evaluatesway eachway Aluevay-Expressionway, "
"indingbay away emporarytay\n"
"  ariablevay otay ethay esultray, andway appingwray ethay Et*Lay aroundway "
"ethay esultray ofway ethay\n"
"  evaluationway ofway Odybay.  Ithinway ethay odybay, eachway Arvay isway "
"oundbay otay ethay orrespondicaygnay\n"
"  emporarytay ariablevay."

#: src/code/extensions.lisp
msgid "Malformed Once-Only binding spec: ~S."
msgstr "Alformedmay Onceway-Onlyway indingbay ecspay: ~S."

#: src/code/extensions.lisp
msgid "Ill-formed ~S -- possibly illegal old style DO?"
msgstr "Illway-ormedfay ~S -- ossiblypay illegalway oldway tylesay DO?"

#: src/code/extensions.lisp
msgid "~S step variable is not a symbol: ~S"
msgstr "~S tepsay ariablevay isway otnay away ymbolsay: ~S"

#: src/code/extensions.lisp
msgid "~S is an illegal form for a ~S varlist."
msgstr "~S isway anway illegalway ormfay orfay away ~S arlistvay."

#: src/code/extensions.lisp
msgid ""
"DO-ANONYMOUS ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Like DO, but has no implicit NIL block.  Each Var is initialized in "
"parallel\n"
"  to the value of the specified Init form.  On subsequent iterations, the "
"Vars\n"
"  are assigned the value of the Step form (if any) in paralell.  The Test "
"is\n"
"  evaluated before each evaluation of the body Forms.  When the Test is "
"true,\n"
"  the Exit-Forms are evaluated as a PROGN, with the result being the value\n"
"  of the DO."
msgstr ""
"DO-ANONYMOUS ({(Arvay [Initway] [Tepsay])}*) (Esttay Exitway-Orm*Fay) "
"Eclaration*Day Orm*Fay\n"
"  Ikelay DO, utbay ashay onay implicitway NIL ockblay.  Eachway Arvay isway "
"initializedway inway arallelpay\n"
"  otay ethay aluevay ofway ethay ecifiedspay Initway ormfay.  Onway "
"ubsequentsay iterationsway, ethay Arsvay\n"
"  areway assignedway ethay aluevay ofway ethay Tepsay ormfay (ifway anyway) "
"inway aralellpay.  Ethay Esttay isway\n"
"  evaluatedway eforebay eachway evaluationway ofway ethay odybay Ormsfay.  "
"Enwhay ethay Esttay isway uetray,\n"
"  ethay Exitway-Ormsfay areway evaluatedway asway away PROGN, ithway ethay "
"esultray eingbay ethay aluevay\n"
"  ofway ethay DO."

#: src/code/extensions.lisp
msgid ""
"DO-HASH (Key-Var Value-Var Table [Result]) Declaration* Form*\n"
"   Iterate over the entries in a hash-table."
msgstr ""
"DO-HASH (Eykay-Arvay Aluevay-Arvay Abletay [Esultray]) Eclaration*Day "
"Orm*Fay\n"
"   Iterateway overway ethay entriesway inway away ashhay-abletay."

#: src/code/extensions.lisp
msgid ""
"DEFINE-HASH-CACHE Name ({(Arg-Name Test-Function)}*) {Key Value}*\n"
"  Define a hash cache that associates some number of argument values to a\n"
"  result value.  The Test-Function paired with each Arg-Name is used to "
"compare\n"
"  the value for that arg in a cache entry with a supplied arg.  The\n"
"  Test-Function must not error when passed NIL as its first arg, but need "
"not\n"
"  return any particular value.  Test-Function may be any thing that can be\n"
"  place in CAR position.\n"
"\n"
"  Name is used to define functions these functions:\n"
"\n"
"  <name>-CACHE-LOOKUP Arg*\n"
"      See if there is an entry for the specified Args in the cache.  The if "
"not\n"
"      present, the :DEFAULT keyword (default NIL) determines the result(s).\n"
"\n"
"  <name>-CACHE-ENTER Arg* Value*\n"
"      Encache the association of the specified args with Value.\n"
"\n"
"  <name>-CACHE-FLUSH-<arg-name> Arg\n"
"      Flush all entries from the cache that have the value Arg for the "
"named\n"
"      arg.\n"
"\n"
"  <name>-CACHE-CLEAR\n"
"      Reinitialize the cache, invalidating all entries and allowing the\n"
"      arguments and result values to be GC'd.\n"
"\n"
"  These other keywords are defined:\n"
"\n"
"  :HASH-BITS <n>\n"
"      The size of the cache as a power of 2.\n"
"\n"
"  :HASH-FUNCTION function\n"
"      Some thing that can be placed in CAR position which will compute a "
"value\n"
"      between 0 and (1- (expt 2 <hash-bits>)).\n"
"\n"
"  :VALUES <n>\n"
"      The number of values cached.\n"
"\n"
"   :INIT-FORM <name>\n"
"      The DEFVAR for creating the cache is enclosed in a form with the\n"
"      specified name.  Default PROGN."
msgstr ""
"DEFINE-HASH-CACHE Amenay ({(Argway-Amenay Esttay-Unctionfay)}*) {Eykay "
"Aluevay}*\n"
"  Efineday away ashhay achecay atthay associatesway omesay umbernay ofway "
"argumentway aluesvay otay away\n"
"  esultray aluevay.  Ethay Esttay-Unctionfay airedpay ithway eachway Argway-"
"Amenay isway usedway otay omparecay\n"
"  ethay aluevay orfay atthay argway inway away achecay entryway ithway away "
"uppliedsay argway.  Ethay\n"
"  Esttay-Unctionfay ustmay otnay errorway enwhay assedpay NIL asway itsway "
"irstfay argway, utbay eednay otnay\n"
"  eturnray anyway articularpay aluevay.  Esttay-Unctionfay aymay ebay anyway "
"ingthay atthay ancay ebay\n"
"  aceplay inway CAR ositionpay.\n"
"\n"
"  Amenay isway usedway otay efineday unctionsfay esethay unctionsfay:\n"
"\n"
"  <amenay>-CACHE-LOOKUP Arg*Way\n"
"      Eesay ifway erethay isway anway entryway orfay ethay ecifiedspay "
"Argsway inway ethay achecay.  Ethay ifway otnay\n"
"      esentpray, ethay :DEFAULT eywordkay (efaultday NIL) eterminesday ethay "
"esultray(s).\n"
"\n"
"  <amenay>-CACHE-ENTER Arg*Way Alue*Vay\n"
"      Encacheway ethay associationway ofway ethay ecifiedspay argsway ithway "
"Aluevay.\n"
"\n"
"  <amenay>-CACHE-FLUSH-<argway-amenay> Argway\n"
"      Ushflay allway entriesway omfray ethay achecay atthay avehay ethay "
"aluevay Argway orfay ethay amednay\n"
"      argway.\n"
"\n"
"  <amenay>-CACHE-CLEAR\n"
"      Einitializeray ethay achecay, invalidatingway allway entriesway andway "
"allowingway ethay\n"
"      argumentsway andway esultray aluesvay otay ebay GC'd.\n"
"\n"
"  Esethay otherway eywordskay areway efinedday:\n"
"\n"
"  :HASH-BITS <n>\n"
"      Ethay izesay ofway ethay achecay asway away owerpay ofway 2.\n"
"\n"
"  :HASH-FUNCTION unctionfay\n"
"      Omesay ingthay atthay ancay ebay acedplay inway CAR ositionpay ichwhay "
"illway omputecay away aluevay\n"
"      etweenbay 0 andway (1- (exptway 2 <ashhay-itsbay>)).\n"
"\n"
"  :VALUES <n>\n"
"      Ethay umbernay ofway aluesvay achedcay.\n"
"\n"
"   :INIT-FORM <amenay>\n"
"      Ethay DEFVAR orfay eatingcray ethay achecay isway enclosedway inway "
"away ormfay ithway ethay\n"
"      ecifiedspay amenay.  Efaultday PROGN."

#: src/code/extensions.lisp
msgid "Number of default values ~S differs from :VALUES ~D."
msgstr "Umbernay ofway efaultday aluesvay ~S iffersday omfray :VALUES ~D."

#: src/code/extensions.lisp
msgid "Bad arg spec: ~S."
msgstr "Adbay argway ecspay: ~S."

#: src/code/extensions.lisp
msgid ""
"DEFUN-CACHED (Name {Key Value}*) ({(Arg-Name Test-Function)}*) Form*\n"
"  Some syntactic sugar for defining a function whose values are cached by\n"
"  DEFINE-HASH-CACHE."
msgstr ""
"DEFUN-CACHED (Amenay {Eykay Aluevay}*) ({(Argway-Amenay Esttay-Unctionfay)}"
"*) Orm*Fay\n"
"  Omesay yntacticsay ugarsay orfay efiningday away unctionfay osewhay "
"aluesvay areway achedcay ybay\n"
"  DEFINE-HASH-CACHE."

#: src/code/extensions.lisp
msgid ""
"Return an EQ hash of X.  The value of this hash for any given object can "
"(of\n"
"  course) change at arbitary times."
msgstr ""
"Eturnray anway EQ ashhay ofway X.  Ethay aluevay ofway isthay ashhay orfay "
"anyway ivengay objectway ancay (ofway\n"
"  oursecay) angechay atway arbitaryway imestay."

#: src/code/commandline.lisp
msgid "A list of all the command line arguments after --"
msgstr ""
"Away istlay ofway allway ethay ommandcay inelay argumentsway afterway --"

#: src/code/commandline.lisp
msgid ""
"A list of cmd-switch's representing the arguments used to invoke\n"
"  this process."
msgstr ""
"Away istlay ofway mdcay-witchsay's epresentingray ethay argumentsway usedway "
"otay invokeway\n"
"  isthay ocesspray."

#: src/code/commandline.lisp
msgid "The string name that was used to invoke this process."
msgstr ""
"Ethay ingstray amenay atthay asway usedway otay invokeway isthay ocesspray."

#: src/code/commandline.lisp
msgid "A list of words between the utility name and the first switch."
msgstr ""
"Away istlay ofway ordsway etweenbay ethay utilityway amenay andway ethay "
"irstfay witchsay."

#: src/code/commandline.lisp
msgid ""
"A list of strings obtained from the command line that invoked this process."
msgstr ""
"Away istlay ofway ingsstray obtainedway omfray ethay ommandcay inelay atthay "
"invokedway isthay ocesspray."

#: src/code/commandline.lisp
msgid "An Alist of (\"argument-name\" . demon-function)"
msgstr "Anway Alistway ofway (\"argumentway-amenay\" . emonday-unctionfay)"

#: src/code/commandline.lisp
msgid ""
"When True runs lisp with its input coming from standard-input.\n"
"  If an error is detected returns error code 1, otherwise 0."
msgstr ""
"Enwhay Uetray unsray isplay ithway itsway inputway omingcay omfray "
"tandardsay-inputway.\n"
"  Ifway anway errorway isway etectedday eturnsray errorway odecay 1, "
"otherwiseway 0."

#: src/code/commandline.lisp
msgid ""
"Accepts the name of a switch as a string and returns the value of\n"
"  the switch.  If no value was specified, then any following words are\n"
"  returned.  If there are no following words, then t is returned.  If\n"
"  the switch was not specified, then nil is returned."
msgstr ""
"Acceptsway ethay amenay ofway away witchsay asway away ingstray andway "
"eturnsray ethay aluevay ofway\n"
"  ethay witchsay.  Ifway onay aluevay asway ecifiedspay, enthay anyway "
"ollowingfay ordsway areway\n"
"  eturnedray.  Ifway erethay areway onay ollowingfay ordsway, enthay t isway "
"eturnedray.  Ifway\n"
"  ethay witchsay asway otnay ecifiedspay, enthay ilnay isway eturnedray."

#: src/code/commandline.lisp
msgid ""
"When set, invoking switch demons complains about illegal switches\n"
"  that have not been defined with DEFSWITCH."
msgstr ""
"Enwhay etsay, invokingway witchsay emonsday omplainscay aboutway illegalway "
"witchessay\n"
"  atthay avehay otnay eenbay efinedday ithway DEFSWITCH."

#: src/code/commandline.lisp
msgid "~S is an illegal switch"
msgstr "~S isway anway illegalway witchsay"

#: src/code/commandline.lisp
msgid ""
"Associates function with the switch name in\n"
"  *command-switch-demons*.  Name is a simple-string that does not\n"
"  begin with a hyphen, unless the switch name really does begin with\n"
"  one.  Function is optional, but defining the switch is necessary to\n"
"  keep invoking switch demons from complaining about illegal switches.\n"
"  This can be inhibited with *complain-about-illegal-switches*.\n"
"\n"
"  The optional arguments, arg-name and docstring, are used by -help to\n"
"  describe the switch.  Arg-name is a string naming the argument (if\n"
"  any) for the switch.  Docstring describe the switch."
msgstr ""
"Associatesway unctionfay ithway ethay witchsay amenay inway\n"
"  *command-switch-demons*.  Amenay isway away implesay-ingstray atthay "
"oesday otnay\n"
"  eginbay ithway away yphenhay, unlessway ethay witchsay amenay eallyray "
"oesday eginbay ithway\n"
"  oneway.  Unctionfay isway optionalway, utbay efiningday ethay witchsay "
"isway ecessarynay otay\n"
"  eepkay invokingway witchsay emonsday omfray omplainingcay aboutway "
"illegalway witchessay.\n"
"  Isthay ancay ebay inhibitedway ithway *complain-about-illegal-switches*.\n"
"\n"
"  Ethay optionalway argumentsway, argway-amenay andway ocstringday, areway "
"usedway ybay -elphay otay\n"
"  escribeday ethay witchsay.  Argway-amenay isway away ingstray amingnay "
"ethay argumentway (ifway\n"
"  anyway) orfay ethay witchsay.  Ocstringday escribeday ethay witchsay."

#: src/code/commandline.lisp
#, fuzzy
msgid ""
"Evaluate the specified Lisp expression during the start up\n"
"  sequence.  The value of the form will not be printed unless it is\n"
"  wrapped in a form that does output."
msgstr ""
"Evaluateway ethay ecifiedspay Isplay expressionway uringday ethay tartsay "
"upway\n"
"  equencesay.  ethay aluevay ofway ethay ormfay illway otnay ebay intedpray "
"unlessway itway isway\n"
"  appedwray inway away ormfay atthay oesday outputway."

#: src/code/commandline.lisp
msgid "expression"
msgstr "expressionway"

#: src/code/commandline.lisp
msgid "a symbol or function"
msgstr "away ymbolsay orway unctionfay"

#: src/code/commandline.lisp
msgid ""
"Loads the specified file into Lisp before entering Lisp's\n"
"  read-eval-print loop."
msgstr ""
"Oadslay ethay ecifiedspay ilefay intoway Isplay eforebay enteringway "
"Isplay's\n"
"  eadray-evalway-intpray ooplay."

#: src/code/commandline.lisp
msgid "filename"
msgstr "ilenamefay"

#: src/code/commandline.lisp
msgid "Specifies the suspended Lisp image ('core' file) to start up"
msgstr ""
"Ecifiesspay ethay uspendedsay Isplay imageway ('orecay' ilefay) otay tartsay "
"upway"

#: src/code/commandline.lisp
msgid "corefile"
msgstr "orefilecay"

#: src/code/commandline.lisp
msgid ""
"Specifies the name of a file containing user customizations that is\n"
"  to be loaded each time Lisp starts up (default ~/init or\n"
"  ~/.cmucl-init.lisp).  The loader loads any existing compiled binary\n"
"  or the lisp source if none."
msgstr ""
"Ecifiesspay ethay amenay ofway away ilefay ontainingcay userway "
"ustomizationscay atthay isway\n"
"  otay ebay oadedlay eachway imetay Isplay tartssay upway (efaultday ~/"
"initway orway\n"
"  ~/.muclcay-initway.isplay).  Ethay oaderlay oadslay anyway existingway "
"ompiledcay inarybay\n"
"  orway ethay isplay ourcesay ifway onenay."

#: src/code/commandline.lisp
msgid ""
"Suppresses loading of the init file and also prevents -edit from\n"
"  loading the Hemlock init file."
msgstr ""
"Uppressessay oadinglay ofway ethay initway ilefay andway alsoway eventspray -"
"editway omfray\n"
"  oadinglay ethay Emlockhay initway ilefay."

#: src/code/commandline.lisp
msgid ""
"Suppresses loading of the site-init site specific initialization\n"
"  file."
msgstr ""
"Uppressessay oadinglay ofway ethay itesay-initway itesay ecificspay "
"initializationway\n"
"  ilefay."

#: src/code/commandline.lisp
msgid ""
"Specifies the name of the Hemlock init file (default ~/hemlock-init\n"
"  or ~/.hemlock-init), which is loaded only when Hemlock is started."
msgstr ""
"Ecifiesspay ethay amenay ofway ethay Emlockhay initway ilefay (efaultday ~/"
"emlockhay-initway\n"
"  orway ~/.emlockhay-initway), ichwhay isway oadedlay onlyway enwhay "
"Emlockhay isway tartedsay."

#: src/code/commandline.lisp
msgid ""
"Causes Lisp to run in batch mode where all input is directed from\n"
"  standard-input.  A unix return code of 0 is returned upon\n"
"  encountering an EOF, while any unhandled error condition will cause\n"
"  an immediate exit with a return code of 1, instead of entering the\n"
"  debugger."
msgstr ""
"Ausescay Isplay otay unray inway atchbay odemay erewhay allway inputway "
"isway irectedday omfray\n"
"  tandardsay-inputway.  Away unixway eturnray odecay ofway 0 isway "
"eturnedray uponway\n"
"  encounteringway anway EOF, ilewhay anyway unhandledway errorway "
"onditioncay illway ausecay\n"
"  anway immediateway exitway ithway away eturnray odecay ofway 1, insteadway "
"ofway enteringway ethay\n"
"  ebuggerday."

#: src/code/commandline.lisp
#, fuzzy
msgid ""
"Specifies the number of megabytes that should be allocated to the\n"
"  heap.  If not specified, a platform-specific default is used.  If 0,\n"
"  the platform-specific maximum heap size is used.  The actual maximum\n"
"  allowed heap size is platform-specific."
msgstr ""
"Ecifiesspay ethay umbernay ofway egabytesmay atthay ouldshay ebay "
"allocatedway otay ethay\n"
"  eaphay.  Ifway otnay ecifiedspay, away atformplay-ecificspay efaultday "
"isway usedway.  Ethay\n"
"  actualway aximummay allowedway eaphay izesay isway atformplay-ecificspay."

#: src/code/commandline.lisp
msgid "megabytes"
msgstr "egabytesmay"

#: src/code/commandline.lisp
msgid ""
"Specifies the number of megabytes that should be allocated for the\n"
"  read-only space.  If not specified, a platform-specific default is\n"
"  used.  The actual maximum allowed read-only size is\n"
"  platform-specific."
msgstr ""
"Ecifiesspay ethay umbernay ofway egabytesmay atthay ouldshay ebay "
"allocatedway orfay ethay\n"
"  eadray-onlyway acespay.  Ifway otnay ecifiedspay, away atformplay-"
"ecificspay efaultday isway\n"
"  usedway.  Ethay actualway aximummay allowedway eadray-onlyway izesay "
"isway\n"
"  atformplay-ecificspay."

#: src/code/commandline.lisp
msgid ""
"Specifies the number of megabytes that should be allocated for the\n"
"  static space.  If not specified, a platform-specific default is\n"
"  used.  The actual maximum allowed static space size is\n"
"  platform-specific."
msgstr ""
"Ecifiesspay ethay umbernay ofway egabytesmay atthay ouldshay ebay "
"allocatedway orfay ethay\n"
"  taticsay acespay.  Ifway otnay ecifiedspay, away atformplay-ecificspay "
"efaultday isway\n"
"  usedway.  Ethay actualway aximummay allowedway taticsay acespay izesay "
"isway\n"
"  atformplay-ecificspay."

#: src/code/commandline.lisp
msgid ""
"Specifies the number of megabytes that should be allocated for the\n"
"  control stack.  If not specified, a platform-specific default is\n"
"  used.  The actual maximum allowed control stack size is\n"
"  platform-specific."
msgstr ""
"Ecifiesspay ethay umbernay ofway egabytesmay atthay ouldshay ebay "
"allocatedway orfay ethay\n"
"  ontrolcay tacksay.  Ifway otnay ecifiedspay, away atformplay-ecificspay "
"efaultday isway\n"
"  usedway.  Ethay actualway aximummay allowedway ontrolcay tacksay izesay "
"isway\n"
"  atformplay-ecificspay."

#: src/code/commandline.lisp
msgid ""
"Specifies the number of megabytes that should be allocated for the\n"
"  binding stack.  If not specified, a platform-specific default is\n"
"  used.  The actual maximum allowed binding stack size is\n"
"  platform-specific."
msgstr ""
"Ecifiesspay ethay umbernay ofway egabytesmay atthay ouldshay ebay "
"allocatedway orfay ethay\n"
"  indingbay tacksay.  Ifway otnay ecifiedspay, away atformplay-ecificspay "
"efaultday isway\n"
"  usedway.  Ethay actualway aximummay allowedway indingbay tacksay izesay "
"isway\n"
"  atformplay-ecificspay."

#: src/code/commandline.lisp
msgid ""
"A colon-separated list of directories to be used for the library:\n"
"  search-list."
msgstr ""
"Away oloncay-eparatedsay istlay ofway irectoriesday otay ebay usedway orfay "
"ethay ibrarylay:\n"
"  earchsay-istlay."

#: src/code/commandline.lisp
msgid "libpath"
msgstr "ibpathlay"

#: src/code/commandline.lisp
#, fuzzy
msgid ""
"Causes Lisp to start up silently, disabling printing of the herald\n"
"  and causing most unnecessary noise, like GC messages, load messages,\n"
"  etc. to be suppressed."
msgstr ""
"Ausescay Isplay otay tartsay upway ilentlysay, isablingday intingpray ofway "
"ethay eraldhay\n"
"  andway ausingcay ostmay unnecessaryway oisenay, ikelay GC essagesmay,"
"oadlay essagesmay,\n"
"  etcway. otay ebay uppressedsay."

#: src/code/commandline.lisp
msgid ""
"Enables printing of messages indication how CMUCL is searching for\n"
"  its default core file."
msgstr ""
"Enablesway intingpray ofway essagesmay indicationway owhay CMUCL isway "
"earchingsay orfay\n"
"  itsway efaultday orecay ilefay."

#: src/code/commandline.lisp
msgid "Specify the unidata.bin file to be used."
msgstr "Ecifyspay ethay unidataway.inbay ilefay otay ebay usedway."

#: src/code/commandline.lisp
#, fuzzy
msgid "~&Usage: ~A <options> [-- [app-args]*]~2%"
msgstr "~&Usageway: ~Away <optionsway>~2%"

#: src/code/commandline.lisp
msgid "Print out the command line options and exit"
msgstr "Intpray outway ethay ommandcay inelay optionsway andway exitway"

#: src/code/commandline.lisp
#, fuzzy
msgid "Prints the cmucl version and exits, without loading the lisp core."
msgstr "Intpray outway ethay ommandcay inelay optionsway andway exitway"

#: src/code/env-access.lisp
msgid ""
"Returns information about the symbol VAR in the lexical environment ENV.\n"
"Three values are returned:\n"
"  1) Type or binding of VAR.\n"
"     NIL           No definition or binding\n"
"     :special      VAR is special\n"
"     :lexical      VAR is lexical\n"
"     :symbol-macro VAR refers to a SYMBOL-MACROLET binding\n"
"     :constant     VAR refers to a named constant or VAR is a keyword\n"
"  2) non-NIL if there is a local binding\n"
"  3) An a-list containing information about any declarations that apply."
msgstr ""
"Eturnsray informationway aboutway ethay ymbolsay VAR inway ethay exicallay "
"environmentway ENV.\n"
"Reethay aluesvay areway eturnedray:\n"
"  1) Ypetay orway indingbay ofway VAR.\n"
"     NIL           Onay efinitionday orway indingbay\n"
"     :ecialspay      VAR isway ecialspay\n"
"     :exicallay      VAR isway exicallay\n"
"     :ymbolsay-acromay VAR efersray otay away SYMBOL-MACROLET indingbay\n"
"     :onstantcay     VAR efersray otay away amednay onstantcay orway VAR "
"isway away eywordkay\n"
"  2) onnay-NIL ifway erethay isway away ocallay indingbay\n"
"  3) Anway away-istlay ontainingcay informationway aboutway anyway "
"eclarationsday atthay applyway."

#: src/code/env-access.lisp
msgid ""
"Returns information about declarations named by the symbol DECLARATION-"
"NAME.\n"
"Supported DECLARATION-NAMES are\n"
"  1) OPTIMIZE\n"
"     A list whose entries are of the form (QUALITY VALUE) is returned,\n"
"     where QUALITY and VALUE are standard optimization qualities and\n"
"     values.\n"
"  2) EXT:OPTIMIZE-INTERFACE\n"
"     Like OPTIMIZE, but for the EXT:OPTIMIZE-INTERFACE declaration.\n"
"  3) DECLARATION.\n"
"     A list of the declaration names the have been proclaimed as valid."
msgstr ""
"Eturnsray informationway aboutway eclarationsday amednay ybay ethay ymbolsay "
"DECLARATION-NAME.\n"
"Upportedsay DECLARATION-NAMES areway\n"
"  1) OPTIMIZE\n"
"     Away istlay osewhay entriesway areway ofway ethay ormfay (QUALITY "
"VALUE) isway eturnedray,\n"
"     erewhay QUALITY andway VALUE areway tandardsay optimizationway "
"alitiesquay andway\n"
"     aluesvay.\n"
"  2) EXT:OPTIMIZE-INTERFACE\n"
"     Ikelay OPTIMIZE, utbay orfay ethay EXT:OPTIMIZE-INTERFACE "
"eclarationday.\n"
"  3) DECLARATION.\n"
"     Away istlay ofway ethay eclarationday amesnay ethay avehay eenbay "
"oclaimedpray asway alidvay."

#: src/code/env-access.lisp
msgid "Unsupported declaration ~S."
msgstr "Unsupportedway eclarationday ~S."

#: src/code/env-access.lisp
msgid ""
"Process a macro in the same way that DEFMACRO or MACROLET would.\n"
"Three values are returned:\n"
"  1) A lambda-expression that accepts two arguments\n"
"  2) A form\n"
"  3) An environment"
msgstr ""
"Ocesspray away acromay inway ethay amesay ayway atthay DEFMACRO orway "
"MACROLET ouldway.\n"
"Reethay aluesvay areway eturnedray:\n"
"  1) Away ambdalay-expressionway atthay acceptsway wotay argumentsway\n"
"  2) Away ormfay\n"
"  3) Anway environmentway"

#: src/code/env-access.lisp
msgid ""
"Returns information about the function name FUNCTION in the lexical "
"environment ENV.\n"
"Three values are returned:\n"
"  1) Type of definition or binding:\n"
"     NIL          No apparent definition\n"
"    :function    FUNCTION refers to a function\n"
"    :macro        FUNCTION refers to a macro\n"
"    :special-form FUNCTION is a special form\n"
"  2) non-NIL if definition is local\n"
"  3) An a-list containing information about the declarations that apply."
msgstr ""
"Eturnsray informationway aboutway ethay unctionfay amenay FUNCTION inway "
"ethay exicallay environmwayentway ENV.\n"
"Reethay aluesvay areway eturnedray:\n"
"  1) Ypetay ofway efinitionday orway indingbay:\n"
"     NIL          Onay apparentway efinitionday\n"
"    :unctionfay    FUNCTION efersray otay away unctionfay\n"
"    :acromay        FUNCTION efersray otay away acromay\n"
"    :ecialspay-ormfay FUNCTION isway away ecialspay ormfay\n"
"  2) onnay-NIL ifway efinitionday isway ocallay\n"
"  3) Anway away-istlay ontainingcay informationway aboutway ethay "
"eclarationsday atthay applyway."

#: src/code/env-access.lisp
msgid ""
"Return a new environment containing information in ENV that is augmented\n"
"by the specified parameters:\n"
"  :VARIABLE     a list of symbols visible as bound variables in the new\n"
"                environemnt\n"
"  :SYMBOL-MACRO a list of symbol macro definitions\n"
"  :FUNCTION     a list of function names that will be visible as local\n"
"                functions\n"
"  :MACRO        a list of local macro definitions\n"
"  :DECLARE      a list of declaration specifiers"
msgstr ""
"Eturnray away ewnay environmentway ontainingcay informationway inway ENV "
"atthay isway augmentedway\n"
"ybay ethay ecifiedspay arameterspay:\n"
"  :VARIABLE     away istlay ofway ymbolssay isiblevay asway oundbay "
"ariablesvay inway ethay ewnay\n"
"                environemntway\n"
"  :SYMBOL-MACRO away istlay ofway ymbolsay acromay efinitionsday\n"
"  :FUNCTION     away istlay ofway unctionfay amesnay atthay illway ebay "
"isiblevay asway ocallay\n"
"                unctionsfay\n"
"  :MACRO        away istlay ofway ocallay acromay efinitionsday\n"
"  :DECLARE      away istlay ofway eclarationday ecifiersspay"

#: src/code/dfixnum.lisp
msgid "increments dfixnum v by dfixnum i"
msgstr "incrementsway fixnumday v ybay fixnumday i"

#: src/code/dfixnum.lisp
msgid "dfixnum became too big ~a + ~a"
msgstr "fixnumday ecamebay ootay igbay ~away + ~away"

#: src/code/dfixnum.lisp
msgid "increments dfixnum v by i (max half fixnum)"
msgstr "incrementsway fixnumday v ybay i (axmay alfhay ixnumfay)"

#: src/code/dfixnum.lisp
msgid "not a half-fixnum: ~a"
msgstr "otnay away alfhay-ixnumfay: ~away"

#: src/code/dfixnum.lisp
msgid "decrement dfixnum v by dfixnum i"
msgstr "ecrementday fixnumday v ybay fixnumday i"

#: src/code/dfixnum.lisp
msgid "dfixnum became negative ~a - ~a (~a/~a)"
msgstr "fixnumday ecamebay egativenay ~away - ~away (~away/~away)"

#: src/code/dfixnum.lisp
msgid "decrement dfixnum v by half-fixnum i"
msgstr "ecrementday fixnumday v ybay alfhay-ixnumfay i"

#: src/code/dfixnum.lisp
msgid ""
"increments dfixnum by an interger which may be bigger than fixnum.\n"
"   May cons"
msgstr ""
"incrementsway fixnumday ybay anway intergerway ichwhay aymay ebay iggerbay "
"anthay ixnumfay.\n"
"   Aymay onscay"

#: src/code/dfixnum.lisp
msgid "returns a new dfixnum from number i"
msgstr "eturnsray away ewnay fixnumday omfray umbernay i"

#: src/code/dfixnum.lisp
msgid "increments a pair of halffixnums by another pair"
msgstr "incrementsway away airpay ofway alffixnumshay ybay anotherway airpay"

#: src/code/dfixnum.lisp
msgid "decrement dfixnum pair by another pair"
msgstr "ecrementday fixnumday airpay ybay anotherway airpay"

#: src/code/room.lisp
msgid "~2&Summary of spaces: ~(~{~A ~}~)~%"
msgstr "~2&Ummarysay ofway acesspay: ~(~{~Away ~}~)~%"

#: src/code/room.lisp
msgid "~%~A:~%    ~:D bytes, ~:D object"
msgid_plural "~%~A:~%    ~:D bytes, ~:D objects"
msgstr[0] "~%~Away:~%    ~:D ytesbay, ~:D objectway"
msgstr[1] "~%~Away:~%    ~:D ytesbay, ~:D objectsway"

#: src/code/room.lisp
msgid "~%Summary total:~%    ~:D bytes, ~:D objects.~%"
msgstr "~%Ummarysay otaltay:~%    ~:D ytesbay, ~:D objectsway.~%"

#: src/code/room.lisp
msgid "~2&Breakdown for ~(~A~) space:~%"
msgstr "~2&Eakdownbray orfay ~(~Away~) acespay:~%"

#: src/code/room.lisp
msgid "  ~13:D bytes for ~9:D other object.~%"
msgid_plural "  ~13:D bytes for ~9:D other objects.~%"
msgstr[0] "  ~13:D ytesbay orfay ~9:D otherway objectway.~%"
msgstr[1] "  ~13:D ytesbay orfay ~9:D otherway objectsway.~%"

#: src/code/room.lisp
msgid "  ~13:D bytes for ~9:D ~(~A~) object.~%"
msgid_plural "  ~13:D bytes for ~9:D ~(~A~) objects.~%"
msgstr[0] "  ~13:D ytesbay orfay ~9:D ~(~Away~) objectway.~%"
msgstr[1] "  ~13:D ytesbay orfay ~9:D ~(~Away~) objectsway.~%"

#: src/code/room.lisp
msgid "  ~13:D bytes for ~9:D ~(~A~) object (space total.)~%"
msgid_plural "  ~13:D bytes for ~9:D ~(~A~) objects (space total.)~%"
msgstr[0] "  ~13:D ytesbay orfay ~9:D ~(~Away~) objectway (acespay otaltay.)~%"
msgstr[1] ""
"  ~13:D ytesbay orfay ~9:D ~(~Away~) objectsway (acespay otaltay.)~%"

#: src/code/room.lisp
msgid ""
"Print out information about the heap memory in use.  :Print-Spaces is a "
"list\n"
"  of the spaces to print detailed information for.  :Count-Spaces is a list "
"of\n"
"  the spaces to scan.  For either one, T means all spaces (:Static, :"
"Dyanmic\n"
"  and :Read-Only.)  If :Print-Summary is true, then summary information will "
"be\n"
"  printed.  The defaults print only summary information for dynamic space.\n"
"  If true, Cutoff is a fraction of the usage in a report below which types "
"will\n"
"  be combined as OTHER."
msgstr ""
"Intpray outway informationway aboutway ethay eaphay emorymay inway useway.  :"
"Intpray-Acesspay isway away istlay\n"
"  ofway ethay acesspay otay intpray etailedday informationway orfay.  :"
"Ountcay-Acesspay isway away istlay ofway\n"
"  ethay acesspay otay anscay.  Orfay eitherway oneway, T eansmay allway "
"acesspay (:Taticsay, :Yanmicday\n"
"  andway :Eadray-Onlyway.)  Ifway :Intpray-Ummarysay isway uetray, enthay "
"ummarysay informationway illway ebay\n"
"  intedpray.  Ethay efaultsday intpray onlyway ummarysay informationway "
"orfay ynamicday acespay.\n"
"  Ifway uetray, Utoffcay isway away actionfray ofway ethay usageway inway "
"away eportray elowbay ichwhay ypestay illway\n"
"  ebay ombinedcay asway OTHER."

#: src/code/room.lisp
msgid "Print info about how much code and no-ops there are in Space."
msgstr ""
"Intpray infoway aboutway owhay uchmay odecay andway onay-opsway erethay "
"areway inway Acespay."

#: src/code/room.lisp
msgid "~:D code-object bytes, ~:D code words, with ~:D no-ops (~D%).~%"
msgstr ""
"~:D odecay-objectway ytesbay, ~:D odecay ordsway, ithway ~:D onay-opsway "
"(~D%).~%"

#: src/code/room.lisp
msgid "Bogus type: ~D"
msgstr "Ogusbay ypetay: ~D"

#: src/code/room.lisp
msgid "~:D words allocated for descriptor objects.~%"
msgstr "~:D ordsway allocatedway orfay escriptorday objectsway.~%"

#: src/code/room.lisp
msgid "~:D bytes data/~:D words header for non-descriptor objects.~%"
msgstr ""
"~:D ytesbay ataday/~:D ordsway eaderhay orfay onnay-escriptorday objectsway."
"~%"

#: src/code/room.lisp
msgid ""
"Print a breakdown by instance type of all the allocation in Space.  \n"
"\n"
"  :TOP-N \n"
"      If true, print only the TOP-N types by largest usage.\n"
"\n"
"  :ENTRIES-VAR\n"
"      If bound, contains the name of the symbol used to store the hash-"
"table\n"
"      of allocated entries for later processing.\n"
"\n"
"  :CALL-SOURCE\n"
"      A string identifying the location from which instance-usage was called."
msgstr ""

#: src/code/room.lisp
msgid "~2&~@[Top ~D ~]~(~A~) instance types:~%"
msgstr "~2&~@[Optay ~D ~]~(~Away~) instanceway ypestay:~%"

#: src/code/room.lisp
msgid "  ~32A: ~7:D bytes, ~5D object.~%"
msgid_plural "  ~32A: ~7:D bytes, ~5D objects.~%"
msgstr[0] "  ~32Away: ~7:D ytesbay, ~5D objectway.~%"
msgstr[1] "  ~32Away: ~7:D ytesbay, ~5D objectsway.~%"

#: src/code/room.lisp
msgid "  Other types: ~:D bytes, ~D: object~:P.~%"
msgid_plural "  Other types: ~:D bytes, ~D: object~:P.~%"
msgstr[0] "  Otherway ypestay: ~:D ytesbay, ~D: objectway~:P.~%"
msgstr[1] "  Otherway ypestay: ~:D ytesbay, ~D: objectway~:P.~%"

#: src/code/room.lisp
msgid "  ~:(~A~) instance total: ~:D bytes, ~:D object.~%"
msgid_plural "  ~:(~A~) instance total: ~:D bytes, ~:D objects.~%"
msgstr[0] "  ~:(~Away~) instanceway otaltay: ~:D ytesbay, ~:D objectway.~%"
msgstr[1] "  ~:(~Away~) instanceway otaltay: ~:D ytesbay, ~:D objectsway.~%"

#: src/code/room.lisp
msgid "In ~A space:~%"
msgstr "Inway ~Away acespay:~%"

#: src/code/room.lisp
msgid "~D bytes at #x~X~%"
msgstr "~D ytesbay atway #x~X~%"

#: src/code/room.lisp
msgid "No source for ~S"
msgstr "Onay ourcesay orfay ~S"

#: src/code/room.lisp
msgid "~%Package ~A: ~32T~9:D bytes, ~9:D object.~%"
msgid_plural "~%Package ~A: ~32T~9:D bytes, ~9:D objects.~%"
msgstr[0] "~%Ackagepay ~Away: ~32T~9:D ytesbay, ~9:D objectway.~%"
msgstr[1] "~%Ackagepay ~Away: ~32T~9:D ytesbay, ~9:D objectsway.~%"

#: src/code/room.lisp
msgid "~30@A: ~9:D bytes, ~9:D object.~%"
msgid_plural "~30@A: ~9:D bytes, ~9:D objects.~%"
msgstr[0] "~30@Away: ~9:D ytesbay, ~9:D objectway.~%"
msgstr[1] "~30@Away: ~9:D ytesbay, ~9:D objectsway.~%"

#: src/code/room.lisp
msgid ""
"Given a hashtable, print a histogram of the contents.  Function should give\n"
"  the value to plot when applied to the hashtable values."
msgstr ""
"Ivengay away ashtablehay, intpray away istogramhay ofway ethay ontentscay.  "
"Unctionfay ouldshay ivegay\n"
"  ethay aluevay otay otplay enwhay appliedway otay ethay ashtablehay "
"aluesvay."

#: src/code/room.lisp
msgid ""
"Report the Top-N entries in the hashtable Table, when sorted by Function\n"
"  applied to the hash value.  If Top-N is NIL, report all entries."
msgstr ""
"Eportray ethay Optay-N entriesway inway ethay ashtablehay Abletay, enwhay "
"ortedsay ybay Unctionfay\n"
"  appliedway otay ethay ashhay aluevay.  Ifway Optay-N isway NIL, eportray "
"allway entriesway."

#: src/code/room.lisp
msgid "~8:D: Other~%"
msgstr "~8:D: Otherway~%"

#: src/code/room.lisp
msgid "~8:D: Total~%"
msgstr "~8:D: Otaltay~%"

#: src/code/room.lisp
msgid ""
"Return a hashtable mapping each function in for which a call appears in\n"
"  Space to the number of times such a call appears."
msgstr ""
"Eturnray away ashtablehay appingmay eachway unctionfay inway orfay ichwhay "
"away allcay appearsway inway\n"
"  Acespay otay ethay umbernay ofway imestay uchsay away allcay appearsway."

#: src/code/room.lisp
msgid ""
"Return a hashtable translating code objects to function constant counts for\n"
"  all code objects in Space with more than Above function constants."
msgstr ""
"Eturnray away ashtablehay anslatingtray odecay objectsway otay unctionfay "
"onstantcay ountscay orfay\n"
"  allway odecay objectsway inway Acespay ithway oremay anthay Aboveway "
"unctionfay onstantscay."

#: src/code/gc.lisp
msgid ""
"Returns a list of the current GC assertion settings. The list is\n"
"    in the same format as the keyword arguments to SET-GC-ASSERTIONS,\n"
"    i.e.,\n"
"\n"
"      (apply #'set-gc-assertions (get-gc-assertions))\n"
"\n"
"   See SET-GC-ASSERTIONS for more information."
msgstr ""

#: src/code/gc.lisp
msgid ""
"Set GC assertion to the specified value:\n"
"       :ASSERT-LEVEL\n"
"           Defaults to 0, higher values indicate more assertions are "
"enabled.\n"
"\n"
"       :VERIFY-AFTER-FREE-HEAP\n"
"           If non-NIL, the heap is verified for consistency whenever\n"
"           part of the heap is collected.\n"
"\n"
"       :VERIFY-GENERATIONS\n"
"           Set to generation number.  When GC occurs, generations\n"
"           equal to or higher than this value are checked for\n"
"           consistency.\n"
"\n"
"       :VERIFY-NEW-OBJECTS\n"
"           When GC occurs for the newest generation, the heap for this\n"
"           generation is checked for validity.\n"
msgstr ""

#: src/code/gc.lisp
msgid "Oh no.  The current dynamic space is missing!"
msgstr "Ohway onay.  Ethay urrentcay ynamicday acespay isway issingmay!"

#: src/code/gc.lisp
msgid "Dynamic Space Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr "Ynamicday Acespay Usageway:    ~13:D ytesbay (outway ofway ~4:D MB).~%"

#: src/code/gc.lisp
msgid "Read-Only Space Usage:  ~13:D bytes (out of ~4:D MB).~%"
msgstr ""
"Eadray-Onlyway Acespay Usageway:  ~13:D ytesbay (outway ofway ~4:D MB).~%"

#: src/code/gc.lisp
msgid "Static Space Usage:     ~13:D bytes (out of ~4:D MB).~%"
msgstr "Taticsay Acespay Usageway:     ~13:D ytesbay (outway ofway ~4:D MB).~%"

#: src/code/gc.lisp
msgid "Control Stack Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr "Ontrolcay Tacksay Usageway:    ~13:D ytesbay (outway ofway ~4:D MB).~%"

#: src/code/gc.lisp
msgid "Binding Stack Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr "Indingbay Tacksay Usageway:    ~13:D ytesbay (outway ofway ~4:D MB).~%"

#: src/code/gc.lisp
msgid "The current dynamic space is ~D.~%"
msgstr "Ethay urrentcay ynamicday acespay isway ~D.~%"

#: src/code/gc.lisp
msgid "Garbage collection is currently ~:[enabled~;DISABLED~].~%"
msgstr "Arbagegay ollectioncay isway urrentlycay ~:[enabledway~;DISABLED~].~%"

#: src/code/gc.lisp
msgid ""
"Prints to *STANDARD-OUTPUT* information about the state of internal\n"
"  storage and its management.  The optional argument controls the\n"
"  verbosity of ROOM.  If it is T, ROOM prints out a maximal amount of\n"
"  information.  If it is NIL, ROOM prints out a minimal amount of\n"
"  information.  If it is :DEFAULT or it is not supplied, ROOM prints out\n"
"  an intermediate amount of information.  See also VM:MEMORY-USAGE and\n"
"  VM:INSTANCE-USAGE for finer report control."
msgstr ""
"Intspray otay *STANDARD-OUTPUT* informationway aboutway ethay tatesay ofway "
"internalway\n"
"  toragesay andway itsway anagementmay.  Ethay optionalway argumentway "
"ontrolscay ethay\n"
"  erbosityvay ofway ROOM.  Ifway itway isway T, ROOM intspray outway away "
"aximalmay amountway ofway\n"
"  informationway.  Ifway itway isway NIL, ROOM intspray outway away "
"inimalmay amountway ofway\n"
"  informationway.  Ifway itway isway :DEFAULT orway itway isway otnay "
"uppliedsay, ROOM intspray outway\n"
"  anway intermediateway amountway ofway informationway.  Eesay alsoway VM:"
"MEMORY-USAGE andway\n"
"  VM:INSTANCE-USAGE orfay inerfay eportray ontrolcay."

#: src/code/gc.lisp
msgid ""
"No way man!  The optional argument to ROOM must be T, NIL, ~\n"
"\t\t or :DEFAULT.~%What do you think you are doing?"
msgstr ""
"Onay ayway anmay!  Ethay optionalway argumentway otay ROOM ustmay ebay T, "
"NIL, ~\n"
"\t\t orway :DEFAULT.~%Atwhay oday ouyay inkthay ouyay areway oingday?"

#: src/code/gc.lisp
msgid "resetting GC counters"
msgstr "esettingray GC ounterscay"

#: src/code/gc.lisp
msgid ""
"Returns the number of bytes consed since the first time this function\n"
"  was called.  The first time it is called, it returns zero."
msgstr ""
"Eturnsray ethay umbernay ofway ytesbay onsedcay incesay ethay irstfay imetay "
"isthay unctionfay\n"
"  asway alledcay.  Ethay irstfay imetay itway isway alledcay, itway "
"eturnsray erozay."

#: src/code/gc.lisp
msgid ""
"This number specifies the minimum number of bytes of dynamic space\n"
"   that must be consed before the next gc will occur."
msgstr ""
"Isthay umbernay ecifiesspay ethay inimummay umbernay ofway ytesbay ofway "
"ynamicday acespay\n"
"   atthay ustmay ebay onsedcay eforebay ethay extnay cgay illway occurway."

#: src/code/gc.lisp
msgid ""
"The total CPU time spend doing garbage collection (as reported by\n"
"   GET-INTERNAL-RUN-TIME.)"
msgstr ""
"Ethay otaltay CPU imetay endspay oingday arbagegay ollectioncay (asway "
"eportedray ybay\n"
"   GET-INTERNAL-RUN-TIME.)"

#: src/code/gc.lisp
msgid ""
"A list of functions that are called before garbage collection occurs.\n"
"  The functions should take no arguments."
msgstr ""
"Away istlay ofway unctionsfay atthay areway alledcay eforebay arbagegay "
"ollectioncay occursway.\n"
"  Ethay unctionsfay ouldshay aketay onay argumentsway."

#: src/code/gc.lisp
msgid ""
"A list of functions that are called after garbage collection occurs.\n"
"  The functions should take no arguments."
msgstr ""
"Away istlay ofway unctionsfay atthay areway alledcay afterway arbagegay "
"ollectioncay occursway.\n"
"  Ethay unctionsfay ouldshay aketay onay argumentsway."

#: src/code/gc.lisp
msgid ""
"Should be bound to a function or NIL.  If it is a function, this\n"
"  function should take one argument, the current amount of dynamic\n"
"  usage.  The function should return NIL if garbage collection should\n"
"  continue and non-NIL if it should be inhibited.  Use with caution."
msgstr ""
"Ouldshay ebay oundbay otay away unctionfay orway NIL.  Ifway itway isway "
"away unctionfay, isthay\n"
"  unctionfay ouldshay aketay oneway argumentway, ethay urrentcay amountway "
"ofway ynamicday\n"
"  usageway.  Ethay unctionfay ouldshay eturnray NIL ifway arbagegay "
"ollectioncay ouldshay\n"
"  ontinuecay andway onnay-NIL ifway itway ouldshay ebay inhibitedway.  "
"Useway ithway autioncay."

#: src/code/gc.lisp
msgid ""
"When non-NIL, causes the functions bound to *GC-NOTIFY-BEFORE* and\n"
"  *GC-NOTIFY-AFTER* to be called before and after a garbage collection\n"
"  occurs respectively.  If :BEEP, causes the default notify functions to "
"beep\n"
"  annoyingly."
msgstr ""
"Enwhay onnay-NIL, ausescay ethay unctionsfay oundbay otay *GC-NOTIFY-BEFORE* "
"andway\n"
"  *GC-NOTIFY-AFTER* otay ebay alledcay eforebay andway afterway away "
"arbagegay ollectioncay\n"
"  occursway espectivelyray.  Ifway :BEEP, ausescay ethay efaultday otifynay "
"unctionsfay otay eepbay\n"
"  annoyinglyway."

#: src/code/gc.lisp
msgid ""
"~&; [GC threshold exceeded with ~:D bytes in use.  ~\n"
"             Commencing GC.]~%"
msgstr ""
"~&; [GC resholdthay exceededway ithway ~:D ytesbay inway useway.  ~\n"
"             Ommencingcay GC.]~%"

#: src/code/gc.lisp
msgid ""
"This function bound to this variable is invoked before GC'ing (unless\n"
"  *GC-VERBOSE* is NIL) with the current amount of dynamic usage (in\n"
"  bytes).  It should notify the user that the system is going to GC."
msgstr ""
"Isthay unctionfay oundbay otay isthay ariablevay isway invokedway eforebay "
"GC'ingway (unlessway\n"
"  *GC-VERBOSE* isway NIL) ithway ethay urrentcay amountway ofway ynamicday "
"usageway (inway\n"
"  ytesbay).  Itway ouldshay otifynay ethay userway atthay ethay ystemsay "
"isway oinggay otay GC."

#: src/code/gc.lisp
msgid "~&; [GC completed with ~:D bytes retained and ~:D bytes freed.]~%"
msgstr ""
"~&; [GC ompletedcay ithway ~:D ytesbay etainedray andway ~:D ytesbay "
"eedfray.]~%"

#: src/code/gc.lisp
msgid "~&; [GC will next occur when at least ~:D bytes are in use.]~%"
msgstr ""
"~&; [GC illway extnay occurway enwhay atway eastlay ~:D ytesbay areway inway "
"useway.]~%"

#: src/code/gc.lisp
msgid ""
"The function bound to this variable is invoked after GC'ing (unless\n"
"  *GC-VERBOSE* is NIL) with the amount of dynamic usage (in bytes) now\n"
"  free, the number of bytes freed by the GC, and the new GC trigger\n"
"  threshold.  The function should notify the user that the system has\n"
"  finished GC'ing."
msgstr ""
"Ethay unctionfay oundbay otay isthay ariablevay isway invokedway afterway "
"GC'ingway (unlessway\n"
"  *GC-VERBOSE* isway NIL) ithway ethay amountway ofway ynamicday usageway "
"(inway ytesbay) ownay\n"
"  eefray, ethay umbernay ofway ytesbay eedfray ybay ethay GC, andway ethay "
"ewnay GC iggertray\n"
"  resholdthay.  Ethay unctionfay ouldshay otifynay ethay userway atthay "
"ethay ystemsay ashay\n"
"  inishedfay GC'ingway."

#: src/code/gc.lisp
msgid ""
"The value of *BYTES-CONSED-BETWEEN-GCS*, ~S, is not an ~\n"
"\t       integer.  Resetting it to ~D."
msgstr ""
"Ethay aluevay ofway *BYTES-CONSED-BETWEEN-GCS*, ~S, isway otnay anway ~\n"
"\t       integerway.  Esettingray itway otay ~D."

#: src/code/gc.lisp
msgid "(FUNCALL ~S~{ ~S~}) lost:~%~A"
msgstr "(FUNCALL ~S~{ ~S~}) ostlay:~%~Away"

#: src/code/gc.lisp
msgid ""
"Initiates a garbage collection.  The optional argument, VERBOSE-P,\n"
"  which defaults to the value of the variable *GC-VERBOSE* controls\n"
"  whether or not GC statistics are printed."
msgstr ""
"Initiatesway away arbagegay ollectioncay.  Ethay optionalway argumentway, "
"VERBOSE-P,\n"
"  ichwhay efaultsday otay ethay aluevay ofway ethay ariablevay *GC-VERBOSE* "
"ontrolscay\n"
"  etherwhay orway otnay GC tatisticssay areway intedpray."

#: src/code/gc.lisp
msgid ""
"Initiates a garbage collection.  The keyword :VERBOSE, which\n"
"   defaults to the value of the variable *GC-VERBOSE* controls whether or\n"
"   not GC statistics are printed. The keyword :GEN defaults to 0, and\n"
"   controls the number of generations to garbage collect."
msgstr ""
"Initiatesway away arbagegay ollectioncay.  Ethay eywordkay :VERBOSE, "
"ichwhay\n"
"   efaultsday otay ethay aluevay ofway ethay ariablevay *GC-VERBOSE* "
"ontrolscay etherwhay orway\n"
"   otnay GC tatisticssay areway intedpray. Ethay eywordkay :GEN efaultsday "
"otay 0, andway\n"
"   ontrolscay ethay umbernay ofway enerationsgay otay arbagegay ollectcay."

#: src/code/gc.lisp
msgid ""
"Return the amount of memory that will be allocated before the next garbage\n"
"   collection is initiated.  This can be set with SETF."
msgstr ""
"Eturnray ethay amountway ofway emorymay atthay illway ebay allocatedway "
"eforebay ethay extnay arbagegay\n"
"   ollectioncay isway initiatedway.  Isthay ancay ebay etsay ithway SETF."

#: src/code/gc.lisp
msgid "Enables the garbage collector."
msgstr "Enablesway ethay arbagegay ollectorcay."

#: src/code/gc.lisp
msgid "Disables the garbage collector."
msgstr "Isablesday ethay arbagegay ollectorcay."

#: src/code/gc.lisp
msgid ""
"Return some GC statistics for the specified GENERATION.  The\n"
"  statistics are the number of bytes allocated in this generation; the\n"
"  gc-trigger; the number of bytes consed between GCs; the number of\n"
"  GCs that have occurred; the trigger age; the cumulative number of\n"
"  bytes allocated in this generation; and the average age of this\n"
"  generation.  See the gencgc source code for more info."
msgstr ""
"Eturnray omesay GC tatisticssay orfay ethay ecifiedspay GENERATION.  Ethay\n"
"  tatisticssay areway ethay umbernay ofway ytesbay allocatedway inway isthay "
"enerationgay; ethay\n"
"  cgay-iggertray; ethay umbernay ofway ytesbay onsedcay etweenbay Csgay; "
"ethay umbernay ofway\n"
"  Csgay atthay avehay occurredway; ethay iggertray ageway; ethay "
"umulativecay umbernay ofway\n"
"  ytesbay allocatedway inway isthay enerationgay; andway ethay averageway "
"ageway ofway isthay\n"
"  enerationgay.  Eesay ethay encgcgay ourcesay odecay orfay oremay infoway."

#: src/code/purify.lisp
msgid ""
"This function optimizes garbage collection by moving all currently live\n"
"   objects into non-collected storage.  ROOT-STRUCTURES is an optional list "
"of\n"
"   objects which should be copied first to maximize locality.\n"
"\n"
"   DEFSTRUCT structures defined with the (:PURE T) option are moved into\n"
"   read-only storage, further reducing GC cost.  List and vector slots of "
"pure\n"
"   structures are also moved into read-only storage.\n"
"\n"
"   ENVIRONMENT-NAME is gratuitous documentation for compacted version of "
"the\n"
"   current global environment (as seen in C::*INFO-ENVIRONMENT*.)  If NIL "
"is\n"
"   supplied, then environment compaction is inhibited."
msgstr ""
"Isthay unctionfay optimizesway arbagegay ollectioncay ybay ovingmay allway "
"urrentlycay ivelay\n"
"   objectsway intoway onnay-ollectedcay toragesay.  ROOT-STRUCTURES isway "
"anway optionalway istlay ofway\n"
"   objectsway ichwhay ouldshay ebay opiedcay irstfay otay aximizemay "
"ocalitylay.\n"
"\n"
"   DEFSTRUCT ucturesstray efinedday ithway ethay (:PURE T) optionway areway "
"ovedmay intoway\n"
"   eadray-onlyway toragesay, urtherfay educingray GC ostcay.  Istlay andway "
"ectorvay otsslay ofway urepay\n"
"   ucturesstray areway alsoway ovedmay intoway eadray-onlyway toragesay.\n"
"\n"
"   ENVIRONMENT-NAME isway atuitousgray ocumentationday orfay ompactedcay "
"ersionvay ofway ethay\n"
"   urrentcay obalglay environmentway (asway eensay inway C::*INFO-"
"ENVIRONMENT*.)  Ifway NIL isway\n"
"   uppliedsay, enthay environmentway ompactioncay isway inhibitedway."

#: src/code/purify.lisp
msgid "[Doing purification: "
msgstr "[Oingday urificationpay: "

#: src/code/purify.lisp
msgid "Done.]"
msgstr "Oneday.]"

#: src/code/scavhook.lisp
msgid "Returns T if OBJECT is a scavenger-hook, and NIL if not."
msgstr ""
"Eturnsray T ifway OBJECT isway away avengerscay-ookhay, andway NIL ifway "
"otnay."

#: src/code/scavhook.lisp
msgid ""
"Create a new scavenger-hook with the specified VALUE and FUNCTION.  For\n"
"   as long as the scavenger-hook is alive, the scavenger in the garbage\n"
"   collector will note whenever VALUE is moved, and arrange for FUNCTION\n"
"   to be funcalled."
msgstr ""
"Eatecray away ewnay avengerscay-ookhay ithway ethay ecifiedspay VALUE andway "
"FUNCTION.  Orfay\n"
"   asway onglay asway ethay avengerscay-ookhay isway aliveway, ethay "
"avengerscay inway ethay arbagegay\n"
"   ollectorcay illway otenay eneverwhay VALUE isway ovedmay, andway "
"arrangeway orfay FUNCTION\n"
"   otay ebay uncalledfay."

#: src/code/scavhook.lisp
msgid "Returns the VALUE being monitored by SCAVHOOK.  Can be setf."
msgstr ""
"Eturnsray ethay VALUE eingbay onitoredmay ybay SCAVHOOK.  Ancay ebay etfsay."

#: src/code/scavhook.lisp
msgid ""
"Returns the FUNCTION invoked when the monitored value is moved.  Can be\n"
"   setf."
msgstr ""
"Eturnsray ethay FUNCTION invokedway enwhay ethay onitoredmay aluevay isway "
"ovedmay.  Ancay ebay\n"
"   etfsay."

#: src/code/save.lisp
msgid ""
"This is a list of functions which are called before creating a saved core\n"
"  image.  These functions are executed in the child process which has no "
"ports,\n"
"  so they cannot do anything that tries to talk to the outside world."
msgstr ""
"Isthay isway away istlay ofway unctionsfay ichwhay areway alledcay eforebay "
"eatingcray away avedsay orecay\n"
"  imageway.  Esethay unctionsfay areway executedway inway ethay ildchay "
"ocesspray ichwhay ashay onay ortspay,\n"
"  osay eythay annotcay oday anythingway atthay iestray otay alktay otay "
"ethay outsideway orldway."

#: src/code/save.lisp
msgid ""
"This is a list of functions which are called when a saved core image starts\n"
"  up.  The system itself should be initialized at this point, but "
"applications\n"
"  might not be."
msgstr ""
"Isthay isway away istlay ofway unctionsfay ichwhay areway alledcay enwhay "
"away avedsay orecay imageway tartssay\n"
"  upway.  Ethay ystemsay itselfway ouldshay ebay initializedway atway isthay "
"ointpay, utbay applicatiowaysnay\n"
"  ightmay otnay ebay."

#: src/code/save.lisp
#, fuzzy
msgid ""
"An alist mapping each environment variable (as a keyword) to its\n"
"  value."
msgstr ""
"Anway alistway appingmay environmentway ariablesvay (asway eywordskay) otay "
"eitherway aluesvay"

#: src/code/save.lisp
msgid "Non-NIL if environment-init has been called"
msgstr "Onnay-NIL ifway environmentway-initway ashay eenbay alledcay"

#: src/code/save.lisp
msgid "This is true if and only if the lisp was started with the -edit switch."
msgstr ""
"Isthay isway uetray ifway andway onlyway ifway ethay isplay asway tartedsay "
"ithway ethay -editway witchsay."

#: src/code/save.lisp
msgid ""
"Add external format alias for :locale to the format specified by\n"
"  the locale as set by setlocale(3C)."
msgstr ""

#: src/code/save.lisp
#, fuzzy
msgid ""
"Saves a CMU Common Lisp core image in the file of the specified name.  The\n"
"  following keywords are defined:\n"
"  \n"
"  :purify\n"
"      If true (the default), do a purifying GC which moves all dynamically\n"
"  allocated objects into static space so that they stay pure.  This takes\n"
"  somewhat longer than the normal GC which is otherwise done, but GC's will\n"
"  be done less often and take less time in the resulting core file.  See\n"
"  EXT:PURIFY.\n"
"\n"
"  :root-structures\n"
"      This should be a list of the main entry points in any newly loaded\n"
"  systems.  This need not be supplied, but locality and/or GC performance\n"
"  will be better if they are.  Meaningless if :purify is NIL.  See EXT:"
"PURIFY.\n"
"\n"
"  :environment-name\n"
"      Also passed to EXT:PURIFY when :PURIFY is T.  Rarely used.\n"
"  \n"
"  :init-function\n"
"      This is the function that starts running when the created core file "
"is\n"
"  resumed.  The default function simply invokes the top level\n"
"  read-eval-print loop.  If the function returns the lisp will exit.\n"
"  \n"
"  :load-init-file\n"
"      If true, then look for an init file when the core file is resumed.\n"
"  Look for home:init first and then home:.cmucl-init.  No error if\n"
"  there is no init file.\n"
"\n"
"  :site-init\n"
"      If true, then the name of the site init file to load.  The default is\n"
"  library:site-init if it exists.  If not, library:default-site-init\n"
"  is used if it exists.  No error if these files do not exist.\n"
"\n"
"  :print-herald\n"
"      If true (the default), print out the lisp system herald when "
"starting.\n"
"\n"
"  :process-command-line\n"
"      If true (the default), process command-line switches via the normal\n"
"  mechanisms, otherwise ignore all switches (except those processed by\n"
"  the C startup code).  In either case, the command line switches are\n"
"  saved in *COMMAND-LINE-STRINGS* and\n"
"  *COMMAND-LINE-APPLICATION-ARGUMENTS*.\n"
"\n"
"  :executable\n"
"      If nil (the default), save-lisp will save using the traditional\n"
"   core-file format.  If true, save-lisp will create an executable\n"
"   file that contains the lisp image built in. \n"
"   (Not all architectures support this yet.)\n"
"\n"
"  :batch-mode\n"
"      If nil (the default), then the presence of the -batch command-line\n"
"  switch will invoke batch-mode processing.  If true, the produced core\n"
"  will always be in batch-mode, regardless of any command-line switches.\n"
"\n"
"  :quiet\n"
"     If non-NIL, loading, compiling, and GC messages are suppressed.\n"
"     This is equivalent to setting *load-verbose*, *compile-verbose*,\n"
"     *compile-print*, *compile-progress*, *require-verbose*, and\n"
"     *gc-verbose* all to NIL.  If NIL (the default), the default\n"
"     values of these variables are used."
msgstr ""
"Avessay away CMU Ommoncay Isplay orecay imageway inway ethay ilefay ofway "
"ethay ecifiedspay amenay.  Ethay\n"
"  ollowingfay eywordskay areway efinedday:\n"
"  \n"
"  :urifypay\n"
"      Ifway uetray (ethay efaultday), oday away urifyingpay GC ichwhay "
"ovesmay allway ynamicallyday\n"
"  allocatedway objectsway intoway taticsay acespay osay atthay eythay taysay "
"urepay.  Isthay akestay\n"
"  omewhatsay ongerlay anthay ethay ormalnay GC ichwhay isway otherwiseway "
"oneday, utbay GC's illway\n"
"  ebay oneday esslay oftenway andway aketay esslay imetay inway ethay "
"esultingray orecay ilefay.  Eesay\n"
"  EXT:PURIFY.\n"
"\n"
"  :ootray-ucturesstray\n"
"      Isthay ouldshay ebay away istlay ofway ethay ainmay entryway ointspay "
"inway anyway ewlynay oadedlay\n"
"  ystemssay.  Isthay eednay otnay ebay uppliedsay, utbay ocalitylay andway/"
"orway GC erformancepay\n"
"  illway ebay etterbay ifway eythay areway.  Eaninglessmay ifway :urifypay "
"isway NIL.  Eesay EXT:PURIFY.\n"
"\n"
"  :environmentway-amenay\n"
"      Alsoway assedpay otay EXT:PURIFY enwhay :PURIFY isway T.  Arelyray "
"usedway.\n"
"  \n"
"  :initway-unctionfay\n"
"      Isthay isway ethay unctionfay atthay tartssay unningray enwhay ethay "
"eatedcray orecay ilefay isway\n"
"  esumedray.  Ethay efaultday unctionfay implysay invokesway ethay optay "
"evellay\n"
"  eadray-evalway-intpray ooplay.  Ifway ethay unctionfay eturnsray ethay "
"isplay illway exitway.\n"
"  \n"
"  :oadlay-initway-ilefay\n"
"      Ifway uetray, enthay ooklay orfay anway initway ilefay enwhay ethay "
"orecay ilefay isway esumedray.\n"
"  Ooklay orfay omehay:initway irstfay andway enthay omehay:.muclcay-"
"initway.  Onay errorway ifway\n"
"  erethay isway onay initway ilefay.\n"
"\n"
"  :itesay-initway\n"
"      Ifway uetray, enthay ethay amenay ofway ethay itesay initway ilefay "
"otay oadlay.  Ethay efaultday isway\n"
"  ibrarylay:itesay-initway.  Onay errorway ifway isthay oesday otnay "
"existway.\n"
"\n"
"  :intpray-eraldhay\n"
"      Ifway uetray (ethay efaultday), intpray outway ethay isplay ystemsay "
"eraldhay enwhay tartingsay.\n"
"\n"
"  :ocesspray-ommandcay-inelay\n"
"      Ifway uetray (ethay efaultday), ocesspray ommandcay-inelay witchessay "
"iavay ethay ormalnay\n"
"  echanismsmay, otherwiseway ignoreway allway witchessay (exceptway osethay "
"ocessedpray ybay ethay\n"
"  C tartupsay odecay).\n"
"\n"
"  :executableway\n"
"      Ifway ilnay (ethay efaultday), avesay-isplay illway avesay usingway "
"ethay aditionaltray\n"
"   orecay-ilefay ormatfay.  Ifway uetray, avesay-isplay illway eatecray "
"anway executableway\n"
"   ilefay atthay ontainscay ethay isplay imageway uiltbay inway. \n"
"   (Otnay allway architecturesway upportsay isthay etyay.)\n"
"\n"
"  :atchbay-odemay\n"
"      Ifway ilnay (ethay efaultday), enthay ethay esencepray ofway ethay -"
"atchbay ommandcay-inelay\n"
"  witchsay illway invokeway atchbay-odemay ocessingpray.  Ifway uetray, "
"ethay oducedpray orecay\n"
"  illway alwaysway ebay inway atchbay-odemay, egardlessray ofway anyway "
"ommandcay-inelay witchessay."

#: src/code/save.lisp
msgid "Directory ~S does not exist"
msgstr "Irectoryday ~S oesday otnay existway"

#: src/code/save.lisp
msgid "Skip remaining initializations."
msgstr "Kipsay emainingray initializationsway."

#: src/code/save.lisp
msgid "Error in batch processing:~%~A~%"
msgstr "Errorway inway atchbay ocessingpray:~%~Away~%"

#: src/code/save.lisp
msgid ""
"Determines what PRINT-HERALD prints (the system startup banner.)  This is a\n"
"   database which can be augmented by each loaded system.  The format is a\n"
"   property list which maps from subsystem names to the banner information "
"for\n"
"   that system.  This list can be manipulated with GETF -- entries are "
"printed\n"
"   in, reverse order, so the newest entry is printed last.  Usually the "
"system\n"
"   feature keyword is used as the system name.  A given banner is a list of\n"
"   strings and functions (or function names).  Strings are printed, and\n"
"   functions are called with an output stream argument."
msgstr ""
"Eterminesday atwhay PRINT-HERALD intspray (ethay ystemsay tartupsay "
"annerbay.)  Isthay isway away\n"
"   atabaseday ichwhay ancay ebay augmentedway ybay eachway oadedlay "
"ystemsay.  Ethay ormatfay isway away\n"
"   opertypray istlay ichwhay apsmay omfray ubsystemsay amesnay otay ethay "
"annerbay informationway orfay\n"
"   atthay ystemsay.  Isthay istlay ancay ebay anipulatedmay ithway GETF -- "
"entriesway areway intedpray\n"
"   inway, everseray orderway, osay ethay ewestnay entryway isway intedpray "
"astlay.  Usuallyway ethay ystemsay\n"
"   eaturefay eywordkay isway usedway asway ethay ystemsay amenay.  Away "
"ivengay annerbay isway away istlay ofway\n"
"   ingsstray andway unctionsfay (orway unctionfay amesnay).  Ingsstray "
"areway intedpray, andway\n"
"   unctionsfay areway alledcay ithway anway outputway eamstray argumentway."

#: src/code/save.lisp
msgid ", running on "
msgstr ", unningray onway "

#: src/code/save.lisp
msgid "With core: "
msgstr "Ithway orecay: "

#: src/code/save.lisp
msgid "Dumped on: "
msgstr "Umpedday onway: "

#: src/code/save.lisp
msgid " on "
msgstr " onway "

#: src/code/save.lisp
msgid "Please visit https://cmucl.org/bugs to report bugs and ask questions."
msgstr ""

#: src/code/save.lisp
msgid "Loaded subsystems:"
msgstr "Oadedlay ubsystemssay:"

#: src/code/save.lisp
msgid "    Unicode "
msgstr "    Unicodeway "

#: src/code/save.lisp
msgid "with Unicode version "
msgstr "ithway Unicodeway ersionvay "

#: src/code/save.lisp
msgid ""
"Print some descriptive information about the Lisp system version and\n"
"   configuration."
msgstr ""
"Intpray omesay escriptiveday informationway aboutway ethay Isplay ystemsay "
"ersionvay andway\n"
"   onfigurationcay."

#: src/code/save.lisp
msgid "Unrecognized *HERALD-ITEMS* entry: ~S."
msgstr "Unrecognizedway *HERALD-ITEMS* entryway: ~S."

#: src/code/save.lisp
msgid "Change *PACKAGE* to the USER package and try again."
msgstr "Angechay *PACKAGE* otay ethay USER ackagepay andway ytray againway."

#: src/code/stream.lisp
msgid "Terminal I/O stream."
msgstr "Erminaltay Iway/O eamstray."

#: src/code/stream.lisp
msgid "Default input stream."
msgstr "Efaultday inputway eamstray."

#: src/code/stream.lisp
msgid "Default output stream."
msgstr "Efaultday outputway eamstray."

#: src/code/stream.lisp
msgid "Error output stream."
msgstr "Errorway outputway eamstray."

#: src/code/stream.lisp
msgid "Query I/O stream."
msgstr "Eryquay Iway/O eamstray."

#: src/code/stream.lisp
msgid "Trace output stream."
msgstr "Acetray outputway eamstray."

#: src/code/stream.lisp
msgid "Interactive debugging stream."
msgstr "Interactiveway ebuggingday eamstray."

#: src/code/stream.lisp
msgid "~S is not an input stream."
msgstr "~S isway otnay anway inputway eamstray."

#: src/code/stream.lisp
msgid "~S is not an output stream."
msgstr "~S isway otnay anway outputway eamstray."

#: src/code/stream.lisp
msgid "~S is not a character input stream."
msgstr "~S isway otnay away aracterchay inputway eamstray."

#: src/code/stream.lisp
msgid "~S is not a character output stream."
msgstr "~S isway otnay away aracterchay outputway eamstray."

#: src/code/stream.lisp
msgid "~S is not a binary input stream."
msgstr "~S isway otnay away inarybay inputway eamstray."

#: src/code/stream.lisp
msgid ""
"~S is not a binary input stream ~\n"
"                          or does not support multi-byte read operations."
msgstr ""
"~S isway otnay away inarybay inputway eamstray ~\n"
"                          orway oesday otnay upportsay ultimay-ytebay eadray "
"operationsway."

#: src/code/stream.lisp
msgid "~S is not a binary output stream."
msgstr "~S isway otnay away inarybay outputway eamstray."

#: src/code/stream.lisp
msgid "~S is closed."
msgstr "~S isway osedclay."

#: src/code/stream.lisp
msgid "~S is an unsupported Gray stream."
msgstr "~S isway anway unsupportedway Aygray eamstray."

#: src/pcl/gray-streams.lisp src/code/stream.lisp
msgid "Returns non-nil if the given Stream can perform input operations."
msgstr ""
"Eturnsray onnay-ilnay ifway ethay ivengay Eamstray ancay erformpay inputway "
"operationsway."

#: src/pcl/gray-streams.lisp src/code/stream.lisp
msgid "Returns non-nil if the given Stream can perform output operations."
msgstr ""
"Eturnsray onnay-ilnay ifway ethay ivengay Eamstray ancay erformpay outputway "
"operationsway."

#: src/code/stream.lisp
msgid "Return true if Stream is not closed."
msgstr "Eturnray uetray ifway Eamstray isway otnay osedclay."

#: src/code/stream.lisp
msgid "Returns a type specifier for the kind of object returned by the Stream."
msgstr ""
"Eturnsray away ypetay ecifierspay orfay ethay indkay ofway objectway "
"eturnedray ybay ethay Eamstray."

#: src/code/stream.lisp
msgid ""
"Return true if Stream does I/O on a terminal or other interactive device."
msgstr ""
"Eturnray uetray ifway Eamstray oesday Iway/O onway away erminaltay orway "
"otherway interactiveway eviceday."

#: src/code/stream.lisp
msgid "Can't set interactive flag on ~S."
msgstr "Ancay't etsay interactiveway agflay onway ~S."

#: src/code/stream.lisp
msgid "Returns the external format used by the given Stream."
msgstr ""
"Eturnsray ethay externalway ormatfay usedway ybay ethay ivengay Eamstray."

#: src/code/stream.lisp
msgid ""
"Closes the given Stream.  No more I/O may be performed, but inquiries\n"
"  may still be made.  If :Abort is non-nil, an attempt is made to clean\n"
"  up the side effects of having created the stream."
msgstr ""
"Osesclay ethay ivengay Eamstray.  Onay oremay Iway/O aymay ebay erformedpay, "
"utbay inquiriesway\n"
"  aymay tillsay ebay ademay.  Ifway :Abortway isway onnay-ilnay, anway "
"attemptway isway ademay otay eanclay\n"
"  upway ethay idesay effectsway ofway avinghay eatedcray ethay eamstray."

#: src/code/stream.lisp
msgid ""
"With one argument returns the current position within the file\n"
"   File-Stream is open to.  If the second argument is supplied, then\n"
"   this becomes the new file position.  The second argument may also\n"
"   be :start or :end for the start and end of the file, respectively."
msgstr ""
"Ithway oneway argumentway eturnsray ethay urrentcay ositionpay ithinway "
"ethay ilefay\n"
"   Ilefay-Eamstray isway openway otay.  Ifway ethay econdsay argumentway "
"isway uppliedsay, enthay\n"
"   isthay ecomesbay ethay ewnay ilefay ositionpay.  Ethay econdsay "
"argumentway aymay alsoway\n"
"   ebay :tartsay orway :endway orfay ethay tartsay andway endway ofway ethay "
"ilefay, espectivelyray."

#: src/code/stream.lisp
msgid ""
"This function returns the length of the file that File-Stream is open to."
msgstr ""
"Isthay unctionfay eturnsray ethay engthlay ofway ethay ilefay atthay Ilefay-"
"Eamstray isway openway otay."

#: src/code/stream.lisp
msgid ""
"Returns a line of text read from the Stream as a string, discarding the\n"
"  newline character."
msgstr ""
"Eturnsray away inelay ofway exttay eadray omfray ethay Eamstray asway away "
"ingstray, iscardingday ethay\n"
"  ewlinenay aracterchay."

#: src/code/stream.lisp
msgid "Inputs a character from Stream and returns it."
msgstr "Inputsway away aracterchay omfray Eamstray andway eturnsray itway."

#: src/code/stream.lisp
msgid "Puts the Character back on the front of the input Stream."
msgstr ""
"Utspay ethay Aracterchay ackbay onway ethay ontfray ofway ethay inputway "
"Eamstray."

#: src/code/stream.lisp
msgid "Nothing to unread."
msgstr "Othingnay otay unreadway."

#: src/code/stream.lisp
msgid ""
"Peeks at the next character in the input Stream.  See manual for details."
msgstr ""
"Eekspay atway ethay extnay aracterchay inway ethay inputway Eamstray.  Eesay "
"anualmay orfay etailsday."

#: src/code/stream.lisp
msgid "~@<bad PEEK-TYPE=~S, ~_expected ~S~:>"
msgstr "~@<adbay PEEK-TYPE=~S, ~_expectedway ~S~:>"

#: src/code/stream.lisp
msgid "Impossible case reached in PEEK-CHAR"
msgstr "Impossibleway asecay eachedray inway PEEK-CHAR"

#: src/code/stream.lisp
msgid ""
"Returns T if a character is available on the given Stream.\n"
"  Argument Width is only used by instances of SIMPLE-STREAM. If\n"
"  Stream is a LISP-STREAM or FUNDAMENTAL-STREAM, passing more\n"
"  than one argument is invalid."
msgstr ""

#: src/code/interr.lisp src/code/stream.lisp
msgid "Invalid number of arguments: ~S"
msgstr "Invalidway umbernay ofway argumentsway: ~S"

#: src/code/stream.lisp
msgid "Returns the next character from the Stream if one is available, or nil."
msgstr ""
"Eturnsray ethay extnay aracterchay omfray ethay Eamstray ifway oneway isway "
"availableway, orway ilnay."

#: src/code/stream.lisp
msgid "Clears any buffered input associated with the Stream."
msgstr ""
"Earsclay anyway ufferedbay inputway associatedway ithway ethay Eamstray."

#: src/code/stream.lisp
msgid "Returns the next byte of the Stream."
msgstr "Eturnsray ethay extnay ytebay ofway ethay Eamstray."

#: src/code/stream.lisp
msgid ""
"Reads Numbytes bytes into the Buffer starting at Start, returning the "
"number\n"
"   of bytes read.\n"
"   -- If EOF-ERROR-P is true, an END-OF-FILE condition is signalled if\n"
"      end-of-file is encountered before Count bytes have been read.\n"
"   -- If EOF-ERROR-P is false, READ-N-BYTES reads as much data as is "
"currently\n"
"      available (up to count bytes).  On pipes or similar devices, this\n"
"      function returns as soon as any data is available, even if the amount\n"
"      read is less than Count and eof has not been hit."
msgstr ""
"Eadsray Umbytesnay ytesbay intoway ethay Ufferbay tartingsay atway Tartsay, "
"eturningray ethay umbernay\n"
"   ofway ytesbay eadray.\n"
"   -- Ifway EOF-ERROR-P isway uetray, anway END-OF-FILE onditioncay isway "
"ignalledsay ifway\n"
"      endway-ofway-ilefay isway encounteredway eforebay Ountcay ytesbay "
"avehay eenbay eadray.\n"
"   -- Ifway EOF-ERROR-P isway alsefay, READ-N-BYTES eadsray asway uchmay "
"ataday asway isway urrentlycay\n"
"      availableway (upway otay ountcay ytesbay).  Onway ipespay orway "
"imilarsay evicesday, isthay\n"
"      unctionfay eturnsray asway oonsay asway anyway ataday isway "
"availableway, evenway ifway ethay amountway\n"
"      eadray isway esslay anthay Ountcay andway eofway ashay otnay eenbay "
"ithay."

#: src/code/stream.lisp
msgid "Outputs the Character to the Stream."
msgstr "Outputsway ethay Aracterchay otay ethay Eamstray."

#: src/code/stream.lisp
msgid "Outputs a new line to the Stream."
msgstr "Outputsway away ewnay inelay otay ethay Eamstray."

#: src/code/stream.lisp
msgid ""
"Outputs a new line to the Stream if it is not positioned at the beginning "
"of\n"
"   a line.  Returns T if it output a new line, nil otherwise."
msgstr ""
"Outputsway away ewnay inelay otay ethay Eamstray ifway itway isway otnay "
"ositionedpay atway ethay eginningbay ofway\n"
"   away inelay.  Eturnsray T ifway itway outputway away ewnay inelay, ilnay "
"otherwiseway."

#: src/code/stream.lisp
msgid "Outputs the String to the given Stream."
msgstr "Outputsway ethay Ingstray otay ethay ivengay Eamstray."

#: src/code/stream.lisp
msgid ""
"Outputs the String to the given Stream, followed by a newline character."
msgstr ""
"Outputsway ethay Ingstray otay ethay ivengay Eamstray, ollowedfay ybay away "
"ewlinenay aracterchay."

#: src/code/stream.lisp
msgid ""
"Returns the number of characters on the current line of output of the given\n"
"  Stream, or Nil if that information is not availible."
msgstr ""
"Eturnsray ethay umbernay ofway aracterschay onway ethay urrentcay inelay "
"ofway outputway ofway ethay ivengay\n"
"  Eamstray, orway Ilnay ifway atthay informationway isway otnay availibleway."

#: src/code/stream.lisp
msgid ""
"Returns the number of characters that will fit on a line of output on the\n"
"  given Stream, or Nil if that information is not available."
msgstr ""
"Eturnsray ethay umbernay ofway aracterschay atthay illway itfay onway away "
"inelay ofway outputway onway ethay\n"
"  ivengay Eamstray, orway Ilnay ifway atthay informationway isway otnay "
"availableway."

#: src/code/stream.lisp
msgid ""
"Attempts to ensure that all output sent to the Stream has reached its\n"
"   destination, and only then returns."
msgstr ""
"Attemptsway otay ensureway atthay allway outputway entsay otay ethay "
"Eamstray ashay eachedray itsway\n"
"   estinationday, andway onlyway enthay eturnsray."

#: src/code/stream.lisp
msgid "Attempts to force any buffered output to be sent."
msgstr "Attemptsway otay orcefay anyway ufferedbay outputway otay ebay entsay."

#: src/code/stream.lisp
msgid "Clears the given output Stream."
msgstr "Earsclay ethay ivengay outputway Eamstray."

#: src/code/stream.lisp
msgid "Outputs the Integer to the binary Stream."
msgstr "Outputsway ethay Integerway otay ethay inarybay Eamstray."

#: src/code/stream.lisp
msgid ""
"Returns an output stream which sends its output to all of the given\n"
"streams."
msgstr ""
"Eturnsray anway outputway eamstray ichwhay endssay itsway outputway otay "
"allway ofway ethay ivengay\n"
"eamsstray."

#: src/code/stream.lisp
msgid ""
"Returns a stream which performs its operations on the stream which is the\n"
"   value of the dynamic variable named by Symbol."
msgstr ""
"Eturnsray away eamstray ichwhay erformspay itsway operationsway onway ethay "
"eamstray ichwhay isway ethay\n"
"   aluevay ofway ethay ynamicday ariablevay amednay ybay Ymbolsay."

#: src/code/stream.lisp
msgid ""
"Returns a bidirectional stream which gets its input from Input-Stream and\n"
"   sends its output to Output-Stream."
msgstr ""
"Eturnsray away idirectionalbay eamstray ichwhay etsgay itsway inputway "
"omfray Inputway-Eamstray andway\n"
"   endssay itsway outputway otay Outputway-Eamstray."

#: src/code/stream.lisp
msgid ""
"Returns a stream which takes its input from each of the Streams in turn,\n"
"   going on to the next at EOF."
msgstr ""
"Eturnsray away eamstray ichwhay akestay itsway inputway omfray eachway ofway "
"ethay Eamsstray inway urntay,\n"
"   oinggay onway otay ethay extnay atway EOF."

#: src/code/stream.lisp
msgid ""
"Returns an echo stream that takes input from Input-stream and sends\n"
"output to Output-stream"
msgstr ""
"Eturnsray anway echoway eamstray atthay akestay inputway omfray Inputway-"
"eamstray andway endssay\n"
"outputway otay Outputway-eamstray"

#: src/code/stream.lisp
msgid ""
"Returns a bidirectional stream which gets its input from Input-Stream and\n"
"   sends its output to Output-Stream.  In addition, all input is echoed to\n"
"   the output stream"
msgstr ""
"Eturnsray away idirectionalbay eamstray ichwhay etsgay itsway inputway "
"omfray Inputway-Eamstray andway\n"
"   endssay itsway outputway otay Outputway-Eamstray.  Inway additionway, "
"allway inputway isway echoedway otay\n"
"   ethay outputway eamstray"

#: src/code/stream.lisp
msgid ""
"Returns an input stream which will supply the characters of String between\n"
"  Start and End in order."
msgstr ""
"Eturnsray anway inputway eamstray ichwhay illway upplysay ethay aracterschay "
"ofway Ingstray etweenbay\n"
"  Tartsay andway Endway inway orderway."

#: src/code/stream.lisp
msgid ""
"Returns an Output stream which will accumulate all output given to it for\n"
"   the benefit of the function Get-Output-Stream-String."
msgstr ""
"Eturnsray anway Outputway eamstray ichwhay illway accumulateway allway "
"outputway ivengay otay itway orfay\n"
"   ethay enefitbay ofway ethay unctionfay Etgay-Outputway-Eamstray-Ingstray."

#: src/code/stream.lisp
msgid ""
"Returns a string of all the characters sent to a stream made by\n"
"   Make-String-Output-Stream since the last call to this function."
msgstr ""
"Eturnsray away ingstray ofway allway ethay aracterschay entsay otay away "
"eamstray ademay ybay\n"
"   Akemay-Ingstray-Outputway-Eamstray incesay ethay astlay allcay otay "
"isthay unctionfay."

#: src/code/stream.lisp
msgid ""
"Dumps the characters buffer up in the In-Stream to the Out-Stream as\n"
"  Get-Output-Stream-String would return them."
msgstr ""
"Umpsday ethay aracterschay ufferbay upway inway ethay Inway-Eamstray otay "
"ethay Outway-Eamstray asway\n"
"  Etgay-Outputway-Eamstray-Ingstray ouldway eturnray emthay."

#: src/code/stream.lisp
msgid "Returns an output stream which indents its output by some amount."
msgstr ""
"Eturnsray anway outputway eamstray ichwhay indentsway itsway outputway ybay "
"omesay amountway."

#: src/code/stream.lisp
msgid ""
"Returns a stream that sends all output to the stream TARGET, but modifies\n"
"   the case of letters, depending on KIND, which should be one of:\n"
"     :upcase - convert to upper case.\n"
"     :downcase - convert to lower case.\n"
"     :capitalize - convert the first letter of words to upper case and the\n"
"        rest of the word to lower case.\n"
"     :capitalize-first - convert the first letter of the first word to "
"upper\n"
"        case and everything else to lower case."
msgstr ""
"Eturnsray away eamstray atthay endssay allway outputway otay ethay eamstray "
"TARGET, utbay odifiesmay\n"
"   ethay asecay ofway etterslay, ependingday onway KIND, ichwhay ouldshay "
"ebay oneway ofway:\n"
"     :upcaseway - onvertcay otay upperway asecay.\n"
"     :owncaseday - onvertcay otay owerlay asecay.\n"
"     :apitalizecay - onvertcay ethay irstfay etterlay ofway ordsway otay "
"upperway asecay andway ethay\n"
"        estray ofway ethay ordway otay owerlay asecay.\n"
"     :apitalizecay-irstfay - onvertcay ethay irstfay etterlay ofway ethay "
"irstfay ordway otay upperway\n"
"        asecay andway everythingway elseway otay owerlay asecay."

#: src/code/stream.lisp
msgid ""
"This takes a stream and waits for text or a command to appear on it.  If\n"
"   text appears before a command, this returns nil, and otherwise it "
"returns\n"
"   a command."
msgstr ""
"Isthay akestay away eamstray andway aitsway orfay exttay orway away "
"ommandcay otay appearway onway itway.  Ifway\n"
"   exttay appearsway eforebay away ommandcay, isthay eturnsray ilnay, andway "
"otherwiseway itway eturnsray\n"
"   away ommandcay."

#: src/code/stream.lisp
msgid ""
"Destructively modify SEQ by reading elements from STREAM.\n"
"\n"
"  Seq is bounded by Start and End. Seq is destructively modified by\n"
"  copying successive elements into it from Stream. If the end of file\n"
"  for Stream is reached before copying all elements of the subsequence,\n"
"  then the extra elements near the end of sequence are not updated.\n"
"\n"
"  Argument(s):\n"
"  SEQ:\t    a proper SEQUENCE\n"
"  STREAM:   an input STREAM\n"
"  START:    a bounding index designator of type '(INTEGER 0 *)' (default 0)\n"
"  END:      a bounding index designator which be NIL or an INTEGER of\n"
"\t    type '(INTEGER 0 *)' (default NIL)\n"
"\n"
"  Value(s):\n"
"  POSITION: an INTEGER greater than or equal to zero, and less than or\n"
"\t    equal to the length of the SEQ. POSITION is the index of\n"
"\t    the first element of SEQ that was not updated, which might be\n"
"\t    less than END because the end of file was reached."
msgstr ""
"Estructivelyday odifymay SEQ ybay eadingray elementsway omfray STREAM.\n"
"\n"
"  Eqsay isway oundedbay ybay Tartsay andway Endway. Eqsay isway "
"estructivelyday odifiedmay ybay\n"
"  opyingcay uccessivesay elementsway intoway itway omfray Eamstray. Ifway "
"ethay endway ofway ilefay\n"
"  orfay Eamstray isway eachedray eforebay opyingcay allway elementsway ofway "
"ethay ubsequencesay,\n"
"  enthay ethay extraway elementsway earnay ethay endway ofway equencesay "
"areway otnay updatedway.\n"
"\n"
"  Argumentway(s):\n"
"  SEQ:\t    away operpray SEQUENCE\n"
"  STREAM:   anway inputway STREAM\n"
"  START:    away oundingbay indexway esignatorday ofway ypetay '(INTEGER 0 "
"*)' (efaultday 0)\n"
"  END:      away oundingbay indexway esignatorday ichwhay ebay NIL orway "
"anway INTEGER ofway\n"
"\t    ypetay '(INTEGER 0 *)' (efaultday NIL)\n"
"\n"
"  Aluevay(s):\n"
"  POSITION: anway INTEGER eatergray anthay orway equalway otay erozay, "
"andway esslay anthay orway\n"
"\t    equalway otay ethay engthlay ofway ethay SEQ. POSITION isway ethay "
"indexway ofway\n"
"\t    ethay irstfay elementway ofway SEQ atthay asway otnay updatedway, "
"ichwhay ightmay ebay\n"
"\t    esslay anthay END ecausebay ethay endway ofway ilefay asway eachedray."

#: src/code/stream.lisp
msgid "The stream is not open."
msgstr "Ethay eamstray isway otnay openway."

#: src/code/stream.lisp
msgid "The stream is not open for input."
msgstr "Ethay eamstray isway otnay openway orfay inputway."

#: src/code/stream.lisp
msgid "Trying to read characters from a binary stream."
msgstr "Yingtray otay eadray aracterschay omfray away inarybay eamstray."

#: src/code/stream.lisp
msgid ""
"Writes the elements of the Seq bounded by Start and End to Stream.\n"
"\n"
"  Argument(s):\n"
"  SEQ:     a proper SEQUENCE\n"
"  STREAM:  an output STREAM\n"
"  START:   a bounding index designator of type '(INTEGER 0 *)' (default 0)\n"
"  END:     a bounding index designator which be NIL or an INTEGER of\n"
"           type '(INTEGER 0 *)' (default NIL)\n"
"\n"
"  Value(s):\n"
"  SEQ:\ta proper SEQUENCE\n"
msgstr ""
"Iteswray ethay elementsway ofway ethay Eqsay oundedbay ybay Tartsay andway "
"Endway otay Eamstray.\n"
"\n"
"  Argumentway(s):\n"
"  SEQ:     away operpray SEQUENCE\n"
"  STREAM:  anway outputway STREAM\n"
"  START:   away oundingbay indexway esignatorday ofway ypetay '(INTEGER 0 "
"*)' (efaultday 0)\n"
"  END:     away oundingbay indexway esignatorday ichwhay ebay NIL orway "
"anway INTEGER ofway\n"
"           ypetay '(INTEGER 0 *)' (efaultday NIL)\n"
"\n"
"  Aluevay(s):\n"
"  SEQ:\taway operpray SEQUENCE\n"

#: src/code/stream.lisp
msgid "The stream is not open for output."
msgstr "Ethay eamstray isway otnay openway orfay outputway."

#: src/code/stream.lisp
msgid "Trying to output an element of unproper type to a stream."
msgstr ""
"Yingtray otay outputway anway elementway ofway unproperway ypetay otay away "
"eamstray."

#: src/code/stream.lisp
msgid "Trying to output a string to a binary stream."
msgstr "Yingtray otay outputway away ingstray otay away inarybay eamstray."

#: src/code/stream.lisp
msgid "Trying to output binary data to a text stream."
msgstr "Yingtray otay outputway inarybay ataday otay away exttay eamstray."

#: src/code/print.lisp
msgid ""
"If true, all objects will printed readably.  If readably printing is\n"
"  impossible, an error will be signalled.  This overrides the value of\n"
"  *PRINT-ESCAPE*."
msgstr ""
"Ifway uetray, allway objectsway illway intedpray eadablyray.  Ifway "
"eadablyray intingpray isway\n"
"  impossibleway, anway errorway illway ebay ignalledsay.  Isthay "
"overridesway ethay aluevay ofway\n"
"  *PRINT-ESCAPE*."

#: src/code/print.lisp
msgid "Flag which indicates that slashification is on.  See the manual"
msgstr ""
"Agflay ichwhay indicatesway atthay ashificationslay isway onway.  Eesay "
"ethay anualmay"

#: src/code/print.lisp
msgid "Flag which indicates that pretty printing is to be used"
msgstr ""
"Agflay ichwhay indicatesway atthay ettypray intingpray isway otay ebay "
"usedway"

#: src/code/print.lisp
msgid "The output base for integers and rationals."
msgstr "Ethay outputway asebay orfay integersway andway ationalsray."

#: src/code/print.lisp
msgid "This flag requests to verify base when printing rationals."
msgstr ""
"Isthay agflay equestsray otay erifyvay asebay enwhay intingpray ationalsray."

#: src/code/print.lisp
msgid "How many levels deep to print.  Unlimited if null."
msgstr "Owhay anymay evelslay eepday otay intpray.  Unlimitedway ifway ullnay."

#: src/code/print.lisp
msgid "How many elements to print on each level.  Unlimited if null."
msgstr ""
"Owhay anymay elementsway otay intpray onway eachway evellay.  Unlimitedway "
"ifway ullnay."

#: src/code/print.lisp
msgid "Whether to worry about circular list structures. See the manual."
msgstr ""
"Etherwhay otay orryway aboutway ircularcay istlay ucturesstray. Eesay ethay "
"anualmay."

#: src/code/print.lisp
msgid "What kind of case the printer should use by default"
msgstr ""
"Atwhay indkay ofway asecay ethay interpray ouldshay useway ybay efaultday"

#: src/code/print.lisp
msgid "Whether the array should print it's guts out"
msgstr "Etherwhay ethay arrayway ouldshay intpray itway's utsgay outway"

#: src/code/print.lisp
msgid ""
"If true, symbols with no home package are printed with a #: prefix.\n"
"  If false, no prefix is printed."
msgstr ""
"Ifway uetray, ymbolssay ithway onay omehay ackagepay areway intedpray ithway "
"away #: efixpray.\n"
"  Ifway alsefay, onay efixpray isway intedpray."

#: src/code/print.lisp
msgid "The maximum number of lines to print.  If NIL, unlimited."
msgstr ""
"Ethay aximummay umbernay ofway ineslay otay intpray.  Ifway NIL, "
"unlimitedway."

#: src/code/print.lisp
msgid ""
"The position of the right margin in ems.  If NIL, try to determine this\n"
"   from the stream in use."
msgstr ""
"Ethay ositionpay ofway ethay ightray arginmay inway emsway.  Ifway NIL, "
"ytray otay etermineday isthay\n"
"   omfray ethay eamstray inway useway."

#: src/code/print.lisp
msgid ""
"If the remaining space between the current column and the right margin\n"
"   is less than this, then print using ``miser-style'' output.  Miser\n"
"   style conditional newlines are turned on, and all indentations are\n"
"   turned off.  If NIL, never use miser mode."
msgstr ""
"Ifway ethay emainingray acespay etweenbay ethay urrentcay olumncay andway "
"ethay ightray arginmay\n"
"   isway esslay anthay isthay, enthay intpray usingway ``isermay-tylesay'' "
"outputway.  Isermay\n"
"   tylesay onditionalcay ewlinesnay areway urnedtay onway, andway allway "
"indentationsway areway\n"
"   urnedtay offway.  Ifway NIL, evernay useway isermay odemay."

#: src/code/print.lisp
msgid ""
"The pprint-dispatch-table that controls how to pretty print objects.  See\n"
"   COPY-PPRINT-DISPATH, PPRINT-DISPATCH, and SET-PPRINT-DISPATCH."
msgstr ""
"Ethay printpay-ispatchday-abletay atthay ontrolscay owhay otay ettypray "
"intpray objectsway.  Eesay\n"
"   COPY-PPRINT-DISPATH, PPRINT-DISPATCH, andway SET-PPRINT-DISPATCH."

#: src/code/print.lisp
msgid ""
"Bind the reader and printer control variables to values that enable READ\n"
"   to reliably read the results of PRINT.  These values are:\n"
"       *PACKAGE*\t\t\tThe COMMON-LISP-USER package\n"
"       *PRINT-ARRAY*\t\t\tT\n"
"       *PRINT-BASE*\t\t\t10\n"
"       *PRINT-CASE*\t\t\t:UPCASE\n"
"       *PRINT-CIRCLE*\t\t\tNIL\n"
"       *PRINT-ESCAPE*\t\t\tT\n"
"       *PRINT-GENSYM*\t\t\tT\n"
"       *PRINT-LENGTH*\t\t\tNIL\n"
"       *PRINT-LEVEL*\t\t\tNIL\n"
"       *PRINT-LINES*\t\t\tNIL\n"
"       *PRINT-MISER-WIDTH*\t\tNIL\n"
"       *PRINT-PPRINT-DISPATCH*          The standard pprint dispatch table\n"
"       *PRINT-PRETTY*\t\t\tNIL\n"
"       *PRINT-RADIX*\t\t\tNIL\n"
"       *PRINT-READABLY*\t\t\tT\n"
"       *PRINT-RIGHT-MARGIN*\t\tNIL\n"
"       *READ-BASE*\t\t\t10\n"
"       *READ-DEFAULT-FLOAT-FORMAT* \tSINGLE-FLOAT\n"
"       *READ-EVAL*\t\t\tT\n"
"       *READ-SUPPRESS*\t\t\tNIL\n"
"       *READTABLE*\t\t\tthe standard readtable."
msgstr ""
"Indbay ethay eaderray andway interpray ontrolcay ariablesvay otay aluesvay "
"atthay enableway READ\n"
"   otay eliablyray eadray ethay esultsray ofway PRINT.  Esethay aluesvay "
"areway:\n"
"       *PACKAGE*\t\t\tEthay COMMON-LISP-USER ackagepay\n"
"       *PRINT-ARRAY*\t\t\tT\n"
"       *PRINT-BASE*\t\t\t10\n"
"       *PRINT-CASE*\t\t\t:UPCASE\n"
"       *PRINT-CIRCLE*\t\t\tNIL\n"
"       *PRINT-ESCAPE*\t\t\tT\n"
"       *PRINT-GENSYM*\t\t\tT\n"
"       *PRINT-LENGTH*\t\t\tNIL\n"
"       *PRINT-LEVEL*\t\t\tNIL\n"
"       *PRINT-LINES*\t\t\tNIL\n"
"       *PRINT-MISER-WIDTH*\t\tNIL\n"
"       *PRINT-PPRINT-DISPATCH*          Ethay tandardsay printpay ispatchday "
"abletay\n"
"       *PRINT-PRETTY*\t\t\tNIL\n"
"       *PRINT-RADIX*\t\t\tNIL\n"
"       *PRINT-READABLY*\t\t\tT\n"
"       *PRINT-RIGHT-MARGIN*\t\tNIL\n"
"       *READ-BASE*\t\t\t10\n"
"       *READ-DEFAULT-FLOAT-FORMAT* \tSINGLE-FLOAT\n"
"       *READ-EVAL*\t\t\tT\n"
"       *READ-SUPPRESS*\t\t\tNIL\n"
"       *READTABLE*\t\t\tethay tandardsay eadtableray."

#: src/code/print.lisp
msgid "Outputs OBJECT to the specified stream, defaulting to *standard-output*"
msgstr ""
"Outputsway OBJECT otay ethay ecifiedspay eamstray, efaultingday otay "
"*standard-output*"

#: src/code/print.lisp
msgid ""
"Outputs a mostly READable printed representation of OBJECT on the specified\n"
"  stream."
msgstr ""
"Outputsway away ostlymay Eadableray intedpray epresentationray ofway OBJECT "
"onway ethay ecifiedspay\n"
"  eamstray."

#: src/code/print.lisp
msgid ""
"Outputs an asthetic but not READable printed representation of OBJECT on "
"the\n"
"  specified stream."
msgstr ""
"Outputsway anway astheticway utbay otnay Eadableray intedpray "
"epresentationray ofway OBJECT onway ethay\n"
"  ecifiedspay eamstray."

#: src/code/print.lisp
msgid ""
"Outputs a terpri, the mostly READable printed represenation of OBJECT, and \n"
"  space to the stream."
msgstr ""
"Outputsway away erpritay, ethay ostlymay Eadableray intedpray "
"epresenationray ofway OBJECT, andway \n"
"  acespay otay ethay eamstray."

#: src/code/print.lisp
msgid "Prettily outputs the Object preceded by a newline."
msgstr "Ettilypray outputsway ethay Objectway ecededpray ybay away ewlinenay."

#: src/code/print.lisp
msgid "Returns the printed representation of OBJECT as a string."
msgstr ""
"Eturnsray ethay intedpray epresentationray ofway OBJECT asway away ingstray."

#: src/code/print.lisp
msgid ""
"Returns the printed representation of OBJECT as a string with \n"
"   slashification on."
msgstr ""
"Eturnsray ethay intedpray epresentationray ofway OBJECT asway away ingstray "
"ithway \n"
"   ashificationslay onway."

#: src/code/print.lisp
msgid ""
"Returns the printed representation of OBJECT as a string with\n"
"  slashification off and readability off."
msgstr ""
"Eturnsray ethay intedpray epresentationray ofway OBJECT asway away ingstray "
"ithway\n"
"  ashificationslay offway andway eadabilityray offway."

#: src/compiler/byte-comp.lisp src/compiler/dyncount.lisp
#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/meta-vmdef.lisp src/compiler/vop.lisp src/compiler/node.lisp
#: src/compiler/sset.lisp src/compiler/backend.lisp src/code/print.lisp
msgid "~S cannot be printed readably."
msgstr "~S annotcay ebay intedpray eadablyray."

#: src/code/print.lisp
msgid "Determines whether or not the character is considered whitespace."
msgstr ""
"Eterminesday etherwhay orway otnay ethay aracterchay isway onsideredcay "
"itespacewhay."

#: src/code/print.lisp
msgid ""
"Check to see if OBJECT is a circular reference, and return something non-"
"NIL\n"
"   if it is.  If ASSIGN is T, then the number to use in the #n= and #n# "
"noise\n"
"   is assigned at this time.  Note: CHECK-FOR-CIRCULARITY must be called\n"
"   *EXACTLY* once with ASSIGN T, or the circularity detection noise will "
"get\n"
"   confused about when to use #n= and when to use #n#.  If this returns\n"
"   non-NIL when ASSIGN is T, then you must call HANDLE-CIRCULARITY on it."
msgstr ""
"Eckchay otay eesay ifway OBJECT isway away ircularcay eferenceray, andway "
"eturnray omethingsay onnay-NIL\n"
"   ifway itway isway.  Ifway ASSIGN isway T, enthay ethay umbernay otay "
"useway inway ethay #n= andway #n# oisenay\n"
"   isway assignedway atway isthay imetay.  Otenay: CHECK-FOR-CIRCULARITY "
"ustmay ebay alledcay\n"
"   *EXACTLY* onceway ithway ASSIGN T, orway ethay ircularitycay etectionday "
"oisenay illway etgay\n"
"   onfusedcay aboutway enwhay otay useway #n= andway enwhay otay useway "
"#n#.  Ifway isthay eturnsray\n"
"   onnay-NIL enwhay ASSIGN isway T, enthay ouyay ustmay allcay HANDLE-"
"CIRCULARITY onway itway."

#: src/code/print.lisp
msgid ""
"Handle the results of CHECK-FOR-CIRCULARITY.  If this returns T then\n"
"   you should go ahead and print the object.  If it returns NIL, then\n"
"   you should blow it off."
msgstr ""
"Andlehay ethay esultsray ofway CHECK-FOR-CIRCULARITY.  Ifway isthay "
"eturnsray T enthay\n"
"   ouyay ouldshay ogay aheadway andway intpray ethay objectway.  Ifway itway "
"eturnsray NIL, enthay\n"
"   ouyay ouldshay owblay itway offway."

#: src/code/print.lisp
msgid ""
"Attempt to use CHECK-FOR-CIRCULARITY when circularity ~\n"
"\t       checking has not been initiated."
msgstr ""
"Attemptway otay useway CHECK-FOR-CIRCULARITY enwhay ircularitycay ~\n"
"\t       eckingchay ashay otnay eenbay initiatedway."

#: src/code/print.lisp
msgid ""
"The current level we are printing at, to be compared against *PRINT-LEVEL*.\n"
"   See the macro DESCEND-INTO for a handy interface to depth abbreviation."
msgstr ""
"Ethay urrentcay evellay eway areway intingpray atway, otay ebay omparedcay "
"againstway *PRINT-LEVEL*.\n"
"   Eesay ethay acromay DESCEND-INTO orfay away andyhay interfaceway otay "
"epthday abbreviationway."

#: src/code/print.lisp
msgid ""
"Automatically handle *print-level* abbreviation.  If we are too deep, then\n"
"   a # is printed to STREAM and BODY is ignored."
msgstr ""
"Automaticallyway andlehay *print-level* abbreviationway.  Ifway eway areway "
"ootay eepday, enthay\n"
"   away # isway intedpray otay STREAM andway BODY isway ignoredway."

#: src/code/print.lisp
msgid ""
"Punt if INDEX is equal or larger then *PRINT-LENGTH* (and *PRINT-READABLY*\n"
"   is NIL) by outputting \"...\" and returning from the block named NIL."
msgstr ""
"Untpay ifway INDEX isway equalway orway argerlay enthay *PRINT-LENGTH* "
"(andway *PRINT-READABLY*\n"
"   isway NIL) ybay outputtingway \"...\" andway eturningray omfray ethay "
"ockblay amednay NIL."

#: src/code/print.lisp
msgid ""
"The current pretty printer.  Should be either a function that takes two\n"
"   arguments (the object and the stream) or NIL to indicate that there is\n"
"   no pretty printer installed."
msgstr ""
"Ethay urrentcay ettypray interpray.  Ouldshay ebay eitherway away unctionfay "
"atthay akestay wotay\n"
"   argumentsway (ethay objectway andway ethay eamstray) orway NIL otay "
"indicateway atthay erethay isway\n"
"   onay ettypray interpray installedway."

#: src/code/print.lisp
msgid "Output OBJECT to STREAM observing all printer control variables."
msgstr ""
"Outputway OBJECT otay STREAM observingway allway interpray ontrolcay "
"ariablesvay."

#: src/code/print.lisp
msgid ""
"Output OBJECT to STREAM observing all printer control variables except\n"
"   for *PRINT-PRETTY*.  Note: if *PRINT-PRETTY* is non-NIL, then the pretty\n"
"   printer will be used for any components of OBJECT, just not for OBJECT\n"
"   itself."
msgstr ""
"Outputway OBJECT otay STREAM observingway allway interpray ontrolcay "
"ariablesvay exceptway\n"
"   orfay *PRINT-PRETTY*.  Otenay: ifway *PRINT-PRETTY* isway onnay-NIL, "
"enthay ethay ettypray\n"
"   interpray illway ebay usedway orfay anyway omponentscay ofway OBJECT, "
"ustjay otnay orfay OBJECT\n"
"   itselfway."

#: src/code/print.lisp
msgid "Invalid *PRINT-CASE* value: ~S"
msgstr "Invalidway *PRINT-CASE* aluevay: ~S"

#: src/code/print.lisp
msgid "Invalid READTABLE-CASE value: ~S"
msgstr "Invalidway READTABLE-CASE aluevay: ~S"

#: src/code/print.lisp
msgid ""
"Outputs the printed representation of any array in either the #< or #A\n"
"   form."
msgstr ""
"Outputsway ethay intedpray epresentationray ofway anyway arrayway inway "
"eitherway ethay #< orway #Away\n"
"   ormfay."

#: src/code/print.lisp
msgid "Obsolete Instance"
msgstr "Obsoleteway Instanceway"

#: src/code/print.lisp
msgid "Unprintable Instance"
msgstr "Unprintableway Instanceway"

#: src/code/print.lisp
msgid "~A is not a reasonable value for *Print-Base*."
msgstr "~Away isway otnay away easonableray aluevay orfay *Print-Base*."

#: src/code/print.lisp
msgid ""
"Compute a list of pairs (2^i . r^{2^i}), stopping with the largest r^{2^i}\n"
"greater than n."
msgstr ""
"Omputecay away istlay ofway airspay (2^i . r^{2^i}), toppingsay ithway ethay "
"argestlay r^{2^i}\n"
"eatergray anthay n."

#: src/code/print.lisp
msgid "overflow in digit-to-char"
msgstr "overflowway inway igitday-otay-archay"

#: src/code/print.lisp
msgid "Convert digit into a character representation."
msgstr "Onvertcay igitday intoway away aracterchay epresentationray."

#: src/code/print.lisp
msgid ""
"Print a fixnum N to stream S, maybe with leading zeros.  This isn't\n"
"ever-so efficient, but we probably don't need to care."
msgstr ""
"Intpray away ixnumfay N otay eamstray S, aybemay ithway eadinglay eroszay.  "
"Isthay isnway't\n"
"everway-osay efficientway, utbay eway obablypray onday't eednay otay arecay."

#: src/code/print.lisp
msgid ""
"Use the power list (see power-list) PL to split N roughly in half; then\n"
"print the left and right halves using (cdr PL).  Make sure we count the\n"
"leading zeroes correctly."
msgstr ""
"Useway ethay owerpay istlay (eesay owerpay-istlay) PL otay litspay N "
"oughlyray inway alfhay; enthay\n"
"intpray ethay eftlay andway ightray alveshay usingway (drcay PL).  Akemay "
"uresay eway ountcay ethay\n"
"eadinglay eroeszay orrectlycay."

#: src/code/print.lisp
msgid ""
"Primary fast bignum-printing interface.  Prints integer N to stream S in\n"
"radix-R.  If you have a power-list then pass it in as PL."
msgstr ""
"Imarypray astfay ignumbay-intingpray interfaceway.  Intspray integerway N "
"otay eamstray S inway\n"
"adixray-R.  Ifway ouyay avehay away owerpay-istlay enthay asspay itway inway "
"asway PL."

#: src/code/print.lisp
msgid ""
"Minimum power of 10 that allows the float printer to use free format,\n"
"   instead of exponential format.  See section 22.1.3.1.3: Printing Floats\n"
"   in the ANSI CL standard."
msgstr ""
"Inimummay owerpay ofway 10 atthay allowsway ethay oatflay interpray otay "
"useway eefray ormatfay,\n"
"   insteadway ofway exponentialway ormatfay.  Eesay ectionsay 22.1.3.1.3: "
"Intingpray Oatsflay\n"
"   inway ethay ANSI CL tandardsay."

#: src/code/print.lisp
msgid ""
"Maximum power of 10 that allows the float printer to use free format,\n"
"   instead of exponential format.  See section 22.1.3.1.3: Printing Floats\n"
"   in the ANSI CL standard."
msgstr ""
"Aximummay owerpay ofway 10 atthay allowsway ethay oatflay interpray otay "
"useway eefray ormatfay,\n"
"   insteadway ofway exponentialway ormatfay.  Eesay ectionsay 22.1.3.1.3: "
"Intingpray Oatsflay\n"
"   inway ethay ANSI CL tandardsay."

#: src/code/print.lisp
msgid "Convert a DD number to a lisp rational"
msgstr "Onvertcay away DD umbernay otay away isplay ationalray"

#: src/code/print.lisp
msgid "Print out a double-double to a string"
msgstr "Intpray outway away oubleday-oubleday otay away ingstray"

#: src/code/print.lisp
msgid "Weak Pointer: "
msgstr "Eakway Ointerpay: "

#: src/code/print.lisp
msgid "Broken Weak Pointer"
msgstr "Okenbray Eakway Ointerpay"

#: src/code/print.lisp
msgid "Bogus Code Object"
msgstr "Ogusbay Odecay Objectway"

#: src/code/print.lisp
msgid "Code Object"
msgstr "Odecay Objectway"

#: src/code/print.lisp
msgid "Return PC Object"
msgstr "Eturnray PC Objectway"

#: src/code/print.lisp
msgid "FDEFINITION object for "
msgstr "FDEFINITION objectway orfay "

#: src/code/print.lisp
msgid "Function "
msgstr "Unctionfay "

#: src/code/print.lisp
msgid "Interpreted Function ~S"
msgstr "Interpretedway Unctionfay ~S"

#: src/code/print.lisp
msgid "Byte Compiled Function"
msgstr "Ytebay Ompiledcay Unctionfay"

#: src/code/print.lisp
msgid "Byte Compiled Closure"
msgstr "Ytebay Ompiledcay Osureclay"

#: src/code/print.lisp
msgid "Closure Over "
msgstr "Osureclay Overway "

#: src/code/print.lisp
msgid "Unknown Function"
msgstr "Unknownway Unctionfay"

#: src/code/print.lisp
msgid "Value Cell "
msgstr "Aluevay Ellcay "

#: src/code/print.lisp
msgid "Unknown Pointer Object, type="
msgstr "Unknownway Ointerpay Objectway, ypetay="

#: src/code/print.lisp
msgid "Unbound Marker"
msgstr "Unboundway Arkermay"

#: src/code/print.lisp
msgid "Unknown Immediate Object, lowtag="
msgstr "Unknownway Immediateway Objectway, owtaglay="

#: src/code/print.lisp
msgid ", type="
msgstr ", ypetay="

#: src/code/print.lisp
msgid "Continue anyway"
msgstr "Ontinuecay anywayway"

#: src/code/print.lisp
msgid "Cannot find ~S, so unicode support is not available"
msgstr "Annotcay indfay ~S, osay unicodeway upportsay isway otnay availableway"

#: src/code/pprint.lisp
msgid ""
"Insert an annotation into the pretty-printing stream STREAM.\n"
"HANDLER is a function, and RECORD is an arbitrary datum.  The\n"
"pretty-printing stream conceptionally queues annotations in sequence\n"
"with the characters that are printed to the stream, until the stream\n"
"has decided on the concrete layout.  When the characters are forwarded\n"
"to the target stream, annotations are invoked at the right position.\n"
"An annotation is invoked by calling the function HANDLER with the\n"
"three arguments RECORD, TARGET-STREAM, and TRUNCATEP.  The argument\n"
"TRUNCATEP is true if the text surrounding the annotation is suppressed\n"
"due to line abbreviation (see *PRINT-LINES*).\n"
"If STREAM is not a pretty-printing stream, simply call HANDLER\n"
"with the arguments RECORD, STREAM and nil."
msgstr ""
"Insertway anway annotationway intoway ethay ettypray-intingpray eamstray "
"STREAM.\n"
"HANDLER isway away unctionfay, andway RECORD isway anway arbitraryway "
"atumday.  Ethay\n"
"ettypray-intingpray eamstray onceptionallycay euesquay annotationsway inway "
"equencesay\n"
"ithway ethay aracterschay atthay areway intedpray otay ethay eamstray, "
"untilway ethay eamstray\n"
"ashay ecidedday onway ethay oncretecay ayoutlay.  Enwhay ethay aracterschay "
"areway orwardedfay\n"
"otay ethay argettay eamstray, annotationsway areway invokedway atway ethay "
"ightray ositionpay.\n"
"Anway annotationway isway invokedway ybay allingcay ethay unctionfay HANDLER "
"ithway ethay\n"
"reethay argumentsway RECORD, TARGET-STREAM, andway TRUNCATEP.  Ethay "
"argumentway\n"
"TRUNCATEP isway uetray ifway ethay exttay urroundingsay ethay annotationway "
"isway uppressedsay\n"
"ueday otay inelay abbreviationway (eesay *PRINT-LINES*).\n"
"Ifway STREAM isway otnay away ettypray-intingpray eamstray, implysay allcay "
"HANDLER\n"
"ithway ethay argumentsway RECORD, STREAM andway ilnay."

#: src/code/pprint.lisp
msgid "Insert ANNOTATION into the queue of annotations in STREAM."
msgstr ""
"Insertway ANNOTATION intoway ethay euequay ofway annotationsway inway STREAM."

#: src/code/pprint.lisp
msgid ""
"Insert all annotations in STREAM from the queue of pending\n"
"operations into the queue of annotations.  When END is non-nil, \n"
"stop before reaching the queued-op END."
msgstr ""
"Insertway allway annotationsway inway STREAM omfray ethay euequay ofway "
"endingpay\n"
"operationsway intoway ethay euequay ofway annotationsway.  Enwhay END isway "
"onnay-ilnay, \n"
"topsay eforebay eachingray ethay euedquay-opway END."

#: src/code/pprint.lisp
msgid ""
"Dequeue the next annotation from the queue of annotations of STREAM\n"
"and return it.  Return nil if there are no more annotations.  When\n"
":END-POSN is given and the next annotation has a posn greater than\n"
"this, also return nil."
msgstr ""
"Equeueday ethay extnay annotationway omfray ethay euequay ofway "
"annotationsway ofway STREAM\n"
"andway eturnray itway.  Eturnray ilnay ifway erethay areway onay oremay "
"annotationsway.  Enwhay\n"
":END-POSN isway ivengay andway ethay extnay annotationway ashay away osnpay "
"eatergray anthay\n"
"isthay, alsoway eturnray ilnay."

#: src/code/pprint.lisp
msgid ""
"Output the buffer of STREAM up to (excluding) the buffer index END.\n"
"When annotations are present, invoke them at the right positions."
msgstr ""
"Outputway ethay ufferbay ofway STREAM upway otay (excludingway) ethay "
"ufferbay indexway END.\n"
"Enwhay annotationsway areway esentpray, invokeway emthay atway ethay ightray "
"ositionspay."

#: src/code/pprint.lisp
msgid ""
"Invoke all annotations in STREAM up to (including) the buffer index END."
msgstr ""
"Invokeway allway annotationsway inway STREAM upway otay (includingway) ethay "
"ufferbay indexway END."

#: src/code/pprint.lisp
msgid "Output-partial-line called when nothing can be output."
msgstr ""
"Outputway-artialpay-inelay alledcay enwhay othingnay ancay ebay outputway."

#: src/code/pprint.lisp
msgid ""
"Group some output into a logical block.  STREAM-SYMBOL should be either a\n"
"   stream, T (for *TERMINAL-IO*), or NIL (for *STANDARD-OUTPUT*).  The "
"printer\n"
"   control variable *PRINT-LEVEL* is automatically handled."
msgstr ""
"Oupgray omesay outputway intoway away ogicallay ockblay.  STREAM-SYMBOL "
"ouldshay ebay eitherway away\n"
"   eamstray, T (orfay *TERMINAL-IO*), orway NIL (orfay *STANDARD-OUTPUT*).  "
"Ethay interpray\n"
"   ontrolcay ariablevay *PRINT-LEVEL* isway automaticallyway andledhay."

#: src/code/pprint.lisp
msgid "Cannot specify both a prefix and a per-line-prefix."
msgstr ""
"Annotcay ecifyspay othbay away efixpray andway away erpay-inelay-efixpray."

#: src/code/pprint.lisp
msgid ""
"Cause the closest enclosing use of PPRINT-LOGICAL-BLOCK to return\n"
"   if it's list argument is exhausted.  Can only be used inside\n"
"   PPRINT-LOGICAL-BLOCK, and only when the LIST argument to\n"
"   PPRINT-LOGICAL-BLOCK is supplied."
msgstr ""
"Ausecay ethay osestclay enclosingway useway ofway PPRINT-LOGICAL-BLOCK otay "
"eturnray\n"
"   ifway itway's istlay argumentway isway exhaustedway.  Ancay onlyway ebay "
"usedway insideway\n"
"   PPRINT-LOGICAL-BLOCK, andway onlyway enwhay ethay LIST argumentway otay\n"
"   PPRINT-LOGICAL-BLOCK isway uppliedsay."

#: src/code/pprint.lisp
msgid ""
"PPRINT-EXIT-IF-LIST-EXHAUSTED must be lexically inside ~\n"
"\t  PPRINT-LOGICAL-BLOCK."
msgstr ""
"PPRINT-EXIT-IF-LIST-EXHAUSTED ustmay ebay exicallylay insideway ~\n"
"\t  PPRINT-LOGICAL-BLOCK."

#: src/code/pprint.lisp
msgid ""
"Return the next element from LIST argument to the closest enclosing\n"
"   use of PPRINT-LOGICAL-BLOCK, automatically handling *PRINT-LENGTH*\n"
"   and *PRINT-CIRCLE*.  Can only be used inside PPRINT-LOGICAL-BLOCK.\n"
"   If the LIST argument to PPRINT-LOGICAL-BLOCK was NIL, then nothing\n"
"   is poped, but the *PRINT-LENGTH* testing still happens."
msgstr ""
"Eturnray ethay extnay elementway omfray LIST argumentway otay ethay "
"osestclay enclosingway\n"
"   useway ofway PPRINT-LOGICAL-BLOCK, automaticallyway andlinghay *PRINT-"
"LENGTH*\n"
"   andway *PRINT-CIRCLE*.  Ancay onlyway ebay usedway insideway PPRINT-"
"LOGICAL-BLOCK.\n"
"   Ifway ethay LIST argumentway otay PPRINT-LOGICAL-BLOCK asway NIL, enthay "
"othingnay\n"
"   isway opedpay, utbay ethay *PRINT-LENGTH* estingtay tillsay appenshay."

#: src/code/pprint.lisp
msgid "PPRINT-POP must be lexically inside PPRINT-LOGICAL-BLOCK."
msgstr "PPRINT-POP ustmay ebay exicallylay insideway PPRINT-LOGICAL-BLOCK."

#: src/code/pprint.lisp
msgid ""
"Output a conditional newline to STREAM (which defaults to\n"
"   *STANDARD-OUTPUT*) if it is a pretty-printing stream, and do\n"
"   nothing if not.  KIND can be one of:\n"
"     :LINEAR - A line break is inserted if and only if the immediatly\n"
"        containing section cannot be printed on one line.\n"
"     :MISER - Same as LINEAR, but only if ``miser-style'' is in effect.\n"
"        (See *PRINT-MISER-WIDTH*.)\n"
"     :FILL - A line break is inserted if and only if either:\n"
"       (a) the following section cannot be printed on the end of the\n"
"           current line,\n"
"       (b) the preceding section was not printed on a single line, or\n"
"       (c) the immediately containing section cannot be printed on one\n"
"           line and miser-style is in effect.\n"
"     :MANDATORY - A line break is always inserted.\n"
"   When a line break is inserted by any type of conditional newline, any\n"
"   blanks that immediately precede the conditional newline are ommitted\n"
"   from the output and indentation is introduced at the beginning of the\n"
"   next line.  (See PPRINT-INDENT.)"
msgstr ""
"Outputway away onditionalcay ewlinenay otay STREAM (ichwhay efaultsday otay\n"
"   *STANDARD-OUTPUT*) ifway itway isway away ettypray-intingpray eamstray, "
"andway oday\n"
"   othingnay ifway otnay.  KIND ancay ebay oneway ofway:\n"
"     :LINEAR - Away inelay eakbray isway insertedway ifway andway onlyway "
"ifway ethay immediatlyway\n"
"        ontainingcay ectionsay annotcay ebay intedpray onway oneway inelay.\n"
"     :MISER - Amesay asway LINEAR, utbay onlyway ifway ``isermay-tylesay'' "
"isway inway effectway.\n"
"        (Eesay *PRINT-MISER-WIDTH*.)\n"
"     :FILL - Away inelay eakbray isway insertedway ifway andway onlyway "
"ifway eitherway:\n"
"       (away) ethay ollowingfay ectionsay annotcay ebay intedpray onway "
"ethay endway ofway ethay\n"
"           urrentcay inelay,\n"
"       (b) ethay ecedingpray ectionsay asway otnay intedpray onway away "
"inglesay inelay, orway\n"
"       (c) ethay immediatelyway ontainingcay ectionsay annotcay ebay "
"intedpray onway oneway\n"
"           inelay andway isermay-tylesay isway inway effectway.\n"
"     :MANDATORY - Away inelay eakbray isway alwaysway insertedway.\n"
"   Enwhay away inelay eakbray isway insertedway ybay anyway ypetay ofway "
"onditionalcay ewlinenay, anyway\n"
"   anksblay atthay immediatelyway ecedepray ethay onditionalcay ewlinenay "
"areway ommittedway\n"
"   omfray ethay outputway andway indentationway isway introducedway atway "
"ethay eginningbay ofway ethay\n"
"   extnay inelay.  (Eesay PPRINT-INDENT.)"

#: src/code/pprint.lisp
msgid ""
"Specify the indentation to use in the current logical block if STREAM\n"
"   (which defaults to *STANDARD-OUTPUT*) is a pretty-printing stream\n"
"   and do nothing if not.  (See PPRINT-LOGICAL-BLOCK.)  N is the indention\n"
"   to use (in ems, the width of an ``m'') and RELATIVE-TO can be either:\n"
"     :BLOCK - Indent relative to the column the current logical block\n"
"        started on.\n"
"     :CURRENT - Indent relative to the current column.\n"
"   The new indention value does not take effect until the following line\n"
"   break.  The indention value is silently truncated to an integer."
msgstr ""
"Ecifyspay ethay indentationway otay useway inway ethay urrentcay ogicallay "
"ockblay ifway STREAM\n"
"   (ichwhay efaultsday otay *STANDARD-OUTPUT*) isway away ettypray-"
"intingpray eamstray\n"
"   andway oday othingnay ifway otnay.  (Eesay PPRINT-LOGICAL-BLOCK.)  N "
"isway ethay indentionway\n"
"   otay useway (inway emsway, ethay idthway ofway anway ``m'') andway "
"RELATIVE-TO ancay ebay eitherway:\n"
"     :BLOCK - Indentway elativeray otay ethay olumncay ethay urrentcay "
"ogicallay ockblay\n"
"        tartedsay onway.\n"
"     :CURRENT - Indentway elativeray otay ethay urrentcay olumncay.\n"
"   Ethay ewnay indentionway aluevay oesday otnay aketay effectway untilway "
"ethay ollowingfay inelay\n"
"   eakbray.  Ethay indentionway aluevay isway ilentlysay uncatedtray otay "
"anway integerway."

#: src/code/pprint.lisp
msgid ""
"If STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing\n"
"   stream, perform tabbing based on KIND, otherwise do nothing.  KIND can\n"
"   be one of:\n"
"     :LINE - Tab to column COLNUM.  If already past COLNUM tab to the next\n"
"       multiple of COLINC.\n"
"     :SECTION - Same as :LINE, but count from the start of the current\n"
"       section, not the start of the line.\n"
"     :LINE-RELATIVE - Output COLNUM spaces, then tab to the next multiple "
"of\n"
"       COLINC.\n"
"     :SECTION-RELATIVE - Same as :LINE-RELATIVE, but count from the start\n"
"       of the current section, not the start of the line."
msgstr ""
"Ifway STREAM (ichwhay efaultsday otay *STANDARD-OUTPUT*) isway away ettypray-"
"intingpray\n"
"   eamstray, erformpay abbingtay asedbay onway KIND, otherwiseway oday "
"othingnay.  KIND ancay\n"
"   ebay oneway ofway:\n"
"     :LINE - Abtay otay olumncay COLNUM.  Ifway alreadyway astpay COLNUM "
"abtay otay ethay extnay\n"
"       ultiplemay ofway COLINC.\n"
"     :SECTION - Amesay asway :LINE, utbay ountcay omfray ethay tartsay ofway "
"ethay urrentcay\n"
"       ectionsay, otnay ethay tartsay ofway ethay inelay.\n"
"     :LINE-RELATIVE - Outputway COLNUM acesspay, enthay abtay otay ethay "
"extnay ultiplemay ofway\n"
"       COLINC.\n"
"     :SECTION-RELATIVE - Amesay asway :LINE-RELATIVE, utbay ountcay omfray "
"ethay tartsay\n"
"       ofway ethay urrentcay ectionsay, otnay ethay tartsay ofway ethay "
"inelay."

#: src/code/pprint.lisp
msgid ""
"Output LIST to STREAM putting :FILL conditional newlines between each\n"
"   element.  If COLON? is NIL (defaults to T), then no parens are printed\n"
"   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-FILL\n"
"   can be used with the ~/.../ format directive."
msgstr ""
"Outputway LIST otay STREAM uttingpay :FILL onditionalcay ewlinesnay "
"etweenbay eachway\n"
"   elementway.  Ifway COLON? isway NIL (efaultsday otay T), enthay onay "
"arenspay areway intedpray\n"
"   aroundway ethay outputway.  ATSIGN? isway ignoredway (utbay allowedway "
"osay atthay PPRINT-FILL\n"
"   ancay ebay usedway ithway ethay ~/.../ ormatfay irectiveday."

#: src/code/pprint.lisp
msgid ""
"Output LIST to STREAM putting :LINEAR conditional newlines between each\n"
"   element.  If COLON? is NIL (defaults to T), then no parens are printed\n"
"   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-"
"LINEAR\n"
"   can be used with the ~/.../ format directive."
msgstr ""
"Outputway LIST otay STREAM uttingpay :LINEAR onditionalcay ewlinesnay "
"etweenbay eachway\n"
"   elementway.  Ifway COLON? isway NIL (efaultsday otay T), enthay onay "
"arenspay areway intedpray\n"
"   aroundway ethay outputway.  ATSIGN? isway ignoredway (utbay allowedway "
"osay atthay PPRINT-LINEAR\n"
"   ancay ebay usedway ithway ethay ~/.../ ormatfay irectiveday."

#: src/code/pprint.lisp
msgid ""
"Output LIST to STREAM tabbing to the next column that is an even multiple\n"
"   of TABSIZE (which defaults to 16) between each element.  :FILL style\n"
"   conditional newlines are also output between each element.  If COLON? is\n"
"   NIL (defaults to T), then no parens are printed around the output.\n"
"   ATSIGN? is ignored (but allowed so that PPRINT-TABULAR can be used with\n"
"   the ~/.../ format directive."
msgstr ""
"Outputway LIST otay STREAM abbingtay otay ethay extnay olumncay atthay isway "
"anway evenway ultiplemay\n"
"   ofway TABSIZE (ichwhay efaultsday otay 16) etweenbay eachway "
"elementway.  :FILL tylesay\n"
"   onditionalcay ewlinesnay areway alsoway outputway etweenbay eachway "
"elementway.  Ifway COLON? isway\n"
"   NIL (efaultsday otay T), enthay onay arenspay areway intedpray aroundway "
"ethay outputway.\n"
"   ATSIGN? isway ignoredway (utbay allowedway osay atthay PPRINT-TABULAR "
"ancay ebay usedway ithway\n"
"   ethay ~/.../ ormatfay irectiveday."

#: src/code/pprint.lisp
msgid "CONS PPRINT dispatch ignored w/o compiler loaded:~%  ~S"
msgstr "CONS PPRINT ispatchday ignoredway w/o ompilercay oadedlay:~%  ~S"

#: src/pcl/env.lisp src/pcl/methods.lisp src/pcl/std-class.lisp
#: src/pcl/defclass.lisp src/code/format.lisp src/code/pprint-loop.lisp
#: src/code/pprint.lisp
msgid "No more arguments."
msgstr "Onay oremay argumentsway."

#: src/code/format.lisp
msgid ""
"~:[~;Error in format: ~]~\n"
"\t      ~?~@[~%  ~A~%  ~V@T^~]"
msgstr ""
"~:[~;Errorway inway ormatfay: ~]~\n"
"\t      ~?~@[~%  ~Away~%  ~V@T^~]"

#: src/code/format.lisp
msgid ""
"A justification directive cannot be in the same format string~%~\n"
"                         as ~~W, ~~I, ~~:T, or a logical-block directive."
msgstr ""
"Away ustificationjay irectiveday annotcay ebay inway ethay amesay ormatfay "
"ingstray~%~\n"
"                         asway ~~W, ~~Iway, ~~:T, orway away ogicallay-"
"ockblay irectiveday."

#: src/code/format.lisp
msgid "String ended before directive was found."
msgstr "Ingstray endedway eforebay irectiveday asway oundfay."

#: src/code/format.lisp
msgid "Too many colons supplied."
msgstr "Ootay anymay olonscay uppliedsay."

#: src/code/format.lisp
msgid "Too many at-signs supplied."
msgstr "Ootay anymay atway-ignssay uppliedsay."

#: src/code/format.lisp
msgid "No matching closing slash."
msgstr "Onay atchingmay osingclay ashslay."

#: src/code/format.lisp
msgid ""
"Provides various facilities for formatting output.\n"
"  CONTROL-STRING contains a string to be output, possibly with embedded\n"
"  directives, which are flagged with the escape character \"~\".  "
"Directives\n"
"  generally expand into additional text to be output, usually consuming one\n"
"  or more of the FORMAT-ARGUMENTS in the process.  A few useful directives\n"
"  are:\n"
"        ~A or ~nA     Prints one argument as if by PRINC\n"
"        ~S or ~nS     Prints one argument as if by PRIN1\n"
"        ~D or ~nD     Prints one argument as a decimal integer\n"
"        ~%            Does a TERPRI\n"
"        ~&            Does a FRESH-LINE\n"
"\n"
"         where n is the width of the field in which the object is printed.\n"
"  \n"
"  DESTINATION controls where the result will go.  If DESTINATION is T, then\n"
"  the output is sent to the standard output stream.  If it is NIL, then the\n"
"  output is returned in a string as the value of the call.  Otherwise,\n"
"  DESTINATION must be a stream to which the output will be sent.\n"
"\n"
"  Example:   (FORMAT NIL \"The answer is ~D.\" 10) => \"The answer is 10.\"\n"
"\n"
"  FORMAT has many additional capabilities not described here.  Consult\n"
"  Section 22.3 (Formatted Output) of the ANSI Common Lisp standard for\n"
"  details."
msgstr ""
"Ovidespray ariousvay acilitiesfay orfay ormattingfay outputway.\n"
"  CONTROL-STRING ontainscay away ingstray otay ebay outputway, ossiblypay "
"ithway embeddedway\n"
"  irectivesday, ichwhay areway aggedflay ithway ethay escapeway aracterchay "
"\"~\".  Irectivesday\n"
"  enerallygay expandway intoway additionalway exttay otay ebay outputway, "
"usuallyway onsumingcay oneway\n"
"  orway oremay ofway ethay FORMAT-ARGUMENTS inway ethay ocesspray.  Away "
"ewfay usefulway irectivesday\n"
"  areway:\n"
"        ~Away orway ~anay     Intspray oneway argumentway asway ifway ybay "
"PRINC\n"
"        ~S orway ~snay     Intspray oneway argumentway asway ifway ybay "
"PRIN1\n"
"        ~D orway ~dnay     Intspray oneway argumentway asway away ecimalday "
"integerway\n"
"        ~%            Oesday away TERPRI\n"
"        ~&            Oesday away FRESH-LINE\n"
"\n"
"         erewhay n isway ethay idthway ofway ethay ieldfay inway ichwhay "
"ethay objectway isway intedpray.\n"
"  \n"
"  DESTINATION ontrolscay erewhay ethay esultray illway ogay.  Ifway "
"DESTINATION isway T, enthay\n"
"  ethay outputway isway entsay otay ethay tandardsay outputway eamstray.  "
"Ifway itway isway NIL, enthay ethay\n"
"  outputway isway eturnedray inway away ingstray asway ethay aluevay ofway "
"ethay allcay.  Otherwiseway,\n"
"  DESTINATION ustmay ebay away eamstray otay ichwhay ethay outputway illway "
"ebay entsay.\n"
"\n"
"  Exampleway:   (FORMAT NIL \"Ethay answerway isway ~D.\" 10) => \"Ethay "
"answerway isway 10.\"\n"
"\n"
"  FORMAT ashay anymay additionalway apabilitiescay otnay escribedday "
"erehay.  Onsultcay\n"
"  Ectionsay 22.3 (Ormattedfay Outputway) ofway ethay ANSI Ommoncay Isplay "
"tandardsay orfay\n"
"  etailsday."

#: src/code/format.lisp
msgid "Unknown format directive."
msgstr "Unknownway ormatfay irectiveday."

#: src/code/format.lisp
msgid "Unknown directive."
msgstr "Unknownway irectiveday."

#: src/code/format.lisp
msgid "Too many parameters, expected no more than ~D"
msgstr "Ootay anymay arameterspay, expectedway onay oremay anthay ~D"

#: src/code/format.lisp
msgid "Too many parameters, expected no more than 0"
msgstr "Ootay anymay arameterspay, expectedway onay oremay anthay 0"

#: src/code/format.lisp
msgid "Table of ordinal ones-place digits in English"
msgstr "Abletay ofway ordinalway onesway-aceplay igitsday inway Englishway"

#: src/code/format.lisp
msgid "Table of ordinal tens-place digits in English"
msgstr "Abletay ofway ordinalway enstay-aceplay igitsday inway Englishway"

#: src/code/format.lisp
msgid "Number too large to print in old Roman numerals: ~:D"
msgstr ""
"Umbernay ootay argelay otay intpray inway oldway Omanray umeralsnay: ~:D"

#: src/code/format.lisp
msgid "Number too large to print in Roman numerals: ~:D"
msgstr "Umbernay ootay argelay otay intpray inway Omanray umeralsnay: ~:D"

#: src/code/format.lisp
msgid "No previous argument."
msgstr "Onay eviouspray argumentway."

#: src/code/format.lisp
msgid "Cannot specify the colon modifier with this directive."
msgstr "Annotcay ecifyspay ethay oloncay odifiermay ithway isthay irectiveday."

#: src/code/format.lisp
msgid "Cannot specify either colon or atsign for this directive."
msgstr ""
"Annotcay ecifyspay eitherway oloncay orway atsignway orfay isthay "
"irectiveday."

#: src/code/format.lisp
msgid "Cannot specify both colon and atsign for this directive."
msgstr ""
"Annotcay ecifyspay othbay oloncay andway atsignway orfay isthay irectiveday."

#: src/code/format.lisp
msgid "Cannot specify the at-sign modifier."
msgstr "Annotcay ecifyspay ethay atway-ignsay odifiermay."

#: src/code/format.lisp
msgid "Cannot specify both colon and at-sign."
msgstr "Annotcay ecifyspay othbay oloncay andway atway-ignsay."

#: src/code/format.lisp
msgid ""
"Index ~D out of bounds.  Should have been ~\n"
"\t\t\t\t   between 0 and ~D."
msgstr ""
"Indexway ~D outway ofway oundsbay.  Ouldshay avehay eenbay ~\n"
"\t\t\t\t   etweenbay 0 andway ~D."

#: src/code/format.lisp
msgid ""
"Index ~D out of bounds.  Should have been ~\n"
"\t\t\t       between 0 and ~D."
msgstr ""
"Indexway ~D outway ofway oundsbay.  Ouldshay avehay eenbay ~\n"
"\t\t\t       etweenbay 0 andway ~D."

#: src/code/format.lisp
msgid "Cannot specify the colon modifier."
msgstr "Annotcay ecifyspay ethay oloncay odifiermay."

#: src/pcl/seal.lisp src/pcl/method-slot-access-optimization.lisp
#: src/pcl/low.lisp src/code/format.lisp
msgid "~A~%while processing indirect format string:"
msgstr "~Away~%ilewhay ocessingpray indirectway ormatfay ingstray:"

#: src/code/format.lisp
msgid "No corresponding close paren."
msgstr "Onay orrespondingcay oseclay arenpay."

#: src/code/format.lisp
msgid "No corresponding open paren."
msgstr "Onay orrespondingcay openway arenpay."

#: src/code/format.lisp
msgid "No corresponding close bracket."
msgstr "Onay orrespondingcay oseclay acketbray."

#: src/code/format.lisp
msgid "Cannot specify both the colon and at-sign modifiers."
msgstr ""
"Annotcay ecifyspay othbay ethay oloncay andway atway-ignsay odifiersmay."

#: src/code/format.lisp
msgid "Can only specify one section"
msgstr "Ancay onlyway ecifyspay oneway ectionsay"

#: src/code/format.lisp
msgid "~~:; directive not effective in ~~:["
msgstr "~~:; irectiveday otnay effectiveway inway ~~:["

#: src/code/format.lisp
msgid "Must specify exactly two sections."
msgstr "Ustmay ecifyspay exactlyway wotay ectionssay."

#: src/code/format.lisp
msgid "~~; not contained within either ~~[...~~] or ~~<...~~>."
msgstr "~~; otnay ontainedcay ithinway eitherway ~~[...~~] orway ~~<...~~>."

#: src/code/format.lisp
msgid "No corresponding open bracket."
msgstr "Onay orrespondingcay openway acketbray."

#: src/code/format.lisp
msgid "Attempt to use ~~:^ outside a ~~:{...~~} construct."
msgstr "Attemptway otay useway ~~:^ outsideway away ~~:{...~~} onstructcay."

#: src/code/format.lisp
msgid "No corresponding close brace."
msgstr "Onay orrespondingcay oseclay acebray."

#: src/code/format.lisp
msgid "No corresponding open brace."
msgstr "Onay orrespondingcay openway acebray."

#: src/code/format.lisp
msgid "~D illegal directive found inside justification block"
msgid_plural "~D illegal directives found inside justification block"
msgstr[0] "~D illegalway irectiveday oundfay insideway ustificationjay ockblay"
msgstr[1] ""
"~D illegalway irectivesday oundfay insideway ustificationjay ockblay"

#: src/code/format.lisp
msgid "No parameters can be supplied with ~~<...~~:>."
msgstr "Onay arameterspay ancay ebay uppliedsay ithway ~~<...~~:>."

#: src/code/format.lisp
msgid ""
"Cannot include format directives inside the ~\n"
"\t\t\t       ~:[suffix~;prefix~] segment of ~~<...~~:>"
msgstr ""
"Annotcay includeway ormatfay irectivesday insideway ethay ~\n"
"\t\t\t       ~:[uffixsay~;efixpray~] egmentsay ofway ~~<...~~:>"

#: src/code/format.lisp
msgid "Too many segments for ~~<...~~:>."
msgstr "Ootay anymay egmentssay orfay ~~<...~~:>."

#: src/code/format.lisp
msgid "Malformed ~~/ directive."
msgstr "Alformedmay ~~/ irectiveday."

#: src/code/format.lisp
msgid "No package named ~S"
msgstr "Onay ackagepay amednay ~S"

#: src/code/package.lisp
msgid ""
"The list of packages to use by default of no :USE argument is supplied\n"
"   to MAKE-PACKAGE or other package creation forms."
msgstr ""
"Ethay istlay ofway ackagespay otay useway ybay efaultday ofway onay :USE "
"argumentway isway uppliedsay\n"
"   otay MAKE-PACKAGE orway otherway ackagepay eationcray ormsfay."

#: src/code/package.lisp
msgid "The ~A package, ~D/~D internal, ~D/~D external"
msgstr "Ethay ~Away ackagepay, ~D/~D internalway, ~D/~D externalway"

#: src/code/package.lisp
msgid "The ~A package"
msgstr "Ethay ~Away ackagepay"

#: src/code/package.lisp
msgid "deleted package"
msgstr "eletedday ackagepay"

#: src/code/package.lisp
msgid "The current package."
msgstr "Ethay urrentcay ackagepay."

#: src/code/package.lisp
msgid "~&~@<Attempt to modify the locked package ~A, by ~3i~:_~?~:>"
msgstr ""
"~&~@<Attemptway otay odifymay ethay ockedlay ackagepay ~Away, ybay ~3i~:_~?~:"
">"

#: src/code/package.lisp
msgid "redefining function ~A"
msgstr "edefiningray unctionfay ~Away"

#: src/code/macros.lisp src/code/defstruct.lisp src/code/package.lisp
msgid "Ignore the lock and continue"
msgstr "Ignoreway ethay ocklay andway ontinuecay"

#: src/code/package.lisp
msgid "Disable package's definition-lock, then continue"
msgstr "Isableday ackagepay's efinitionday-ocklay, enthay ontinuecay"

#: src/code/package.lisp
msgid "Disable all package locks, then continue"
msgstr "Isableday allway ackagepay ockslay, enthay ontinuecay"

#: src/code/package.lisp
msgid "Bogus ~A name: ~S"
msgstr "Ogusbay ~Away amenay: ~S"

#: src/code/package.lisp
msgid "Can't do anything to a deleted package: ~S"
msgstr "Ancay't oday anythingway otay away eletedday ackagepay: ~S"

#: src/code/package.lisp
msgid ""
"Given PACKAGE-SPECIFIER, a package, symbol or string, return the\n"
"  parent package.  If there is not a parent, signal an error."
msgstr ""
"Ivengay PACKAGE-SPECIFIER, away ackagepay, ymbolsay orway ingstray, eturnray "
"ethay\n"
"  arentpay ackagepay.  Ifway erethay isway otnay away arentpay, ignalsay "
"anway errorway."

#: src/code/package.lisp
msgid "The parent of ~a does not exist."
msgstr "Ethay arentpay ofway ~away oesday otnay existway."

#: src/code/package.lisp
msgid "There is no parent of ~a."
msgstr "Erethay isway onay arentpay ofway ~away."

#: src/code/package.lisp
msgid ""
"Given PACKAGE-SPECIFIER, a package, symbol or string, return all the\n"
"  packages which are in the hierarchy 'under' the given package.  If\n"
"  :recurse is nil, then only return the immediate children of the package."
msgstr ""
"Ivengay PACKAGE-SPECIFIER, away ackagepay, ymbolsay orway ingstray, eturnray "
"allway ethay\n"
"  ackagespay ichwhay areway inway ethay ierarchyhay 'underway' ethay ivengay "
"ackagepay.  Ifway\n"
"  :ecurseray isway ilnay, enthay onlyway eturnray ethay immediateway "
"ildrenchay ofway ethay ackagepay."

#: src/code/package.lisp
msgid "Find the package having the specified name."
msgstr "Indfay ethay ackagepay avinghay ethay ecifiedspay amenay."

#: src/code/package.lisp
msgid "Make this package."
msgstr "Akemay isthay ackagepay."

#: src/code/package.lisp
msgid "#<Package-Hashtable: Size = ~D, Free = ~D, Deleted = ~D>"
msgstr "#<Ackagepay-Ashtablehay: Izesay = ~D, Eefray = ~D, Eletedday = ~D>"

#: src/code/package.lisp
msgid ""
"DO-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECLARATION}* {TAG | FORM}*\n"
"   Executes the FORMs at least once for each symbol accessible in the given\n"
"   PACKAGE with VAR bound to the current symbol."
msgstr ""
"DO-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECLARATION}* {TAG | FORM}*\n"
"   Executesway ethay Ormsfay atway eastlay onceway orfay eachway ymbolsay "
"accessibleway inway ethay ivengay\n"
"   PACKAGE ithway VAR oundbay otay ethay urrentcay ymbolsay."

#: src/code/package.lisp
msgid ""
"DO-EXTERNAL-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECL}* {TAG | FORM}*\n"
"   Executes the FORMs once for each external symbol in the given PACKAGE "
"with\n"
"   VAR bound to the current symbol."
msgstr ""
"DO-EXTERNAL-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECL}* {TAG | FORM}*\n"
"   Executesway ethay Ormsfay onceway orfay eachway externalway ymbolsay "
"inway ethay ivengay PACKAGE ithway\n"
"   VAR oundbay otay ethay urrentcay ymbolsay."

#: src/code/package.lisp
msgid ""
"DO-ALL-SYMBOLS (VAR [RESULT-FORM]) {DECLARATION}* {TAG | FORM}*\n"
"   Executes the FORMs once for each symbol in every package with VAR bound\n"
"   to the current symbol."
msgstr ""
"DO-ALL-SYMBOLS (VAR [RESULT-FORM]) {DECLARATION}* {TAG | FORM}*\n"
"   Executesway ethay Ormsfay onceway orfay eachway ymbolsay inway everyway "
"ackagepay ithway VAR oundbay\n"
"   otay ethay urrentcay ymbolsay."

#: src/code/package.lisp
msgid ""
"Within the lexical scope of the body forms, MNAME is defined via macrolet\n"
"   such that successive invocations of (mname) will return the symbols,\n"
"   one by one, from the packages in PACKAGE-LIST. SYMBOL-TYPES may be\n"
"   any of :inherited :external :internal."
msgstr ""
"Ithinway ethay exicallay opescay ofway ethay odybay ormsfay, MNAME isway "
"efinedday iavay acroletmay\n"
"   uchsay atthay uccessivesay invocationsway ofway (amemnay) illway eturnray "
"ethay ymbolssay,\n"
"   oneway ybay oneway, omfray ethay ackagespay inway PACKAGE-LIST. SYMBOL-"
"TYPES aymay ebay\n"
"   anyway ofway :inheritedway :externalway :internalway."

#: src/code/package.lisp
msgid ""
"Must supply at least one of :internal, ~\n"
"\t                             :external, or :inherited."
msgstr ""
"Ustmay upplysay atway eastlay oneway ofway :internalway, ~\n"
"\t                             :externalway, orway :inheritedway."

#: src/code/package.lisp
msgid ""
"~S is not one of :internal, :external, ~\n"
"\t\t                       or :inherited."
msgstr ""
"~S isway otnay oneway ofway :internalway, :externalway, ~\n"
"\t\t                       orway :inheritedway."

#: src/code/package.lisp
#, fuzzy
msgid ""
"Defines a new package called PACKAGE.  Each of OPTIONS should be one of the\n"
"   following:\n"
"     (:NICKNAMES {package-name}*)\n"
"     (:DOCUMENTATION doc-string)\n"
"     (:USE {package-name}*)\n"
"     (:SHADOW {symbol-name}*)\n"
"     (:SHADOWING-IMPORT-FROM <package-name> {symbol-name}*)\n"
"     (:IMPORT-FROM <package-name> {symbol-name}*)\n"
"     (:EXPORT {symbol-name}*)\n"
"     (:INTERN {symbol-name}*)\n"
"     (:SIZE <integer>)\n"
"   All options except :SIZE and :DOCUMENTATION can be used multiple times."
msgstr ""
"Efinesday away ewnay ackagepay alledcay PACKAGE.  Eachway ofway OPTIONS "
"ouldshay ebay oneway ofway ethay\n"
"   ollowingfay:\n"
"     (:NICKNAMES {ackagepay-amenay}*)\n"
"     (:SIZE <integerway>)\n"
"     (:SHADOW {ymbolsay-amenay}*)\n"
"     (:SHADOWING-IMPORT-FROM <ackagepay-amenay> {ymbolsay-amenay}*)\n"
"     (:USE {ackagepay-amenay}*)\n"
"     (:IMPORT-FROM <ackagepay-amenay> {ymbolsay-amenay}*)\n"
"     (:INTERN {ymbolsay-amenay}*)\n"
"     (:EXPORT {ymbolsay-amenay}*)\n"
"     (:DOCUMENTATION ocday-ingstray)\n"
"   Allway optionsway exceptway :SIZE andway :DOCUMENTATION ancay ebay "
"usedway ultiplemay imestay."

#: src/code/package.lisp
msgid "Bogus DEFPACKAGE option: ~S"
msgstr "Ogusbay DEFPACKAGE optionway: ~S"

#: src/code/package.lisp
msgid "Can't specify :SIZE twice."
msgstr "Ancay't ecifyspay :SIZE wicetay."

#: src/code/package.lisp
msgid "Bogus :SIZE, must be a positive integer: ~S"
msgstr "Ogusbay :SIZE, ustmay ebay away ositivepay integerway: ~S"

#: src/code/package.lisp
msgid "Can't specify :DOCUMENTATION twice."
msgstr "Ancay't ecifyspay :DOCUMENTATION wicetay."

#: src/code/package.lisp
msgid ""
"Parameters ~S and ~S must be disjoint ~\n"
"\t                             but have common elements ~%   ~S"
msgstr ""
"Arameterspay ~S andway ~S ustmay ebay isjointday ~\n"
"\t                             utbay avehay ommoncay elementsway ~%   ~S"

#: src/code/package.lisp
msgid "~A is a nick-name for the package ~A"
msgstr "~Away isway away icknay-amenay orfay ethay ackagepay ~Away"

#: src/code/package.lisp
msgid "~A also shadows the following symbols:~%  ~S"
msgstr "~Away alsoway adowsshay ethay ollowingfay ymbolssay:~%  ~S"

#: src/code/package.lisp
msgid "~A previously used the following packages:~%  ~S"
msgstr "~Away eviouslypray usedway ethay ollowingfay ackagespay:~%  ~S"

#: src/code/package.lisp
msgid "~A also exports the following symbols:~%  ~S"
msgstr "~Away alsoway exportsway ethay ollowingfay ymbolssay:~%  ~S"

#: src/code/package.lisp
msgid "~A does not contain a symbol ~A"
msgstr "~Away oesday otnay ontaincay away ymbolsay ~Away"

#: src/code/package.lisp
msgid "~S is a package name, so it cannot be a nickname for ~S."
msgstr ""
"~S isway away ackagepay amenay, osay itway annotcay ebay away icknamenay "
"orfay ~S."

#: src/code/package.lisp
msgid "Ignore this nickname."
msgstr "Ignoreway isthay icknamenay."

#: src/code/package.lisp
msgid "~S is already a nickname for ~S."
msgstr "~S isway alreadyway away icknamenay orfay ~S."

#: src/code/package.lisp
msgid "Redefine this nickname."
msgstr "Edefineray isthay icknamenay."

#: src/code/package.lisp
msgid ""
"Makes a new package having the specified Name and Nicknames.  The\n"
"  package will inherit all external symbols from each package in\n"
"  the use list.  :Internal-Symbols and :External-Symbols are\n"
"  estimates for the number of internal and external symbols which\n"
"  will ultimately be present in the package."
msgstr ""
"Akesmay away ewnay ackagepay avinghay ethay ecifiedspay Amenay andway "
"Icknamesnay.  Ethay\n"
"  ackagepay illway inheritway allway externalway ymbolssay omfray eachway "
"ackagepay inway\n"
"  ethay useway istlay.  :Internalway-Ymbolssay andway :Externalway-Ymbolssay "
"areway\n"
"  estimatesway orfay ethay umbernay ofway internalway andway externalway "
"ymbolssay ichwhay\n"
"  illway ultimatelyway ebay esentpray inway ethay ackagepay."

#: src/code/package.lisp
msgid "Leave existing package alone."
msgstr "Eavelay existingway ackagepay aloneway."

#: src/code/package.lisp
msgid "A package named ~S already exists"
msgstr "Away ackagepay amednay ~S alreadyway existsway"

#: src/code/package.lisp
msgid ""
"Sets *PACKAGE* to package with given NAME, creating the package if\n"
"   it does not exist.  If the package already exists then it is modified\n"
"   to agree with the :USE and :NICKNAMES arguments.  Any new nicknames\n"
"   are added without removing any old ones not specified.  If any package\n"
"   in the :Use list is not currently used, then it is added to the use\n"
"   list."
msgstr ""
"Etssay *PACKAGE* otay ackagepay ithway ivengay NAME, eatingcray ethay "
"ackagepay ifway\n"
"   itway oesday otnay existway.  Ifway ethay ackagepay alreadyway existsway "
"enthay itway isway odifiedmay\n"
"   otay agreeway ithway ethay :USE andway :NICKNAMES argumentsway.  Anyway "
"ewnay icknamesnay\n"
"   areway addedway ithoutway emovingray anyway oldway onesway otnay "
"ecifiedspay.  Ifway anyway ackagepay\n"
"   inway ethay :Useway istlay isway otnay urrentlycay usedway, enthay itway "
"isway addedway otay ethay useway\n"
"   istlay."

#: src/code/package.lisp
msgid "Old-style IN-PACKAGE."
msgstr "Oldway-tylesay IN-PACKAGE."

#: src/code/package.lisp
msgid "The package named ~S doesn't exist."
msgstr "Ethay ackagepay amednay ~S oesnday't existway."

#: src/code/package.lisp
msgid ""
"Replaces the name and nicknames of Package. The old name and all of\n"
"  the old nicknames of Package are eliminated and are replaced by\n"
"  New-Name and New-Nicknames."
msgstr ""

#: src/code/package.lisp
msgid "A package named ~S already exists."
msgstr "Away ackagepay amednay ~S alreadyway existsway."

#: src/code/package.lisp
msgid "Delete the PACKAGE-OR-NAME from the package system data structures."
msgstr ""
"Eleteday ethay PACKAGE-OR-NAME omfray ethay ackagepay ystemsay ataday "
"ucturesstray."

#: src/code/package.lisp
msgid "No package of name ~S."
msgstr "Onay ackagepay ofway amenay ~S."

#: src/code/package.lisp
msgid "Return NIL"
msgstr "Eturnray NIL"

#: src/code/package.lisp
msgid "Remove dependency in other packages."
msgstr "Emoveray ependencyday inway otherway ackagespay."

#: src/code/package.lisp
msgid "Returns a list of all existing packages."
msgstr "Eturnsray away istlay ofway allway existingway ackagespay."

#: src/code/package.lisp
msgid "Returns a symbol having the specified name, creating it if necessary."
msgstr ""
"Eturnsray away ymbolsay avinghay ethay ecifiedspay amenay, eatingcray itway "
"ifway ecessarynay."

#: src/code/package.lisp
msgid ""
"Returns the symbol NAME in PACKAGE.  If such a symbol is found\n"
"  then the second value is :internal, :external or :inherited to indicate\n"
"  how the symbol is accessible.  If no symbol is found then both values\n"
"  are NIL."
msgstr ""
"Eturnsray ethay ymbolsay NAME inway PACKAGE.  Ifway uchsay away ymbolsay "
"isway oundfay\n"
"  enthay ethay econdsay aluevay isway :internalway, :externalway orway :"
"inheritedway otay indicateway\n"
"  owhay ethay ymbolsay isway accessibleway.  Ifway onay ymbolsay isway "
"oundfay enthay othbay aluesvay\n"
"  areway NIL."

#: src/code/package.lisp
msgid ""
"Makes SYMBOL no longer present in PACKAGE.  If SYMBOL was present\n"
"  then T is returned, otherwise NIL.  If PACKAGE is SYMBOL's home\n"
"  package, then it is made uninterned."
msgstr ""
"Akesmay SYMBOL onay ongerlay esentpray inway PACKAGE.  Ifway SYMBOL asway "
"esentpray\n"
"  enthay T isway eturnedray, otherwiseway NIL.  Ifway PACKAGE isway SYMBOL's "
"omehay\n"
"  ackagepay, enthay itway isway ademay uninternedway."

#: src/code/package.lisp
msgid "uninterning symbol ~A"
msgstr "uninterningway ymbolsay ~Away"

#: src/code/package.lisp
msgid "Disable package's lock then continue"
msgstr "Isableday ackagepay's ocklay enthay ontinuecay"

#: src/code/macros.lisp src/code/defstruct.lisp src/code/package.lisp
msgid "Unlock all packages, then continue"
msgstr "Unlockway allway ackagespay, enthay ontinuecay"

#: src/code/package.lisp
msgid "prompt for a symbol to shadowing-import."
msgstr "omptpray orfay away ymbolsay otay adowingshay-importway."

#: src/code/package.lisp
msgid "Uninterning symbol ~S causes name conflict among these symbols:~%~S"
msgstr ""
"Uninterningway ymbolsay ~S ausescay amenay onflictcay amongway esethay "
"ymbolssay:~%~S"

#: src/code/package.lisp
msgid "Symbol to shadowing-import: "
msgstr "Ymbolsay otay adowingshay-importway: "

#: src/code/package.lisp
msgid "~S is not a symbol."
msgstr "~S isway otnay away ymbolsay."

#: src/code/package.lisp
msgid "~S is not one of the conflicting symbols."
msgstr "~S isway otnay oneway ofway ethay onflictingcay ymbolssay."

#: src/code/package.lisp
msgid "~S is neither a symbol nor a list of symbols."
msgstr "~S isway eithernay away ymbolsay ornay away istlay ofway ymbolssay."

#: src/code/package.lisp
msgid "Exports SYMBOLS from PACKAGE, checking that no name conflicts result."
msgstr ""
"Exportsway SYMBOLS omfray PACKAGE, eckingchay atthay onay amenay onflictscay "
"esultray."

#: src/code/package.lisp
msgid ""
"Exporting these symbols from the ~A package:~%~S~%~\n"
"\t      results in name conflicts with these packages:~%~{~A ~}"
msgstr ""
"Exportingway esethay ymbolssay omfray ethay ~Away ackagepay:~%~S~%~\n"
"\t      esultsray inway amenay onflictscay ithway esethay ackagespay:"
"~%~{~Away ~}"

#: src/code/package.lisp
msgid "Unintern conflicting symbols."
msgstr "Uninternway onflictingcay ymbolssay."

#: src/code/package.lisp
msgid "Skip exporting conflicting symbols."
msgstr "Kipsay exportingway onflictingcay ymbolssay."

#: src/code/package.lisp
msgid "These symbols are not accessible in the ~A package:~%~S"
msgstr ""
"Esethay ymbolssay areway otnay accessibleway inway ethay ~Away ackagepay:~%~S"

#: src/code/package.lisp
msgid "Import these symbols into the ~A package."
msgstr "Importway esethay ymbolssay intoway ethay ~Away ackagepay."

#: src/code/package.lisp
msgid "Makes SYMBOLS no longer exported from PACKAGE."
msgstr "Akesmay SYMBOLS onay ongerlay exportedway omfray PACKAGE."

#: src/code/package.lisp
msgid "unexporting symbols ~A"
msgstr "unexportingway ymbolssay ~Away"

#: src/code/package.lisp
msgid "~S is not accessible in the ~A package."
msgstr "~S isway otnay accessibleway inway ethay ~Away ackagepay."

#: src/code/package.lisp
msgid ""
"Make SYMBOLS accessible as internal symbols in PACKAGE.  If a symbol\n"
"  is already accessible then it has no effect.  If a name conflict\n"
"  would result from the importation, then a correctable error is signalled."
msgstr ""
"Akemay SYMBOLS accessibleway asway internalway ymbolssay inway PACKAGE.  "
"Ifway away ymbolsay\n"
"  isway alreadyway accessibleway enthay itway ashay onay effectway.  Ifway "
"away amenay onflictcay\n"
"  ouldway esultray omfray ethay importationway, enthay away orrectablecay "
"errorway isway ignalledsay."

#: src/code/package.lisp
msgid ""
"Importing these symbols into the ~A package ~\n"
"\t\tcauses a name conflict:~%~S"
msgstr ""
"Importingway esethay ymbolssay intoway ethay ~Away ackagepay ~\n"
"\t\tausescay away amenay onflictcay:~%~S"

#: src/code/package.lisp
msgid "Import these symbols with Shadowing-Import."
msgstr "Importway esethay ymbolssay ithway Adowingshay-Importway."

#: src/code/package.lisp
msgid ""
"Import SYMBOLS into PACKAGE, disregarding any name conflict.  If\n"
"  a symbol of the same name is present, then it is uninterned.\n"
"  The symbols are added to the Package-Shadowing-Symbols."
msgstr ""
"Importway SYMBOLS intoway PACKAGE, isregardingday anyway amenay onflictcay.  "
"Ifway\n"
"  away ymbolsay ofway ethay amesay amenay isway esentpray, enthay itway "
"isway uninternedway.\n"
"  Ethay ymbolssay areway addedway otay ethay Ackagepay-Adowingshay-Ymbolssay."

#: src/code/package.lisp
msgid ""
"Make an internal symbol in PACKAGE with the same name as each of the\n"
"  specified SYMBOLS, adding the new symbols to the Package-Shadowing-"
"Symbols.\n"
"  If a symbol with the given name is already present in PACKAGE, then\n"
"  the existing symbol is placed in the shadowing symbols list if it is\n"
"  not already present."
msgstr ""
"Akemay anway internalway ymbolsay inway PACKAGE ithway ethay amesay amenay "
"asway eachway ofway ethay\n"
"  ecifiedspay SYMBOLS, addingway ethay ewnay ymbolssay otay ethay Ackagepay-"
"Adowingshay-Ymbolssay.\n"
"  Ifway away ymbolsay ithway ethay ivengay amenay isway alreadyway esentpray "
"inway PACKAGE, enthay\n"
"  ethay existingway ymbolsay isway acedplay inway ethay adowingshay "
"ymbolssay istlay ifway itway isway\n"
"  otnay alreadyway esentpray."

#: src/code/package.lisp
msgid ""
"Add all the PACKAGES-TO-USE to the use list for PACKAGE so that\n"
"  the external symbols of the used packages are accessible as internal\n"
"  symbols in PACKAGE."
msgstr ""
"Addway allway ethay PACKAGES-TO-USE otay ethay useway istlay orfay PACKAGE "
"osay atthay\n"
"  ethay externalway ymbolssay ofway ethay usedway ackagespay areway "
"accessibleway asway internalway\n"
"  ymbolssay inway PACKAGE."

#: src/code/package.lisp
msgid "Unintern the conflicting symbols in the ~2*~A package."
msgstr ""
"Uninternway ethay onflictingcay ymbolssay inway ethay ~2*~Away ackagepay."

#: src/code/package.lisp
msgid "Use'ing package ~A results in name conflicts for these symbols:~%~S"
msgstr ""
"Useway'ingway ackagepay ~Away esultsray inway amenay onflictscay orfay "
"esethay ymbolssay:~%~S"

#: src/code/package.lisp
msgid "Remove PACKAGES-TO-UNUSE from the use list for PACKAGE."
msgstr "Emoveray PACKAGES-TO-UNUSE omfray ethay useway istlay orfay PACKAGE."

#: src/code/package.lisp
msgid "Return a list of all symbols in the system having the specified name."
msgstr ""
"Eturnray away istlay ofway allway ymbolssay inway ethay ystemsay avinghay "
"ethay ecifiedspay amenay."

#: src/code/describe.lisp src/code/package.lisp
msgid "special variable"
msgstr "ecialspay ariablevay"

#: src/code/describe.lisp src/code/package.lisp
msgid "constant"
msgstr "onstantcay"

#: src/code/describe.lisp src/code/package.lisp
msgid "undefined variable"
msgstr "undefinedway ariablevay"

#: src/code/describe.lisp src/code/package.lisp
msgid "symbol macro"
msgstr "ymbolsay acromay"

#: src/code/package.lisp
msgid "alien variable"
msgstr "alienway ariablevay"

#: src/code/package.lisp
msgid "value: "
msgstr "aluevay: "

#: src/code/package.lisp
msgid "macro"
msgstr "acromay"

#: src/code/package.lisp
msgid "special operator"
msgstr "ecialspay operatorway"

#: src/code/package.lisp
msgid "function"
msgstr "unctionfay"

#: src/code/package.lisp
msgid "class"
msgstr "assclay"

#: src/code/package.lisp
msgid "type"
msgstr "ypetay"

#: src/code/package.lisp
msgid ""
"Call FUN with each symbol that contains STRING.\n"
"  If PACKAGE is supplied then only use symbols present in\n"
"  that package.  If EXTERNAL-ONLY is true then only use\n"
"  symbols exported from the specified package."
msgstr ""
"Allcay FUN ithway eachway ymbolsay atthay ontainscay STRING.\n"
"  Ifway PACKAGE isway uppliedsay enthay onlyway useway ymbolssay esentpray "
"inway\n"
"  atthay ackagepay.  Ifway EXTERNAL-ONLY isway uetray enthay onlyway useway\n"
"  ymbolssay exportedway omfray ethay ecifiedspay ackagepay."

#: src/code/package.lisp
msgid ""
"Briefly describe all symbols which contain the specified STRING.\n"
"  If PACKAGE is supplied then only describe symbols present in\n"
"  that package.  If EXTERNAL-ONLY is non-NIL then only describe\n"
"  external symbols in the specified package."
msgstr ""
"Ieflybray escribeday allway ymbolssay ichwhay ontaincay ethay ecifiedspay "
"STRING.\n"
"  Ifway PACKAGE isway uppliedsay enthay onlyway escribeday ymbolssay "
"esentpray inway\n"
"  atthay ackagepay.  Ifway EXTERNAL-ONLY isway onnay-NIL enthay onlyway "
"escribeday\n"
"  externalway ymbolssay inway ethay ecifiedspay ackagepay."

#: src/code/package.lisp
msgid ""
"Identical to APROPOS, except that it returns a list of the symbols\n"
"  found instead of describing them."
msgstr ""
"Identicalway otay APROPOS, exceptway atthay itway eturnsray away istlay "
"ofway ethay ymbolssay\n"
"  oundfay insteadway ofway escribingday emthay."

#: src/code/reader.lisp
msgid "Float format for 1.0E1"
msgstr "Oatflay ormatfay orfay 1.0E1"

#: src/code/reader.lisp
msgid "Variable bound to current readtable."
msgstr "Ariablevay oundbay otay urrentcay eadtableray."

#: src/code/reader.lisp
msgid "Reader error ~@[at ~D ~]on ~S:~%~?"
msgstr "Eaderray errorway ~@[atway ~D ~]onway ~S:~%~?"

#: src/code/reader.lisp
msgid "Unexpected EOF on ~S ~A."
msgstr "Unexpectedway EOF onway ~S ~Away."

#: src/code/reader.lisp
msgid ""
"Standard lisp readtable. This is for recovery from broken\n"
"   read-tables, and should not normally be user-visible."
msgstr ""
"Tandardsay isplay eadtableray. Isthay isway orfay ecoveryray omfray "
"okenbray\n"
"   eadray-ablestay, andway ouldshay otnay ormallynay ebay userway-isiblevay."

#: src/code/reader.lisp
msgid "Value of *package* at the start of the last read or Nil."
msgstr ""
"Aluevay ofway *package* atway ethay tartsay ofway ethay astlay eadray orway "
"Ilnay."

#: src/code/reader.lisp
msgid "Undefined read-macro character ~S"
msgstr "Undefinedway eadray-acromay aracterchay ~S"

#: src/code/reader.lisp
msgid "A copy is made of from-readtable and place into to-readtable."
msgstr ""
"Away opycay isway ademay ofway omfray-eadtableray andway aceplay intoway "
"otay-eadtableray."

#: src/code/reader.lisp
msgid ""
"Causes the syntax of to-char to be the same as from-char in the \n"
"  optional readtable (defaults to the current readtable).  The\n"
"  from-table defaults the standard lisp readtable by being nil."
msgstr ""
"Ausescay ethay yntaxsay ofway otay-archay otay ebay ethay amesay asway "
"omfray-archay inway ethay \n"
"  optionalway eadtableray (efaultsday otay ethay urrentcay eadtableray).  "
"Ethay\n"
"  omfray-abletay efaultsday ethay tandardsay isplay eadtableray ybay eingbay "
"ilnay."

#: src/code/reader.lisp
msgid ""
"Causes char to be a macro character which invokes function when\n"
"   seen by the reader.  The non-terminatingp flag can be used to\n"
"   make the macro character non-terminating.  The optional readtable\n"
"   argument defaults to the current readtable.  Set-macro-character\n"
"   returns T."
msgstr ""
"Ausescay archay otay ebay away acromay aracterchay ichwhay invokesway "
"unctionfay enwhay\n"
"   eensay ybay ethay eaderray.  Ethay onnay-erminatingptay agflay ancay ebay "
"usedway otay\n"
"   akemay ethay acromay aracterchay onnay-erminatingtay.  Ethay optionalway "
"eadtableray\n"
"   argumentway efaultsday otay ethay urrentcay eadtableray.  Etsay-acromay-"
"aracterchay\n"
"   eturnsray T."

#: src/code/reader.lisp
msgid ""
"Returns the function associated with the specified char which is a macro\n"
"  character.  The optional readtable argument defaults to the current\n"
"  readtable."
msgstr ""
"Eturnsray ethay unctionfay associatedway ithway ethay ecifiedspay archay "
"ichwhay isway away acromay\n"
"  aracterchay.  Ethay optionalway eadtableray argumentway efaultsday otay "
"ethay urrentcay\n"
"  eadtableray."

#: src/code/reader.lisp
msgid "Bind *read-buffer* to a fresh buffer and execute Body."
msgstr ""
"Indbay *read-buffer* otay away eshfray ufferbay andway executeway Odybay."

#: src/code/reader.lisp
msgid "If true, only warn when there is an extra close paren, otherwise error."
msgstr ""
"Ifway uetray, onlyway arnway enwhay erethay isway anway extraway oseclay "
"arenpay, otherwiseway errorway."

#: src/code/reader.lisp
msgid ""
"Reads from stream and returns the object read, preserving the whitespace\n"
"   that followed the object."
msgstr ""
"Eadsray omfray eamstray andway eturnsray ethay objectway eadray, "
"eservingpray ethay itespacewhay\n"
"   atthay ollowedfay ethay objectway."

#: src/code/reader.lisp
msgid ""
"Reads in the next object in the stream, which defaults to\n"
"   *standard-input*. For details see the I/O chapter of\n"
"   the manual."
msgstr ""
"Eadsray inway ethay extnay objectway inway ethay eamstray, ichwhay "
"efaultsday otay\n"
"   *standard-input*. Orfay etailsday eesay ethay Iway/O apterchay ofway\n"
"   ethay anualmay."

#: src/code/reader.lisp
msgid ""
"Reads objects from input-stream until the next character after an\n"
"   object's representation is endchar.  A list of those objects read\n"
"   is returned."
msgstr ""
"Eadsray objectsway omfray inputway-eamstray untilway ethay extnay "
"aracterchay afterway anway\n"
"   objectway's epresentationray isway endcharway.  Away istlay ofway osethay "
"objectsway eadray\n"
"   isway eturnedray."

#: src/code/reader.lisp
msgid "Nothing appears before . in list."
msgstr "Othingnay appearsway eforebay . inway istlay."

#: src/code/reader.lisp
msgid "Nothing appears after . in list."
msgstr "Othingnay appearsway afterway . inway istlay."

#: src/code/reader.lisp
msgid "More than one object follows . in list."
msgstr "Oremay anthay oneway objectway ollowsfay . inway istlay."

#: src/code/reader.lisp
msgid ""
"Ignoring unmatched close parenthesis~\n"
"\t\t  ~@[ at file position ~D~]."
msgstr ""
"Ignoringway unmatchedway oseclay arenthesispay~\n"
"\t\t  ~@[ atway ilefay ositionpay ~D~]."

#: src/code/reader.lisp
msgid "Unmatched close parenthesis."
msgstr "Unmatchedway oseclay arenthesispay."

#: src/code/reader.lisp
msgid "after escape character"
msgstr "afterway escapeway aracterchay"

#: src/code/reader.lisp
msgid "inside extended token"
msgstr "insideway extendedway okentay"

#: src/code/reader.lisp
msgid "invalid constituent"
msgstr "invalidway onstituentcay"

#: src/code/reader.lisp
msgid "Suppresses most interpreting of the reader when T"
msgstr "Uppressessay ostmay interpretingway ofway ethay eaderray enwhay T"

#: src/code/reader.lisp
msgid "The radix that Lisp reads numbers in."
msgstr "Ethay adixray atthay Isplay eadsray umbersnay inway."

#: src/code/reader.lisp
msgid "impossible!"
msgstr "impossibleway!"

#: src/code/reader.lisp
msgid "dot context error"
msgstr "otday ontextcay errorway"

#: src/code/reader.lisp
msgid "too many dots"
msgstr "ootay anymay otsday"

#: src/code/reader.lisp
msgid "too many colons in ~S"
msgstr "ootay anymay olonscay inway ~S"

#: src/code/reader.lisp
msgid "after reading a colon"
msgstr "afterway eadingray away oloncay"

#: src/code/reader.lisp
msgid "package ~S not found"
msgstr "ackagepay ~S otnay oundfay"

#: src/code/reader.lisp
msgid "Use symbol anyway."
msgstr "Useway ymbolsay anywayway."

#: src/code/reader.lisp
msgid "The symbol ~S is not external in the ~A package."
msgstr "Ethay ymbolsay ~S isway otnay externalway inway ethay ~Away ackagepay."

#: src/code/reader.lisp
msgid "Symbol ~S not found in the ~A package."
msgstr "Ymbolsay ~S otnay oundfay inway ethay ~Away ackagepay."

#: src/code/reader.lisp
msgid "This function is just an fsm that recognizes numbers and symbols."
msgstr ""
"Isthay unctionfay isway ustjay anway smfay atthay ecognizesray umbersnay "
"andway ymbolssay."

#: src/code/reader.lisp
msgid ""
"For semi-external use: returns 3 values: the string for the token,\n"
"   a flag for whether there was an escape char, and the position of any\n"
"   package delimiter."
msgstr ""
"Orfay emisay-externalway useway: eturnsray 3 aluesvay: ethay ingstray orfay "
"ethay okentay,\n"
"   away agflay orfay etherwhay erethay asway anway escapeway archay, andway "
"ethay ositionpay ofway anyway\n"
"   ackagepay elimiterday."

#: src/code/reader.lisp
msgid "after escape"
msgstr "afterway escapeway"

#: src/code/reader.lisp
msgid ""
"For semi-external use: read an extended token with the first character\n"
"  escaped.  Returns the string for the token."
msgstr ""
"Orfay emisay-externalway useway: eadray anway extendedway okentay ithway "
"ethay irstfay aracterchay\n"
"  escapedway.  Eturnsray ethay ingstray orfay ethay okentay."

#: src/code/reader.lisp
msgid ""
"Holds the mapping of base to 'safe' number of digits to read for a fixnum."
msgstr ""
"Oldshay ethay appingmay ofway asebay otay 'afesay' umbernay ofway igitsday "
"otay eadray orfay away ixnumfay."

#: src/code/reader.lisp
msgid "Holds the largest fixnum power of the base for make-integer."
msgstr ""
"Oldshay ethay argestlay ixnumfay owerpay ofway ethay asebay orfay akemay-"
"integerway."

#: src/code/reader.lisp
msgid ""
"Minimizes bignum-fixnum multiplies by reading a 'safe' number of digits, \n"
"  then multiplying by a power of the base and adding."
msgstr ""
"Inimizesmay ignumbay-ixnumfay ultipliesmay ybay eadingray away 'afesay' "
"umbernay ofway igitsday, \n"
"  enthay ultiplyingmay ybay away owerpay ofway ethay asebay andway addingway."

#: src/code/reader.lisp
msgid ""
"Fast bignum-reading interface.  Reads from stream S an integer in radix\n"
"R.  If we find some kind of error (bad characters, EOF), then NIL is\n"
"returned; otherwise the number.  Reads at least one digit, but may not get "
"to\n"
"the end of the stream."
msgstr ""
"Astfay ignumbay-eadingray interfaceway.  Eadsray omfray eamstray S anway "
"integerway inway adixray\n"
"R.  Ifway eway indfay omesay indkay ofway errorway (adbay aracterschay, "
"EOF), enthay NIL isway\n"
"eturnedray; otherwiseway ethay umbernay.  Eadsray atway eastlay oneway "
"igitday, utbay aymay otnay etgay otay\n"
"ethay endway ofway ethay eamstray."

#: src/code/reader.lisp
msgid "Internal error in floating point reader."
msgstr "Internalway errorway inway oatingflay ointpay eaderray."

#: src/code/reader.lisp
#, fuzzy
msgid "Floating-point overflow reading ~S: ~S"
msgstr "Onnay-istlay ollowingfay #S: ~S"

#: src/code/reader.lisp
#, fuzzy
msgid "Floating point underflow when reading ~S: ~S"
msgstr "Ootay anymay indicesway enwhay erefingday ~S: ~D"

#: src/code/reader.lisp
msgid "Number not representable as a ~S: ~S"
msgstr "Umbernay otnay epresentableray asway away ~S: ~S"

#: src/code/reader.lisp
msgid "Invalid ratio: ~S/~S"
msgstr "Invalidway atioray: ~S/~S"

#: src/code/reader.lisp
msgid "No dispatch function defined for ~S."
msgstr "Onay ispatchday unctionfay efinedday orfay ~S."

#: src/code/reader.lisp
msgid ""
"Causes char to become a dispatching macro character in readtable\n"
"   (which defaults to the current readtable).  If the non-terminating-p\n"
"   flag is set to T, the char will be non-terminating.  Make-dispatch-\n"
"   macro-character returns T."
msgstr ""
"Ausescay archay otay ecomebay away ispatchingday acromay aracterchay inway "
"eadtableray\n"
"   (ichwhay efaultsday otay ethay urrentcay eadtableray).  Ifway ethay onnay-"
"erminatingtay-p\n"
"   agflay isway etsay otay T, ethay archay illway ebay onnay-erminatingtay.  "
"Akemay-ispatchday-\n"
"   acromay-aracterchay eturnsray T."

#: src/code/reader.lisp
msgid "Dispatch Sub-Char must not be a decimal digit: ~S"
msgstr "Ispatchday Ubsay-Archay ustmay otnay ebay away ecimalday igitday: ~S"

#: src/code/reader.lisp
msgid "~S is not a dispatch character."
msgstr "~S isway otnay away ispatchday aracterchay."

#: src/code/reader.lisp
msgid ""
"Causes function to be called whenever the reader reads\n"
"   disp-char followed by sub-char. Set-dispatch-macro-character\n"
"   returns T."
msgstr ""
"Ausescay unctionfay otay ebay alledcay eneverwhay ethay eaderray eadsray\n"
"   ispday-archay ollowedfay ybay ubsay-archay. Etsay-ispatchday-acromay-"
"aracterchay\n"
"   eturnsray T."

#: src/code/reader.lisp
msgid ""
"Returns the macro character function for sub-char under disp-char\n"
"   or nil if there is no associated function."
msgstr ""
"Eturnsray ethay acromay aracterchay unctionfay orfay ubsay-archay underway "
"ispday-archay\n"
"   orway ilnay ifway erethay isway onay associatedway unctionfay."

#: src/code/reader.lisp
msgid "inside dispatch character"
msgstr "insideway ispatchday aracterchay"

#: src/code/reader.lisp
msgid "No dispatch table for dispatch char."
msgstr "Onay ispatchday abletay orfay ispatchday archay."

#: src/code/reader.lisp
msgid "A resource of string streams for Read-From-String."
msgstr "Away esourceray ofway ingstray eamsstray orfay Eadray-Omfray-Ingstray."

#: src/code/reader.lisp
msgid ""
"The characters of string are successively given to the lisp reader\n"
"   and the lisp object built by the reader is returned.  Macro chars\n"
"   will take effect."
msgstr ""
"Ethay aracterschay ofway ingstray areway uccessivelysay ivengay otay ethay "
"isplay eaderray\n"
"   andway ethay isplay objectway uiltbay ybay ethay eaderray isway "
"eturnedray.  Acromay arschay\n"
"   illway aketay effectway."

#: src/code/reader.lisp
msgid "There are no digits in this string: ~S"
msgstr "Erethay areway onay igitsday inway isthay ingstray: ~S"

#: src/code/reader.lisp
msgid "There's junk in this string: ~S."
msgstr "Erethay's unkjay inway isthay ingstray: ~S."

#: src/code/reader.lisp
msgid ""
"Examine the substring of string delimited by start and end\n"
"  (default to the beginning and end of the string)  It skips over\n"
"  whitespace characters and then tries to parse an integer.  The\n"
"  radix parameter must be between 2 and 36."
msgstr ""
"Examineway ethay ubstringsay ofway ingstray elimitedday ybay tartsay andway "
"endway\n"
"  (efaultday otay ethay eginningbay andway endway ofway ethay ingstray)  "
"Itway kipssay overway\n"
"  itespacewhay aracterschay andway enthay iestray otay arsepay anway "
"integerway.  Ethay\n"
"  adixray arameterpay ustmay ebay etweenbay 2 andway 36."

#: src/code/sharpm.lisp
msgid "Numeric argument ignored in #~D~A."
msgstr "Umericnay argumentway ignoredway inway #~D~Away."

#: src/code/sharpm.lisp
msgid "Unrecognized character name: ~S"
msgstr "Unrecognizedway aracterchay amenay: ~S"

#: src/code/sharpm.lisp
msgid "Ill-formed vector: #~S"
msgstr "Illway-ormedfay ectorvay: #~S"

#: src/code/sharpm.lisp
msgid "Vector longer than specified length: #~S~S"
msgstr "Ectorvay ongerlay anthay ecifiedspay engthlay: #~S~S"

#: src/code/sharpm.lisp
msgid "Escape character appeared after #*"
msgstr "Escapeway aracterchay appearedway afterway #*"

#: src/code/sharpm.lisp
msgid "You have to give a little bit for non-zero #* bit-vectors."
msgstr ""
"Ouyay avehay otay ivegay away ittlelay itbay orfay onnay-erozay #* itbay-"
"ectorsvay."

#: src/code/sharpm.lisp
msgid "Illegal element given for bit-vector: ~S"
msgstr "Illegalway elementway ivengay orfay itbay-ectorvay: ~S"

#: src/code/sharpm.lisp
msgid "Bit vector is longer than specified length #~A*~A"
msgstr "Itbay ectorvay isway ongerlay anthay ecifiedspay engthlay #~A*Way~Away"

#: src/code/sharpm.lisp
msgid "Symbol following #: contains a package marker: ~S"
msgstr "Ymbolsay ollowingfay #: ontainscay away ackagepay arkermay: ~S"

#: src/code/sharpm.lisp
msgid "If false, then the #. read macro is disabled."
msgstr "Ifway alsefay, enthay ethay #. eadray acromay isway isabledday."

#: src/code/sharpm.lisp
msgid "Attempt to read #. while *READ-EVAL* is bound to NIL."
msgstr "Attemptway otay eadray #. ilewhay *READ-EVAL* isway oundbay otay NIL."

#: src/code/sharpm.lisp
msgid "Radix missing in #R."
msgstr "Adixray issingmay inway #R."

#: src/code/sharpm.lisp
msgid "Illegal radix for #R: ~D."
msgstr "Illegalway adixray orfay #R: ~D."

#: src/code/sharpm.lisp
msgid "#~A (base ~D) value is not a rational: ~S."
msgstr "#~Away (asebay ~D) aluevay isway otnay away ationalray: ~S."

#: src/code/sharpm.lisp
msgid ""
"#~DA axis ~D is empty, but axis ~\n"
"\t\t\t\t          ~D is non-empty."
msgstr ""
"#~DA axisway ~D isway emptyway, utbay axisway ~\n"
"\t\t\t\t          ~D isway onnay-emptyway."

#: src/code/sharpm.lisp
msgid "Non-list following #S: ~S"
msgstr "Onnay-istlay ollowingfay #S: ~S"

#: src/code/sharpm.lisp
msgid "Structure type is not a symbol: ~S"
msgstr "Ucturestray ypetay isway otnay away ymbolsay: ~S"

#: src/code/sharpm.lisp
msgid "~S is not a defined structure type."
msgstr "~S isway otnay away efinedday ucturestray ypetay."

#: src/code/sharpm.lisp
msgid "The ~S structure does not have a default constructor."
msgstr "Ethay ~S ucturestray oesday otnay avehay away efaultday onstructorcay."

#: src/code/sharpm.lisp
msgid "Non-list following #S"
msgstr "Onnay-istlay ollowingfay #S"

#: src/code/sharpm.lisp
msgid "Missing label for #=."
msgstr "Issingmay abellay orfay #=."

#: src/code/sharpm.lisp
msgid "Multiply defined label: #~D="
msgstr "Ultiplymay efinedday abellay: #~D="

#: src/code/sharpm.lisp
msgid "Have to tag something more than just #~D#."
msgstr "Avehay otay agtay omethingsay oremay anthay ustjay #~D#."

#: src/code/sharpm.lisp
msgid "Missing label for ##."
msgstr "Issingmay abellay orfay ##."

#: src/code/sharpm.lisp
msgid "reference to undefined label #~D#"
msgstr "eferenceray otay undefinedway abellay #~D#"

#: src/code/sharpm.lisp
msgid "Illegal complex number format: #C~S"
msgstr "Illegalway omplexcay umbernay ormatfay: #C~S"

#: src/code/sharpm.lisp
msgid "Illegal sharp character ~S"
msgstr "Illegalway arpshay aracterchay ~S"

#: src/code/backq.lisp
msgid "How deep we are into backquotes"
msgstr "Owhay eepday eway areway intoway ackquotesbay"

#: src/code/backq.lisp
msgid ",@ after backquote in ~S"
msgstr ",@ afterway ackquotebay inway ~S"

#: src/code/backq.lisp
msgid ",. after backquote in ~S"
msgstr ",. afterway ackquotebay inway ~S"

#: src/code/backq.lisp
msgid "Comma not inside a backquote."
msgstr "Ommacay otnay insideway away ackquotebay."

#: src/code/backq.lisp
msgid ",@ after dot in ~S"
msgstr ",@ afterway otday inway ~S"

#: src/code/backq.lisp
msgid ",. after dot in ~S"
msgstr ",. afterway otday inway ~S"

#: src/code/backq.lisp
msgid ""
"Given a lisp form containing the magic functions BACKQ-LIST, BACKQ-LIST*,\n"
"  BACKQ-APPEND, etc. produced by the backquote reader macro, will return a\n"
"  corresponding backquote input form.  In this form, `,' `,@' and `,.' are\n"
"  represented by lists whose cars are BACKQ-COMMA, BACKQ-COMMA-AT, and\n"
"  BACKQ-COMMA-DOT respectively, and whose cadrs are the form after the "
"comma.\n"
"  SPLICING indicates whether a comma-escape return should be modified for\n"
"  splicing with other forms: a value of T or :NCONC meaning that an extra\n"
"  level of parentheses should be added."
msgstr ""
"Ivengay away isplay ormfay ontainingcay ethay agicmay unctionsfay BACKQ-"
"LIST, BACKQ-Ist*Lay,\n"
"  BACKQ-APPEND, etcway. oducedpray ybay ethay ackquotebay eaderray acromay, "
"illway eturnray away\n"
"  orrespondingcay ackquotebay inputway ormfay.  Inway isthay ormfay, `,' `,"
"@' andway `,.' areway\n"
"  epresentedray ybay istslay osewhay arscay areway BACKQ-COMMA, BACKQ-COMMA-"
"AT, andway\n"
"  BACKQ-COMMA-DOT espectivelyray, andway osewhay adrscay areway ethay ormfay "
"afterway ethay ommacay.\n"
"  SPLICING indicatesway etherwhay away ommacay-escapeway eturnray ouldshay "
"ebay odifiedmay orfay\n"
"  licingspay ithway otherway ormsfay: away aluevay ofway T orway :NCONC "
"eaningmay atthay anway extraway\n"
"  evellay ofway arenthesespay ouldshay ebay addedway."

#: src/code/backq.lisp
msgid "### illegal dotted backquote form ###"
msgstr "### illegalway ottedday ackquotebay ormfay ###"

#: src/code/serve-event.lisp
msgid ""
"Make an object set for use by a RPC/xevent server.  Name is for\n"
"      descriptive purposes only."
msgstr ""
"Akemay anway objectway etsay orfay useway ybay away RPC/eventxay erversay.  "
"Amenay isway orfay\n"
"      escriptiveday urposespay onlyway."

#: src/code/serve-event.lisp
msgid "You lose, object: ~S"
msgstr "Ouyay oselay, objectway: ~S"

#: src/code/serve-event.lisp
msgid ""
"Return as multiple values the object and object-set mapped to by xwindow."
msgstr ""
"Eturnray asway ultiplemay aluesvay ethay objectway andway objectway-etsay "
"appedmay otay ybay windowxay."

#: src/code/serve-event.lisp
msgid "Add a new xwindow/object/object-set association."
msgstr "Addway away ewnay windowxay/objectway/objectway-etsay associationway."

#: src/code/serve-event.lisp
msgid "Remove xwindow and its associated object/object-set pair."
msgstr ""
"Emoveray windowxay andway itsway associatedway objectway/objectway-etsay "
"airpay."

#: src/code/serve-event.lisp
msgid ""
"Return the handler function in Object-Set for the operation specified by\n"
"   Message-ID, if none, NIL is returned."
msgstr ""
"Eturnray ethay andlerhay unctionfay inway Objectway-Etsay orfay ethay "
"operationway ecifiedspay ybay\n"
"   Essagemay-ID, ifway onenay, NIL isway eturnedray."

#: src/code/serve-event.lisp
msgid "#<Handler for ~A on ~:[~;BOGUS ~]descriptor ~D: ~S>"
msgstr "#<Andlerhay orfay ~Away onway ~:[~;BOGUS ~]escriptorday ~D: ~S>"

#: src/code/serve-event.lisp
msgid "List of all the currently active handlers for file descriptors"
msgstr ""
"Istlay ofway allway ethay urrentlycay activeway andlershay orfay ilefay "
"escriptorsday"

#: src/code/serve-event.lisp
msgid ""
"Arange to call FUNCTION whenever FD is usable. DIRECTION should be\n"
"  either :INPUT or :OUTPUT. The value returned should be passed to\n"
"  SYSTEM:REMOVE-FD-HANDLER when it is no longer needed."
msgstr ""
"Arangeway otay allcay FUNCTION eneverwhay FD isway usableway. DIRECTION "
"ouldshay ebay\n"
"  eitherway :INPUT orway :OUTPUT. Ethay aluevay eturnedray ouldshay ebay "
"assedpay otay\n"
"  SYSTEM:REMOVE-FD-HANDLER enwhay itway isway onay ongerlay eedednay."

#: src/code/serve-event.lisp
msgid "Invalid direction ~S, must be either :INPUT or :OUTPUT"
msgstr "Invalidway irectionday ~S, ustmay ebay eitherway :INPUT orway :OUTPUT"

#: src/code/serve-event.lisp
msgid "Removes HANDLER from the list of active handlers."
msgstr "Emovesray HANDLER omfray ethay istlay ofway activeway andlershay."

#: src/code/serve-event.lisp
msgid ""
"Remove any handers refering to FD. This should only be used when attempting\n"
"  to recover from a detected inconsistency."
msgstr ""
"Emoveray anyway andershay eferingray otay FD. Isthay ouldshay onlyway ebay "
"usedway enwhay attemptingway\n"
"  otay ecoverray omfray away etectedday inconsistencyway."

#: src/code/serve-event.lisp
msgid ""
"Establish a handler with SYSTEM:ADD-FD-HANDLER for the duration of BODY.\n"
"   DIRECTION should be either :INPUT or :OUTPUT, FD is the file descriptor "
"to\n"
"   use, and FUNCTION is the function to call whenever FD is usable."
msgstr ""
"Establishway away andlerhay ithway SYSTEM:ADD-FD-HANDLER orfay ethay "
"urationday ofway BODY.\n"
"   DIRECTION ouldshay ebay eitherway :INPUT orway :OUTPUT, FD isway ethay "
"ilefay escriptorday otay\n"
"   useway, andway FUNCTION isway ethay unctionfay otay allcay eneverwhay FD "
"isway usableway."

#.  This needs more work.
#: src/code/serve-event.lisp
msgid "~S ~[have~;has a~:;have~] bad file descriptor."
msgid_plural "~S ~[have~;has a~:;have~] bad file descriptors."
msgstr[0] "~S ~[avehay~;ashay away~:;avehay~] adbay ilefay escriptorday."
msgstr[1] "~S ~[avehay~;ashay away~:;avehay~] adbay ilefay escriptorsday."

#: src/code/serve-event.lisp
msgid "Remove bogus handlers."
msgstr "Emoveray ogusbay andlershay."

#: src/code/serve-event.lisp
msgid "Retry bogus handlers."
msgstr "Etryray ogusbay andlershay."

#: src/code/serve-event.lisp
msgid "Go on, leaving handlers marked as bogus."
msgstr "Ogay onway, eavinglay andlershay arkedmay asway ogusbay."

#: src/code/serve-event.lisp
msgid "Timeout is not a real number or NIL: ~S"
msgstr "Imeouttay isway otnay away ealray umbernay orway NIL: ~S"

#: src/code/serve-event.lisp
msgid ""
"Wait until FD is usable for DIRECTION. DIRECTION should be either :INPUT or\n"
"  :OUTPUT. TIMEOUT, if supplied, is the number of seconds to wait before "
"giving\n"
"  up."
msgstr ""
"Aitway untilway FD isway usableway orfay DIRECTION. DIRECTION ouldshay ebay "
"eitherway :INPUT orway\n"
"  :OUTPUT. TIMEOUT, ifway uppliedsay, isway ethay umbernay ofway econdssay "
"otay aitway eforebay ivinggay\n"
"  upway."

#: src/code/time.lisp src/code/serve-event.lisp
msgid "Syscall ~A failed: ~A"
msgstr "Yscallsay ~Away ailedfay: ~Away"

#: src/code/serve-event.lisp
msgid ""
"This is an alist mapping displays to user functions to be called when\n"
"   SYSTEM:SERVE-EVENT notices input on a display connection.  Do not modify\n"
"   this directly; use EXT:ENABLE-CLX-EVENT-HANDLING.  A given display\n"
"   should be represented here only once."
msgstr ""
"Isthay isway anway alistway appingmay isplaysday otay userway unctionsfay "
"otay ebay alledcay enwhay\n"
"   SYSTEM:SERVE-EVENT oticesnay inputway onway away isplayday onnectioncay.  "
"Oday otnay odifymay\n"
"   isthay irectlyday; useway EXT:ENABLE-CLX-EVENT-HANDLING.  Away ivengay "
"isplayday\n"
"   ouldshay ebay epresentedray erehay onlyway onceway."

#: src/code/serve-event.lisp
msgid ""
"SERVE-ALL-EVENTS calls SERVE-EVENT with the specified timeout.  If\n"
"  SERVE-EVENT does something (returns T) it loops over SERVE-EVENT with "
"timeout\n"
"  0 until all events have been served.  SERVE-ALL-EVENTS returns T if\n"
"  SERVE-EVENT did something and NIL if not."
msgstr ""
"SERVE-ALL-EVENTS allscay SERVE-EVENT ithway ethay ecifiedspay imeouttay.  "
"Ifway\n"
"  SERVE-EVENT oesday omethingsay (eturnsray T) itway oopslay overway SERVE-"
"EVENT ithway imeouttay\n"
"  0 untilway allway eventsway avehay eenbay ervedsay.  SERVE-ALL-EVENTS "
"eturnsray T ifway\n"
"  SERVE-EVENT idday omethingsay andway NIL ifway otnay."

#: src/code/serve-event.lisp
msgid ""
"Receive on all ports and Xevents and dispatch to the appropriate handler\n"
"  function.  If timeout is specified, server will wait the specified time "
"(in\n"
"  seconds) and then return, otherwise it will wait until something happens.\n"
"  Server returns T if something happened and NIL otherwise."
msgstr ""
"Eceiveray onway allway ortspay andway Eventsxay andway ispatchday otay ethay "
"appropriateway andlerhay\n"
"  unctionfay.  Ifway imeouttay isway ecifiedspay, erversay illway aitway "
"ethay ecifiedspay imetay (inway\n"
"  econdssay) andway enthay eturnray, otherwiseway itway illway aitway "
"untilway omethingsay appenshay.\n"
"  Erversay eturnsray T ifway omethingsay appenedhay andway NIL otherwiseway."

#: src/code/serve-event.lisp
msgid "Event-listen was true, but handler didn't handle: ~%~S"
msgstr ""
"Eventway-istenlay asway uetray, utbay andlerhay idnday't andlehay: ~%~S"

#: src/code/extfmts.lisp
#, fuzzy
msgid ""
"The default external format to use if no other external format is\n"
"  specified.  This is unaffected by any locale settings or by\n"
"  SET-SYSTEM-EXTERNAL-FORMAT."
msgstr ""
"Ethay efaultday externalway ormatfay otay useway ifway onay otherway "
"externalway ormatfay isway\n"
"  ecifiedspay"

#: src/code/extfmts.lisp
msgid "Hash table of all the external formats that have been loaded"
msgstr ""
"Ashhay abletay ofway allway ethay externalway ormatsfay atthay avehay eenbay "
"oadedlay"

#: src/code/extfmts.lisp
msgid ""
"Hash table mapping an external format alias to the actual external\n"
"  format implementation"
msgstr ""
"Ashhay abletay appingmay anway externalway ormatfay aliasway otay ethay "
"actualway externalway\n"
"  ormatfay implementationway"

#: src/code/extfmts.lisp
msgid "Attempting unimplemented external-format I/O."
msgstr "Attemptingway unimplementedway externalway-ormatfay Iway/O."

#: src/code/extfmts.lisp
msgid "External format ~S not found."
msgstr "Externalway ormatfay ~S otnay oundfay."

#: src/code/extfmts.lisp
msgid "Bad entry in external-format aliases file: ~S => ~S."
msgstr "Adbay entryway inway externalway-ormatfay aliasesway ilefay: ~S => ~S."

#: src/code/extfmts.lisp
msgid "External-format aliases file ends early."
msgstr "Externalway-ormatfay aliasesway ilefay endsway earlyway."

#: src/code/extfmts.lisp
msgid ""
"List the available external formats.  A list is returned where each\n"
"  element is list of the external format and a list of aliases for the\n"
"  format.  No distinction is made between external formats and\n"
"  composing external formats."
msgstr ""
"Istlay ethay availableway externalway ormatsfay.  Away istlay isway "
"eturnedray erewhay eachway\n"
"  elementway isway istlay ofway ethay externalway ormatfay andway away "
"istlay ofway aliasesway orfay ethay\n"
"  ormatfay.  Onay istinctionday isway ademay etweenbay externalway ormatsfay "
"andway\n"
"  omposingcay externalway ormatsfay."

#: src/code/extfmts.lisp
msgid ""
"Print a description of the given External-Format.  This may cause\n"
"  the external format to be loaded (silently), if it is not already\n"
"  loaded."
msgstr ""
"Intpray away escriptionday ofway ethay ivengay Externalway-Ormatfay.  Isthay "
"aymay ausecay\n"
"  ethay externalway ormatfay otay ebay oadedlay (ilentlysay), ifway itway "
"isway otnay alreadyway\n"
"  oadedlay."

#: src/code/extfmts.lisp
msgid "~&~S is an alias for the external format ~S.~2%"
msgstr "~&~S isway anway aliasway orfay ethay externalway ormatfay ~S.~2%"

#: src/code/extfmts.lisp
msgid "~&~S is a composed external format.~2%"
msgstr "~&~S isway away omposedcay externalway ormatfay.~2%"

#: src/code/extfmts.lisp
msgid "~S~:[~; - [Aliases: ~{~S~^, ~}~]]~%"
msgstr "~S~:[~; - [Aliasesway: ~{~S~^, ~}~]]~%"

#: src/code/extfmts.lisp
msgid "~&~S is a composing external format.~2%"
msgstr "~&~S isway away omposingcay externalway ormatfay.~2%"

#: src/code/extfmts.lisp
msgid "~&Could not find external format ~S~%"
msgstr "~&Ouldcay otnay indfay externalway ormatfay ~S~%"

#: src/code/extfmts.lisp
msgid ""
"List of external formats that are builtin so that they don't need to\n"
"  be loaded on first use."
msgstr ""

#: src/code/extfmts.lisp
msgid "External-format aliasing depth exceeded."
msgstr "Externalway-ormatfay aliasingway epthday exceededway."

#: src/code/extfmts.lisp
msgid "~S is a Composing-External-Format."
msgstr "~S isway away Omposingcay-Externalway-Ormatfay."

#: src/code/extfmts.lisp
msgid "~S is not a Composing-External-Format."
msgstr "~S isway otnay away Omposingcay-Externalway-Ormatfay."

#: src/code/extfmts.lisp
msgid "~S is not a valid external format name."
msgstr "~S isway otnay away alidvay externalway ormatfay amenay."

#: src/code/extfmts.lisp
msgid "Attempting I/O through void external-format."
msgstr "Attemptingway Iway/O roughthay oidvay externalway-ormatfay."

#: src/code/extfmts.lisp
msgid "Void external format that signals an error on any input or output."
msgstr ""
"Oidvay externalway ormatfay atthay ignalssay anway errorway onway anyway "
"inputway orway outputway."

#: src/code/extfmts.lisp
msgid ""
"ISO8859-1 is an 8-bit character encoding generally intended for\n"
"Western European languages including English, German, Italian,\n"
"Norwegian, Portuguese, Spanish, Swedish and many others.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-1 isway anway 8-itbay aracterchay encodingway enerallygay "
"intendedway orfay\n"
"Esternway Europeanway anguageslay includingway Englishway, Ermangay, "
"Italianway,\n"
"Orwegiannay, Ortuguesepay, Anishspay, Wedishsay andway anymay othersway.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

#: src/code/extfmts.lisp
msgid ""
"Convert String to octets using the specified External-format.  The\n"
"  string is bounded by Start (defaulting to 0) and End (defaulting to\n"
"  the end of the string.  If Buffer is given, the octets are stored\n"
"  there.  If not, a new buffer is created.  Buffer-start specifies\n"
"  where in the buffer the first octet will be placed.\n"
"\n"
"  Three values are returned: The buffer, the number of valid octets\n"
"  written, and the number of characters converted.  Note that the\n"
"  actual number of octets written may be greater than the returned\n"
"  value, These represent the partial octets of the next character to\n"
"  be converted, but there was not enough room to hold the complete set\n"
"  of octets."
msgstr ""
"Onvertcay Ingstray otay octetsway usingway ethay ecifiedspay Externalway-"
"ormatfay.  Ethay\n"
"  ingstray isway oundedbay ybay Tartsay (efaultingday otay 0) andway Endway "
"(efaultingday otay\n"
"  ethay endway ofway ethay ingstray.  Ifway Ufferbay isway ivengay, ethay "
"octetsway areway toredsay\n"
"  erethay.  Ifway otnay, away ewnay ufferbay isway eatedcray.  Ufferbay-"
"tartsay ecifiesspay\n"
"  erewhay inway ethay ufferbay ethay irstfay octetway illway ebay acedplay.\n"
"\n"
"  Reethay aluesvay areway eturnedray: Ethay ufferbay, ethay umbernay ofway "
"alidvay octetsway\n"
"  ittenwray, andway ethay umbernay ofway aracterschay onvertedcay.  Otenay "
"atthay ethay\n"
"  actualway umbernay ofway octetsway ittenwray aymay ebay eatergray anthay "
"ethay eturnedray\n"
"  aluevay, Esethay epresentray ethay artialpay octetsway ofway ethay extnay "
"aracterchay otay\n"
"  ebay onvertedcay, utbay erethay asway otnay enoughway oomray otay oldhay "
"ethay ompletecay etsay\n"
"  ofway octetsway."

#: src/code/extfmts.lisp
msgid ""
"Octets-to-string converts an array of octets in Octets to a string\n"
"  according to the specified External-format.  The array of octets is\n"
"  bounded by Start (defaulting ot 0) and End (defaulting to the end of\n"
"  the array.  If String is not given, a new string is created.  If\n"
"  String is given, the converted octets are stored in String, starting\n"
"  at S-Start (defaulting to the 0) and ending at S-End (defaulting to\n"
"  the length of String).  If the string is not large enough to hold\n"
"  all of characters, then some octets will not be converted.  A State\n"
"  may also be specified; this is used as the state of the external\n"
"  format.  An error method may also be specified by Error, which\n"
"  defaults to NIL to mean the default handling of conversion errors is\n"
"  done.\n"
"\n"
"  Four values are returned: the string, the position of where the next\n"
"  character would be read into the string, the number of octets\n"
"  actually consumed and the new state of the external format."
msgstr ""
"Octetsway-otay-ingstray onvertscay anway arrayway ofway octetsway inway "
"Octetsway otay away ingstray\n"
"  accordingway otay ethay ecifiedspay Externalway-ormatfay.  Ethay arrayway "
"ofway octetsway isway\n"
"  oundedbay ybay Tartsay (efaultingday otway 0) andway Endway (efaultingday "
"otay ethay endway ofway\n"
"  ethay arrayway.  Ifway Ingstray isway otnay ivengay, away ewnay ingstray "
"isway eatedcray.  Ifway\n"
"  Ingstray isway ivengay, ethay onvertedcay octetsway areway toredsay inway "
"Ingstray, tartingsay\n"
"  atway S-Tartsay (efaultingday otay ethay 0) andway endingway atway S-"
"Endway (efaultingday otay\n"
"  ethay engthlay ofway Ingstray).  Ifway ethay ingstray isway otnay argelay "
"enoughway otay oldhay\n"
"  allway ofway aracterschay, enthay omesay octetsway illway otnay ebay "
"onvertedcay.  Away Tatesay\n"
"  aymay alsoway ebay ecifiedspay; isthay isway usedway asway ethay tatesay "
"ofway ethay externalway\n"
"  ormatfay.  Anway errorway ethodmay aymay alsoway ebay ecifiedspay ybay "
"Errorway, ichwhay\n"
"  efaultsday otay NIL otay eanmay ethay efaultday andlinghay ofway "
"onversioncay errorsway isway\n"
"  oneday.\n"
"\n"
"  Ourfay aluesvay areway eturnedray: ethay ingstray, ethay ositionpay ofway "
"erewhay ethay extnay\n"
"  aracterchay ouldway ebay eadray intoway ethay ingstray, ethay umbernay "
"ofway octetsway\n"
"  actuallyway onsumedcay andway ethay ewnay tatesay ofway ethay externalway "
"ormatfay."

#: src/code/extfmts.lisp
msgid ""
"Octets-to-string converts an array of octets in Octets to a string\n"
"  according to the specified External-format.  The array of octets is\n"
"  bounded by Start (defaulting ot 0) and End (defaulting to the end of\n"
"  the array.  If String is not given, a new string is created.  If\n"
"  String is given, the converted octets are stored in String, starting\n"
"  at S-Start (defaulting to the 0) and ending at S-End (defaulting to\n"
"  the length of String).  If the string is not large enough to hold\n"
"  all of characters, then some octets will not be converted.  A State\n"
"  may also be specified; this is used as the state of the external\n"
"  format.\n"
"\n"
"  In Ocount, the number of octets read for each character in the\n"
"  string is saved\n"
"\n"
"  Four values are returned: the string, the number of characters read,\n"
"  the number of octets actually consumed and the new state of the\n"
"  external format."
msgstr ""
"Octetsway-otay-ingstray onvertscay anway arrayway ofway octetsway inway "
"Octetsway otay away ingstray\n"
"  accordingway otay ethay ecifiedspay Externalway-ormatfay.  Ethay arrayway "
"ofway octetsway isway\n"
"  oundedbay ybay Tartsay (efaultingday otway 0) andway Endway (efaultingday "
"otay ethay endway ofway\n"
"  ethay arrayway.  Ifway Ingstray isway otnay ivengay, away ewnay ingstray "
"isway eatedcray.  Ifway\n"
"  Ingstray isway ivengay, ethay onvertedcay octetsway areway toredsay inway "
"Ingstray, tartingsay\n"
"  atway S-Tartsay (efaultingday otay ethay 0) andway endingway atway S-"
"Endway (efaultingday otay\n"
"  ethay engthlay ofway Ingstray).  Ifway ethay ingstray isway otnay argelay "
"enoughway otay oldhay\n"
"  allway ofway aracterschay, enthay omesay octetsway illway otnay ebay "
"onvertedcay.  Away Tatesay\n"
"  aymay alsoway ebay ecifiedspay; isthay isway usedway asway ethay tatesay "
"ofway ethay externalway\n"
"  ormatfay.\n"
"\n"
"  Inway Ocountway, ethay umbernay ofway octetsway eadray orfay eachway "
"aracterchay inway ethay\n"
"  ingstray isway avedsay\n"
"\n"
"  Ourfay aluesvay areway eturnedray: ethay ingstray, ethay umbernay ofway "
"aracterschay eadray,\n"
"  ethay umbernay ofway octetsway actuallyway onsumedcay andway ethay ewnay "
"tatesay ofway ethay\n"
"  externalway ormatfay."

#: src/code/extfmts.lisp
msgid ""
"Compute the number of octets needed to convert String using the\n"
"  specified External-format.  The string is bound by Start (defaulting\n"
"  to 0) and End (defaulting to the end of the string)."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"Encode the given String using External-Format and return a new\n"
"  string.  The characters of the new string are the octets of the\n"
"  encoded result, with each octet converted to a character via\n"
"  code-char.  This is the inverse to String-Decode"
msgstr ""
"Encodeway ethay ivengay Ingstray usingway Externalway-Ormatfay andway "
"eturnray away ewnay\n"
"  ingstray.  Ethay aracterschay ofway ethay ewnay ingstray areway ethay "
"octetsway ofway ethay\n"
"  encodedway esultray, ithway eachway octetway onvertedcay otay away "
"aracterchay iavay\n"
"  odecay-archay.  Isthay isway ethay inverseway otay Ingstray-Ecodeday"

#: src/code/extfmts.lisp
msgid ""
"Decode String using the given External-Format and return the new\n"
"  string.  The input string is treated as if it were an array of\n"
"  octets, where the char-code of each character is the octet.  This is\n"
"  the inverse of String-Encode."
msgstr ""
"Ecodeday Ingstray usingway ethay ivengay Externalway-Ormatfay andway "
"eturnray ethay ewnay\n"
"  ingstray.  Ethay inputway ingstray isway eatedtray asway ifway itway "
"ereway anway arrayway ofway\n"
"  octetsway, erewhay ethay archay-odecay ofway eachway aracterchay isway "
"ethay octetway.  Isthay isway\n"
"  ethay inverseway ofway Ingstray-Encodeway."

#: src/code/extfmts.lisp
#, fuzzy
msgid ""
"Change the external format of the standard streams to Terminal.\n"
"  The standard streams are sys::*stdin*, sys::*stdout*, and\n"
"  sys::*stderr*, which are normally the input and/or output streams\n"
"  for *standard-input* and *standard-output*.  Also sets sys::*tty*\n"
"  (normally *terminal-io* to the given external format.  The value of\n"
"  *default-external-format* is not changed.\n"
"\n"
"  If the optional argument Filenames is given, then the filename\n"
"  encoding is set to the specified format, if it has not already been\n"
"  specified previously."
msgstr ""
"Angechay ethay externalway ormatfay ofway ethay tandardsay eamsstray otay "
"Erminaltay.\n"
"  Ethay tandardsay eamsstray areway yssay::*stdin*, yssay::*stdout*, andway\n"
"  yssay::*stderr*, ichwhay areway ormallynay ethay inputway andway/orway "
"outputway eamsstray\n"
"  orfay *standard-input* andway *standard-output*.  Alsoway etssay yssay::"
"*tty*\n"
"  (ormallynay *terminal-io* otay ethay ivengay externalway ormatfay.  Ifway "
"ethay\n"
"  optionalway argumentway Ilenamesfay isway viengay, enthay ethay ilenamefay "
"encodingway isway\n"
"  etsay otay ethay ecifiedspay ormatfay."

#: src/code/extfmts.lisp
msgid "Can't find external-format ~S."
msgstr "Ancay't indfay externalway-ormatfay ~S."

#: src/code/extfmts.lisp
msgid "Change it anyway."
msgstr "Angechay itway anywayway."

#: src/code/extfmts.lisp
msgid "The external-format for encoding filenames is already set."
msgstr ""
"Ethay externalway-ormatfay orfay encodingway ilenamesfay isway alreadyway "
"etsay."

#: src/code/extfmts.lisp
msgid ""
"UTF-8 is a variable-length character encoding for Unicode.  By\n"
"default, illegal input sequences are replaced by the Unicode\n"
"replacement character."
msgstr ""
"UTF-8 isway away ariablevay-engthlay aracterchay encodingway orfay "
"Unicodeway.  Ybay\n"
"efaultday, illegalway inputway equencessay areway eplacedray ybay ethay "
"Unicodeway\n"
"eplacementray aracterchay."

#: src/code/extfmts.lisp
msgid ""
"US ASCII 7-bit encoding.  Illegal input sequences are replaced with\n"
"the Unicode replacment character.  Illegal output characters are\n"
"replaced with a question mark."
msgstr ""
"US ASCII 7-itbay encodingway.  Illegalway inputway equencessay areway "
"eplacedray ithway\n"
"ethay Unicodeway eplacmentray aracterchay.  Illegalway outputway "
"aracterschay areway\n"
"eplacedray ithway away estionquay arkmay."

#: src/code/fd-stream.lisp
msgid ""
"List of available buffers.  Each buffer is an sap pointing to\n"
"  bytes-per-buffer of memory."
msgstr ""
"Istlay ofway availableway uffersbay.  Eachway ufferbay isway anway apsay "
"ointingpay otay\n"
"  ytesbay-erpay-ufferbay ofway emorymay."

#: src/code/fd-stream.lisp
msgid "Number of bytes per buffer."
msgstr "Umbernay ofway ytesbay erpay ufferbay."

#: src/code/fd-stream.lisp
msgid "The maximum supported byte size for a stream element-type."
msgstr ""
"Ethay aximummay upportedsay ytebay izesay orfay away eamstray elementway-"
"ypetay."

#: src/code/fd-stream.lisp
msgid "Timeout ~(~A~)ing ~S."
msgstr "Imeouttay ~(~Away~)ingway ~S."

#: src/code/fd-stream.lisp
msgid ""
"List of all available output routines. Each element is a list of the\n"
"  element-type output, the kind of buffering, the function name, and the "
"number\n"
"  of bytes per element."
msgstr ""
"Istlay ofway allway availableway outputway outinesray. Eachway elementway "
"isway away istlay ofway ethay\n"
"  elementway-ypetay outputway, ethay indkay ofway ufferingbay, ethay "
"unctionfay amenay, andway ethay umbernay\n"
"  ofway ytesbay erpay elementway."

#: src/code/fd-stream.lisp
msgid "Write would have blocked, but SERVER told us to go."
msgstr "Itewray ouldway avehay ockedblay, utbay SERVER oldtay usway otay ogay."

#: src/code/fd-stream.lisp
msgid "While writing ~S: ~A"
msgstr "Ilewhay itingwray ~S: ~Away"

#: src/code/fd-stream.lisp
msgid ""
"Output THING to stream.  THING can be any kind of vector or a sap.  If "
"THING\n"
"  is a SAP, END must be supplied (as length won't work)."
msgstr ""
"Outputway THING otay eamstray.  THING ancay ebay anyway indkay ofway "
"ectorvay orway away apsay.  Ifway THING\n"
"  isway away SAP, END ustmay ebay uppliedsay (asway engthlay onway't orkway)."

#: src/code/fd-stream.lisp
msgid "Just go on as if nothing happened..."
msgstr "Ustjay ogay onway asway ifway othingnay appenedhay..."

#: src/code/fd-stream.lisp
msgid "~S called with :END before :START!"
msgstr "~S alledcay ithway :END eforebay :START!"

#: src/code/fd-stream.lisp
msgid ""
"List of all available input routines. Each element is a list of the\n"
"  element-type input, the function name, and the number of bytes per element."
msgstr ""
"Istlay ofway allway availableway inputway outinesray. Eachway elementway "
"isway away istlay ofway ethay\n"
"  elementway-ypetay inputway, ethay unctionfay amenay, andway ethay umbernay "
"ofway ytesbay erpay elementway."

#: src/code/fd-stream.lisp
msgid "Error reading ~S: ~A"
msgstr "Errorway eadingray ~S: ~Away"

#: src/code/fd-stream.lisp
msgid "Could not find any input routine for ~S"
msgstr "Ouldcay otnay indfay anyway inputway outineray orfay ~S"

#: src/code/fd-stream.lisp
msgid "Could not find any output routine for ~S buffered ~S."
msgstr ""
"Ouldcay otnay indfay anyway outputway outineray orfay ~S ufferedbay ~S."

#: src/code/fd-stream.lisp
msgid "Element sizes for input (~S:~S) and output (~S:~S) differ?"
msgstr ""
"Elementway izessay orfay inputway (~S:~S) andway outputway (~S:~S) ifferday?"

#: src/code/fd-stream.lisp
msgid "Input type (~S) and output type (~S) are unrelated?"
msgstr "Inputway ypetay (~S) andway outputway ypetay (~S) areway unrelatedway?"

#: src/code/fd-stream.lisp
msgid "Go on as if nothing bad happened."
msgstr "Ogay onway asway ifway othingnay adbay appenedhay."

#: src/code/fd-stream.lisp
msgid "Could not restore ~S to its original contents: ~A"
msgstr "Ouldcay otnay estoreray ~S otay itsway originalway ontentscay: ~Away"

#: src/code/fd-stream.lisp
msgid "~s is not a stream associated with a file."
msgstr "~s isway otnay away eamstray associatedway ithway away ilefay."

#: src/code/fd-stream.lisp
msgid "Error fstating ~S: ~A"
msgstr "Errorway statingfay ~S: ~Away"

#: src/code/fd-stream.lisp
msgid "Error lseek'ing ~S: ~A"
msgstr "Errorway seeklay'ingway ~S: ~Away"

#: src/code/fd-stream.lisp
msgid "Invalid position given to file-position: ~S"
msgstr "Invalidway ositionpay ivengay otay ilefay-ositionpay: ~S"

#: src/code/fd-stream.lisp
msgid "Use Unicode replacement character instead"
msgstr "Useway Unicodeway eplacementray aracterchay insteadway"

#: src/code/fd-stream.lisp
msgid "Use question mark character instead"
msgstr "Useway estionquay arkmay aracterchay insteadway"

#: src/code/fd-stream.lisp
msgid ""
"Create a stream for the given unix file descriptor.\n"
"  If input is non-nil, allow input operations.\n"
"  If output is non-nil, allow output operations.\n"
"  If neither input nor output are specified, default to allowing input.\n"
"  Element-type indicates the element type to use (as for open).\n"
"  Buffering indicates the kind of buffering to use.\n"
"  Timeout (if true) is the number of seconds to wait for input.  If NIL "
"(the\n"
"    default), then wait forever.  When we time out, we signal IO-TIMEOUT.\n"
"  File is the name of the file (will be returned by PATHNAME).\n"
"  Name is used to identify the stream when printed.\n"
"  External-format is the external format to use for the stream.\n"
"  Decoding-error and Encoding-error indicate how decoding/encoding errors "
"on\n"
"    the stream should be handled.  The default is to use a replacement "
"character."
msgstr ""
"Eatecray away eamstray orfay ethay ivengay unixway ilefay escriptorday.\n"
"  Ifway inputway isway onnay-ilnay, allowway inputway operationsway.\n"
"  Ifway outputway isway onnay-ilnay, allowway outputway operationsway.\n"
"  Ifway eithernay inputway ornay outputway areway ecifiedspay, efaultday "
"otay allowingway inputway.\n"
"  Elementway-ypetay indicatesway ethay elementway ypetay otay useway (asway "
"orfay openway).\n"
"  Ufferingbay indicatesway ethay indkay ofway ufferingbay otay useway.\n"
"  Imeouttay (ifway uetray) isway ethay umbernay ofway econdssay otay aitway "
"orfay inputway.  Ifway NIL (ethay\n"
"    efaultday), enthay aitway oreverfay.  Enwhay eway imetay outway, eway "
"ignalsay IO-TIMEOUT.\n"
"  Ilefay isway ethay amenay ofway ethay ilefay (illway ebay eturnedray ybay "
"PATHNAME).\n"
"  Amenay isway usedway otay identifyway ethay eamstray enwhay intedpray.\n"
"  Externalway-ormatfay isway ethay externalway ormatfay otay useway orfay "
"ethay eamstray.\n"
"  Ecodingday-errorway andway Encodingway-errorway indicateway owhay "
"ecodingday/encodingway errorsway onway\n"
"    ethay eamstray ouldshay ebay andledhay.  Ethay efaultday isway otay "
"useway away eplacementray aracterchay."

#: src/code/fd-stream.lisp
msgid "File descriptor must be opened either for input or output."
msgstr ""
"Ilefay escriptorday ustmay ebay openedway eitherway orfay inputway orway "
"outputway."

#: src/code/fd-stream.lisp
msgid "** Closed ~A~%"
msgstr "** Osedclay ~Away~%"

#: src/code/fd-stream.lisp
msgid ""
"This is a string that OPEN tacks on the end of a file namestring to produce\n"
"   a name for the :if-exists :rename-and-delete and :rename options.  Also,\n"
"   this can be a function that takes a namestring and returns a complete\n"
"   namestring."
msgstr ""
"Isthay isway away ingstray atthay OPEN ackstay onway ethay endway ofway away "
"ilefay amestringnay otay oducepray\n"
"   away amenay orfay ethay :ifway-existsway :enameray-andway-eleteday "
"andway :enameray optionsway.  Alsoway,\n"
"   isthay ancay ebay away unctionfay atthay akestay away amestringnay andway "
"eturnsray away ompletecay\n"
"   amestringnay."

#: src/code/fd-stream.lisp
msgid "Enter new value for ~*~S"
msgstr "Enterway ewnay aluevay orfay ~*~S"

#: src/code/fd-stream.lisp
msgid "~S is invalid for ~S. Must be one of~{ ~S~}"
msgstr "~S isway invalidway orfay ~S. Ustmay ebay oneway ofway~{ ~S~}"

#: src/code/fd-stream.lisp
msgid "Enter new value for ~S: "
msgstr "Enterway ewnay aluevay orfay ~S: "

#: src/code/fd-stream.lisp
msgid "Try to rename it anyway."
msgstr "Ytray otay enameray itway anywayway."

#: src/code/fd-stream.lisp
msgid "File ~S is not writable."
msgstr "Ilefay ~S isway otnay itablewray."

#: src/code/fd-stream.lisp
msgid "Use :SUPERSEDE instead."
msgstr "Useway :SUPERSEDE insteadway."

#: src/code/fd-stream.lisp
msgid "Could not rename ~S to ~S: ~A."
msgstr "Ouldcay otnay enameray ~S otay ~S: ~Away."

#: src/code/fd-stream.lisp
msgid "Cannot open ~S for output: Is a directory."
msgstr "Annotcay openway ~S orfay outputway: Isway away irectoryday."

#: src/code/fd-stream.lisp
msgid "Cannot find ~S: ~A"
msgstr "Annotcay indfay ~S: ~Away"

#: src/code/fd-stream.lisp
msgid "Return NIL."
msgstr "Eturnray NIL."

#: src/code/fd-stream.lisp
msgid "Error opening ~S, ~A."
msgstr "Errorway openingway ~S, ~Away."

#: src/code/fd-stream.lisp
msgid "Error creating ~S, path does not exist."
msgstr "Errorway eatingcray ~S, athpay oesday otnay existway."

#: src/pcl/braid.lisp src/code/fd-stream.lisp
msgid "Try again."
msgstr "Ytray againway."

#: src/code/fd-stream.lisp
msgid ""
"Return a stream which reads from or writes to Filename.\n"
"  Defined keywords:\n"
"   :direction - one of :input, :output, :io, or :probe\n"
"   :element-type - Type of object to read or write, default BASE-CHAR\n"
"   :if-exists - one of :error, :new-version, :rename, :rename-and-delete,\n"
"                       :overwrite, :append, :supersede or nil\n"
"   :if-does-not-exist - one of :error, :create or nil\n"
"   :external-format - an external format name\n"
"   :decoding-error - How to handle decoding errors from the external "
"format.\n"
"                       If a character, then that character is used as\n"
"                       the replacment character for all errors.  If T,\n"
"                       then a continuable error is signaled.  If\n"
"                       continued, the Unicode replacement character is\n"
"                       used.  Otherwise, it should be a symbol or\n"
"                       function of 3 arguments.  If it returns, it\n"
"                       should return a code point to use as the\n"
"                       replacment.  The function arguments are a\n"
"                       format message string, the offending octet, and\n"
"                       the number of octets read in the current\n"
"                       encoding.\n"
"   :encoding-error - Like :decoding-error, but for errors when encoding the\n"
"                       stream.  If a character, that character is used\n"
"                       as the replacment code point.  Otherwise, it\n"
"                       should be a symbol or function oof two\n"
"                       arguments: a format message string and the\n"
"                       incorrect codepoint.\n"
"\n"
"  See the manual for details."
msgstr ""
"Eturnray away eamstray ichwhay eadsray omfray orway iteswray otay "
"Ilenamefay.\n"
"  Efinedday eywordskay:\n"
"   :irectionday - oneway ofway :inputway, :outputway, :ioway, orway :"
"obepray\n"
"   :elementway-ypetay - Ypetay ofway objectway otay eadray orway itewray, "
"efaultday BASE-CHAR\n"
"   :ifway-existsway - oneway ofway :errorway, :ewnay-ersionvay, :enameray, :"
"enameray-andway-eleteday,\n"
"                       :overwriteway, :appendway, :upersedesay orway ilnay\n"
"   :ifway-oesday-otnay-existway - oneway ofway :errorway, :eatecray orway "
"ilnay\n"
"   :externalway-ormatfay - anway externalway ormatfay amenay\n"
"   :ecodingday-errorway - Owhay otay andlehay ecodingday errorsway omfray "
"ethay externalway ormatfay.\n"
"                       Ifway away aracterchay, enthay atthay aracterchay "
"isway usedway asway\n"
"                       ethay eplacmentray aracterchay orfay allway "
"errorsway.  Ifway T,\n"
"                       enthay away ontinuablecay errorway isway ignaledsay.  "
"Ifway\n"
"                       ontinuedcay, ethay Unicodeway eplacementray "
"aracterchay isway\n"
"                       usedway.  Otherwiseway, itway ouldshay ebay away "
"ymbolsay orway\n"
"                       unctionfay ofway 3 argumentsway.  Ifway itway "
"eturnsray, itway\n"
"                       ouldshay eturnray away odecay ointpay otay useway "
"asway ethay\n"
"                       eplacmentray.  Ethay unctionfay argumentsway areway "
"away\n"
"                       ormatfay essagemay ingstray, ethay offendingway "
"octetway, andway\n"
"                       ethay umbernay ofway octetsway eadray inway ethay "
"urrentcay\n"
"                       encodingway.\n"
"   :encodingway-errorway - Ikelay :ecodingday-errorway, utbay orfay "
"errorsway enwhay encodingway ethay\n"
"                       eamstray.  Ifway away aracterchay, atthay aracterchay "
"isway usedway\n"
"                       asway ethay eplacmentray odecay ointpay.  "
"Otherwiseway, itway\n"
"                       ouldshay ebay away ymbolsay orway unctionfay oofway "
"wotay\n"
"                       argumentsway: away ormatfay essagemay ingstray andway "
"ethay\n"
"                       incorrectway odepointcay.\n"
"\n"
"  Eesay ethay anualmay orfay etailsday."

#: src/pcl/std-class.lisp src/pcl/boot.lisp src/pcl/defs.lisp
#: src/pcl/defclass.lisp src/code/fd-stream.lisp
msgid "Odd-length property list in REMF."
msgstr "Oddway-engthlay opertypray istlay inway REMF."

#: src/code/fd-stream.lisp
msgid "Do it anyway."
msgstr "Oday itway anywayway."

#: src/code/fd-stream.lisp
msgid "Can't create simple-streams with an element-type."
msgstr "Ancay't eatecray implesay-eamsstray ithway anway elementway-ypetay."

#: src/code/fd-stream.lisp
msgid "Unable to open streams of class ~S."
msgstr "Unableway otay openway eamsstray ofway assclay ~S."

#: src/code/fd-stream.lisp
msgid ""
"The stream connected to the controlling terminal or NIL if there is none."
msgstr ""
"Ethay eamstray onnectedcay otay ethay ontrollingcay erminaltay orway NIL "
"ifway erethay isway onenay."

#: src/code/fd-stream.lisp
msgid "The stream connected to the standard input (file descriptor 0)."
msgstr ""
"Ethay eamstray onnectedcay otay ethay tandardsay inputway (ilefay "
"escriptorday 0)."

#: src/code/fd-stream.lisp
msgid "The stream connected to the standard output (file descriptor 1)."
msgstr ""
"Ethay eamstray onnectedcay otay ethay tandardsay outputway (ilefay "
"escriptorday 1)."

#: src/code/fd-stream.lisp
msgid "The stream connected to the standard error output (file descriptor 2)."
msgstr ""
"Ethay eamstray onnectedcay otay ethay tandardsay errorway outputway (ilefay "
"escriptorday 2)."

#: src/code/fd-stream.lisp
msgid "This is called in BEEP to feep the user.  It takes a stream."
msgstr ""
"Isthay isway alledcay inway BEEP otay eepfay ethay userway.  Itway akestay "
"away eamstray."

#: src/code/fd-stream.lisp
msgid ""
"Return the delta in Stream's FILE-POSITION that would be caused by writing\n"
"   Object to Stream.  Non-trivial only in implementations that support\n"
"   international character sets."
msgstr ""
"Eturnray ethay eltaday inway Eamstray's FILE-POSITION atthay ouldway ebay "
"ausedcay ybay itingwray\n"
"   Objectway otay Eamstray.  Onnay-ivialtray onlyway inway "
"implementationsway atthay upportsay\n"
"   internationalway aracterchay etssay."

#: src/code/fd-stream-extfmt.lisp
msgid "Don't know how to set external-format for ~S."
msgstr "Onday't nowkay owhay otay etsay externalway-ormatfay orfay ~S."

#: src/code/fd-stream-extfmt.lisp
msgid "Loading simple-streams should redefine this"
msgstr "Oadinglay implesay-eamsstray ouldshay edefineray isthay"

#: src/code/fd-stream-extfmt.lisp
msgid "Setting external-format on Gray streams not supported."
msgstr ""
"Ettingsay externalway-ormatfay onway Aygray eamsstray otnay upportedsay."

#: src/code/fd-stream-comp.lisp
msgid "Surrogate codepoint #x~~4,'0X is illegal for ~A"
msgstr "Urrogatesay odepointcay #x~~4,'0X isway illegalway orfay ~Away"

#: src/code/fd-stream-comp.lisp
msgid "Illegal codepoint on input: #x~X"
msgstr "Illegalway odepointcay onway inputway: #x~X"

#: src/code/fd-stream-comp.lisp
msgid "Cannot output codepoint #x~X to ISO8859-1 stream"
msgstr "Annotcay outputway odepointcay #x~X otay ISO8859-1 eamstray"

#: src/code/fd-stream-comp.lisp
msgid "Cannot convert invalid surrogate #x~X to character"
msgstr "Annotcay onvertcay invalidway urrogatesay #x~X otay aracterchay"

#: src/code/fd-stream-comp.lisp
msgid "Cannot convert lone trailing surrogate #x~X to character"
msgstr "Annotcay onvertcay onelay ailingtray urrogatesay #x~X otay aracterchay"

#: src/code/pathname.lisp
msgid ""
"When non-nil, attempt to load \"library:<host>.translations\" to resolve\n"
"   an otherwise undefined logical host."
msgstr ""
"Enwhay onnay-ilnay, attemptway otay oadlay \"ibrarylay:<osthay>."
"anslationstray\" otay esolveray\n"
"   anway otherwiseway undefinedway ogicallay osthay."

#: src/code/pathname.lisp
msgid ""
"When non-NIL, pathnames are on Darwin are normalized when created.\n"
"  Otherwise, the pathnames are unchanged.\n"
"\n"
"  This must be NIL during bootstrapping because Unicode is not yet\n"
"  available."
msgstr ""

#: src/code/pathname.lisp
msgid "A path specification, either a string, file-stream or pathname."
msgstr ""
"Away athpay ecificationspay, eitherway away ingstray, ilefay-eamstray orway "
"athnamepay."

#: src/code/pathname.lisp
msgid "Convert thing (a pathname, string or stream) into a pathname."
msgstr ""
"Onvertcay ingthay (away athnamepay, ingstray orway eamstray) intoway away "
"athnamepay."

#: src/code/pathname.lisp
msgid ""
"Construct a filled in pathname by completing the unspecified components\n"
"   from the defaults."
msgstr ""
"Onstructcay away illedfay inway athnamepay ybay ompletingcay ethay "
"unspecifiedway omponentscay\n"
"   omfray ethay efaultsday."

#: src/code/pathname.lisp
msgid "~S is not allowed as a directory component."
msgstr "~S isway otnay allowedway asway away irectoryday omponentcay."

#: src/code/pathname.lisp
msgid ""
"Makes a new pathname from the component arguments.  Note that host is\n"
"a host-structure or string."
msgstr ""
"Akesmay away ewnay athnamepay omfray ethay omponentcay argumentsway.  Otenay "
"atthay osthay isway\n"
"away osthay-ucturestray orway ingstray."

#: src/code/pathname.lisp
msgid "Silly argument for a unix ~A: ~S"
msgstr "Illysay argumentway orfay away unixway ~Away: ~S"

#: src/code/pathname.lisp
msgid "Silly argument for a unix PATHNAME-NAME: ~S"
msgstr "Illysay argumentway orfay away unixway PATHNAME-NAME: ~S"

#: src/code/pathname.lisp
msgid ""
"Illegal pathname: ~\n"
"                                Directory with ~S immediately followed by ~S"
msgstr ""
"Illegalway athnamepay: ~\n"
"                                Irectoryday ithway ~S immediatelyway "
"ollowedfay ybay ~S"

#: src/code/pathname.lisp
msgid "Accessor for the pathname's host."
msgstr "Accessorway orfay ethay athnamepay's osthay."

#: src/code/pathname.lisp
msgid "Accessor for pathname's device."
msgstr "Accessorway orfay athnamepay's eviceday."

#: src/code/pathname.lisp
msgid "Accessor for the pathname's directory list."
msgstr "Accessorway orfay ethay athnamepay's irectoryday istlay."

#: src/code/pathname.lisp
msgid "Accessor for the pathname's name."
msgstr "Accessorway orfay ethay athnamepay's amenay."

#: src/code/pathname.lisp
msgid "Accessor for the pathname's version."
msgstr "Accessorway orfay ethay athnamepay's ersionvay."

#: src/code/pathname.lisp
msgid "Parse error in namestring: ~?~%  ~A~%  ~V@T^"
msgstr "Arsepay errorway inway amestringnay: ~?~%  ~Away~%  ~V@T^"

#: src/code/pathname.lisp
msgid ""
"When Host arg is not supplied, Defaults arg must ~\n"
"\t\t  have a non-null PATHNAME-HOST."
msgstr ""
"Enwhay Osthay argway isway otnay uppliedsay, Efaultsday argway ustmay ~\n"
"\t\t  avehay away onnay-ullnay PATHNAME-HOST."

#: src/code/pathname.lisp
msgid ""
"Host in namestring: ~S~@\n"
"\t\t    does not match explicit host argument: ~S"
msgstr ""
"Osthay inway amestringnay: ~S~@\n"
"\t\t    oesday otnay atchmay explicitway osthay argumentway: ~S"

#: src/code/pathname.lisp
msgid ""
"Converts pathname, a pathname designator, into a pathname structure,\n"
"   for a physical pathname, returns the printed representation. Host may be\n"
"   a physical host structure or host namestring."
msgstr ""
"Onvertscay athnamepay, away athnamepay esignatorday, intoway away athnamepay "
"ucturestray,\n"
"   orfay away ysicalphay athnamepay, eturnsray ethay intedpray "
"epresentationray. Osthay aymay ebay\n"
"   away ysicalphay osthay ucturestray orway osthay amestringnay."

#: src/code/pathname.lisp
msgid "Hosts do not match: ~S and ~S."
msgstr "Ostshay oday otnay atchmay: ~S andway ~S."

#: src/code/pathname.lisp
msgid "Can't figure out the file associated with stream:~%  ~S"
msgstr ""
"Ancay't igurefay outway ethay ilefay associatedway ithway eamstray:~%  ~S"

#: src/code/pathname.lisp
msgid ""
"A LIST representing a pathname host is not ~\n"
"                              supported in this implementation:~%  ~S"
msgstr ""
"Away LIST epresentingray away athnamepay osthay isway otnay ~\n"
"                              upportedsay inway isthay implementationway:~%  "
"~S"

#: src/code/pathname.lisp
msgid "Construct the full (name)string form of the pathname."
msgstr ""
"Onstructcay ethay ullfay (amenay)ingstray ormfay ofway ethay athnamepay."

#: src/code/pathname.lisp
msgid ""
"Cannot determine the namestring for pathnames with no ~\n"
"\t\t  host:~%  ~S"
msgstr ""
"Annotcay etermineday ethay amestringnay orfay athnamespay ithway onay ~\n"
"\t\t  osthay:~%  ~S"

#: src/code/pathname.lisp
msgid ""
"Returns a string representation of the name of the host in the pathname."
msgstr ""
"Eturnsray away ingstray epresentationray ofway ethay amenay ofway ethay "
"osthay inway ethay athnamepay."

#: src/code/pathname.lisp
msgid "Cannot determine the namestring for pathnames with no host:~%  ~S"
msgstr ""
"Annotcay etermineday ethay amestringnay orfay athnamespay ithway onay osthay:"
"~%  ~S"

#: src/code/pathname.lisp
msgid ""
"Returns a string representation of the directories used in the pathname."
msgstr ""
"Eturnsray away ingstray epresentationray ofway ethay irectoriesday usedway "
"inway ethay athnamepay."

#: src/code/pathname.lisp
msgid "Returns a string representation of the name used in the pathname."
msgstr ""
"Eturnsray away ingstray epresentationray ofway ethay amenay usedway inway "
"ethay athnamepay."

#: src/code/pathname.lisp
msgid ""
"Returns an abbreviated pathname sufficent to identify the pathname relative\n"
"   to the defaults."
msgstr ""
"Eturnsray anway abbreviatedway athnamepay ufficentsay otay identifyway ethay "
"athnamepay elativeray\n"
"   otay ethay efaultsday."

#: src/code/pathname.lisp
msgid "Predicate for determining whether pathname contains any wildcards."
msgstr ""
"Edicatepray orfay eterminingday etherwhay athnamepay ontainscay anyway "
"ildcardsway."

#: src/code/pathname.lisp
msgid "Pathname matches the wildname template?"
msgstr "Athnamepay atchesmay ethay ildnameway emplatetay?"

#: src/code/pathname.lisp
msgid ""
"Not enough wildcards in FROM pattern to match ~\n"
"\t\t       TO pattern:~%  ~S"
msgstr ""
"Otnay enoughway ildcardsway inway FROM atternpay otay atchmay ~\n"
"\t\t       TO atternpay:~%  ~S"

#: src/code/pathname.lisp
msgid ""
"Can't substitute this into the middle of a word:~\n"
"\t\t\t  ~%  ~S"
msgstr ""
"Ancay't ubstitutesay isthay intoway ethay iddlemay ofway away ordway:~\n"
"\t\t\t  ~%  ~S"

#: src/code/pathname.lisp
msgid ""
"Pathname components from Source and From args to TRANSLATE-PATHNAME~@\n"
"\t  did not match:~%  ~S ~S"
msgstr ""
"Athnamepay omponentscay omfray Ourcesay andway Omfray argsway otay TRANSLATE-"
"PATHNAME~@\n"
"\t  idday otnay atchmay:~%  ~S ~S"

#: src/code/pathname.lisp
msgid ""
":WILD-INFERIORS not paired in from and to ~\n"
"\t\t\t   patterns:~%  ~S ~S"
msgstr ""
":WILD-INFERIORS otnay airedpay inway omfray andway otay ~\n"
"\t\t\t   atternspay:~%  ~S ~S"

#: src/code/pathname.lisp
msgid ""
"Use the source pathname to translate the from-wildname's wild and\n"
"   unspecified elements into a completed to-pathname based on the to-"
"wildname."
msgstr ""
"Useway ethay ourcesay athnamepay otay anslatetray ethay omfray-ildnameway's "
"ildway andway\n"
"   unspecifiedway elementsway intoway away ompletedcay otay-athnamepay "
"asedbay onway ethay otay-ildnamwaye."

#: src/code/pathname.lisp
msgid "~S doesn't match ~S"
msgstr "~S oesnday't atchmay ~S"

#: src/code/pathname.lisp
msgid "Search-list ~a not defined."
msgstr "Earchsay-istlay ~away otnay efinedday."

#: src/code/pathname.lisp
msgid ""
"Clear the current definition for the search-list NAME.  Returns T if such\n"
"   a definition existed, and NIL if not."
msgstr ""
"Earclay ethay urrentcay efinitionday orfay ethay earchsay-istlay NAME.  "
"Eturnsray T ifway uchsay\n"
"   away efinitionday existedway, andway NIL ifway otnay."

#: src/code/pathname.lisp
msgid ""
"Clear the definition for all search-lists.  Only use this if you know\n"
"   what you are doing."
msgstr ""
"Earclay ethay efinitionday orfay allway earchsay-istslay.  Onlyway useway "
"isthay ifway ouyay nowkay\n"
"   atwhay ouyay areway oingday."

#: src/code/pathname.lisp
msgid "~S doesn't start with a search-list."
msgstr "~S oesnday't tartsay ithway away earchsay-istlay."

#: src/code/pathname.lisp
msgid ""
"Return the expansions for the search-list starting PATHNAME.  If PATHNAME\n"
"   does not start with a search-list, then an error is signaled.  If\n"
"   the search-list has not been defined yet, then an error is signaled.\n"
"   The expansion for a search-list can be set with SETF."
msgstr ""
"Eturnray ethay expansionsway orfay ethay earchsay-istlay tartingsay "
"PATHNAME.  Ifway PATHNAME\n"
"   oesday otnay tartsay ithway away earchsay-istlay, enthay anway errorway "
"isway ignaledsay.  Ifway\n"
"   ethay earchsay-istlay ashay otnay eenbay efinedday etyay, enthay anway "
"errorway isway ignaledsay.\n"
"   Ethay expansionway orfay away earchsay-istlay ancay ebay etsay ithway "
"SETF."

#: src/code/pathname.lisp
msgid "Search list ~S has not been defined yet."
msgstr "Earchsay istlay ~S ashay otnay eenbay efinedday etyay."

#: src/code/pathname.lisp
msgid ""
"Returns T if the search-list starting PATHNAME is currently defined, and\n"
"   NIL otherwise.  An error is signaled if PATHNAME does not start with a\n"
"   search-list."
msgstr ""
"Eturnsray T ifway ethay earchsay-istlay tartingsay PATHNAME isway "
"urrentlycay efinedday, andway\n"
"   NIL otherwiseway.  Anway errorway isway ignaledsay ifway PATHNAME oesday "
"otnay tartsay ithway away\n"
"   earchsay-istlay."

#: src/code/pathname.lisp
msgid ""
"That would result in a circularity:~%  ~\n"
"\t\t     ~A~{ -> ~A~} -> ~A"
msgstr ""
"Atthay ouldway esultray inway away ircularitycay:~%  ~\n"
"\t\t     ~Away~{ -> ~Away~} -> ~Away"

#: src/code/pathname.lisp
msgid ""
"Search-lists cannot expand into pathnames that have ~\n"
"\t\t       a name, type, or ~%version specified:~%  ~S"
msgstr ""
"Earchsay-istslay annotcay expandway intoway athnamespay atthay avehay ~\n"
"\t\t       away amenay, ypetay, orway ~%ersionvay ecifiedspay:~%  ~S"

#: src/code/pathname.lisp
msgid ""
"Execute BODY with VAR bound to each successive possible expansion for\n"
"   PATHNAME and then return RESULT.  Note: if PATHNAME does not contain a\n"
"   search-list, then BODY is executed exactly once.  Everything is wrapped\n"
"   in a block named NIL, so RETURN can be used to terminate early.  Note:\n"
"   VAR is *not* bound inside of RESULT."
msgstr ""
"Executeway BODY ithway VAR oundbay otay eachway uccessivesay ossiblepay "
"expansionway orfay\n"
"   PATHNAME andway enthay eturnray RESULT.  Otenay: ifway PATHNAME oesday "
"otnay ontaincay away\n"
"   earchsay-istlay, enthay BODY isway executedway exactlyway onceway.  "
"Everythingway isway appedwray\n"
"   inway away ockblay amednay NIL, osay RETURN ancay ebay usedway otay "
"erminatetay earlyway.  Otenay:\n"
"   VAR isway *not* oundbay insideway ofway RESULT."

#: src/code/pathname.lisp
msgid "Undefined search list: ~A"
msgstr "Undefinedway earchsay istlay: ~Away"

#: src/code/pathname.lisp
msgid ""
"Logical namestring character ~\n"
"\t\t\t     is not alphanumeric or hyphen:~%  ~S"
msgstr ""
"Ogicallay amestringnay aracterchay ~\n"
"\t\t\t     isway otnay alphanumericway orway yphenhay:~%  ~S"

#: src/code/pathname.lisp
msgid "Logical host not yet defined: ~S"
msgstr "Ogicallay osthay otnay etyay efinedday: ~S"

#: src/code/pathname.lisp
msgid ""
"Double asterisk inside of logical ~\n"
"\t\t\t\t     word: ~S"
msgstr ""
"Oubleday asteriskway insideway ofway ogicallay ~\n"
"\t\t\t\t     ordway: ~S"

#: src/code/pathname.lisp
msgid "Illegal character for logical pathname:~%  ~S"
msgstr "Illegalway aracterchay orfay ogicallay athnamepay:~%  ~S"

#: src/code/pathname.lisp
msgid "a host name"
msgstr "away osthay amenay"

#: src/code/pathname.lisp
msgid "a directory name"
msgstr "away irectoryday amenay"

#: src/code/pathname.lisp
msgid "a file name"
msgstr "away ilefay amenay"

#: src/code/pathname.lisp
msgid "Expecting a dot, got ~S."
msgstr "Expectingway away otday, otgay ~S."

#: src/code/pathname.lisp
msgid "a file type"
msgstr "away ilefay ypetay"

#: src/code/pathname.lisp
msgid "a positive integer, * or NEWEST"
msgstr "away ositivepay integerway, * orway NEWEST"

#: src/code/pathname.lisp
msgid "Expecting ~A, got ~:[nothing~;~:*~S~]."
msgstr "Expectingway ~Away, otgay ~:[othingnay~;~:*~S~]."

#: src/code/pathname.lisp
msgid ""
"Expected a positive integer, ~\n"
"\t\t\t\t\t    got ~S"
msgstr ""
"Expectedway away ositivepay integerway, ~\n"
"\t\t\t\t\t    otgay ~S"

#: src/code/pathname.lisp
msgid "Extra stuff after end of file name."
msgstr "Extraway tuffsay afterway endway ofway ilefay amenay."

#: src/code/pathname.lisp
msgid "Converts the pathspec argument to a logical-pathname and returns it."
msgstr ""
"Onvertscay ethay athspecpay argumentway otay away ogicallay-athnamepay "
"andway eturnsray itway."

#: src/code/pathname.lisp
msgid "Logical namestring does not specify a host:~%  ~S"
msgstr "Ogicallay amestringnay oesday otnay ecifyspay away osthay:~%  ~S"

#: src/code/filesys.lisp src/code/pathname.lisp
msgid "Invalid directory component: ~S"
msgstr "Invalidway irectoryday omponentcay: ~S"

#: src/code/pathname.lisp
msgid "Invalid keyword: ~S"
msgstr "Invalidway eywordkay: ~S"

#: src/code/pathname.lisp
msgid "Logical pathname translation is not a two-list:~%  ~S"
msgstr ""
"Ogicallay athnamepay anslationtray isway otnay away wotay-istlay:~%  ~S"

#: src/code/pathname.lisp
msgid "Return the (logical) host object argument's list of translations."
msgstr ""
"Eturnray ethay (ogicallay) osthay objectway argumentway's istlay ofway "
"anslationstray."

#: src/code/pathname.lisp
msgid ""
"Set the translations list for the logical host argument.\n"
"   Return translations."
msgstr ""
"Etsay ethay anslationstray istlay orfay ethay ogicallay osthay argumentway.\n"
"   Eturnray anslationstray."

#: src/code/pathname.lisp
msgid "Clobber search-list host with logical pathname host"
msgstr "Obberclay earchsay-istlay osthay ithway ogicallay athnamepay osthay"

#: src/code/pathname.lisp
msgid "~S names a CMUCL search-list"
msgstr "~S amesnay away CMUCL earchsay-istlay"

#: src/code/pathname.lisp
msgid ""
"Search for a logical pathname named host, if not already defined. If "
"already\n"
"   defined no attempt to find or load a definition is attempted and NIL is\n"
"   returned. If host is not already defined, but definition is found and "
"loaded\n"
"   successfully, T is returned, else error."
msgstr ""
"Earchsay orfay away ogicallay athnamepay amednay osthay, ifway otnay "
"alreadyway efinedday. Ifway alreadyway\n"
"   efinedday onay attemptway otay indfay orway oadlay away efinitionday "
"isway attemptedway andway NIL isway\n"
"   eturnedray. Ifway osthay isway otnay alreadyway efinedday, utbay "
"efinitionday isway oundfay andway oadedlay\n"
"   uccessfullysay, T isway eturnedray, elseway errorway."

#: src/code/pathname.lisp
msgid ";; Loading pathname translations from ~A~%"
msgstr ";; Oadinglay athnamepay anslationstray omfray ~Away~%"

#: src/code/pathname.lisp
msgid "Translates pathname to a physical pathname, which is returned."
msgstr ""
"Anslatestray athnamepay otay away ysicalphay athnamepay, ichwhay isway "
"eturnedray."

#: src/code/pathname.lisp
msgid "No translation for ~S"
msgstr "Onay anslationtray orfay ~S"

#: src/code/filesys.lisp
msgid ""
"Remove any occurrences of \\ from the string because we've already\n"
"   checked for whatever may have been backslashed."
msgstr ""
"Emoveray anyway occurrencesway ofway \\ omfray ethay ingstray ecausebay "
"eway'evay alreadyway\n"
"   eckedchay orfay ateverwhay aymay avehay eenbay ackslashedbay."

#: src/code/filesys.lisp
msgid "Backslash in bad place."
msgstr "Ackslashbay inway adbay aceplay."

#: src/code/filesys.lisp
msgid ""
"If non-NIL, Unix shell-style wildcards are ignored when parsing\n"
"  pathname namestrings.  They are also ignored when computing\n"
"  namestrings for pathname objects.  Thus, *, ?, etc. are not\n"
"  wildcards when parsing a namestring, and are not escaped when\n"
"  printing pathnames."
msgstr ""
"Ifway onnay-NIL, Unixway ellshay-tylesay ildcardsway areway ignoredway "
"enwhay arsingpay\n"
"  athnamepay amestringsnay.  Eythay areway alsoway ignoredway enwhay "
"omputingcay\n"
"  amestringsnay orfay athnamepay objectsway.  Usthay, *, ?, etcway. areway "
"otnay\n"
"  ildcardsway enwhay arsingpay away amestringnay, andway areway otnay "
"escapedway enwhay\n"
"  intingpray athnamespay."

#: src/code/filesys.lisp
msgid "``['' with no corresponding ``]''"
msgstr "``['' ithway onay orrespondingcay ``]''"

#: src/code/filesys.lisp
msgid "~A already names a logical host"
msgstr "~Away alreadyway amesnay away ogicallay osthay"

#: src/code/filesys.lisp
msgid "Invalid pattern piece: ~S"
msgstr "Invalidway atternpay iecepay: ~S"

#: src/code/filesys.lisp
msgid ":BACK cannot be represented in namestrings."
msgstr ":BACK annotcay ebay epresentedray inway amestringsnay."

#: src/code/filesys.lisp
msgid "Cannot represent \"\" in namestrings."
msgstr "Annotcay epresentray \"\" inway amestringsnay."

#: src/code/filesys.lisp
msgid "Cannot represent an explicit directory separator in namestrings."
msgstr ""
"Annotcay epresentray anway explicitway irectoryday eparatorsay inway "
"amestringsnay."

#: src/code/filesys.lisp
msgid "Cannot specify a directory separator in a pathname name: ~S"
msgstr ""
"Annotcay ecifyspay away irectoryday eparatorsay inway away athnamepay "
"amenay: ~S"

#: src/code/filesys.lisp
msgid "Cannot specify a dot in a pathname name without a pathname type: ~S"
msgstr ""
"Annotcay ecifyspay away otday inway away athnamepay amenay ithoutway away "
"athnamepay ypetay: ~S"

#: src/code/filesys.lisp
msgid "Invalid value for a pathname name: ~S"
msgstr "Invalidway aluevay orfay away athnamepay amenay: ~S"

#: src/code/filesys.lisp
msgid "Cannot specify the type without a file: ~S"
msgstr "Annotcay ecifyspay ethay ypetay ithoutway away ilefay: ~S"

#: src/code/filesys.lisp
msgid "Cannot specify a directory separator in a pathname type: ~S"
msgstr ""
"Annotcay ecifyspay away irectoryday eparatorsay inway away athnamepay "
"ypetay: ~S"

#: src/code/filesys.lisp
msgid "Cannot specify a dot in a pathname type: ~S"
msgstr "Annotcay ecifyspay away otday inway away athnamepay ypetay: ~S"

#: src/code/filesys.lisp
msgid "Cannot specify a version without a file: ~S"
msgstr "Annotcay ecifyspay away ersionvay ithoutway away ilefay: ~S"

#: src/code/filesys.lisp
msgid "~S cannot be represented relative to ~S"
msgstr "~S annotcay ebay epresentedray elativeray otay ~S"

#: src/code/filesys.lisp
msgid "Cannot supply a type without a name:~%  ~S"
msgstr "Annotcay upplysay away ypetay ithoutway away amenay:~%  ~S"

#: src/code/filesys.lisp
msgid ""
"Convert PATHNAME into a string that can be used with UNIX system calls.\n"
"   Search-lists and wild-cards are expanded. If optional argument\n"
"   FOR-INPUT is true and PATHNAME doesn't exist, NIL is returned.\n"
"   If optional argument EXECUTABLE-ONLY is true, NIL is returned\n"
"   unless an executable version of PATHNAME exists."
msgstr ""
"Onvertcay PATHNAME intoway away ingstray atthay ancay ebay usedway ithway "
"UNIX ystemsay allscay.\n"
"   Earchsay-istslay andway ildway-ardscay areway expandedway. Ifway "
"optionalway argumentway\n"
"   FOR-INPUT isway uetray andway PATHNAME oesnday't existway, NIL isway "
"eturnedray.\n"
"   Ifway optionalway argumentway EXECUTABLE-ONLY isway uetray, NIL isway "
"eturnedray\n"
"   unlessway anway executableway ersionvay ofway PATHNAME existsway."

#: src/code/filesys.lisp
msgid "~S is ambiguous:~{~%  ~A~}"
msgstr "~S isway ambiguousway:~{~%  ~Away~}"

#: src/code/filesys.lisp
msgid ""
"Return the pathname for the actual file described by the pathname\n"
"  An error of type file-error is signalled if no such file exists,\n"
"  or the pathname is wild."
msgstr ""
"Eturnray ethay athnamepay orfay ethay actualway ilefay escribedday ybay "
"ethay athnamepay\n"
"  Anway errorway ofway ypetay ilefay-errorway isway ignalledsay ifway onay "
"uchsay ilefay existsway,\n"
"  orway ethay athnamepay isway ildway."

#: src/code/filesys.lisp
msgid "Bad place for a wild pathname."
msgstr "Adbay aceplay orfay away ildway athnamepay."

#: src/code/filesys.lisp
msgid "The file ~S does not exist."
msgstr "Ethay ilefay ~S oesday otnay existway."

#: src/code/filesys.lisp
msgid ""
"Return a pathname which is the truename of the file if it exists, NIL\n"
"  otherwise. An error of type file-error is signalled if pathname is wild."
msgstr ""
"Eturnray away athnamepay ichwhay isway ethay uenametray ofway ethay ilefay "
"ifway itway existsway, NIL\n"
"  otherwiseway. Anway errorway ofway ypetay ilefay-errorway isway "
"ignalledsay ifway athnamepay isway ildway."

#: src/code/filesys.lisp
msgid ""
"Rename File to have the specified New-Name.  If file is a stream\n"
"  open to a file, then the associated file is renamed.\n"
"\n"
"  Three values are returned if successful: the defaulted new name\n"
"  composed of New-Name with missing components filled in from File;\n"
"  the truename of File before it was renamed; the new truename of the\n"
"  File after it was renamed."
msgstr ""
"Enameray Ilefay otay avehay ethay ecifiedspay Ewnay-Amenay.  Ifway ilefay "
"isway away eamstray\n"
"  openway otay away ilefay, enthay ethay associatedway ilefay isway "
"enamedray.\n"
"\n"
"  Reethay aluesvay areway eturnedray ifway uccessfulsay: ethay efaultedday "
"ewnay amenay\n"
"  omposedcay ofway Ewnay-Amenay ithway issingmay omponentscay illedfay inway "
"omfray Ilefay;\n"
"  ethay uenametray ofway Ilefay eforebay itway asway enamedray; ethay ewnay "
"uenametray ofway ethay\n"
"  Ilefay afterway itway asway enamedray."

#: src/code/filesys.lisp
msgid "~S can't be created."
msgstr "~S ancay't ebay eatedcray."

#: src/code/filesys.lisp
msgid "Failed to rename ~A to ~A: ~A"
msgstr "Ailedfay otay enameray ~Away otay ~Away: ~Away"

#: src/code/filesys.lisp
msgid "Delete the specified file."
msgstr "Eleteday ethay ecifiedspay ilefay."

#: src/code/filesys.lisp
msgid "~S doesn't exist."
msgstr "~S oesnday't existway."

#: src/code/filesys.lisp
msgid "Could not delete ~A: ~A."
msgstr "Ouldcay otnay eleteday ~Away: ~Away."

#: src/code/filesys.lisp
msgid ""
"Delete old versions of files matching the given Pathname,\n"
"optionally keeping some of the most recent old versions."
msgstr ""
"Eleteday oldway ersionsvay ofway ilesfay atchingmay ethay ivengay "
"Athnamepay,\n"
"optionallyway eepingkay omesay ofway ethay ostmay ecentray oldway ersionsvay."

#: src/code/filesys.lisp
msgid ""
"Returns the home directory of the logged in user as a pathname.\n"
"  This is obtained from the logical name \"home:\"."
msgstr ""
"Eturnsray ethay omehay irectoryday ofway ethay oggedlay inway userway asway "
"away athnamepay.\n"
"  Isthay isway obtainedway omfray ethay ogicallay amenay \"omehay:\"."

#: src/code/filesys.lisp
msgid ""
"Return file's creation date, or NIL if it doesn't exist.\n"
" An error of type file-error is signalled if file is a wild pathname"
msgstr ""
"Eturnray ilefay's eationcray ateday, orway NIL ifway itway oesnday't "
"existway.\n"
" Anway errorway ofway ypetay ilefay-errorway isway ignalledsay ifway ilefay "
"isway away ildway athnamepay"

#: src/code/filesys.lisp
msgid ""
"Returns the file author as a string, or nil if the author cannot be\n"
" determined.  Signals an error of type file-error if file doesn't exist,\n"
" or file is a wild pathname."
msgstr ""
"Eturnsray ethay ilefay authorway asway away ingstray, orway ilnay ifway "
"ethay authorway annotcay ebay\n"
" eterminedday.  Ignalssay anway errorway ofway ypetay ilefay-errorway ifway "
"ilefay oesnday't existway,\n"
" orway ilefay isway away ildway athnamepay."

#: src/code/filesys.lisp
msgid ""
"Returns a list of pathnames, one for each file that matches the given\n"
"   pathname.  Supplying :ALL as nil causes this to ignore Unix dot files.  "
"This\n"
"   never includes Unix dot and dot-dot in the result.  If :TRUENAMEP is "
"NIL,\n"
"   then symbolic links in the result are not expanded, which is not the\n"
"   default because TRUENAME does follow links and the result pathnames are\n"
"   defined to be the TRUENAME of the pathname (the truename of a link may "
"well\n"
"   be in another directory).  If FOLLOW-LINKS is NIL then symbolic links "
"are\n"
"   not followed."
msgstr ""
"Eturnsray away istlay ofway athnamespay, oneway orfay eachway ilefay atthay "
"atchesmay ethay ivengay\n"
"   athnamepay.  Upplyingsay :ALL asway ilnay ausescay isthay otay ignoreway "
"Unixway otday ilesfay.  Isthay\n"
"   evernay includesway Unixway otday andway otday-otday inway ethay "
"esultray.  Ifway :TRUENAMEP isway NIL,\n"
"   enthay ymbolicsay inkslay inway ethay esultray areway otnay expandedway, "
"ichwhay isway otnay ethay\n"
"   efaultday ecausebay TRUENAME oesday ollowfay inkslay andway ethay "
"esultray athnamespay areway\n"
"   efinedday otay ebay ethay TRUENAME ofway ethay athnamepay (ethay "
"uenametray ofway away inklay aymay ellway\n"
"   ebay inway anotherway irectoryday).  Ifway FOLLOW-LINKS isway NIL enthay "
"ymbolicsay inkslay areway\n"
"   otnay ollowedfay."

#: src/code/filesys.lisp
msgid ""
"Like Directory, but prints a terse, multi-column directory listing\n"
"   instead of returning a list of pathnames.  When :all is supplied and\n"
"   non-nil, then Unix dot files are included too (as ls -a).  When :verbose\n"
"   is supplied and non-nil, then a long listing of miscellaneous\n"
"   information is output one file per line."
msgstr ""
"Ikelay Irectoryday, utbay intspray away ersetay, ultimay-olumncay "
"irectoryday istinglay\n"
"   insteadway ofway eturningray away istlay ofway athnamespay.  Enwhay :"
"allway isway uppliedsay andway\n"
"   onnay-ilnay, enthay Unixway otday ilesfay areway includedway ootay (asway "
"slay -away).  Enwhay :erbosevay\n"
"   isway uppliedsay andway onnay-ilnay, enthay away onglay istinglay ofway "
"iscellaneousmay\n"
"   informationway isway outputway oneway ilefay erpay inelay."

#: src/code/filesys.lisp
msgid "Directory of ~A:~%"
msgstr "Irectoryday ofway ~Away:~%"

#: src/code/filesys.lisp
msgid "Couldn't stat ~A -- ~A.~%"
msgstr "Ouldncay't tatsay ~Away -- ~Away.~%"

#: src/code/filesys.lisp
msgid ""
"Return a list of all files which are possible completions of Pathname.\n"
"   We look in the directory specified by Defaults as well as looking down\n"
"   the search list."
msgstr ""
"Eturnray away istlay ofway allway ilesfay ichwhay areway ossiblepay "
"ompletionscay ofway Athnamepay.\n"
"   Eway ooklay inway ethay irectoryday ecifiedspay ybay Efaultsday asway "
"ellway asway ookinglay ownday\n"
"   ethay earchsay istlay."

#: src/code/filesys.lisp
msgid ""
"File-writable accepts a pathname and returns T if the current\n"
"  process can write it, and NIL otherwise."
msgstr ""
"Ilefay-itablewray acceptsway away athnamepay andway eturnsray T ifway ethay "
"urrentcay\n"
"  ocesspray ancay itewray itway, andway NIL otherwiseway."

#: src/code/filesys.lisp
msgid ""
"Returns the pathname for the default directory.  This is the place where\n"
"  a file will be written if no directory is specified.  This may be changed\n"
"  with setf."
msgstr ""
"Eturnsray ethay athnamepay orfay ethay efaultday irectoryday.  Isthay isway "
"ethay aceplay erewhay\n"
"  away ilefay illway ebay ittenwray ifway onay irectoryday isway "
"ecifiedspay.  Isthay aymay ebay angedchay\n"
"  ithway etfsay."

#: src/code/filesys.lisp
msgid ""
"Tests whether the directories containing the specified file\n"
"  actually exist, and attempts to create them if they do not.\n"
"  Portable programs should avoid using the :MODE keyword argument."
msgstr ""
"Eststay etherwhay ethay irectoriesday ontainingcay ethay ecifiedspay ilefay\n"
"  actuallyway existway, andway attemptsway otay eatecray emthay ifway eythay "
"oday otnay.\n"
"  Ortablepay ogramspray ouldshay avoidway usingway ethay :MODE eywordkay "
"argumentway."

#: src/code/filesys.lisp
msgid "~&Creating directory: ~A~%"
msgstr "~&Eatingcray irectoryday: ~Away~%"

#: src/code/filesys.lisp
msgid "Can't create directory ~A."
msgstr "Ancay't eatecray irectoryday ~Away."

#: src/code/load.lisp
msgid "The default for the :IF-SOURCE-NEWER argument to load."
msgstr "Ethay efaultday orfay ethay :IF-SOURCE-NEWER argumentway otay oadlay."

#: src/code/load.lisp
msgid "The source file types which LOAD recognizes."
msgstr "Ethay ourcesay ilefay ypestay ichwhay LOAD ecognizesray."

#: src/code/load.lisp
msgid "A list of the object file types recognized by LOAD."
msgstr ""
"Away istlay ofway ethay objectway ilefay ypestay ecognizedray ybay LOAD."

#: src/code/load.lisp
msgid ""
"A list of the object file types recognized by LOAD for logical pathnames."
msgstr ""
"Away istlay ofway ethay objectway ilefay ypestay ecognizedray ybay LOAD "
"orfay ogicallay athnamespay."

#: src/code/load.lisp
msgid "The default for the :VERBOSE argument to Load."
msgstr "Ethay efaultday orfay ethay :VERBOSE argumentway otay Oadlay."

#: src/code/load.lisp
msgid "The default for the :PRINT argument to Load."
msgstr "Ethay efaultday orfay ethay :PRINT argumentway otay Oadlay."

#: src/code/load.lisp
msgid "The TRUENAME of the file that LOAD is currently loading."
msgstr ""
"Ethay TRUENAME ofway ethay ilefay atthay LOAD isway urrentlycay oadinglay."

#: src/code/load.lisp
msgid "The defaulted pathname that LOAD is currently loading."
msgstr "Ethay efaultedday athnamepay atthay LOAD isway urrentlycay oadinglay."

#: src/code/load.lisp
msgid "Count of the number of recursive loads."
msgstr "Ountcay ofway ethay umbernay ofway ecursiveray oadslay."

#: src/code/load.lisp
msgid ""
"~A was compiled for fasl-file version ~X, ~\n"
"                     but this is version ~X"
msgstr ""
"~Away asway ompiledcay orfay aslfay-ilefay ersionvay ~X, ~\n"
"                     utbay isthay isway ersionvay ~X"

#: src/code/load.lisp
msgid "List of free fop tables for the fasloader."
msgstr "Istlay ofway eefray opfay ablestay orfay ethay asloaderfay."

#: src/code/load.lisp
msgid "The fop stack (we only need one!)."
msgstr "Ethay opfay tacksay (eway onlyway eednay oneway!)."

#: src/code/load.lisp
msgid "Vector indexed by a FaslOP that yields the FOP's name."
msgstr ""
"Ectorvay indexedway ybay away Aslopfay atthay ieldsyay ethay FOP's amenay."

#: src/code/load.lisp
msgid ""
"Vector indexed by a FaslOP that yields a function of 0 arguments which\n"
"  will perform the operation."
msgstr ""
"Ectorvay indexedway ybay away Aslopfay atthay ieldsyay away unctionfay ofway "
"0 argumentsway ichwhay\n"
"  illway erformpay ethay operationway."

#: src/code/load.lisp
msgid "Losing FOP!"
msgstr "Osinglay FOP!"

#: src/code/load.lisp
msgid "Loading ~S.~%"
msgstr "Oadinglay ~S.~%"

#: src/code/load.lisp
msgid "Loading stuff from ~S.~%"
msgstr "Oadinglay tuffsay omfray ~S.~%"

#: src/code/load.lisp
msgid "Attempt to load an empty FASL FILE:~%  ~S"
msgstr "Attemptway otay oadlay anway emptyway FASL FILE:~%  ~S"

#: src/code/load.lisp
msgid "Bad FASL file format."
msgstr "Adbay FASL ilefay ormatfay."

#: src/code/load.lisp
msgid ""
"Loads the file named by Filename into the Lisp environment.  The file type\n"
"   (a.k.a extension) is defaulted if missing.  These options are defined:\n"
"\n"
"   :IF-SOURCE-NEWER <keyword>\n"
"\tIf the file type is not specified, and both source and object files\n"
"        exist, then this argument controls which is loaded:\n"
"\t    :LOAD-OBJECT - load object file (default),\n"
"\t    :LOAD-SOURCE - load the source file,\n"
"\t    :COMPILE - compile the source and then load the object file, or\n"
"\t    :QUERY - ask the user which to load.\n"
"\n"
"   :IF-DOES-NOT-EXIST {:ERROR | NIL}\n"
"       If :ERROR (the default), signal an error if the file can't be "
"located.\n"
"       If NIL, simply return NIL (LOAD normally returns T.)\n"
"\n"
"   :VERBOSE {T | NIL}\n"
"       If true (the default), print a line describing each file loaded.\n"
"\n"
"   :PRINT {T | NIL}\n"
"       If true, print information about loaded values.  When loading the\n"
"       source, the result of evaluating each top-level form is printed.\n"
"\n"
"   :CONTENTS {NIL | :SOURCE | :BINARY}\n"
"       Forces the input to be interpreted as a source or object file, "
"instead\n"
"       of guessing based on the file type.  This also inhibits file type\n"
"       defaulting.  Probably only necessary if you have source files with a\n"
"       \"fasl\" type. \n"
"\n"
"   :EXTERNAL-FORMAT\n"
"       The external-format to use when opening the FILENAME. The default is\n"
"       :default which uses the EXT:*DEFAULT-EXTERNAL-FORMAT*.\n"
"\n"
"   The variables *LOAD-VERBOSE*, *LOAD-PRINT* and EXT:*LOAD-IF-SOURCE-"
"NEWER*\n"
"   determine the defaults for the corresponding keyword arguments.  These\n"
"   variables are also bound to the specified argument values, so specifying "
"a\n"
"   keyword affects nested loads.  The variables EXT:*LOAD-SOURCE-TYPES*,\n"
"   EXT:*LOAD-OBJECT-TYPES*, and EXT:*LOAD-LP-OBJECT-TYPES* determine the "
"file\n"
"   types that we use for defaulting when none is specified."
msgstr ""
"Oadslay ethay ilefay amednay ybay Ilenamefay intoway ethay Isplay "
"environmentway.  Ethay ilefay ypetay\n"
"   (away.k.away extensionway) isway efaultedday ifway issingmay.  Esethay "
"optionsway areway efinedday:\n"
"\n"
"   :IF-SOURCE-NEWER <eywordkay>\n"
"\tIfway ethay ilefay ypetay isway otnay ecifiedspay, andway othbay ourcesay "
"andway objectway ilesfay\n"
"        existway, enthay isthay argumentway ontrolscay ichwhay isway "
"oadedlay:\n"
"\t    :LOAD-OBJECT - oadlay objectway ilefay (efaultday),\n"
"\t    :LOAD-SOURCE - oadlay ethay ourcesay ilefay,\n"
"\t    :COMPILE - ompilecay ethay ourcesay andway enthay oadlay ethay "
"objectway ilefay, orway\n"
"\t    :QUERY - askway ethay userway ichwhay otay oadlay.\n"
"\n"
"   :IF-DOES-NOT-EXIST {:ERROR | NIL}\n"
"       Ifway :ERROR (ethay efaultday), ignalsay anway errorway ifway ethay "
"ilefay ancay't ebay ocatedlay.\n"
"       Ifway NIL, implysay eturnray NIL (LOAD ormallynay eturnsray T.)\n"
"\n"
"   :VERBOSE {T | NIL}\n"
"       Ifway uetray (ethay efaultday), intpray away inelay escribingday "
"eachway ilefay oadedlay.\n"
"\n"
"   :PRINT {T | NIL}\n"
"       Ifway uetray, intpray informationway aboutway oadedlay aluesvay.  "
"Enwhay oadinglay ethay\n"
"       ourcesay, ethay esultray ofway evaluatingway eachway optay-evellay "
"ormfay isway intedpray.\n"
"\n"
"   :CONTENTS {NIL | :SOURCE | :BINARY}\n"
"       Orcesfay ethay inputway otay ebay interpretedway asway away ourcesay "
"orway objectway ilefay, insteadway\n"
"       ofway uessinggay asedbay onway ethay ilefay ypetay.  Isthay alsoway "
"inhibitsway ilefay ypetay\n"
"       efaultingday.  Obablypray onlyway ecessarynay ifway ouyay avehay "
"ourcesay ilesfay ithway away\n"
"       \"aslfay\" ypetay. \n"
"\n"
"   :EXTERNAL-FORMAT\n"
"       Ethay externalway-ormatfay otay useway enwhay openingway ethay "
"FILENAME. Ethay efaultday isway\n"
"       :efaultday ichwhay usesway ethay EXT:*DEFAULT-EXTERNAL-FORMAT*.\n"
"\n"
"   Ethay ariablesvay *LOAD-VERBOSE*, *LOAD-PRINT* andway EXT:load-if-source-"
"newer*ay*\n"
"   etermineday ethay efaultsday orfay ethay orrespondingcay eywordkay "
"argumentsway.  Esethay\n"
"   ariablesvay areway alsoway oundbay otay ethay ecifiedspay argumentway "
"aluesvay, osay ecifyingspay away\n"
"   eywordkay affectsway estednay oadslay.  Ethay ariablesvay EXT:*LOAD-"
"SOURCE-TYPES*,\n"
"   EXT:*LOAD-OBJECT-TYPES*, andway EXT:*LOAD-LP-OBJECT-TYPES* etermineday "
"ethay ilefay\n"
"   ypestay atthay eway useway orfay efaultingday enwhay onenay isway "
"ecifiedspay."

#: src/code/load.lisp
msgid "Return NIL from load of ~S."
msgstr "Eturnray NIL omfray oadlay ofway ~S."

#: src/code/load.lisp
msgid "~S does not exist."
msgstr "~S oesday otnay existway."

#: src/code/load.lisp
msgid "See if it exists now."
msgstr "Eesay ifway itway existsway ownay."

#: src/code/load.lisp
msgid "Prompt for a new name."
msgstr "Omptpray orfay away ewnay amenay."

#: src/code/load.lisp
msgid "New name: "
msgstr "Ewnay amenay: "

#: src/code/load.lisp
msgid "Load it as a source file."
msgstr "Oadlay itway asway away ourcesay ilefay."

#: src/code/load.lisp
msgid "File has a fasl file type, but no fasl file header:~%  ~S"
msgstr ""
"Ilefay ashay away aslfay ilefay ypetay, utbay onay aslfay ilefay eaderhay:"
"~%  ~S"

#: src/code/load.lisp
msgid ""
"Loading object file ~A,~@\n"
"\t\t  which is older than the presumed source:~%  ~A."
msgstr ""
"Oadinglay objectway ilefay ~Away,~@\n"
"\t\t  ichwhay isway olderway anthay ethay esumedpray ourcesay:~%  ~Away."

#: src/code/load.lisp
msgid ""
"Loading source file ~A,~@\n"
"\t\t  which is newer than the presumed object file:~%  ~A."
msgstr ""
"Oadinglay ourcesay ilefay ~Away,~@\n"
"\t\t  ichwhay isway ewernay anthay ethay esumedpray objectway ilefay:~%  "
"~Away."

#: src/code/load.lisp
msgid "Compile of source failed, cannot load object."
msgstr "Ompilecay ofway ourcesay ailedfay, annotcay oadlay objectway."

#: src/code/load.lisp
msgid ""
"Object file ~A is~@\n"
"\t\t       older than the presumed source:~%  ~A."
msgstr ""
"Objectway ilefay ~Away isway~@\n"
"\t\t       olderway anthay ethay esumedpray ourcesay:~%  ~Away."

#: src/code/load.lisp
msgid "load source file"
msgstr "oadlay ourcesay ilefay"

#: src/code/load.lisp
msgid "load object file"
msgstr "oadlay objectway ilefay"

#: src/code/load.lisp
msgid "Fop-End-Header was executed???"
msgstr "Opfay-Endway-Eaderhay asway executedway???"

#: src/code/load.lisp
msgid "Fasl table of improper size.  Bug!"
msgstr "Aslfay abletay ofway improperway izesay.  Ugbay!"

#: src/code/load.lisp
msgid "Fasl stack not empty.  Bug!"
msgstr "Aslfay tacksay otnay emptyway.  Ugbay!"

#: src/code/load.lisp
msgid "The package ~S does not exist."
msgstr "Ethay ackagepay ~S oesday otnay existway."

#: src/code/load.lisp
msgid "Losing i-vector element size: ~S"
msgstr "Osinglay i-ectorvay elementway izesay: ~S"

#: src/code/load.lisp
msgid "Load ~A anyway"
msgstr "Oadlay ~Away anywayway"

#: src/code/load.lisp
msgid "~A was compiled for a ~A, but this is a ~A"
msgstr "~Away asway ompiledcay orfay away ~Away, utbay isthay isway away ~Away"

#: src/compiler/generic/core.lisp src/code/load.lisp
msgid "Unaligned function object, offset = #x~X."
msgstr "Unalignedway unctionfay objectway, offsetway = #x~X."

#: src/code/load.lisp
msgid "~S defined~%"
msgstr "~S efinedday~%"

#: src/code/load.lisp
msgid "Cannot load assembler code."
msgstr "Annotcay oadlay assemblerway odecay."

#: src/compiler/generic/core.lisp src/code/load.lisp
msgid "Undefined assembler routine: ~S"
msgstr "Undefinedway assemblerway outineray: ~S"

#: src/code/foreign-linkage.lisp
msgid "~A is not defined as a foreign symbol"
msgstr "~Away isway otnay efinedday asway away oreignfay ymbolsay"

#: src/code/module.lisp
msgid ""
"This is a list of module names that have been loaded into Lisp so far.\n"
"   It is used by PROVIDE and REQUIRE."
msgstr ""
"Isthay isway away istlay ofway odulemay amesnay atthay avehay eenbay "
"oadedlay intoway Isplay osay arfay.\n"
"   Itway isway usedway ybay PROVIDE andway REQUIRE."

#: src/code/module.lisp
msgid "*load-verbose* is bound to this before loading files."
msgstr "*load-verbose* isway oundbay otay isthay eforebay oadinglay ilesfay."

#: src/code/module.lisp
msgid ""
"Provider functions for cmucl modules and libraries.  These are\n"
"  searched first before trying *module-provider-functions*"
msgstr ""

#: src/code/module.lisp
msgid "See function documentation for REQUIRE"
msgstr "Eesay unctionfay ocumentationday orfay REQUIRE"

#: src/code/module.lisp
msgid ""
"Defines a module by registering the files that need to be loaded when\n"
"   the module is required.  If name is a symbol, its print name is used\n"
"   after downcasing it."
msgstr ""
"Efinesday away odulemay ybay egisteringray ethay ilesfay atthay eednay otay "
"ebay oadedlay enwhay\n"
"   ethay odulemay isway equiredray.  Ifway amenay isway away ymbolsay, "
"itsway intpray amenay isway usedway\n"
"   afterway owncasingday itway."

#: src/code/module.lisp
msgid ""
"Adds a new module name to *modules* indicating that it has been\n"
"  loaded.  Module-name may be any valid string designator.  All\n"
"  comparisons are done using string=, i.e. module names are\n"
"  case-sensitive."
msgstr ""
"Addsway away ewnay odulemay amenay otay *modules* indicatingway atthay itway "
"ashay eenbay\n"
"  oadedlay.  Odulemay-amenay aymay ebay anyway alidvay ingstray "
"esignatorday.  Allway\n"
"  omparisonscay areway oneday usingway ingstray=, i.e. odulemay amesnay "
"areway\n"
"  asecay-ensitivesay."

#: src/code/module.lisp
#, fuzzy
msgid ""
"Loads a module when it has not been already.  Pathname, if\n"
"  supplied, is a single pathname or list of pathnames to be loaded if\n"
"  the module needs to be.  If pathname is not supplied, then functions\n"
"  from the list *MODULE-PROVIDER-FUNCTIONS* are called in order with\n"
"  the stringified MODULE-NAME as the argument, until one of them\n"
"  returns non-NIL.  By default the functions\n"
"  MODULE-PROVIDE-CMUCL-DEFMODULE and MODULE-PROVIDE- CMUCL-LIBRARY are\n"
"  on this list of functions, in that order.  The first of those looks\n"
"  for a list of files that was registered by a EXT:DEFMODULE form.  If\n"
"  the module has not been defined, then the second function causes a\n"
"  file to be loaded whose name is formed by merging \"modules:\" and\n"
"  the concatenation of module-name with the suffix \"-LIBRARY\".  Note\n"
"  that both the module-name and the suffix are each, separately,\n"
"  converted from :case :common to :case :local.  This merged name will\n"
"  be probed with both a .lisp and .fasl extensions, calling LOAD if it\n"
"  exists.\n"
"\n"
"  Note that in all cases covered above, user code is responsible for\n"
"  calling PROVIDE to indicate a successful load of the module.\n"
"\n"
"  While loading any files, *load-verbose* is bound to *require-verbose*\n"
"  which defaults to t.\n"
"\n"
"  The predefined modules included are :defsystem, :asdf, :lisp-unit,\n"
"  :unix, :clx, :clm, :hemlock, and :cmu-contribs.\n"
"\n"
"  The module :cmu-contribs differs from the other modules in that\n"
"  requiring this module only defines the following modules:\n"
"  \"contrib-demos\", \"contrib-follow-mouse\",\n"
"  \"contrib-games-feebs\", \"contrib-hist\", \"contrib-psgraph\",\n"
"  \"contrib-ops\", \"contrib-embedded-c\", \"contrib-sprof\", and\n"
"  \"contrib-packed-sse2\". "
msgstr ""
"Oadslay away odulemay enwhay itway ashay otnay eenbay alreadyway.  "
"Athnamepay, ifway\n"
"  uppliedsay, isway away inglesay athnamepay orway istlay ofway athnamespay "
"otay ebay oadedlay ifway\n"
"  ethay odulemay eedsnay otay ebay.  Ifway athnamepay isway otnay "
"uppliedsay, enthay unctionsfay\n"
"  omfray ethay istlay *MODULE-PROVIDER-FUNCTIONS* areway alledcay inway "
"orderway ithway\n"
"  ethay ingifiedstray MODULE-NAME asway ethay argumentway, untilway oneway "
"ofway emthay\n"
"  eturnsray onnay-NIL.  Ybay efaultday ethay unctionsfay\n"
"  MODULE-PROVIDE-CMUCL-DEFMODULE andway MODULE-PROVIDE- CMUCL-LIBRARY "
"areway\n"
"  onway isthay istlay ofway unctionsfay, inway atthay orderway.  Ethay "
"irstfay ofway osethay ookslay\n"
"  orfay away istlay ofway ilesfay atthay asway egisteredray ybay away EXT:"
"DEFMODULE ormfay.  Ifway\n"
"  ethay odulemay ashay otnay eenbay efinedday, enthay ethay econdsay "
"unctionfay ausescay away\n"
"  ilefay otay ebay oadedlay osewhay amenay isway ormedfay ybay ergingmay "
"\"odulesmay:\" andway\n"
"  ethay oncatenationcay ofway odulemay-amenay ithway ethay uffixsay \"-"
"LIBRARY\".  Otenay\n"
"  atthay othbay ethay odulemay-amenay andway ethay uffixsay areway eachway, "
"eparatelysay,\n"
"  onvertedcay omfray :asecay :ommoncay otay :asecay :ocallay.  Isthay "
"ergedmay amenay illway\n"
"  ebay obedpray ithway othbay away .isplay andway .aslfay extensionsway, "
"allingcay LOAD ifway itway\n"
"  existsway.\n"
"\n"
"  Otenay atthay inway allway asescay overedcay aboveway, userway odecay "
"isway esponsibleray orfay\n"
"  allingcay PROVIDE otay indicateway away uccessfulsay oadlay ofway ethay "
"odulemay.\n"
"\n"
"  Ilewhay oadinglay anyway ilesfay, *load-verbose* isway oundbay otay "
"*require-verbose*\n"
"  ichwhay efaultsday otay t."

#: src/code/module.lisp
msgid "Don't know how to load ~A"
msgstr "Onday't nowkay owhay otay oadlay ~Away"

#: src/code/module.lisp
msgid "Coerce a string designator to a module name."
msgstr "Oercecay away ingstray esignatorday otay away odulemay amenay."

#: src/code/module.lisp
msgid ""
"Derive a default pathname to try to load for an undefined module\n"
"  named module-name.  The default pathname is constructed from the\n"
"  module-name by appending the suffix \"-LIBRARY\" to it, and merging\n"
"  with \"modules:\".  Note that both the module-name and the suffix\n"
"  are each, separately, converted from :case :common to :case :local."
msgstr ""
"Eriveday away efaultday athnamepay otay ytray otay oadlay orfay anway "
"undefinedway odulemay\n"
"  amednay odulemay-amenay.  Ethay efaultday athnamepay isway onstructedcay "
"omfray ethay\n"
"  odulemay-amenay ybay appendingway ethay uffixsay \"-LIBRARY\" otay itway, "
"andway ergingmay\n"
"  ithway \"odulesmay:\".  Otenay atthay othbay ethay odulemay-amenay andway "
"ethay uffixsay\n"
"  areway eachway, eparatelysay, onvertedcay omfray :asecay :ommoncay otay :"
"asecay :ocallay."

#: src/code/eval.lisp
msgid ""
"Keywords that you can put in a lambda-list, supposing you should want\n"
"  to do such a thing."
msgstr ""
"Eywordskay atthay ouyay ancay utpay inway away ambdalay-istlay, upposingsay "
"ouyay ouldshay antway\n"
"  otay oday uchsay away ingthay."

#: src/code/eval.lisp
msgid ""
"The exclusive upper bound on the number of arguments which may be passed\n"
"  to a function, including rest args."
msgstr ""
"Ethay exclusiveway upperway oundbay onway ethay umbernay ofway argumentsway "
"ichwhay aymay ebay assedpay\n"
"  otay away unctionfay, includingway estray argsway."

#: src/code/eval.lisp
msgid ""
"The exclusive upper bound on the number of parameters which may be specifed\n"
"  in a given lambda list.  This is actually the limit on required and "
"optional\n"
"  parameters.  With &key and &aux you can get more."
msgstr ""
"Ethay exclusiveway upperway oundbay onway ethay umbernay ofway arameterspay "
"ichwhay aymay ebay ecifedspay\n"
"  inway away ivengay ambdalay istlay.  Isthay isway actuallyway ethay "
"imitlay onway equiredray andway optionalway\n"
"  arameterspay.  Ithway &eykay andway &auxway ouyay ancay etgay oremay."

#: src/code/eval.lisp
msgid ""
"The exclusive upper bound on the number of multiple-values that you can\n"
"  have."
msgstr ""
"Ethay exclusiveway upperway oundbay onway ethay umbernay ofway ultiplemay-"
"aluesvay atthay ouyay ancay\n"
"  avehay."

#: src/code/eval.lisp
msgid ""
"This variable controls whether assignments to unknown variables at top-"
"level\n"
"   (or in any other call to EVAL of SETQ) will implicitly declare the "
"variable\n"
"   SPECIAL.  These values are meaningful:\n"
"     :WARN  -- Print a warning, but declare the variable special (the "
"default.)\n"
"      T     -- Quietly declare the variable special.\n"
"      NIL   -- Never declare the variable, giving warnings on each use."
msgstr ""
"Isthay ariablevay ontrolscay etherwhay assignmentsway otay unknownway "
"ariablesvay atway optay-evellay\n"
"   (orway inway anyway otherway allcay otay EVAL ofway SETQ) illway "
"implicitlyway eclareday ethay ariablevay\n"
"   SPECIAL.  Esethay aluesvay areway eaningfulmay:\n"
"     :WARN  -- Intpray away arningway, utbay eclareday ethay ariablevay "
"ecialspay (ethay efaultday.)\n"
"      T     -- Ietlyquay eclareday ethay ariablevay ecialspay.\n"
"      NIL   -- Evernay eclareday ethay ariablevay, ivinggay arningsway onway "
"eachway useway."

#: src/code/eval.lisp
msgid ""
"Evaluates its single arg in a null lexical environment, returns the\n"
"  result or results."
msgstr ""
"Evaluatesway itsway inglesay argway inway away ullnay exicallay "
"environmentway, eturnsray ethay\n"
"  esultray orway esultsray."

#: src/code/eval.lisp
msgid "Wrong number of args to FUNCTION:~% ~S."
msgstr "Ongwray umbernay ofway argsway otay FUNCTION:~% ~S."

#: src/code/eval.lisp
msgid "~S is a macro."
msgstr "~S isway away acromay."

#: src/code/eval.lisp
msgid "~S is a special operator."
msgstr "~S isway away ecialspay operatorway."

#: src/code/eval.lisp
msgid "Wrong number of args to QUOTE:~% ~S."
msgstr "Ongwray umbernay ofway argsway otay QUOTE:~% ~S."

#: src/code/eval.lisp
msgid "Odd number of args to SETQ:~% ~S."
msgstr "Oddway umbernay ofway argsway otay SETQ:~% ~S."

#: src/code/eval.lisp
msgid "Declaring ~S special."
msgstr "Eclaringday ~S ecialspay."

#: src/compiler/ir1tran.lisp src/code/eval.lisp
msgid "Bad Eval-When situation list: ~S."
msgstr "Adbay Evalway-Enwhay ituationsay istlay: ~S."

#: src/code/eval.lisp
msgid ""
"Attempt to evaluation a complex expression:~%     ~S~@\n"
"\t  This expression must be compiled, but the compiler is not loaded."
msgstr ""
"Attemptway otay evaluationway away omplexcay expressionway:~%     ~S~@\n"
"\t  Isthay expressionway ustmay ebay ompiledcay, utbay ethay ompilercay "
"isway otnay oadedlay."

#: src/code/eval.lisp
msgid ""
"EVAL called on #'(lambda (x) ...) when the compiler isn't loaded:~\n"
"\t  ~%     ~S~%"
msgstr ""
"EVAL alledcay onway #'(ambdalay (x) ...) enwhay ethay ompilercay isnway't "
"oadedlay:~\n"
"\t  ~%     ~S~%"

#: src/code/eval.lisp
msgid ""
"Given a function, return three values:\n"
"   1] A lambda expression that could be used to define the function, or NIL "
"if\n"
"      the definition isn't available.\n"
"   2] NIL if the function was definitely defined in a null lexical "
"environment,\n"
"      and T otherwise.\n"
"   3] Some object that \"names\" the function.  Although this is allowed to "
"be\n"
"      any object, CMU CL always returns a valid function name or a string."
msgstr ""
"Ivengay away unctionfay, eturnray reethay aluesvay:\n"
"   1] Away ambdalay expressionway atthay ouldcay ebay usedway otay efineday "
"ethay unctionfay, orway NIL ifway\n"
"      ethay efinitionday isnway't availableway.\n"
"   2] NIL ifway ethay unctionfay asway efinitelyday efinedday inway away "
"ullnay exicallay environmewaytnay,\n"
"      andway T otherwiseway.\n"
"   3] Omesay objectway atthay \"amesnay\" ethay unctionfay.  Althoughway "
"isthay isway allowedway otay ebay\n"
"      anyway objectway, CMU CL alwaysway eturnsray away alidvay unctionfay "
"amenay orway away ingstray."

#: src/code/eval.lisp
msgid "If the symbol globally names a special form, returns T, otherwise NIL."
msgstr ""
"Ifway ethay ymbolsay oballyglay amesnay away ecialspay ormfay, eturnsray T, "
"otherwiseway NIL."

#: src/code/eval.lisp
msgid ""
"The value of this variable must be a function that can take three\n"
"  arguments, a macro expander function, the macro form to be expanded,\n"
"  and the lexical environment to expand in.  The function should\n"
"  return the expanded form.  This function is called by MACROEXPAND-1\n"
"  whenever a runtime expansion is needed.  Initially this is set to\n"
"  FUNCALL."
msgstr ""
"Ethay aluevay ofway isthay ariablevay ustmay ebay away unctionfay atthay "
"ancay aketay reethay\n"
"  argumentsway, away acromay expanderway unctionfay, ethay acromay ormfay "
"otay ebay expandedway,\n"
"  andway ethay exicallay environmentway otay expandway inway.  Ethay "
"unctionfay ouldshay\n"
"  eturnray ethay expandedway ormfay.  Isthay unctionfay isway alledcay ybay "
"MACROEXPAND-1\n"
"  eneverwhay away untimeray expansionway isway eedednay.  Initiallyway "
"isthay isway etsay otay\n"
"  FUNCALL."

#: src/code/eval.lisp
msgid ""
"Invoke *MACROEXPAND-HOOK* on FUN, FORM, and ENV after coercing it to\n"
"   a function."
msgstr ""
"Invokeway *MACROEXPAND-HOOK* onway FUN, FORM, andway ENV afterway oercingcay "
"itway otay\n"
"   away unctionfay."

#: src/code/eval.lisp
msgid ""
"If SYMBOL names a macro in ENV, returns the expansion function,\n"
"   else returns NIL.  If ENV is unspecified or NIL, use the global\n"
"   environment only."
msgstr ""
"Ifway SYMBOL amesnay away acromay inway ENV, eturnsray ethay expansionway "
"unctionfay,\n"
"   elseway eturnsray NIL.  Ifway ENV isway unspecifiedway orway NIL, useway "
"ethay obalglay\n"
"   environmentway onlyway."

#: src/code/eval.lisp
msgid "~S names a special form."
msgstr "~S amesnay away ecialspay ormfay."

#: src/code/eval.lisp
msgid "Cannot funcall macro functions."
msgstr "Annotcay uncallfay acromay unctionsfay."

#: src/code/eval.lisp
msgid ""
"If form is a macro (or symbol macro), expands it once.  Returns two values,\n"
"   the expanded form and a T-or-NIL flag indicating whether the form was, "
"in\n"
"   fact, a macro.  Env is the lexical environment to expand in, which "
"defaults\n"
"   to the null environment."
msgstr ""
"Ifway ormfay isway away acromay (orway ymbolsay acromay), expandsway itway "
"onceway.  Eturnsray wotay aluesvay,\n"
"   ethay expandedway ormfay andway away T-orway-NIL agflay indicatingway "
"etherwhay ethay ormfay asway, inway\n"
"   actfay, away acromay.  Envway isway ethay exicallay environmentway otay "
"expandway inway, ichwhay efaultsday\n"
"   otay ethay ullnay environmentway."

#: src/code/eval.lisp
msgid ""
"Repetitively call MACROEXPAND-1 until the form can no longer be expanded.\n"
"   Returns the final resultant form, and T if it was expanded.  ENV is the\n"
"   lexical environment to expand in, or NIL (the default) for the null\n"
"   environment."
msgstr ""
"Epetitivelyray allcay MACROEXPAND-1 untilway ethay ormfay ancay onay "
"ongerlay ebay expandedway.\n"
"   Eturnsray ethay inalfay esultantray ormfay, andway T ifway itway asway "
"expandedway.  ENV isway ethay\n"
"   exicallay environmentway otay expandway inway, orway NIL (ethay "
"efaultday) orfay ethay ullnay\n"
"   environmentway."

#: src/code/eval.lisp
msgid ""
"If NAME names a compiler-macro, returns the expansion function,\n"
"   else returns NIL.  Note: if the name is shadowed in ENV by a local\n"
"   definition, or declared NOTINLINE, NIL is returned.  Can be\n"
"   set with SETF."
msgstr ""
"Ifway NAME amesnay away ompilercay-acromay, eturnsray ethay expansionway "
"unctionfay,\n"
"   elseway eturnsray NIL.  Otenay: ifway ethay amenay isway adowedshay inway "
"ENV ybay away ocallay\n"
"   efinitionday, orway eclaredday NOTINLINE, NIL isway eturnedray.  Ancay "
"ebay\n"
"   etsay ithway SETF."

#: src/code/eval.lisp
msgid ""
"If FORM is a function call for which a compiler-macro has been defined,\n"
"   invoke the expander function using *macroexpand-hook* and return the\n"
"   results and T.  Otherwise, return the original form and NIL."
msgstr ""
"Ifway FORM isway away unctionfay allcay orfay ichwhay away ompilercay-"
"acromay ashay eenbay efinedday,\n"
"   invokeway ethay expanderway unctionfay usingway *macroexpand-hook* andway "
"eturnray ethay\n"
"   esultsray andway T.  Otherwiseway, eturnray ethay originalway ormfay "
"andway NIL."

#: src/code/eval.lisp
msgid ""
"Repetitively call COMPILER-MACROEXPAND-1 until the form can no longer be\n"
"   expanded.  ENV is the lexical environment to expand in, or NIL (the\n"
"   default) for the null environment."
msgstr ""
"Epetitivelyray allcay COMPILER-MACROEXPAND-1 untilway ethay ormfay ancay "
"onay ongerlay ebay\n"
"   expandedway.  ENV isway ethay exicallay environmentway otay expandway "
"inway, orway NIL (ethay\n"
"   efaultday) orfay ethay ullnay environmentway."

#: src/code/eval.lisp
msgid ""
"True of any Lisp object that has a constant value: types that eval to\n"
"  themselves, keywords, constants, and list whose car is QUOTE."
msgstr ""
"Uetray ofway anyway Isplay objectway atthay ashay away onstantcay aluevay: "
"ypestay atthay evalway otay\n"
"  emselvesthay, eywordskay, onstantscay, andway istlay osewhay arcay isway "
"QUOTE."

#: src/code/eval.lisp
msgid ""
"Applies FUNCTION to a list of arguments produced by evaluating ARGS in\n"
"  the manner of LIST*.  That is, a list is made of the values of all but "
"the\n"
"  last argument, appended to the value of the last argument, which must be "
"a\n"
"  list."
msgstr ""
"Appliesway FUNCTION otay away istlay ofway argumentsway oducedpray ybay "
"evaluatingway ARGS inway\n"
"  ethay annermay ofway Ist*Lay.  Atthay isway, away istlay isway ademay "
"ofway ethay aluesvay ofway allway utbay ethay\n"
"  astlay argumentway, appendedway otay ethay aluevay ofway ethay astlay "
"argumentway, ichwhay ustmay ebay away\n"
"  istlay."

#: src/code/eval.lisp
msgid "Calls Function with the given Arguments."
msgstr "Allscay Unctionfay ithway ethay ivengay Argumentsway."

#: src/code/eval.lisp
msgid "Returns all of its arguments, in order, as values."
msgstr ""
"Eturnsray allway ofway itsway argumentsway, inway orderway, asway aluesvay."

#: src/code/eval.lisp
msgid "Returns all of the elements of List, in order, as values."
msgstr ""
"Eturnsray allway ofway ethay elementsway ofway Istlay, inway orderway, asway "
"aluesvay."

#: src/code/signal.lisp
msgid "A list of unix signal structures."
msgstr "Away istlay ofway unixway ignalsay ucturesstray."

#: src/code/signal.lisp
msgid "~S is not a valid signal name or number."
msgstr "~S isway otnay away alidvay ignalsay amenay orway umbernay."

#: src/code/signal.lisp
msgid ""
"Return the name of the signal as a string.  Signal should be a valid\n"
"  signal number or a keyword of the standard UNIX signal name."
msgstr ""
"Eturnray ethay amenay ofway ethay ignalsay asway away ingstray.  Ignalsay "
"ouldshay ebay away alidvay\n"
"  ignalsay umbernay orway away eywordkay ofway ethay tandardsay UNIX "
"ignalsay amenay."

#: src/code/signal.lisp
msgid ""
"Return a string describing signal.  Signal should be a valid signal\n"
"  number or a keyword of the standard UNIX signal name."
msgstr ""
"Eturnray away ingstray escribingday ignalsay.  Ignalsay ouldshay ebay away "
"alidvay ignalsay\n"
"  umbernay orway away eywordkay ofway ethay tandardsay UNIX ignalsay amenay."

#: src/code/signal.lisp
msgid ""
"Return the number of the given signal.  Signal should be a valid\n"
"  signal number or a keyword of the standard UNIX signal name."
msgstr ""
"Eturnray ethay umbernay ofway ethay ivengay ignalsay.  Ignalsay ouldshay "
"ebay away alidvay\n"
"  ignalsay umbernay orway away eywordkay ofway ethay tandardsay UNIX "
"ignalsay amenay."

#: src/code/signal.lisp
msgid "Check"
msgstr "Eckchay"

#: src/code/signal.lisp
msgid "Hangup"
msgstr "Anguphay"

#: src/code/signal.lisp
msgid "Interrupt"
msgstr "Interruptway"

#: src/code/signal.lisp
msgid "Quit"
msgstr "Itquay"

#: src/code/signal.lisp
msgid "Illegal instruction"
msgstr "Illegalway instructionway"

#: src/code/signal.lisp
msgid "Trace trap"
msgstr "Acetray aptray"

#: src/code/signal.lisp
msgid "Iot instruction"
msgstr "Iotway instructionway"

#: src/code/signal.lisp
msgid "C abort()"
msgstr "C abortway()"

#: src/code/signal.lisp
msgid "Floating point exception"
msgstr "Oatingflay ointpay exceptionway"

#: src/code/signal.lisp
msgid "Kill"
msgstr "Illkay"

#: src/code/signal.lisp
msgid "Bus error"
msgstr "Usbay errorway"

#: src/code/signal.lisp
msgid "Segmentation violation"
msgstr "Egmentationsay iolationvay"

#: src/code/signal.lisp
msgid "Write on a pipe with no one to read it"
msgstr "Itewray onway away ipepay ithway onay oneway otay eadray itway"

#: src/code/signal.lisp
msgid "Alarm clock"
msgstr "Alarmway ockclay"

#: src/code/signal.lisp
msgid "Software termination signal"
msgstr "Oftwaresay erminationtay ignalsay"

#: src/code/signal.lisp
msgid "Urgent condition present on socket"
msgstr "Urgentway onditioncay esentpray onway ocketsay"

#: src/code/signal.lisp
msgid "Stop"
msgstr "Topsay"

#: src/code/signal.lisp
msgid "Stop signal generated from keyboard"
msgstr "Topsay ignalsay eneratedgay omfray eyboardkay"

#: src/code/signal.lisp
msgid "Continue after stop"
msgstr "Ontinuecay afterway topsay"

#: src/code/signal.lisp
msgid "Child status has changed"
msgstr "Ildchay tatussay ashay angedchay"

#: src/code/signal.lisp
msgid "Background read attempted from control terminal"
msgstr "Ackgroundbay eadray attemptedway omfray ontrolcay erminaltay"

#: src/code/signal.lisp
msgid "Background write attempted to control terminal"
msgstr "Ackgroundbay itewray attemptedway otay ontrolcay erminaltay"

#: src/code/signal.lisp
msgid "I/O is possible on a descriptor"
msgstr "Iway/O isway ossiblepay onway away escriptorday"

#: src/code/signal.lisp
msgid "Cpu time limit exceeded"
msgstr "Pucay imetay imitlay exceededway"

#: src/code/signal.lisp
msgid "File size limit exceeded"
msgstr "Ilefay izesay imitlay exceededway"

#: src/code/signal.lisp
msgid "Virtual time alarm"
msgstr "Irtualvay imetay alarmway"

#: src/code/signal.lisp
msgid "Profiling timer alarm"
msgstr "Ofilingpray imertay alarmway"

#: src/code/signal.lisp
msgid "Window size change"
msgstr "Indowway izesay angechay"

#: src/code/signal.lisp
msgid "User defined signal 1"
msgstr "Userway efinedday ignalsay 1"

#: src/code/signal.lisp
msgid "User defined signal 2"
msgstr "Userway efinedday ignalsay 2"

#: src/code/signal.lisp
msgid "Returns a mask given a set of signals."
msgstr "Eturnsray away askmay ivengay away etsay ofway ignalssay."

#: src/code/signal.lisp
msgid ""
"Unix-kill sends the signal signal to the process with process \n"
"   id pid.  Signal should be a valid signal number or a keyword of the\n"
"   standard UNIX signal name."
msgstr ""
"Unixway-illkay endssay ethay ignalsay ignalsay otay ethay ocesspray ithway "
"ocesspray \n"
"   idway idpay.  Ignalsay ouldshay ebay away alidvay ignalsay umbernay orway "
"away eywordkay ofway ethay\n"
"   tandardsay UNIX ignalsay amenay."

#: src/code/signal.lisp
msgid ""
"Unix-killpg sends the signal signal to the all the process in process\n"
"  group PGRP.  Signal should be a valid signal number or a keyword of\n"
"  the standard UNIX signal name."
msgstr ""
"Unixway-illpgkay endssay ethay ignalsay ignalsay otay ethay allway ethay "
"ocesspray inway ocesspray\n"
"  oupgray PGRP.  Ignalsay ouldshay ebay away alidvay ignalsay umbernay orway "
"away eywordkay ofway\n"
"  ethay tandardsay UNIX ignalsay amenay."

#: src/code/signal.lisp
msgid ""
"Unix-sigblock cause the signals specified in mask to be\n"
"   added to the set of signals currently being blocked from\n"
"   delivery.  The macro sigmask is provided to create masks."
msgstr ""
"Unixway-igblocksay ausecay ethay ignalssay ecifiedspay inway askmay otay "
"ebay\n"
"   addedway otay ethay etsay ofway ignalssay urrentlycay eingbay ockedblay "
"omfray\n"
"   eliveryday.  Ethay acromay igmasksay isway ovidedpray otay eatecray "
"asksmay."

#: src/code/signal.lisp
msgid ""
"Unix-sigpause sets the set of masked signals to its argument\n"
"   and then waits for a signal to arrive, restoring the previous\n"
"   mask upon its return."
msgstr ""
"Unixway-igpausesay etssay ethay etsay ofway askedmay ignalssay otay itsway "
"argumentway\n"
"   andway enthay aitsway orfay away ignalsay otay arriveway, estoringray "
"ethay eviouspray\n"
"   askmay uponway itsway eturnray."

#: src/code/signal.lisp
msgid ""
"Unix-sigsetmask sets the current set of masked signals (those\n"
"   being blocked from delivery) to the argument.  The macro sigmask\n"
"   can be used to create the mask.  The previous value of the signal\n"
"   mask is returned."
msgstr ""
"Unixway-igsetmasksay etssay ethay urrentcay etsay ofway askedmay ignalssay "
"(osethay\n"
"   eingbay ockedblay omfray eliveryday) otay ethay argumentway.  Ethay "
"acromay igmasksay\n"
"   ancay ebay usedway otay eatecray ethay askmay.  Ethay eviouspray aluevay "
"ofway ethay ignalsay\n"
"   askmay isway eturnedray."

#: src/code/signal.lisp
msgid "Enable all the default signals that Lisp knows how to deal with."
msgstr ""
"Enableway allway ethay efaultday ignalssay atthay Isplay nowskay owhay otay "
"ealday ithway."

#: src/code/signal.lisp
msgid "Execute BODY in a context impervious to interrupts."
msgstr "Executeway BODY inway away ontextcay imperviousway otay interruptsway."

#: src/code/signal.lisp
msgid ""
"Allow interrupts while executing BODY.  As interrupts are normally allowed,\n"
"  this is only useful inside a WITHOUT-INTERRUPTS."
msgstr ""
"Allowway interruptsway ilewhay executingway BODY.  Asway interruptsway "
"areway ormallynay allowedway,\n"
"  isthay isway onlyway usefulway insideway away WITHOUT-INTERRUPTS."

#: src/code/signal.lisp
msgid ""
"With-enabled-interrupts ({(interrupt function)}*) {form}*\n"
"   Establish function as a handler for the Unix signal interrupt which\n"
"   should be a number between 1 and 31 inclusive."
msgstr ""
"Ithway-enabledway-interruptsway ({(interruptway unctionfay)}*) {ormfay}*\n"
"   Establishway unctionfay asway away andlerhay orfay ethay Unixway ignalsay "
"interruptway ichwhay\n"
"   ouldshay ebay away umbernay etweenbay 1 andway 31 inclusiveway."

#: src/code/interr.lisp
msgid "Unknown error:~{ ~S~})"
msgstr "Unknownway errorway:~{ ~S~})"

#: src/code/interr.lisp
msgid "Attempt to use VALUES-LIST on a dotted-list:~%  ~S"
msgstr "Attemptway otay useway VALUES-LIST onway away ottedday-istlay:~%  ~S"

#: src/code/interr.lisp
msgid "Attempt to RETURN-FROM a block or GO to a tag that no longer exists"
msgstr ""
"Attemptway otay RETURN-FROM away ockblay orway GO otay away agtay atthay "
"onay ongerlay existsway"

#: src/code/interr.lisp
msgid "Attempt to THROW to a tag that does not exist: ~S"
msgstr "Attemptway otay THROW otay away agtay atthay oesday otnay existway: ~S"

#: src/code/interr.lisp
msgid "Function with declared result type NIL returned:~%  ~S"
msgstr "Unctionfay ithway eclaredday esultray ypetay NIL eturnedray:~%  ~S"

#: src/code/interr.lisp
msgid "Invalid array index, ~D for ~S.  Array has no elements."
msgstr ""
"Invalidway arrayway indexway, ~D orfay ~S.  Arrayway ashay onay elementsway."

#: src/code/interr.lisp
msgid ""
"Invalid array index, ~D for ~S.  Should have greater than or equal to 0."
msgstr ""
"Invalidway arrayway indexway, ~D orfay ~S.  Ouldshay avehay eatergray anthay "
"orway equalway otay 0."

#: src/code/interr.lisp
msgid "Invalid array index, ~D for ~S.  Should have been less than ~D"
msgstr ""
"Invalidway arrayway indexway, ~D orfay ~S.  Ouldshay avehay eenbay esslay "
"anthay ~D"

#: src/code/interr.lisp
msgid "Undefined foreign symbol: ~S"
msgstr "Undefinedway oreignfay ymbolsay: ~S"

#: src/code/interr.lisp
msgid ""
"The maximum number of nested errors allowed.  Internal errors are\n"
"   double-counted."
msgstr ""
"Ethay aximummay umbernay ofway estednay errorsway allowedway.  Internalway "
"errorsway areway\n"
"   oubleday-ountedcay."

#: src/code/interr.lisp
msgid "The current number of nested errors."
msgstr "Ethay urrentcay umbernay ofway estednay errorsway."

#: src/code/interr.lisp
msgid "Unknown internal error, ~D?  args=~S"
msgstr "Unknownway internalway errorway, ~D?  argsway=~S"

#: src/code/interr.lisp
msgid "Internal error ~D: ~A.  args=~S"
msgstr "Internalway errorway ~D: ~Away.  argsway=~S"

#: src/code/interr.lisp
msgid ""
"~2&~@<A control stack overflow has occurred:~%~\n"
"            the program has entered the yellow control stack guard zone.~%~\n"
"            Please note that you will be returned to the Top-Level if "
"you~%~\n"
"            enter the red control stack guard zone while debugging.~@:>~2%"
msgstr ""
"~2&~@<Away ontrolcay tacksay overflowway ashay occurredway:~%~\n"
"            ethay ogrampray ashay enteredway ethay ellowyay ontrolcay "
"tacksay uardgay onezay.~%~\n"
"            Easeplay otenay atthay ouyay illway ebay eturnedray otay ethay "
"Optay-Evellay ifway ouyay~%~\n"
"            enterway ethay edray ontrolcay tacksay uardgay onezay ilewhay "
"ebuggingday.~@:>~2%"

#: src/code/interr.lisp
msgid ""
"~2&~@<Fatal control stack overflow.  You have entered~%~\n"
"           the red control stack guard zone while debugging.~%~\n"
"           Returning to Top-Level.~@:>~2%"
msgstr ""
"~2&~@<Atalfay ontrolcay tacksay overflowway.  Ouyay avehay enteredway~%~\n"
"           ethay edray ontrolcay tacksay uardgay onezay ilewhay ebuggingday."
"~%~\n"
"           Eturningray otay Optay-Evellay.~@:>~2%"

#: src/code/interr.lisp
msgid ""
"~2&~@<Imminent dynamic space overflow has occurred:~%~\n"
"            Only a small amount of dynamic space is available now.~%~\n"
"            Please note that you will be returned to the Top-Level "
"without~%~\n"
"            warning if you run out of space while debugging.~@:>~%"
msgstr ""
"~2&~@<Imminentway ynamicday acespay overflowway ashay occurredway:~%~\n"
"            Onlyway away mallsay amountway ofway ynamicday acespay isway "
"availableway ownay.~%~\n"
"            Easeplay otenay atthay ouyay illway ebay eturnedray otay ethay "
"Optay-Evellay ithoutway~%~\n"
"            arningway ifway ouyay unray outway ofway acespay ilewhay "
"ebuggingday.~@:>~%"

#: src/code/debug-int.lisp
msgid ""
"All debug-conditions inherit from this type.  These are serious conditions\n"
"    that must be handled, but they are not programmer errors."
msgstr ""
"Allway ebugday-onditionscay inheritway omfray isthay ypetay.  Esethay areway "
"erioussay onditionscay\n"
"    atthay ustmay ebay andledhay, utbay eythay areway otnay ogrammerpray "
"errorsway."

#: src/code/debug-int.lisp
msgid "There is absolutely no debugging information available."
msgstr ""
"Erethay isway absolutelyway onay ebuggingday informationway availableway."

#: src/code/debug-int.lisp
msgid "No debugging information available."
msgstr "Onay ebuggingday informationway availableway."

#: src/code/debug-int.lisp
msgid ""
"The system could not return values from a frame with debug-function since\n"
"    it lacked information about returning values."
msgstr ""
"Ethay ystemsay ouldcay otnay eturnray aluesvay omfray away amefray ithway "
"ebugday-unctionfay incesay\n"
"    itway ackedlay informationway aboutway eturningray aluesvay."

#: src/code/debug-int.lisp
msgid ""
"~&Cannot return values from ~:[frame~;~:*~S~] since ~\n"
"\t\t\tthe debug information lacks details about returning ~\n"
"\t\t\tvalues here."
msgstr ""
"~&Annotcay eturnray aluesvay omfray ~:[amefray~;~:*~S~] incesay ~\n"
"\t\t\tethay ebugday informationway ackslay etailsday aboutway eturningray ~\n"
"\t\t\taluesvay erehay."

#: src/code/debug-int.lisp
msgid "The debug-function has no debug-block information."
msgstr "Ethay ebugday-unctionfay ashay onay ebugday-ockblay informationway."

#: src/code/debug-int.lisp
msgid "~&~S has no debug-block information."
msgstr "~&~S ashay onay ebugday-ockblay informationway."

#: src/code/debug-int.lisp
msgid "The debug-function has no debug-variable information."
msgstr "Ethay ebugday-unctionfay ashay onay ebugday-ariablevay informationway."

#: src/code/debug-int.lisp
msgid "~&~S has no debug-variable information."
msgstr "~&~S ashay onay ebugday-ariablevay informationway."

#: src/code/debug-int.lisp
msgid ""
"The debug-function has no lambda-list since argument debug-variables are\n"
"    unavailable."
msgstr ""
"Ethay ebugday-unctionfay ashay onay ambdalay-istlay incesay argumentway "
"ebugday-ariablesvay areway\n"
"    unavailableway."

#: src/code/debug-int.lisp
msgid "~&~S has no lambda-list information available."
msgstr "~&~S ashay onay ambdalay-istlay informationway availableway."

#: src/code/debug-int.lisp
msgid "~&~S has :invalid or :unknown value in ~S."
msgstr "~&~S ashay :invalidway orway :unknownway aluevay inway ~S."

#: src/code/debug-int.lisp
msgid "~&~S names more than one valid variable in ~S."
msgstr "~&~S amesnay oremay anthay oneway alidvay ariablevay inway ~S."

#: src/code/debug-int.lisp
msgid ""
"All programmer errors from using the interface for building debugging\n"
"    tools inherit from this type."
msgstr ""
"Allway ogrammerpray errorsway omfray usingway ethay interfaceway orfay "
"uildingbay ebuggingday\n"
"    oolstay inheritway omfray isthay ypetay."

#: src/code/debug-int.lisp
msgid "~&Unhandled debug-condition:~%~A"
msgstr "~&Unhandledway ebugday-onditioncay:~%~Away"

#: src/code/debug-int.lisp
msgid "~&Invalid use of an unknown code-location -- ~S."
msgstr "~&Invalidway useway ofway anway unknownway odecay-ocationlay -- ~S."

#: src/code/debug-int.lisp
msgid "~&~S not in ~S."
msgstr "~&~S otnay inway ~S."

#: src/code/debug-int.lisp
msgid "Invalid control stack pointer."
msgstr "Invalidway ontrolcay tacksay ointerpay."

#: src/code/debug-int.lisp
msgid "~&Form was preprocessed for ~S,~% but called on ~S:~%  ~S"
msgstr ""
"~&Ormfay asway eprocessedpray orfay ~S,~% utbay alledcay onway ~S:~%  ~S"

#: src/code/debug-int.lisp
msgid ""
"Returns the name of the debug-variable.  The name is the name of the symbol\n"
"   used as an identifier when writing the code."
msgstr ""
"Eturnsray ethay amenay ofway ethay ebugday-ariablevay.  Ethay amenay isway "
"ethay amenay ofway ethay ymbolsay\n"
"   usedway asway anway identifierway enwhay itingwray ethay odecay."

#: src/code/debug-int.lisp
msgid ""
"Returns the package name of the debug-variable.  This is the package name "
"of\n"
"   the symbol used as an identifier when writing the code."
msgstr ""
"Eturnsray ethay ackagepay amenay ofway ethay ebugday-ariablevay.  Isthay "
"isway ethay ackagepay amenay ofway\n"
"   ethay ymbolsay usedway asway anway identifierway enwhay itingwray ethay "
"odecay."

#: src/code/debug-int.lisp
msgid ""
"Returns the integer that makes debug-variable's name and package name "
"unique\n"
"   with respect to other debug-variable's in the same function."
msgstr ""
"Eturnsray ethay integerway atthay akesmay ebugday-ariablevay's amenay andway "
"ackagepay amenay uniqueway\n"
"   ithway espectray otay otherway ebugday-ariablevay's inway ethay amesay "
"unctionfay."

#: src/code/debug-int.lisp
msgid ""
"Returns the frame immediately above frame on the stack.  When frame is\n"
"   the top of the stack, this returns nil."
msgstr ""
"Eturnsray ethay amefray immediatelyway aboveway amefray onway ethay "
"tacksay.  Enwhay amefray isway\n"
"   ethay optay ofway ethay tacksay, isthay eturnsray ilnay."

#: src/code/debug-int.lisp
msgid ""
"Returns the debug-function for the function whose call frame represents."
msgstr ""
"Eturnsray ethay ebugday-unctionfay orfay ethay unctionfay osewhay allcay "
"amefray epresentsray."

#: src/code/debug-int.lisp
msgid ""
"Returns the code-location where the frame's debug-function will continue\n"
"   running when program execution returns to this frame.  If someone\n"
"   interrupted this frame, the result could be an unknown code-location."
msgstr ""
"Eturnsray ethay odecay-ocationlay erewhay ethay amefray's ebugday-unctionfay "
"illway ontinuecay\n"
"   unningray enwhay ogrampray executionway eturnsray otay isthay amefray.  "
"Ifway omeonesay\n"
"   interruptedway isthay amefray, ethay esultray ouldcay ebay anway "
"unknownway odecay-ocationlay."

#: src/code/debug-int.lisp
msgid "#<Compiled-Frame ~S~:[~;, interrupted~]>"
msgstr "#<Ompiledcay-Amefray ~S~:[~;, interruptedway~]>"

#: src/code/debug-int.lisp
msgid "#<~A-Debug-Function ~S>"
msgstr "#<~Away-Ebugday-Unctionfay ~S>"

#: src/code/debug-int.lisp
msgid ""
"Returns the list of possible code-locations where execution may continue\n"
"   when the basic-block represented by debug-block completes its execution."
msgstr ""
"Eturnsray ethay istlay ofway ossiblepay odecay-ocationslay erewhay "
"executionway aymay ontinuecay\n"
"   enwhay ethay asicbay-ockblay epresentedray ybay ebugday-ockblay "
"ompletescay itsway executionway."

#: src/code/debug-int.lisp
msgid "Returns whether debug-block represents elsewhere code."
msgstr "Eturnsray etherwhay ebugday-ockblay epresentsray elsewhereway odecay."

#: src/code/debug-int.lisp
msgid ""
"Returns the breakpoint's function the system calls when execution "
"encounters\n"
"   the breakpoint, and it is active.  This is SETF'able."
msgstr ""
"Eturnsray ethay eakpointbray's unctionfay ethay ystemsay allscay enwhay "
"executionway encountersway\n"
"   ethay eakpointbray, andway itway isway activeway.  Isthay isway "
"SETF'ableway."

#: src/code/debug-int.lisp
msgid "Returns the breakpoint's what specification."
msgstr "Eturnsray ethay eakpointbray's atwhay ecificationspay."

#: src/code/debug-int.lisp
msgid "Returns the breakpoint's kind specification."
msgstr "Eturnsray ethay eakpointbray's indkay ecificationspay."

#: src/code/debug-int.lisp
msgid ""
"Returns the debug-function representing information about the function\n"
"   corresponding to the code-location."
msgstr ""
"Eturnsray ethay ebugday-unctionfay epresentingray informationway aboutway "
"ethay unctionfay\n"
"   orrespondingcay otay ethay odecay-ocationlay."

#: src/code/debug-int.lisp
msgid ""
"Returns the number of top-level forms processed by the compiler before\n"
"   compiling this source.  If this source is uncompiled, this is zero.  "
"This\n"
"   may be zero even if the source is compiled since the first form in the "
"first\n"
"   file compiled in one compilation, for example, must have a root number "
"of\n"
"   zero -- the compiler saw no other top-level forms before it."
msgstr ""
"Eturnsray ethay umbernay ofway optay-evellay ormsfay ocessedpray ybay ethay "
"ompilercay eforebay\n"
"   ompilingcay isthay ourcesay.  Ifway isthay ourcesay isway uncompiledway, "
"isthay isway erozay.  Isthay\n"
"   aymay ebay erozay evenway ifway ethay ourcesay isway ompiledcay incesay "
"ethay irstfay ormfay inway ethay irstfay\n"
"   ilefay ompiledcay inway oneway ompilationcay, orfay exampleway, ustmay "
"avehay away ootray umbernay ofway\n"
"   erozay -- ethay ompilercay awsay onay otherway optay-evellay ormsfay "
"eforebay itway."

#: src/code/debug-int.lisp
msgid ""
"Returns an indication of the type of source.  The following are the "
"possible\n"
"   values:\n"
"      :file    from a file (obtained by COMPILE-FILE if compiled).\n"
"      :lisp    from Lisp (obtained by COMPILE if compiled).\n"
"      :stream  from a non-file stream."
msgstr ""
"Eturnsray anway indicationway ofway ethay ypetay ofway ourcesay.  Ethay "
"ollowingfay areway ethay ossiblepay\n"
"   aluesvay:\n"
"      :ilefay    omfray away ilefay (obtainedway ybay COMPILE-FILE ifway "
"ompiledcay).\n"
"      :isplay    omfray Isplay (obtainedway ybay COMPILE ifway ompiledcay).\n"
"      :eamstray  omfray away onnay-ilefay eamstray."

#: src/code/debug-int.lisp
msgid ""
"Returns the actual source in some sense represented by debug-source, which\n"
"   is related to DEBUG-SOURCE-FROM:\n"
"      :file    the pathname of the file.\n"
"      :lisp    a lambda-expression.\n"
"      :stream  some descriptive string that's otherwise useless."
msgstr ""
"Eturnsray ethay actualway ourcesay inway omesay ensesay epresentedray ybay "
"ebugday-ourcesay, ichwhay\n"
"   isway elatedray otay DEBUG-SOURCE-FROM:\n"
"      :ilefay    ethay athnamepay ofway ethay ilefay.\n"
"      :isplay    away ambdalay-expressionway.\n"
"      :eamstray  omesay escriptiveday ingstray atthay's otherwiseway "
"uselessway."

#: src/code/debug-int.lisp
msgid ""
"Returns the universal time someone created the source.  This may be nil if\n"
"   it is unavailable."
msgstr ""
"Eturnsray ethay universalway imetay omeonesay eatedcray ethay ourcesay.  "
"Isthay aymay ebay ilnay ifway\n"
"   itway isway unavailableway."

#: src/code/debug-int.lisp
msgid ""
"Returns the time someone compiled the source.  This is nil if the source\n"
"   is uncompiled."
msgstr ""
"Eturnsray ethay imetay omeonesay ompiledcay ethay ourcesay.  Isthay isway "
"ilnay ifway ethay ourcesay\n"
"   isway uncompiledway."

#: src/code/debug-int.lisp
msgid ""
"This function returns the file position of each top-level form as an array\n"
"   if debug-source is from a :file.  If DEBUG-SOURCE-FROM is :lisp or :"
"stream,\n"
"   this returns nil."
msgstr ""
"Isthay unctionfay eturnsray ethay ilefay ositionpay ofway eachway optay-"
"evellay ormfay asway anway arrayway\n"
"   ifway ebugday-ourcesay isway omfray away :ilefay.  Ifway DEBUG-SOURCE-"
"FROM isway :isplay orway :eamstray,\n"
"   isthay eturnsray ilnay."

#: src/code/debug-int.lisp
msgid "Returns whether object is a debug-source."
msgstr "Eturnsray etherwhay objectway isway away ebugday-ourcesay."

#: src/code/debug-int.lisp
msgid ""
"Returns the top frame of the control stack as it was before calling this\n"
"   function."
msgstr ""
"Eturnsray ethay optay amefray ofway ethay ontrolcay tacksay asway itway "
"asway eforebay allingcay isthay\n"
"   unctionfay."

#: src/code/debug-int.lisp
msgid ""
"Flush all of the frames above FRAME, and renumber all the frames below\n"
"   FRAME."
msgstr ""
"Ushflay allway ofway ethay amesfray aboveway FRAME, andway enumberray allway "
"ethay amesfray elowbay\n"
"   FRAME."

#: src/code/debug-int.lisp
msgid ""
"Returns the frame immediately below frame on the stack.  When frame is\n"
"   the bottom of the stack, this returns nil."
msgstr ""
"Eturnsray ethay amefray immediatelyway elowbay amefray onway ethay tacksay.  "
"Enwhay amefray isway\n"
"   ethay ottombay ofway ethay tacksay, isthay eturnsray ilnay."

#: src/code/debug-int.lisp
msgid ""
"When set, the debugger foregoes making interpreted-frames, so you can\n"
"   debug the functions that manifest the interpreter."
msgstr ""
"Enwhay etsay, ethay ebuggerday oregoesfay akingmay interpretedway-amesfray, "
"osay ouyay ancay\n"
"   ebugday ethay unctionsfay atthay anifestmay ethay interpreterway."

#: src/code/debug-int.lisp
msgid ""
"Zero or more than one ~A variable in ~\n"
"\t\t\t   EVAL::INTERNAL-APPLY-LOOP?"
msgstr ""
"Erozay orway oremay anthay oneway ~Away ariablevay inway ~\n"
"\t\t\t   EVAL::INTERNAL-APPLY-LOOP?"

#: src/code/debug-int.lisp
msgid "Return a string describing the foreign function near ADDRESS"
msgstr ""
"Eturnray away ingstray escribingday ethay oreignfay unctionfay earnay ADDRESS"

#: src/code/debug-int.lisp
msgid "Foreign function call land"
msgstr "Oreignfay unctionfay allcay andlay"

#: src/code/debug-int.lisp
msgid "Return t if COMPONENT contains code from assembly routines."
msgstr ""
"Eturnray t ifway COMPONENT ontainscay odecay omfray assemblyway outinesray."

#: src/code/debug-int.lisp
msgid ""
"Return the name of the assembly routine at offset PC in COMPONENT.\n"
"The result is a symbol or nil if the routine cannot be found."
msgstr ""
"Eturnray ethay amenay ofway ethay assemblyway outineray atway offsetway PC "
"inway COMPONENT.\n"
"Ethay esultray isway away ymbolsay orway ilnay ifway ethay outineray "
"annotcay ebay oundfay."

#: src/code/debug-int.lisp
msgid ""
"Returns an a-list mapping catch tags to code-locations.  These are\n"
"   code-locations at which execution would continue with frame as the top\n"
"   frame if someone threw to the corresponding tag."
msgstr ""
"Eturnsray anway away-istlay appingmay atchcay agstay otay odecay-"
"ocationslay.  Esethay areway\n"
"   odecay-ocationslay atway ichwhay executionway ouldway ontinuecay ithway "
"amefray asway ethay optay\n"
"   amefray ifway omeonesay rewthay otay ethay orrespondingcay agtay."

#: src/code/debug-int.lisp
msgid ""
"Executes the forms in a context with block-var bound to each debug-block in\n"
"   debug-function successively.  Result is an optional form to execute for\n"
"   return values, and DO-DEBUG-FUNCTION-BLOCKS returns nil if there is no\n"
"   result form.  This signals a no-debug-blocks condition when the\n"
"   debug-function lacks debug-block information."
msgstr ""
"Executesway ethay ormsfay inway away ontextcay ithway ockblay-arvay oundbay "
"otay eachway ebugday-ockblay inway\n"
"   ebugday-unctionfay uccessivelysay.  Esultray isway anway optionalway "
"ormfay otay executeway orfay\n"
"   eturnray aluesvay, andway DO-DEBUG-FUNCTION-BLOCKS eturnsray ilnay ifway "
"erethay isway onay\n"
"   esultray ormfay.  Isthay ignalssay away onay-ebugday-ocksblay onditioncay "
"enwhay ethay\n"
"   ebugday-unctionfay ackslay ebugday-ockblay informationway."

#: src/code/debug-int.lisp
msgid ""
"Executes body in a context with var bound to each debug-variable in\n"
"   debug-function.  This returns the value of executing result (defaults to\n"
"   nil).  This may iterate over only some of debug-function's variables or "
"none\n"
"   depending on debug policy; for example, possibly the compilation only\n"
"   preserved argument information."
msgstr ""
"Executesway odybay inway away ontextcay ithway arvay oundbay otay eachway "
"ebugday-ariablevay inway\n"
"   ebugday-unctionfay.  Isthay eturnsray ethay aluevay ofway executingway "
"esultray (efaultsday otay\n"
"   ilnay).  Isthay aymay iterateway overway onlyway omesay ofway ebugday-"
"unctionfay's ariablesvay orway onenay\n"
"   ependingday onway ebugday olicypay; orfay exampleway, ossiblypay ethay "
"ompilationcay onlyway\n"
"   eservedpray argumentway informationway."

#: src/code/debug-int.lisp
msgid ""
"Returns the Common Lisp function associated with the debug-function.  This\n"
"   returns nil if the function is unavailable or is non-existent as a user\n"
"   callable function object."
msgstr ""
"Eturnsray ethay Ommoncay Isplay unctionfay associatedway ithway ethay "
"ebugday-unctionfay.  Isthay\n"
"   eturnsray ilnay ifway ethay unctionfay isway unavailableway orway isway "
"onnay-existentway asway away userway\n"
"   allablecay unctionfay objectway."

#: src/code/debug-int.lisp
msgid ""
"Returns the name of the function represented by debug-function.  This may\n"
"   be a string or a cons; do not assume it is a symbol."
msgstr ""
"Eturnsray ethay amenay ofway ethay unctionfay epresentedray ybay ebugday-"
"unctionfay.  Isthay aymay\n"
"   ebay away ingstray orway away onscay; oday otnay assumeway itway isway "
"away ymbolsay."

#: src/code/debug-int.lisp
msgid ""
"Returns a debug-function that represents debug information for function."
msgstr ""
"Eturnsray away ebugday-unctionfay atthay epresentsray ebugday informationway "
"orfay unctionfay."

#: src/code/debug-int.lisp
msgid ""
"Returns the kind of the function which is one of :optional, :external,\n"
"   :top-level, :cleanup, nil."
msgstr ""
"Eturnsray ethay indkay ofway ethay unctionfay ichwhay isway oneway ofway :"
"optionalway, :externalway,\n"
"   :optay-evellay, :eanupclay, ilnay."

#: src/code/debug-int.lisp
msgid "Returns whether there is any variable information for debug-function."
msgstr ""
"Eturnsray etherwhay erethay isway anyway ariablevay informationway orfay "
"ebugday-unctionfay."

#: src/code/debug-int.lisp
msgid ""
"Returns a list of debug-variables in debug-function having the same name\n"
"   and package as symbol.  If symbol is uninterned, then this returns a list "
"of\n"
"   debug-variables without package names and with the same name as symbol.  "
"The\n"
"   result of this function is limited to the availability of variable\n"
"   information in debug-function; for example, possibly debug-function only\n"
"   knows about its arguments."
msgstr ""
"Eturnsray away istlay ofway ebugday-ariablesvay inway ebugday-unctionfay "
"avinghay ethay amesay amenay\n"
"   andway ackagepay asway ymbolsay.  Ifway ymbolsay isway uninternedway, "
"enthay isthay eturnsray away istlay ofway\n"
"   ebugday-ariablesvay ithoutway ackagepay amesnay andway ithway ethay "
"amesay amenay asway ymbolsay.  Ethay\n"
"   esultray ofway isthay unctionfay isway imitedlay otay ethay "
"availabilityway ofway ariablevay\n"
"   informationway inway ebugday-unctionfay; orfay exampleway, ossiblypay "
"ebugday-unctionfay onlyway\n"
"   nowskay aboutway itsway argumentsway."

#: src/code/debug-int.lisp
msgid ""
"Returns a list of debug-variables in debug-function whose names contain\n"
"    name-prefix-string as an intial substring.  The result of this function "
"is\n"
"    limited to the availability of variable information in debug-function; "
"for\n"
"    example, possibly debug-function only knows about its arguments."
msgstr ""
"Eturnsray away istlay ofway ebugday-ariablesvay inway ebugday-unctionfay "
"osewhay amesnay ontaincay\n"
"    amenay-efixpray-ingstray asway anway intialway ubstringsay.  Ethay "
"esultray ofway isthay unctionfay isway\n"
"    imitedlay otay ethay availabilityway ofway ariablevay informationway "
"inway ebugday-unctionfay; orfay\n"
"    exampleway, ossiblypay ebugday-unctionfay onlyway nowskay aboutway "
"itsway argumentsway."

#: src/code/debug-int.lisp
msgid ""
"Returns a list representing the lambda-list for debug-function.  The list\n"
"   has the following structure:\n"
"      (required-var1 required-var2\n"
"       ...\n"
"       (:optional var3 suppliedp-var4)\n"
"       (:optional var5)\n"
"       ...\n"
"       (:rest var6) (:rest var7)\n"
"       ...\n"
"       (:keyword keyword-symbol var8 suppliedp-var9)\n"
"       (:keyword keyword-symbol var10)\n"
"       ...\n"
"      )\n"
"   Each VARi is a debug-variable; however it may be the symbol :deleted it\n"
"   is unreferenced in debug-function.  This signals a lambda-list-"
"unavaliable\n"
"   condition when there is no argument list information."
msgstr ""
"Eturnsray away istlay epresentingray ethay ambdalay-istlay orfay ebugday-"
"unctionfay.  Ethay istlay\n"
"   ashay ethay ollowingfay ucturestray:\n"
"      (equiredray-arvay1 equiredray-arvay2\n"
"       ...\n"
"       (:optionalway arvay3 uppliedpsay-arvay4)\n"
"       (:optionalway arvay5)\n"
"       ...\n"
"       (:estray arvay6) (:estray arvay7)\n"
"       ...\n"
"       (:eywordkay eywordkay-ymbolsay arvay8 uppliedpsay-arvay9)\n"
"       (:eywordkay eywordkay-ymbolsay arvay10)\n"
"       ...\n"
"      )\n"
"   Eachway Arivay isway away ebugday-ariablevay; oweverhay itway aymay ebay "
"ethay ymbolsay :eletedday itway\n"
"   isway unreferencedway inway ebugday-unctionfay.  Isthay ignalssay away "
"ambdalay-istlay-unavaliablwaye\n"
"   onditioncay enwhay erethay isway onay argumentway istlay informationway."

#: src/code/debug-int.lisp
msgid "Malformed arguments description."
msgstr "Alformedmay argumentsway escriptionday."

#: src/code/debug-int.lisp
msgid ""
"Returns whether basic-code-location is unknown.  It returns nil when the\n"
"   code-location is known."
msgstr ""
"Eturnsray etherwhay asicbay-odecay-ocationlay isway unknownway.  Itway "
"eturnsray ilnay enwhay ethay\n"
"   odecay-ocationlay isway nownkay."

#: src/code/debug-int.lisp
msgid ""
"Returns the debug-block containing code-location if it is available.  Some\n"
"   debug policies inhibit debug-block information, and if none is "
"available,\n"
"   then this signals a no-debug-blocks condition."
msgstr ""
"Eturnsray ethay ebugday-ockblay ontainingcay odecay-ocationlay ifway itway "
"isway availableway.  Omesay\n"
"   ebugday oliciespay inhibitway ebugday-ockblay informationway, andway "
"ifway onenay isway availableway,\n"
"   enthay isthay ignalssay away onay-ebugday-ocksblay onditioncay."

#: src/code/debug-int.lisp
msgid "Returns the code-location's debug-source."
msgstr "Eturnsray ethay odecay-ocationlay's ebugday-ourcesay."

#: src/code/debug-int.lisp
msgid ""
"Returns the number of top-level forms before the one containing\n"
"   code-location as seen by the compiler in some compilation unit.  A\n"
"   compilation unit is not necessarily a single file, see the section on\n"
"   debug-sources."
msgstr ""
"Eturnsray ethay umbernay ofway optay-evellay ormsfay eforebay ethay oneway "
"ontainingcay\n"
"   odecay-ocationlay asway eensay ybay ethay ompilercay inway omesay "
"ompilationcay unitway.  Away\n"
"   ompilationcay unitway isway otnay ecessarilynay away inglesay ilefay, "
"eesay ethay ectionsay onway\n"
"   ebugday-ourcessay."

#: src/code/debug-int.lisp
msgid "Unknown code location?  It should be known."
msgstr "Unknownway odecay ocationlay?  Itway ouldshay ebay nownkay."

#: src/code/debug-int.lisp
msgid ""
"Returns the number of the form corresponding to code-location.  The form\n"
"   number is derived by a walking the subforms of a top-level form in\n"
"   depth-first order."
msgstr ""
"Eturnsray ethay umbernay ofway ethay ormfay orrespondingcay otay odecay-"
"ocationlay.  Ethay ormfay\n"
"   umbernay isway erivedday ybay away alkingway ethay ubformssay ofway away "
"optay-evellay ormfay inway\n"
"   epthday-irstfay orderway."

#: src/code/debug-int.lisp
msgid ""
"Return the kind of CODE-LOCATION, one of:\n"
"     :interpreted, :unknown-return, :known-return, :internal-error,\n"
"     :non-local-exit, :block-start, :call-site, :single-value-return,\n"
"     :non-local-entry"
msgstr ""
"Eturnray ethay indkay ofway CODE-LOCATION, oneway ofway:\n"
"     :interpretedway, :unknownway-eturnray, :nownkay-eturnray, :internalway-"
"errorway,\n"
"     :onnay-ocallay-exitway, :ockblay-tartsay, :allcay-itesay, :inglesay-"
"aluevay-eturnray,\n"
"     :onnay-ocallay-entryway"

#: src/code/debug-int.lisp
msgid "Returns whether obj1 and obj2 are the same place in the code."
msgstr ""
"Eturnsray etherwhay objway1 andway objway2 areway ethay amesay aceplay inway "
"ethay odecay."

#: src/code/debug-int.lisp
msgid ""
"Executes forms in a context with code-var bound to each code-location in\n"
"   debug-block.  This returns the value of executing result (defaults to "
"nil)."
msgstr ""
"Executesway ormsfay inway away ontextcay ithway odecay-arvay oundbay otay "
"eachway odecay-ocationlay inway\n"
"   ebugday-ockblay.  Isthay eturnsray ethay aluevay ofway executingway "
"esultray (efaultsday otay ilnay)."

#: src/code/debug-int.lisp
msgid "??? Can't get name of debug-block's function."
msgstr "??? Ancay't etgay amenay ofway ebugday-ockblay's unctionfay."

#: src/code/debug-int.lisp
msgid ""
"Returns the symbol from interning DEBUG-VARIABLE-NAME in the package named\n"
"   by DEBUG-VARIABLE-PACKAGE."
msgstr ""
"Eturnsray ethay ymbolsay omfray interningway DEBUG-VARIABLE-NAME inway ethay "
"ackagepay amednay\n"
"   ybay DEBUG-VARIABLE-PACKAGE."

#: src/code/debug-int.lisp
msgid ""
"Returns the value stored for debug-variable in frame.  If the value is not\n"
"   :valid, then this signals an invalid-value error."
msgstr ""
"Eturnsray ethay aluevay toredsay orfay ebugday-ariablevay inway amefray.  "
"Ifway ethay aluevay isway otnay\n"
"   :alidvay, enthay isthay ignalssay anway invalidway-aluevay errorway."

#: src/code/debug-int.lisp
msgid ""
"Returns the value stored for debug-variable in frame.  The value may be\n"
"   invalid.  This is SETF'able."
msgstr ""
"Eturnsray ethay aluevay toredsay orfay ebugday-ariablevay inway amefray.  "
"Ethay aluevay aymay ebay\n"
"   invalidway.  Isthay isway SETF'ableway."

#: src/code/debug-int.lisp
msgid ""
"Returns three values reflecting the validity of debug-variable's value\n"
"   at basic-code-location:\n"
"      :valid    The value is known to be available.\n"
"      :invalid  The value is known to be unavailable.\n"
"      :unknown  The value's availability is unknown."
msgstr ""
"Eturnsray reethay aluesvay eflectingray ethay alidityvay ofway ebugday-"
"ariablevay's aluevay\n"
"   atway asicbay-odecay-ocationlay:\n"
"      :alidvay    Ethay aluevay isway nownkay otay ebay availableway.\n"
"      :invalidway  Ethay aluevay isway nownkay otay ebay unavailableway.\n"
"      :unknownway  Ethay aluevay's availabilityway isway unknownway."

#: src/code/debug-int.lisp
msgid ""
"This returns a table mapping form numbers to source-paths.  A source-path\n"
"   indicates a descent into the top-level-form form, going directly to the\n"
"   subform corressponding to the form number."
msgstr ""
"Isthay eturnsray away abletay appingmay ormfay umbersnay otay ourcesay-"
"athspay.  Away ourcesay-athpay\n"
"   indicatesway away escentday intoway ethay optay-evellay-ormfay ormfay, "
"oinggay irectlyday otay ethay\n"
"   ubformsay orresspondingcay otay ethay ormfay umbernay."

#: src/code/debug-int.lisp
msgid ""
"Form is a top-level form, and path is a source-path into it.  This returns\n"
"   the form indicated by the source-path.  Context is the number of "
"enclosing\n"
"   forms to return instead of directly returning the source-path form.  "
"When\n"
"   context is non-zero, the form returned contains a marker, #:"
"****HERE****,\n"
"   immediately before the form indicated by path."
msgstr ""
"Ormfay isway away optay-evellay ormfay, andway athpay isway away ourcesay-"
"athpay intoway itway.  Isthay eturnsray\n"
"   ethay ormfay indicatedway ybay ethay ourcesay-athpay.  Ontextcay isway "
"ethay umbernay ofway enclosinwayg\n"
"   ormsfay otay eturnray insteadway ofway irectlyday eturningray ethay "
"ourcesay-athpay ormfay.  Enwhay\n"
"   ontextcay isway onnay-erozay, ethay ormfay eturnedray ontainscay away "
"arkermay, #:****HERE****,\n"
"   immediatelyway eforebay ethay ormfay indicatedway ybay athpay."

#: src/code/debug.lisp src/code/debug-int.lisp
msgid "Source path no longer exists."
msgstr "Ourcesay athpay onay ongerlay existsway."

#: src/code/debug-int.lisp
msgid ""
"Return a function of one argument that evaluates form in the lexical\n"
"   context of the basic-code-location loc.  PREPROCESS-FOR-EVAL signals a\n"
"   no-debug-variables condition when the loc's debug-function has no\n"
"   debug-variable information available.  The returned function takes the "
"frame\n"
"   to get values from as its argument, and it returns the values of form.\n"
"   The returned function signals the following conditions: invalid-value,\n"
"   ambiguous-variable-name, and frame-function-mismatch"
msgstr ""
"Eturnray away unctionfay ofway oneway argumentway atthay evaluatesway ormfay "
"inway ethay exicallay\n"
"   ontextcay ofway ethay asicbay-odecay-ocationlay oclay.  PREPROCESS-FOR-"
"EVAL ignalssay away\n"
"   onay-ebugday-ariablesvay onditioncay enwhay ethay oclay's ebugday-"
"unctionfay ashay onay\n"
"   ebugday-ariablevay informationway availableway.  Ethay eturnedray "
"unctionfay akestay ethay amefray\n"
"   otay etgay aluesvay omfray asway itsway argumentway, andway itway "
"eturnsray ethay aluesvay ofway ormfay.\n"
"   Ethay eturnedray unctionfay ignalssay ethay ollowingfay onditionscay: "
"invalidway-aluevay,\n"
"   ambiguousway-ariablevay-amenay, andway amefray-unctionfay-ismatchmay"

#: src/code/debug-int.lisp
msgid ""
"Evaluate Form in the lexical context of Frame's current code location,\n"
"   returning the results of the evaluation."
msgstr ""
"Evaluateway Ormfay inway ethay exicallay ontextcay ofway Amefray's urrentcay "
"odecay ocationlay,\n"
"   eturningray ethay esultsray ofway ethay evaluationway."

#: src/code/debug-int.lisp
msgid "Find and return the debug catch tag for a given frame, if it exists."
msgstr ""
"Indfay andway eturnray ethay ebugday atchcay agtay orfay away ivengay "
"amefray, ifway itway existsway."

#: src/code/debug-int.lisp
msgid ""
"Evaluate Form in the lexical context of Frame's current code location,\n"
"   returning from the current frame the results of the evaluation."
msgstr ""
"Evaluateway Ormfay inway ethay exicallay ontextcay ofway Amefray's urrentcay "
"odecay ocationlay,\n"
"   eturningray omfray ethay urrentcay amefray ethay esultsray ofway ethay "
"evaluationway."

#: src/code/debug-int.lisp
msgid ""
"This creates and returns a breakpoint.  When program execution encounters\n"
"   the breakpoint, the system calls hook-function.  Hook-function takes the\n"
"   current frame for the function in which the program is running and the\n"
"   breakpoint object.\n"
"      What and kind determine where in a function the system invokes\n"
"   hook-function.  What is either a code-location or a debug-function.  Kind "
"is\n"
"   one of :code-location, :function-start, or :function-end.  Since the "
"starts\n"
"   and ends of functions may not have code-locations representing them,\n"
"   designate these places by supplying what as a debug-function and kind\n"
"   indicating the :function-start or :function-end.  When what is a\n"
"   debug-function and kind is :function-end, then hook-function must take "
"two\n"
"   additional arguments, a list of values returned by the function and a\n"
"   function-end-cookie.\n"
"      Info is information supplied by and used by the user.\n"
"      Function-end-cookie is a function.  To implement :function-end "
"breakpoints,\n"
"   the system uses starter breakpoints to establish the :function-end "
"breakpoint\n"
"   for each invocation of the function.  Upon each entry, the system creates "
"a\n"
"   unique cookie to identify the invocation, and when the user supplies a\n"
"   function for this argument, the system invokes it on the frame and the\n"
"   cookie.  The system later invokes the :function-end breakpoint hook on "
"the\n"
"   same cookie.  The user may save the cookie for comparison in the hook\n"
"   function.\n"
"      This signals an error if what is an unknown code-location."
msgstr ""
"Isthay eatescray andway eturnsray away eakpointbray.  Enwhay ogrampray "
"executionway encountersway\n"
"   ethay eakpointbray, ethay ystemsay allscay ookhay-unctionfay.  Ookhay-"
"unctionfay akestay ethay\n"
"   urrentcay amefray orfay ethay unctionfay inway ichwhay ethay ogrampray "
"isway unningray andway ethay\n"
"   eakpointbray objectway.\n"
"      Atwhay andway indkay etermineday erewhay inway away unctionfay ethay "
"ystemsay invokesway\n"
"   ookhay-unctionfay.  Atwhay isway eitherway away odecay-ocationlay orway "
"away ebugday-unctionfay.  Indkay isway\n"
"   oneway ofway :odecay-ocationlay, :unctionfay-tartsay, orway :unctionfay-"
"endway.  Incesay ethay tartssay\n"
"   andway endsway ofway unctionsfay aymay otnay avehay odecay-ocationslay "
"epresentingray emthay,\n"
"   esignateday esethay acesplay ybay upplyingsay atwhay asway away ebugday-"
"unctionfay andway indkay\n"
"   indicatingway ethay :unctionfay-tartsay orway :unctionfay-endway.  Enwhay "
"atwhay isway away\n"
"   ebugday-unctionfay andway indkay isway :unctionfay-endway, enthay ookhay-"
"unctionfay ustmay aketay wotay\n"
"   additionalway argumentsway, away istlay ofway aluesvay eturnedray ybay "
"ethay unctionfay andway away\n"
"   unctionfay-endway-ookiecay.\n"
"      Infoway isway informationway uppliedsay ybay andway usedway ybay ethay "
"userway.\n"
"      Unctionfay-endway-ookiecay isway away unctionfay.  Otay implementway :"
"unctionfay-endway eakpointsbray,\n"
"   ethay ystemsay usesway tartersay eakpointsbray otay establishway ethay :"
"unctionfay-endway eakpointbray\n"
"   orfay eachway invocationway ofway ethay unctionfay.  Uponway eachway "
"entryway, ethay ystemsay eatescray away\n"
"   uniqueway ookiecay otay identifyway ethay invocationway, andway enwhay "
"ethay userway uppliessay away\n"
"   unctionfay orfay isthay argumentway, ethay ystemsay invokesway itway "
"onway ethay amefray andway ethay\n"
"   ookiecay.  Ethay ystemsay aterlay invokesway ethay :unctionfay-endway "
"eakpointbray ookhay onway ethay\n"
"   amesay ookiecay.  Ethay userway aymay avesay ethay ookiecay orfay "
"omparisoncay inway ethay ookhay\n"
"   unctionfay.\n"
"      Isthay ignalssay anway errorway ifway atwhay isway anway unknownway "
"odecay-ocationlay."

#: src/code/debug-int.lisp
msgid "Cannot make a breakpoint at an unknown code location -- ~S."
msgstr ""
"Annotcay akemay away eakpointbray atway anway unknownway odecay ocationlay "
"-- ~S."

#: src/code/debug-int.lisp
msgid "Breakpoints in interpreted code are currently unsupported."
msgstr ""
"Eakpointsbray inway interpretedway odecay areway urrentlycay unsupportedway."

#: src/code/debug-int.lisp
msgid ""
":FUNCTION-END breakpoints are currently unsupported ~\n"
"\t\t       for the known return convention."
msgstr ""
":FUNCTION-END eakpointsbray areway urrentlycay unsupportedway ~\n"
"\t\t       orfay ethay nownkay eturnray onventioncay."

#: src/code/debug-int.lisp
msgid ""
":function-end breakpoints are currently unsupported ~\n"
"\t     for interpreted-debug-functions."
msgstr ""
":unctionfay-endway eakpointsbray areway urrentlycay unsupportedway ~\n"
"\t     orfay interpretedway-ebugday-unctionsfay."

#: src/code/debug-int.lisp
msgid ""
"This takes a function-end-cookie and a frame, and it returns whether the\n"
"   cookie is still valid.  A cookie becomes invalid when the frame that\n"
"   established the cookie has exited.  Sometimes cookie holders are unaware\n"
"   of cookie invalidation because their :function-end breakpoint hooks "
"didn't\n"
"   run due to THROW'ing.  This takes a frame as an efficiency hack since "
"the\n"
"   user probably has a frame object in hand when using this routine, and it\n"
"   saves repeated parsing of the stack and consing when asking whether a\n"
"   series of cookies is valid."
msgstr ""
"Isthay akestay away unctionfay-endway-ookiecay andway away amefray, andway "
"itway eturnsray etherwhay ethay\n"
"   ookiecay isway tillsay alidvay.  Away ookiecay ecomesbay invalidway "
"enwhay ethay amefray atthay\n"
"   establishedway ethay ookiecay ashay exitedway.  Ometimessay ookiecay "
"oldershay areway unawareway\n"
"   ofway ookiecay invalidationway ecausebay eirthay :unctionfay-endway "
"eakpointbray ookshay idnday't\n"
"   unray ueday otay THROW'ingway.  Isthay akestay away amefray asway anway "
"efficiencyway ackhay incesay ethay\n"
"   userway obablypray ashay away amefray objectway inway andhay enwhay "
"usingway isthay outineray, andway itway\n"
"   avessay epeatedray arsingpay ofway ethay tacksay andway onsingcay enwhay "
"askingway etherwhay away\n"
"   eriessay ofway ookiescay isway alidvay."

#: src/code/debug-int.lisp
msgid ""
"This causes the system to invoke the breakpoint's hook-function until the\n"
"   next call to DEACTIVATE-BREAKPOINT or DELETE-BREAKPOINT.  The system "
"invokes\n"
"   breakpoint hook functions in the opposite order that you activate them."
msgstr ""
"Isthay ausescay ethay ystemsay otay invokeway ethay eakpointbray's ookhay-"
"unctionfay untilway ethay\n"
"   extnay allcay otay DEACTIVATE-BREAKPOINT orway DELETE-BREAKPOINT.  Ethay "
"ystemsay invokesway\n"
"   eakpointbray ookhay unctionsfay inway ethay oppositeway orderway atthay "
"ouyay activateway emthay."

#: src/code/debug-int.lisp
msgid "Cannot activate a deleted breakpoint -- ~S."
msgstr "Annotcay activateway away eletedday eakpointbray -- ~S."

#: src/code/debug-int.lisp
msgid "I don't know how you made this, but they're unsupported -- ~S"
msgstr ""
"Iway onday't nowkay owhay ouyay ademay isthay, utbay eythay'eray "
"unsupportedway -- ~S"

#: src/code/debug-int.lisp
msgid "This stops the system from invoking the breakpoint's hook-function."
msgstr ""
"Isthay topssay ethay ystemsay omfray invokingway ethay eakpointbray's ookhay-"
"unctionfay."

#: src/code/debug-int.lisp
msgid ""
"This returns the user maintained info associated with breakpoint.  This\n"
"   is SETF'able."
msgstr ""
"Isthay eturnsray ethay userway aintainedmay infoway associatedway ithway "
"eakpointbray.  Isthay\n"
"   isway SETF'ableway."

#: src/code/debug-int.lisp
msgid "This returns whether breakpoint is currently active."
msgstr "Isthay eturnsray etherwhay eakpointbray isway urrentlycay activeway."

#: src/code/debug-int.lisp
msgid ""
"This frees system storage and removes computational overhead associated "
"with\n"
"   breakpoint.  After calling this, breakpoint is completely impotent and "
"can\n"
"   never become active again."
msgstr ""
"Isthay eesfray ystemsay toragesay andway emovesray omputationalcay "
"overheadway associatedway ithway\n"
"   eakpointbray.  Afterway allingcay isthay, eakpointbray isway ompletelycay "
"impotentway andway ancay\n"
"   evernay ecomebay activeway againway."

#: src/code/debug-int.lisp
msgid "Unknown breakpoint in ~S at offset ~S."
msgstr "Unknownway eakpointbray inway ~S atway offsetway ~S."

#: src/code/debug-int.lisp
msgid ""
"Make a bogus LRA object that signals a breakpoint trap when returned to.  "
"If\n"
"   the breakpoint trap handler returns, REAL-LRA is returned to.  Three "
"values\n"
"   are returned: the bogus LRA object, the code component it is part of, "
"and\n"
"   the PC offset for the trap instruction."
msgstr ""
"Akemay away ogusbay LRA objectway atthay ignalssay away eakpointbray aptray "
"enwhay eturnedray otay.  Ifway\n"
"   ethay eakpointbray aptray andlerhay eturnsray, REAL-LRA isway eturnedray "
"otay.  Reethay aluesvay\n"
"   areway eturnedray: ethay ogusbay LRA objectway, ethay odecay omponentcay "
"itway isway artpay ofway, andway\n"
"   ethay PC offsetway orfay ethay aptray instructionway."

#: src/code/debug-int.lisp
msgid ""
"The editor calls this remotely in the slave to set breakpoints.  Package is\n"
"   the string name of a package or nil, and name-str is a string "
"representing a\n"
"   function name (for example, \"foo\" or \"(setf foo)\").  After finding\n"
"   package, this READs name-str with *package* bound appropriately.  Path "
"is\n"
"   either a modified source-path or a symbol (:function-start or\n"
"   :function-end).  If it is a modified source-path, it has no top-level-"
"form\n"
"   offset or form-number component, and it is in descent order from the root "
"of\n"
"   the top-level form."
msgstr ""
"Ethay editorway allscay isthay emotelyray inway ethay aveslay otay etsay "
"eakpointsbray.  Ackagepay isway\n"
"   ethay ingstray amenay ofway away ackagepay orway ilnay, andway amenay-"
"trsay isway away ingstray epresentinrayg away\n"
"   unctionfay amenay (orfay exampleway, \"oofay\" orway \"(etfsay "
"oofay)\").  Afterway indingfay\n"
"   ackagepay, isthay Eadsray amenay-trsay ithway *package* oundbay "
"appropriatelyway.  Athpay isway\n"
"   eitherway away odifiedmay ourcesay-athpay orway away ymbolsay (:"
"unctionfay-tartsay orway\n"
"   :unctionfay-endway).  Ifway itway isway away odifiedmay ourcesay-athpay, "
"itway ashay onay optay-evellay-orfaym\n"
"   offsetway orway ormfay-umbernay omponentcay, andway itway isway inway "
"escentday orderway omfray ethay ootray ofway\n"
"   ethay optay-evellay ormfay."

#: src/code/debug-int.lisp
msgid "Editor installed breakpoint."
msgstr "Editorway installedway eakpointbray."

#: src/code/debug-int.lisp
msgid "We don't currently support breakpoints in interpreted code."
msgstr ""
"Eway onday't urrentlycay upportsay eakpointsbray inway interpretedway odecay."

#: src/code/debug-int.lisp
msgid ""
"~%Cannot set breakpoints for editor when source file no ~\n"
"\t\t    longer exists:~%  ~A."
msgstr ""
"~%Annotcay etsay eakpointsbray orfay editorway enwhay ourcesay ilefay onay "
"~\n"
"\t\t    ongerlay existsway:~%  ~Away."

#: src/code/debug-int.lisp
msgid ""
"~%While setting a breakpoint for the editor, noticed ~\n"
"\t\t\tsource file has been modified since compilation:~%  ~A~@\n"
"\t\t\tUsing form offset instead of character position.~%"
msgstr ""
"~%Ilewhay ettingsay away eakpointbray orfay ethay editorway, oticednay ~\n"
"\t\t\tourcesay ilefay ashay eenbay odifiedmay incesay ompilationcay:~%  "
"~Away~@\n"
"\t\t\tUsingway ormfay offsetway insteadway ofway aracterchay ositionpay.~%"

#: src/code/debug-int.lisp
msgid ""
"Cannot set breakpoints for editor when ~\n"
"\t\t\t\t   there is no start positions map."
msgstr ""
"Annotcay etsay eakpointsbray orfay editorway enwhay ~\n"
"\t\t\t\t   erethay isway onay tartsay ositionspay apmay."

#: src/code/debug-int.lisp
msgid ""
"The editor calls this in the slave with a remote-object representing a\n"
"   code-location to set a breakpoint."
msgstr ""
"Ethay editorway allscay isthay inway ethay aveslay ithway away emoteray-"
"objectway epresentingray away\n"
"   odecay-ocationlay otay etsay away eakpointbray."

#: src/code/debug-int.lisp
msgid "The editor calls this remotely in the slave to delete a breakpoint."
msgstr ""
"Ethay editorway allscay isthay emotelyray inway ethay aveslay otay eleteday "
"away eakpointbray."

#: src/code/debug-int.lisp
msgid ""
"This returns a code-location before the body of a function and after all\n"
"   the arguments are in place.  If this cannot determine that location due "
"to\n"
"   a lack of debug information, it returns nil."
msgstr ""
"Isthay eturnsray away odecay-ocationlay eforebay ethay odybay ofway away "
"unctionfay andway afterway allway\n"
"   ethay argumentsway areway inway aceplay.  Ifway isthay annotcay "
"etermineday atthay ocationlay ueday otay\n"
"   away acklay ofway ebugday informationway, itway eturnsray ilnay."

#: src/code/debug-int.lisp
msgid "~S code location at ~D"
msgstr "~S odecay ocationlay atway ~D"

#: src/code/debug.lisp
msgid ""
"*PRINT-LEVEL* is bound to this value when debug prints a function call.  If\n"
"  null, use *PRINT-LEVEL*"
msgstr ""
"*PRINT-LEVEL* isway oundbay otay isthay aluevay enwhay ebugday intspray away "
"unctionfay allcay.  Ifway\n"
"  ullnay, useway *PRINT-LEVEL*"

#: src/code/debug.lisp
msgid ""
"*PRINT-LENGTH* is bound to this value when debug prints a function call.  "
"If\n"
"  null, use *PRINT-LENGTH*."
msgstr ""
"*PRINT-LENGTH* isway oundbay otay isthay aluevay enwhay ebugday intspray "
"away unctionfay allcay.  Ifway\n"
"  ullnay, useway *PRINT-LENGTH*."

#: src/code/debug.lisp
msgid ""
"default value for the verbose argument to print-frame-call.  If set to >= 2, "
"source will be printed for all frames"
msgstr ""
"efaultday aluevay orfay ethay erbosevay argumentway otay intpray-amefray-"
"allcay.  Ifway etsay otay >= 2, ourcesay illway ebay intedpray orfay allway "
"amesfray"

#: src/code/debug.lisp
msgid "This is T while in the debugger."
msgstr "Isthay isway T ilewhay inway ethay ebuggerday."

#: src/code/debug.lisp
msgid "Pushes and pops/exits inside the debugger change this."
msgstr ""
"Ushespay andway opspay/exitsway insideway ethay ebuggerday angechay isthay."

#: src/code/debug.lisp
msgid ""
"If this is bound before the debugger is invoked, it is used as the stack\n"
"   top by the debugger."
msgstr ""
"Ifway isthay isway oundbay eforebay ethay ebuggerday isway invokedway, itway "
"isway usedway asway ethay tacksay\n"
"   optay ybay ethay ebuggerday."

#: src/code/debug.lisp
msgid ""
"This is a function of no arguments that prints the debugger prompt\n"
"   on *debug-io*."
msgstr ""
"Isthay isway away unctionfay ofway onay argumentsway atthay intspray ethay "
"ebuggerday omptpray\n"
"   onway *debug-io*."

#: src/code/debug.lisp
msgid ""
"When true, the LIST-LOCATIONS command only displays block start locations.\n"
"   Otherwise, all locations are displayed."
msgstr ""
"Enwhay uetray, ethay LIST-LOCATIONS ommandcay onlyway isplaysday ockblay "
"tartsay ocationslay.\n"
"   Otherwiseway, allway ocationslay areway isplayedday."

#: src/code/debug.lisp
msgid "If true, list the code location type in the LIST-LOCATIONS command."
msgstr ""
"Ifway uetray, istlay ethay odecay ocationlay ypetay inway ethay LIST-"
"LOCATIONS ommandcay."

#: src/code/debug.lisp
msgid "~%Unknown location: using block start.~%"
msgstr "~%Unknownway ocationlay: usingway ockblay tartsay.~%"

#: src/code/debug.lisp
msgid "~&~S: ~S in ~S"
msgstr "~&~S: ~S inway ~S"

#: src/code/debug.lisp
msgid "~&~S: FUNCTION-START in ~S"
msgstr "~&~S: FUNCTION-START inway ~S"

#: src/code/debug.lisp
msgid "~&~S: FUNCTION-END in ~S"
msgstr "~&~S: FUNCTION-END inway ~S"

#: src/code/debug.lisp
msgid "~%Return values: ~S"
msgstr "~%Eturnray aluesvay: ~S"

#: src/code/debug.lisp
msgid "~&*Step (to a breakpoint)*"
msgstr "~&step*ay (otay away eakpointbray)*"

#: src/code/debug.lisp
msgid "*Step*"
msgstr "*Step*"

#: src/code/debug.lisp
msgid "~&*Breakpoint hit*"
msgstr "~&breakpoint*ay it*hay"

#: src/code/debug.lisp
msgid "Error in main-hook-function: unknown breakpoint"
msgstr "Errorway inway ainmay-ookhay-unctionfay: unknownway eakpointbray"

#: src/code/debug.lisp
msgid "Cannot step, in elsewhere code~%"
msgstr "Annotcay tepsay, inway elsewhereway odecay~%"

#: src/code/debug.lisp
msgid ""
"Currently only compiled code can be stepped.~%~\n"
"                Trying to compile the passed form resulted in ~\n"
"                the following error:~%  ~A"
msgstr ""
"Urrentlycay onlyway ompiledcay odecay ancay ebay teppedsay.~%~\n"
"                Yingtray otay ompilecay ethay assedpay ormfay esultedray "
"inway ~\n"
"                ethay ollowingfay errorway:~%  ~Away"

#: src/code/debug.lisp
msgid "~2&Stepping the form~%  ~S~%"
msgstr "~2&Teppingsay ethay ormfay~%  ~S~%"

#: src/code/debug.lisp
msgid "~&using the debugger.  Type HELP for help.~2%"
msgstr "~&usingway ethay ebuggerday.  Ypetay HELP orfay elphay.~2%"

#: src/code/debug.lisp
msgid ""
"STEP implements a debugging paradigm wherein the programmer is allowed\n"
"   to step through the evaluation of a form.  We use the debugger's "
"stepping\n"
"   facility to step through an anonymous function containing only form.\n"
"\n"
"   Currently the stepping facility only supports stepping compiled code,\n"
"   so step will try to compile the resultant anonymous function.  If this\n"
"   fails, e.g. because it closes over a non-null lexical environment, an\n"
"   error is signalled."
msgstr ""
"STEP implementsway away ebuggingday aradigmpay ereinwhay ethay ogrammerpray "
"isway allowedway\n"
"   otay tepsay roughthay ethay evaluationway ofway away ormfay.  Eway useway "
"ethay ebuggerday's teppingsay\n"
"   acilityfay otay tepsay roughthay anway anonymousway unctionfay "
"ontainingcay onlyway ormfay.\n"
"\n"
"   Urrentlycay ethay teppingsay acilityfay onlyway upportssay teppingsay "
"ompiledcay odecay,\n"
"   osay tepsay illway ytray otay ompilecay ethay esultantray anonymousway "
"unctionfay.  Ifway isthay\n"
"   ailsfay, e.g. ecausebay itway osesclay overway away onnay-ullnay "
"exicallay environmentway, anway\n"
"   errorway isway ignalledsay."

#: src/code/debug.lisp
msgid ""
"Show a listing of the call stack going down from the current frame.  In the\n"
"   debugger, the current frame is indicated by the prompt.  Count is how "
"many\n"
"   frames to show."
msgstr ""
"Owshay away istinglay ofway ethay allcay tacksay oinggay ownday omfray ethay "
"urrentcay amefray.  Inway ethay\n"
"   ebuggerday, ethay urrentcay amefray isway indicatedway ybay ethay "
"omptpray.  Ountcay isway owhay anymay\n"
"   amesfray otay owshay."

#: src/code/debug.lisp
msgid "unavaliable-rest-arg"
msgstr "unavaliableway-estray-argway"

#: src/code/debug.lisp
msgid "lambda-list-unavailable"
msgstr "ambdalay-istlay-unavailableway"

#: src/code/debug.lisp
msgid "error printing object {~X}"
msgstr "errorway intingpray objectway {~X}"

#: src/code/debug.lisp
msgid "unused-arg"
msgstr "unusedway-argway"

#: src/code/debug.lisp
msgid "unavailable-arg"
msgstr "unavailableway-argway"

#: src/code/debug.lisp
msgid "~%Source: "
msgstr "~%Ourcesay: "

#: src/code/debug.lisp
msgid "Error finding source: ~A"
msgstr "Errorway indingfay ourcesay: ~Away"

#: src/code/debug.lisp
msgid "Unable to display error condition~@[: ~A~]"
msgstr "Unableway otay isplayday errorway onditioncay~@[: ~Away~]"

#: src/code/debug.lisp
msgid ""
"This is either nil or a function of two arguments, a condition and the "
"value\n"
"   of *debugger-hook*.  This function can either handle the condition or "
"return\n"
"   which causes the standard debugger to execute.  The system passes the "
"value\n"
"   of this variable to the function because it binds *debugger-hook* to nil\n"
"   around the invocation."
msgstr ""
"Isthay isway eitherway ilnay orway away unctionfay ofway wotay argumentsway, "
"away onditioncay andway ethay aluevay\n"
"   ofway *debugger-hook*.  Isthay unctionfay ancay eitherway andlehay ethay "
"onditioncay orway eturnray\n"
"   ichwhay ausescay ethay tandardsay ebuggerday otay executeway.  Ethay "
"ystemsay assespay ethay aluevay\n"
"   ofway isthay ariablevay otay ethay unctionfay ecausebay itway indsbay "
"*debugger-hook* otay ilnay\n"
"   aroundway ethay invocationway."

#: src/code/debug.lisp
msgid "~2&~A~%   [Condition of type ~S]~2&"
msgstr "~2&~Away~%   [Onditioncay ofway ypetay ~S]~2&"

#: src/code/debug.lisp
msgid "The CMU Common Lisp debugger.  Type h for help."
msgstr "Ethay CMU Ommoncay Isplay ebuggerday.  Ypetay h orfay elphay."

#: src/code/debug.lisp
msgid "~&Restarts:~%"
msgstr "~&Estartsray:~%"

#: src/code/debug.lisp
msgid "~2&Debug  (type H for help)~2%"
msgstr "~2&Ebugday  (ypetay H orfay elphay)~2%"

#: src/code/debug.lisp
msgid ""
"When set, avoid calling INVOKE-DEBUGGER recursively when errors occur while\n"
"   executing in the debugger.  The 'flush' command toggles this."
msgstr ""
"Enwhay etsay, avoidway allingcay INVOKE-DEBUGGER ecursivelyray enwhay "
"errorsway occurway ilewhay\n"
"   executingway inway ethay ebuggerday.  Ethay 'ushflay' ommandcay ogglestay "
"isthay."

#: src/code/debug.lisp
msgid ""
"When non-NIL, becomes the system *READTABLE* in the debugger\n"
"   read-eval-print loop"
msgstr ""
"Enwhay onnay-NIL, ecomesbay ethay ystemsay *READTABLE* inway ethay "
"ebuggerday\n"
"   eadray-evalway-intpray ooplay"

#: src/code/debug.lisp
msgid "When non-NIL, print the current frame when entering the debugger."
msgstr ""
"Enwhay onnay-NIL, intpray ethay urrentcay amefray enwhay enteringway ethay "
"ebuggerday."

#: src/code/debug.lisp
msgid "Unknown stream-command -- ~S."
msgstr "Unknownway eamstray-ommandcay -- ~S."

#: src/code/debug.lisp
msgid "Ambiguous debugger command: ~S."
msgstr "Ambiguousway ebuggerday ommandcay: ~S."

#: src/code/debug.lisp
msgid "~&Your command, ~S, is ambiguous:~%"
msgstr "~&Ouryay ommandcay, ~S, isway ambiguousway:~%"

#: src/code/debug.lisp
msgid "Return to debug level ~D."
msgstr "Eturnray otay ebugday evellay ~D."

#: src/code/debug.lisp
msgid "~&Error flushed ..."
msgstr "~&Errorway ushedflay ..."

#: src/code/debug.lisp
msgid ""
"When set (the default), evaluations in the debugger's command loop occur\n"
"   relative to the current frame's environment without the need of debugger\n"
"   forms that explicitly control this kind of evaluation."
msgstr ""
"Enwhay etsay (ethay efaultday), evaluationsway inway ethay ebuggerday's "
"ommandcay ooplay occurway\n"
"   elativeray otay ethay urrentcay amefray's environmentway ithoutway ethay "
"eednay ofway ebuggerday\n"
"   ormsfay atthay explicitlyway ontrolcay isthay indkay ofway evaluationway."

#: src/code/debug.lisp
msgid "Setting * to NIL -- was unbound marker."
msgstr "Ettingsay * otay NIL -- asway unboundway arkermay."

#: src/code/debug.lisp
msgid ""
"Returns a variable's value if possible.  Name is a simple-string or symbol.\n"
"   If it is a simple-string, it is an initial substring of the variable's "
"name.\n"
"   If name is a symbol, it has the same name and package as the variable "
"whose\n"
"   value this function returns.  If the symbol is uninterned, then the "
"variable\n"
"   has the same name as the symbol, but it has no package.\n"
"\n"
"   If name is the initial substring of variables with different names, then\n"
"   this return no values after displaying the ambiguous names.  If name\n"
"   determines multiple variables with the same name, then you must use the\n"
"   optional id argument to specify which one you want.  If you left id\n"
"   unspecified, then this returns no values after displaying the "
"distinguishing\n"
"   id values.\n"
"\n"
"   The result of this function is limited to the availability of variable\n"
"   information.  This is SETF'able."
msgstr ""
"Eturnsray away ariablevay's aluevay ifway ossiblepay.  Amenay isway away "
"implesay-ingstray orway ymbolsay.\n"
"   Ifway itway isway away implesay-ingstray, itway isway anway initialway "
"ubstringsay ofway ethay ariablevay's amenay.\n"
"   Ifway amenay isway away ymbolsay, itway ashay ethay amesay amenay andway "
"ackagepay asway ethay ariablevay osewhay\n"
"   aluevay isthay unctionfay eturnsray.  Ifway ethay ymbolsay isway "
"uninternedway, enthay ethay ariablevay\n"
"   ashay ethay amesay amenay asway ethay ymbolsay, utbay itway ashay onay "
"ackagepay.\n"
"\n"
"   Ifway amenay isway ethay initialway ubstringsay ofway ariablesvay ithway "
"ifferentday amesnay, enthay\n"
"   isthay eturnray onay aluesvay afterway isplayingday ethay ambiguousway "
"amesnay.  Ifway amenay\n"
"   eterminesday ultiplemay ariablesvay ithway ethay amesay amenay, enthay "
"ouyay ustmay useway ethay\n"
"   optionalway idway argumentway otay ecifyspay ichwhay oneway ouyay "
"antway.  Ifway ouyay eftlay idway\n"
"   unspecifiedway, enthay isthay eturnsray onay aluesvay afterway "
"isplayingday ethay istinguishdayingway\n"
"   idway aluesvay.\n"
"\n"
"   Ethay esultray ofway isthay unctionfay isway imitedlay otay ethay "
"availabilityway ofway ariablevay\n"
"   informationway.  Isthay isway SETF'ableway."

#: src/code/debug.lisp
msgid "No known valid variables match ~S."
msgstr "Onay nownkay alidvay ariablesvay atchmay ~S."

#: src/code/debug.lisp
msgid "Specification ambiguous:~%~{   ~A~%~}"
msgstr "Ecificationspay ambiguousway:~%~{   ~Away~%~}"

#: src/code/debug.lisp
msgid "Invalid variable ID, ~D, should have been one of ~S."
msgstr "Invalidway ariablevay ID, ~D, ouldshay avehay eenbay oneway ofway ~S."

#: src/code/debug.lisp
msgid "Specify variable ID to disambiguate ~S.  Use one of ~S."
msgstr ""
"Ecifyspay ariablevay ID otay isambiguateday ~S.  Useway oneway ofway ~S."

#: src/code/debug.lisp
msgid ""
"Returns the n'th argument's value if possible.  Argument zero is the first\n"
"   argument in a frame's default printed representation.  Count keyword/"
"value\n"
"   pairs as separate arguments."
msgstr ""
"Eturnsray ethay n'thay argumentway's aluevay ifway ossiblepay.  Argumentway "
"erozay isway ethay irstfay\n"
"   argumentway inway away amefray's efaultday intedpray epresentationray.  "
"Ountcay eywordkay/aluvaye\n"
"   airspay asway eparatesay argumentsway."

#: src/code/debug.lisp
msgid "Unused arguments have no values."
msgstr "Unusedway argumentsway avehay onay aluesvay."

#: src/code/debug.lisp
msgid "Invalid argument value."
msgstr "Invalidway argumentway aluevay."

#: src/code/debug.lisp
msgid "No argument values are available."
msgstr "Onay argumentway aluesvay areway availableway."

#: src/code/debug.lisp
msgid "Unused rest-arg before n'th argument."
msgstr "Unusedway estray-argway eforebay n'thay argumentway."

#: src/code/debug.lisp
msgid "Argument specification out of range -- ~S."
msgstr "Argumentway ecificationspay outway ofway angeray -- ~S."

#: src/code/debug.lisp
msgid "Invalid rest-arg before n'th argument."
msgstr "Invalidway estray-argway eforebay n'thay argumentway."

#: src/code/debug.lisp
msgid "Unknown debug command name -- ~S"
msgstr "Unknownway ebugday ommandcay amenay -- ~S"

#: src/code/debug.lisp
msgid "Invoking debugger command while outside the debugger."
msgstr "Invokingway ebuggerday ommandcay ilewhay outsideway ethay ebuggerday."

#: src/code/debug.lisp
msgid "~&Top of stack."
msgstr "~&Optay ofway tacksay."

#: src/code/debug.lisp
msgid "~&Bottom of stack."
msgstr "~&Ottombay ofway tacksay."

#: src/code/debug.lisp
msgid "You are here."
msgstr "Ouyay areway erehay."

#: src/code/debug.lisp
msgid "Bottom of stack encountered."
msgstr "Ottombay ofway tacksay encounteredway."

#: src/code/debug.lisp
msgid "Top of stack encountered."
msgstr "Optay ofway tacksay encounteredway."

#: src/code/debug.lisp
msgid "Frame number: "
msgstr "Amefray umbernay: "

#: src/code/debug.lisp
msgid ""
"~@<can't find a tag for this frame ~\n"
"                   ~2I~_(hint: try increasing the DEBUG optimization quality "
"~\n"
"                   and recompiling)~:@>"
msgstr ""
"~@<ancay't indfay away agtay orfay isthay amefray ~\n"
"                   ~2Iway~_(inthay: ytray increasingway ethay DEBUG "
"optimizationway alityquay ~\n"
"                   andway ecompilingray)~:@>"

#: src/code/debug.lisp
msgid "debug-return: "
msgstr "ebugday-eturnray: "

#: src/code/debug.lisp
msgid "No restart named continue."
msgstr "Onay estartray amednay ontinuecay."

#: src/code/debug.lisp
msgid "Restart: "
msgstr "Estartray: "

#: src/code/debug.lisp
msgid "No such restart."
msgstr "Onay uchsay estartray."

#: src/code/debug.lisp
msgid "~S is invalid as a restart name.~%"
msgstr "~S isway invalidway asway away estartray amenay.~%"

#: src/code/debug.lisp
msgid ""
"This controls how many lines the debugger's help command prints before\n"
"   printing a prompting line to continue with output."
msgstr ""
"Isthay ontrolscay owhay anymay ineslay ethay ebuggerday's elphay ommandcay "
"intspray eforebay\n"
"   intingpray away omptingpray inelay otay ontinuecay ithway outputway."

#: src/code/debug.lisp
msgid "~%[RETURN FOR MORE, Q TO QUIT HELP TEXT]: "
msgstr "~%[RETURN FOR MORE, Q TO QUIT HELP TEXT]: "

#: src/code/debug.lisp
msgid ""
"No local variables ~@[starting with ~A ~]~\n"
"\t               in function."
msgstr ""
"Onay ocallay ariablesvay ~@[tartingsay ithway ~Away ~]~\n"
"\t               inway unctionfay."

#: src/code/debug.lisp
msgid ""
"All variables ~@[starting with ~A ~]currently ~\n"
"\t               have invalid values."
msgstr ""
"Allway ariablesvay ~@[tartingsay ithway ~Away ~]urrentlycay ~\n"
"\t               avehay invalidway aluesvay."

#: src/code/debug.lisp
msgid "No variable information available."
msgstr "Onay ariablevay informationway availableway."

#: src/code/debug.lisp
msgid "Source file no longer exists:~%  ~A."
msgstr "Ourcesay ilefay onay ongerlay existsway:~%  ~Away."

#: src/code/debug.lisp
msgid "~%; File: ~A~%"
msgstr "~%; Ilefay: ~Away~%"

#: src/code/debug.lisp
msgid ""
"~%; File has been modified since compilation:~%;   ~A~@\n"
"\t\t ; Using form offset instead of character position.~%"
msgstr ""
"~%; Ilefay ashay eenbay odifiedmay incesay ompilationcay:~%;   ~Away~@\n"
"\t\t ; Usingway ormfay offsetway insteadway ofway aracterchay ositionpay.~%"

#: src/code/debug.lisp
msgid "No start positions map."
msgstr "Onay tartsay ositionspay apmay."

#: src/code/debug.lisp
msgid "Couldn't continue."
msgstr "Ouldncay't ontinuecay."

#: src/code/debug.lisp
msgid "::FUNCTION-START "
msgstr "::FUNCTION-START "

#: src/code/debug.lisp
msgid " *Active*"
msgstr " *Active*"

#: src/code/debug.lisp
msgid " *Continue here*"
msgstr " continue*ay ere*hay"

#: src/code/debug.lisp
msgid "~&::FUNCTION-END *Active* "
msgstr "~&::FUNCTION-END *Active* "

#: src/code/debug.lisp
msgid "Note: previous breakpoint removed.~%"
msgstr "Otenay: eviouspray eakpointbray emovedray.~%"

#: src/code/debug.lisp
msgid "~&Added."
msgstr "~&Addedway."

#: src/code/debug.lisp
msgid "Location number, :start, or :end: "
msgstr "Ocationlay umbernay, :tartsay, orway :endway: "

#: src/code/debug.lisp
msgid "Breakpoint ~S removed.~%"
msgstr "Eakpointbray ~S emovedray.~%"

#: src/code/debug.lisp
msgid "Breakpoint doesn't exist."
msgstr "Eakpointbray oesnday't existway."

#: src/code/debug.lisp
msgid "All breakpoints deleted.~%"
msgstr "Allway eakpointsbray eletedday.~%"

#: src/code/debug.lisp
msgid "Errors now flushed."
msgstr "Errorsway ownay ushedflay."

#: src/code/debug.lisp
msgid "Errors now create nested debug levels."
msgstr "Errorsway ownay eatecray estednay ebugday evelslay."

#: src/code/debug.lisp
msgid "Can't figure out the function for this frame."
msgstr "Ancay't igurefay outway ethay unctionfay orfay isthay amefray."

#: src/code/debug.lisp
msgid ""
"The debugger's EDIT-SOURCE command only works in slave Lisps ~\n"
"\t    connected to a Hemlock editor."
msgstr ""
"Ethay ebuggerday's EDIT-SOURCE ommandcay onlyway orksway inway aveslay "
"Ispslay ~\n"
"\t    onnectedcay otay away Emlockhay editorway."

#: src/code/query.lisp
msgid ""
"Y-OR-N-P prints the message, if any, and reads characters from *QUERY-IO*\n"
"   until the user enters y or Y as an affirmative, or either n or N as a\n"
"   negative answer.  It ignores preceding whitespace and asks again if you\n"
"   enter any other characters."
msgstr ""
"Y-OR-N-P intspray ethay essagemay, ifway anyway, andway eadsray aracterschay "
"omfray *QUERY-IO*\n"
"   untilway ethay userway entersway y orway Y asway anway affirmativeway, "
"orway eitherway n orway N asway away\n"
"   egativenay answerway.  Itway ignoresway ecedingpray itespacewhay andway "
"asksway againway ifway ouyay\n"
"   enterway anyway otherway aracterschay."

#: src/code/query.lisp
msgid "Type \"y\" for yes or \"n\" for no. "
msgstr "Ypetay \"y\" orfay esyay orway \"n\" orfay onay. "

#: src/code/query.lisp
msgid ""
"YES-OR-NO-P is similar to Y-OR-N-P, except that it clears the \n"
"   input buffer, beeps, and uses READ-LINE to get the strings \n"
"   YES or NO."
msgstr ""
"YES-OR-NO-P isway imilarsay otay Y-OR-N-P, exceptway atthay itway earsclay "
"ethay \n"
"   inputway ufferbay, eepsbay, andway usesway READ-LINE otay etgay ethay "
"ingsstray \n"
"   YES orway NO."

#: src/code/query.lisp
msgid "Type \"yes\" for yes or \"no\" for no. "
msgstr "Ypetay \"esyay\" orfay esyay orway \"onay\" orfay onay. "

#: src/code/rand-xoroshiro.lisp
#, fuzzy
msgid ""
"Generate an random state vector from the given SEED.  The seed can be\n"
"  either an integer or a vector of (unsigned-byte 64)"
msgstr ""
"Enerategay anway andomray tatesay ectorvay omfray ethay ivengay SEED.  Ethay "
"eedsay ancay ebay\n"
"  eitherway anway integerway orway away ectorvay ofway (unsignedway-ytebay "
"32)"

#: src/code/rand-xoroshiro.lisp
msgid ""
"Make a random state object.  If STATE is not supplied, return a copy\n"
"  of the default random state.  If STATE is a random state, then return a\n"
"  copy of it.  If STATE is T then return a random state generated from\n"
"  the universal time or /dev/urandom if available."
msgstr ""
"Akemay away andomray tatesay objectway.  Ifway STATE isway otnay uppliedsay, "
"eturnray away opycay\n"
"  ofway ethay efaultday andomray tatesay.  Ifway STATE isway away andomray "
"tatesay, enthay eturnray away\n"
"  opycay ofway itway.  Ifway STATE isway T enthay eturnray away andomray "
"tatesay eneratedgay omfray\n"
"  ethay universalway imetay orway /evday/urandomway ifway availableway."

#: src/code/rand-xoroshiro.lisp
#, fuzzy
msgid "Argument is not a RANDOM-STATE, T, or NIL: ~S"
msgstr "Argumentway isway otnay away RANDOM-STATE, T orway NIL: ~S"

#: src/code/rand-xoroshiro.lisp
msgid ""
"Generate the next 64-bit result from the xoroshiro128** generator\n"
"  using the state in STATE, a simple-array of 2 double-floats.  The\n"
"  64-bit result is returned as 2 32-bit values, with the high 32-bits\n"
"  being the first value."
msgstr ""

#: src/code/rand-xoroshiro.lisp
msgid ""
"Generate a uniformly distributed pseudo-random number between zero\n"
"  and Arg.  State, if supplied, is the random state to use."
msgstr ""
"Enerategay away uniformlyway istributedday seudopay-andomray umbernay "
"etweenbay erozay\n"
"  andway Argway.  Tatesay, ifway uppliedsay, isway ethay andomray tatesay "
"otay useway."

#: src/code/rand-xoroshiro.lisp
msgid "Argument is not a positive integer or a positive float: ~S"
msgstr ""
"Argumentway isway otnay away ositivepay integerway orway away ositivepay "
"oatflay: ~S"

#: src/code/rand-xoroshiro.lisp
msgid ""
"Jump the RNG-STATE.  This is equivalent to 2^64 calls to the\n"
"  xoroshiro128** generator.  It can be used to generate 2^64\n"
"  non-overlapping subsequences for parallel computations."
msgstr ""

#: src/code/ntrace.lisp
msgid ""
"This is bound to the returned values when evaluating :BREAK-AFTER and\n"
"   :PRINT-AFTER forms."
msgstr ""
"Isthay isway oundbay otay ethay eturnedray aluesvay enwhay evaluatingway :"
"BREAK-AFTER andway\n"
"   :PRINT-AFTER ormsfay."

#: src/code/ntrace.lisp
msgid ""
"If the trace indentation exceeds this value, then indentation restarts at\n"
"   0."
msgstr ""
"Ifway ethay acetray indentationway exceedsway isthay aluevay, enthay "
"indentationway estartsray atway\n"
"   0."

#: src/code/ntrace.lisp
msgid "The default value for the :ENCAPSULATE option to trace."
msgstr ""
"Ethay efaultday aluevay orfay ethay :ENCAPSULATE optionway otay acetray."

#: src/code/ntrace.lisp
msgid ""
"List of package names.  Encapsulate functions from these packages\n"
"   by default.  This should at least include the packages of functions\n"
"   used by TRACE, directly or indirectly."
msgstr ""
"Istlay ofway ackagepay amesnay.  Encapsulateway unctionsfay omfray esethay "
"ackagespay\n"
"   ybay efaultday.  Isthay ouldshay atway eastlay includeway ethay "
"ackagespay ofway unctionsfay\n"
"   usedway ybay TRACE, irectlyday orway indirectlyway."

#: src/code/ntrace.lisp
msgid "Can't trace special form ~S."
msgstr "Ancay't acetray ecialspay ormfay ~S."

#: src/code/ntrace.lisp
msgid "Breaking ~A traced call to ~S:"
msgstr "Eakingbray ~Away acedtray allcay otay ~S:"

#: src/code/ntrace.lisp
msgid "~S returned"
msgstr "~S eturnedray"

#: src/code/ntrace.lisp
msgid "Function ~S already TRACE'd, retracing it."
msgstr "Unctionfay ~S alreadyway TRACE'd, etracingray itway."

#: src/code/ntrace.lisp
msgid "~S name is not a defined global function: ~S"
msgstr "~S amenay isway otnay away efinedday obalglay unctionfay: ~S"

#: src/code/ntrace.lisp
msgid "Can't use encapsulation to trace anonymous function ~S."
msgstr ""
"Ancay't useway encapsulationway otay acetray anonymousway unctionfay ~S."

#: src/code/ntrace.lisp
msgid "Can't use encapsulation to trace local flet/labels function ~S."
msgstr ""
"Ancay't useway encapsulationway otay acetray ocallay etflay/abelslay "
"unctionfay ~S."

#: src/code/ntrace.lisp
msgid "Tracing shared code for ~S:~%  ~S"
msgstr "Acingtray aredshay odecay orfay ~S:~%  ~S"

#: src/code/ntrace.lisp
msgid "Missing argument to ~S TRACE option."
msgstr "Issingmay argumentway otay ~S TRACE optionway."

#: src/code/ntrace.lisp
msgid "Unknown TRACE option: ~S"
msgstr "Unknownway TRACE optionway: ~S"

#: src/code/ntrace.lisp
msgid ""
"TRACE {Option Global-Value}* {Name {Option Value}*}*\n"
"   TRACE is a debugging tool that prints information when specified "
"functions\n"
"   are called.  In its simplest form:\n"
"       (trace Name-1 Name-2 ...)\n"
"\n"
"   CLOS methods can be traced by specifying a name of the form\n"
"   (METHOD {Qualifier}* ({Specializer}*)).\n"
"\n"
"   Labels and Flet functions can be traced by specifying a name of the form\n"
"   (LABELS <lfun> <fun>) or (FLET <lfun> <fun>) where <lfun> is the Labels/"
"Flet\n"
"   function in <fun>.\n"
"\n"
"   TRACE causes a printout on *TRACE-OUTPUT* each time that one of the "
"named\n"
"   functions is entered or returns (the Names are not evaluated.)  The "
"output\n"
"   is indented according to the number of pending traced calls, and this "
"trace\n"
"   depth is printed at the beginning of each line of output.\n"
"\n"
"   Options allow modification of the default behavior.  Each option is a "
"pair\n"
"   of an option keyword and a value form.  Options may be interspersed with\n"
"   function names.  Options only affect tracing of the function whose name "
"they\n"
"   appear immediately after.  Global options are specified before the first\n"
"   name, and affect all functions traced by a given use of TRACE.\n"
"\n"
"   The following options are defined:\n"
"\n"
"   :CONDITION Form\n"
"   :CONDITION-AFTER Form\n"
"   :CONDITION-ALL Form\n"
"       If :CONDITION is specified, then TRACE does nothing unless Form\n"
"       evaluates to true at the time of the call.  :CONDITION-AFTER is\n"
"       similar, but suppresses the initial printout, and is tested when the\n"
"       function returns.  :CONDITION-ALL tries both before and after.\n"
"\n"
"   :WHEREIN Names\n"
"       If specified, Names is a function name or list of names.  TRACE does\n"
"       nothing unless a call to one of those functions encloses the call to\n"
"       this function (i.e. it would appear in a backtrace.)  Anonymous\n"
"       functions have string names like \"DEFUN FOO\".\n"
"   :WHEREIN-ONLY Names\n"
"       Like :WHEREIN, but only if the immediate caller is one of Names,\n"
"       instead of being any where in a backtrace.\n"
"\n"
"   :BREAK Form\n"
"   :BREAK-AFTER Form\n"
"   :BREAK-ALL Form\n"
"       If specified, and Form evaluates to true, then the debugger is "
"invoked\n"
"       at the start of the function, at the end of the function, or both,\n"
"       according to the respective option.\n"
"\n"
"   :PRINT Form\n"
"   :PRINT-AFTER Form\n"
"   :PRINT-ALL Form\n"
"       In addition to the usual printout, the result of evaluating FORM is\n"
"       printed at the start of the function, at the end of the function, or\n"
"       both, according to the respective option.  Multiple print options "
"cause\n"
"       multiple values to be printed.\n"
"\n"
"   :FUNCTION Function-Form\n"
"       This is a not really an option, but rather another way of specifying\n"
"       what function to trace.  The Function-Form is evaluated immediately,\n"
"       and the resulting function is traced.\n"
"\n"
"   :METHODS Function-Form\n"
"       This is a not really an option, but rather a way of specifying\n"
"       that all methods of a generic functions should be traced.  The\n"
"       Function-Form is evaluated immediately, and the methods of the "
"resulting\n"
"       generic function are traced.\n"
"\n"
"   :ENCAPSULATE {:DEFAULT | T | NIL}\n"
"       If T, the tracing is done via encapsulation (redefining the function\n"
"       name) rather than by modifying the function.  :DEFAULT is the "
"default,\n"
"       and means to use encapsulation for interpreted functions and "
"funcallable\n"
"       instances, breakpoints otherwise.  When encapsulation is used, forms "
"are\n"
"       *not* evaluated in the function's lexical environment, but DEBUG:ARG "
"can\n"
"       still be used.\n"
"\n"
"   :CONDITION, :BREAK and :PRINT forms are evaluated in the lexical "
"environment\n"
"   of the called function; DEBUG:VAR and DEBUG:ARG can be used.  The -AFTER "
"and\n"
"   -ALL forms are evaluated in the null environment."
msgstr ""
"TRACE {Optionway Obalglay-Aluevay}* {Amenay {Optionway Aluevay}*}*\n"
"   TRACE isway away ebuggingday ooltay atthay intspray informationway enwhay "
"ecifiedspay unctionfays\n"
"   areway alledcay.  Inway itsway implestsay ormfay:\n"
"       (acetray Amenay-1 Amenay-2 ...)\n"
"\n"
"   CLOS ethodsmay ancay ebay acedtray ybay ecifyingspay away amenay ofway "
"ethay ormfay\n"
"   (METHOD {Alifierquay}* ({Ecializerspay}*)).\n"
"\n"
"   Abelslay andway Etflay unctionsfay ancay ebay acedtray ybay ecifyingspay "
"away amenay ofway ethay ormfay\n"
"   (LABELS <funlay> <unfay>) orway (FLET <funlay> <unfay>) erewhay <funlay> "
"isway ethay Abelslay/Fetlay\n"
"   unctionfay inway <unfay>.\n"
"\n"
"   TRACE ausescay away intoutpray onway *TRACE-OUTPUT* eachway imetay atthay "
"oneway ofway ethay amednay\n"
"   unctionsfay isway enteredway orway eturnsray (ethay Amesnay areway otnay "
"evaluatedway.)  Ethay outputway\n"
"   isway indentedway accordingway otay ethay umbernay ofway endingpay "
"acedtray allscay, andway isthay acetray\n"
"   epthday isway intedpray atway ethay eginningbay ofway eachway inelay "
"ofway outputway.\n"
"\n"
"   Optionsway allowway odificationmay ofway ethay efaultday ehaviorbay.  "
"Eachway optionway isway away airpay\n"
"   ofway anway optionway eywordkay andway away aluevay ormfay.  Optionsway "
"aymay ebay interspersedway ithway\n"
"   unctionfay amesnay.  Optionsway onlyway affectway acingtray ofway ethay "
"unctionfay osewhay amenay eythay\n"
"   appearway immediatelyway afterway.  Obalglay optionsway areway "
"ecifiedspay eforebay ethay irstfay\n"
"   amenay, andway affectway allway unctionsfay acedtray ybay away ivengay "
"useway ofway TRACE.\n"
"\n"
"   Ethay ollowingfay optionsway areway efinedday:\n"
"\n"
"   :CONDITION Ormfay\n"
"   :CONDITION-AFTER Ormfay\n"
"   :CONDITION-ALL Ormfay\n"
"       Ifway :CONDITION isway ecifiedspay, enthay TRACE oesday othingnay "
"unlessway Ormfay\n"
"       evaluatesway otay uetray atway ethay imetay ofway ethay allcay.  :"
"CONDITION-AFTER isway\n"
"       imilarsay, utbay uppressessay ethay initialway intoutpray, andway "
"isway estedtay enwhay ethay\n"
"       unctionfay eturnsray.  :CONDITION-ALL iestray othbay eforebay andway "
"afterway.\n"
"\n"
"   :WHEREIN Amesnay\n"
"       Ifway ecifiedspay, Amesnay isway away unctionfay amenay orway istlay "
"ofway amesnay.  TRACE oesday\n"
"       othingnay unlessway away allcay otay oneway ofway osethay unctionsfay "
"enclosesway ethay allcay otay\n"
"       isthay unctionfay (i.e. itway ouldway appearway inway away "
"acktracebay.)  Anonymousway\n"
"       unctionsfay avehay ingstray amesnay ikelay \"DEFUN FOO\".\n"
"   :WHEREIN-ONLY Amesnay\n"
"       Ikelay :WHEREIN, utbay onlyway ifway ethay immediateway allercay "
"isway oneway ofway Amesnay,\n"
"       insteadway ofway eingbay anyway erewhay inway away acktracebay.\n"
"\n"
"   :BREAK Ormfay\n"
"   :BREAK-AFTER Ormfay\n"
"   :BREAK-ALL Ormfay\n"
"       Ifway ecifiedspay, andway Ormfay evaluatesway otay uetray, enthay "
"ethay ebuggerday isway invokedway\n"
"       atway ethay tartsay ofway ethay unctionfay, atway ethay endway ofway "
"ethay unctionfay, orway othbay,\n"
"       accordingway otay ethay espectiveray optionway.\n"
"\n"
"   :PRINT Ormfay\n"
"   :PRINT-AFTER Ormfay\n"
"   :PRINT-ALL Ormfay\n"
"       Inway additionway otay ethay usualway intoutpray, ethay esultray "
"ofway evaluatingway FORM isway\n"
"       intedpray atway ethay tartsay ofway ethay unctionfay, atway ethay "
"endway ofway ethay unctionfay, orway\n"
"       othbay, accordingway otay ethay espectiveray optionway.  Ultiplemay "
"intpray optionsway ausecay\n"
"       ultiplemay aluesvay otay ebay intedpray.\n"
"\n"
"   :FUNCTION Unctionfay-Ormfay\n"
"       Isthay isway away otnay eallyray anway optionway, utbay atherray "
"anotherway ayway ofway ecifyingspay\n"
"       atwhay unctionfay otay acetray.  Ethay Unctionfay-Ormfay isway "
"evaluatedway immediatelyway,\n"
"       andway ethay esultingray unctionfay isway acedtray.\n"
"\n"
"   :METHODS Unctionfay-Ormfay\n"
"       Isthay isway away otnay eallyray anway optionway, utbay atherray away "
"ayway ofway ecifyingspay\n"
"       atthay allway ethodsmay ofway away enericgay unctionsfay ouldshay "
"ebay acedtray.  Ethay\n"
"       Unctionfay-Ormfay isway evaluatedway immediatelyway, andway ethay "
"ethodsmay ofway ethay esultingray\n"
"       enericgay unctionfay areway acedtray.\n"
"\n"
"   :ENCAPSULATE {:DEFAULT | T | NIL}\n"
"       Ifway T, ethay acingtray isway oneday iavay encapsulationway "
"(edefiningray ethay unctionfay\n"
"       amenay) atherray anthay ybay odifyingmay ethay unctionfay.  :DEFAULT "
"isway ethay efaultday,\n"
"       andway eansmay otay useway encapsulationway orfay interpretedway "
"unctionsfay andway uncallafayeblay\n"
"       instancesway, eakpointsbray otherwiseway.  Enwhay encapsulationway "
"isway usedway, ormsfay areway\n"
"       *not* evaluatedway inway ethay unctionfay's exicallay environmentway, "
"utbay DEBUG:ARG ancay\n"
"       tillsay ebay usedway.\n"
"\n"
"   :CONDITION, :BREAK andway :PRINT ormsfay areway evaluatedway inway ethay "
"exicallay environmwayentway\n"
"   ofway ethay alledcay unctionfay; DEBUG:VAR andway DEBUG:ARG ancay ebay "
"usedway.  Ethay -AFTER andway\n"
"   -ALL ormsfay areway evaluatedway inway ethay ullnay environmentway."

#: src/code/ntrace.lisp
msgid "Function is not TRACE'd -- ~S."
msgstr "Unctionfay isway otnay TRACE'd -- ~S."

#: src/code/ntrace.lisp
msgid ""
"Removes tracing from the specified functions.  With no args, untraces all\n"
"   functions."
msgstr ""
"Emovesray acingtray omfray ethay ecifiedspay unctionsfay.  Ithway onay "
"argsway, untracesway allway\n"
"   unctionsfay."

#: src/code/profile.lisp
msgid "List of functions that are currently being timed."
msgstr "Istlay ofway unctionsfay atthay areway urrentlycay eingbay imedtay."

#: src/code/profile.lisp
msgid "A list of profiled functions which weren't called."
msgstr "Away istlay ofway ofiledpray unctionsfay ichwhay erenway't alledcay."

#: src/code/profile.lisp
msgid ""
"If the number of profiled functions that were not called is less than\n"
"this, the functions are listed.  If NIL, then always list the functions."
msgstr ""
"Ifway ethay umbernay ofway ofiledpray unctionsfay atthay ereway otnay "
"alledcay isway esslay anthay\n"
"isthay, ethay unctionsfay areway istedlay.  Ifway NIL, enthay alwaysway "
"istlay ethay unctionsfay."

#: src/code/profile.lisp
msgid "dfixnum became negative ~a/~a - ~a/~a(~a/~a)"
msgstr "fixnumday ecamebay egativenay ~away/~away - ~away/~away(~away/~away)"

#: src/code/profile.lisp
msgid "dfixnum became too big ~a/~a + ~a/~a"
msgstr "fixnumday ecamebay ootay igbay ~away/~away + ~away/~away"

#: src/code/profile.lisp
msgid ""
"Ensure that a profile fwrapper for functions with NREQ required\n"
"   arguments and optional arguments according to OPTIONALS-P exists.\n"
"   Return the name of that fwrapper."
msgstr ""
"Ensureway atthay away ofilepray wrapperfay orfay unctionsfay ithway NREQ "
"equiredray\n"
"   argumentsway andway optionalway argumentsway accordingway otay OPTIONALS-"
"P existsway.\n"
"   Eturnray ethay amenay ofway atthay wrapperfay."

#: src/code/profile.lisp
msgid "Return the profile FWRAPPER object on function NAME, if any."
msgstr ""
"Eturnray ethay ofilepray FWRAPPER objectway onway unctionfay NAME, ifway "
"anyway."

#: src/code/profile.lisp
msgid ""
"Return the PROFILE-INFO for function NAME.\n"
"   Signal an error if NAME is not profiled."
msgstr ""
"Eturnray ethay PROFILE-INFO orfay unctionfay NAME.\n"
"   Ignalsay anway errorway ifway NAME isway otnay ofiledpray."

#: src/code/profile.lisp
msgid ""
"PROFILE Name*\n"
"   Wraps profiling code around the named functions.  As in TRACE, the names "
"are\n"
"   not evaluated.  If a function is already profiled, then unprofile and\n"
"   reprofile (useful to notice function redefinition.)  If a name is "
"undefined,\n"
"   then we give a warning and ignore it.\n"
"\n"
"   CLOS methods can be profiled by specifying names of the form\n"
"   (METHOD <name> <qualifier>* (<specializer>*)), like in TRACE.\n"
"\n"
"   :METHODS Function-Form is a way of specifying that all methods of a\n"
"   generic functions should be profiled.  The Function-Form is\n"
"   evaluated immediately, and the methods of the resulting generic\n"
"   function are profiled.\n"
"\n"
"   If :CALLERS T appears, subsequent names have counts of the most\n"
"   common calling functions recorded.\n"
"\n"
"   See also UNPROFILE, REPORT-TIME and RESET-TIME."
msgstr ""
"PROFILE Ame*Nay\n"
"   Apswray ofilingpray odecay aroundway ethay amednay unctionsfay.  Asway "
"inway TRACE, ethay amesnay areway\n"
"   otnay evaluatedway.  Ifway away unctionfay isway alreadyway ofiledpray, "
"enthay unprofileway andway\n"
"   eprofileray (usefulway otay oticenay unctionfay edefinitionray.)  Ifway "
"away amenay isway undefinedway,\n"
"   enthay eway ivegay away arningway andway ignoreway itway.\n"
"\n"
"   CLOS ethodsmay ancay ebay ofiledpray ybay ecifyingspay amesnay ofway "
"ethay ormfay\n"
"   (METHOD <amenay> <alifierquay>* (<ecializerspay>*)), ikelay inway TRACE.\n"
"\n"
"   :METHODS Unctionfay-Ormfay isway away ayway ofway ecifyingspay atthay "
"allway ethodsmay ofway away\n"
"   enericgay unctionsfay ouldshay ebay ofiledpray.  Ethay Unctionfay-Ormfay "
"isway\n"
"   evaluatedway immediatelyway, andway ethay ethodsmay ofway ethay "
"esultingray enericgay\n"
"   unctionfay areway ofiledpray.\n"
"\n"
"   Ifway :CALLERS T appearsway, ubsequentsay amesnay avehay ountscay ofway "
"ethay ostmay\n"
"   ommoncay allingcay unctionsfay ecordedray.\n"
"\n"
"   Eesay alsoway UNPROFILE, REPORT-TIME andway RESET-TIME."

#: src/code/profile.lisp
msgid ""
"PROFILE-ALL\n"
"\n"
" Wraps profiling code around all functions in PACKAGE, which defaults\n"
" to *PACKAGE*. If a function is already profiled, then unprofile and\n"
" reprofile (useful to notice function redefinition.)  If a name is\n"
" undefined, then we give a warning and ignore it.  If CALLERS-P is T\n"
" names have counts of the most common calling functions recorded.\n"
"\n"
" When called with arguments :METHODS T, profile all methods of all\n"
" generic function having names in the given package.  Generic functions\n"
" themselves, that is, their dispatch functions, are left alone.\n"
"\n"
" See also UNPROFILE, REPORT-TIME and RESET-TIME. "
msgstr ""
"PROFILE-ALL\n"
"\n"
" Apswray ofilingpray odecay aroundway allway unctionsfay inway PACKAGE, "
"ichwhay efaultsday\n"
" otay *PACKAGE*. Ifway away unctionfay isway alreadyway ofiledpray, enthay "
"unprofileway andway\n"
" eprofileray (usefulway otay oticenay unctionfay edefinitionray.)  Ifway "
"away amenay isway\n"
" undefinedway, enthay eway ivegay away arningway andway ignoreway itway.  "
"Ifway CALLERS-P isway T\n"
" amesnay avehay ountscay ofway ethay ostmay ommoncay allingcay unctionsfay "
"ecordedray.\n"
"\n"
" Enwhay alledcay ithway argumentsway :METHODS T, ofilepray allway ethodsmay "
"ofway allway\n"
" enericgay unctionfay avinghay amesnay inway ethay ivengay ackagepay.  "
"Enericgay unctionsfay\n"
" emselvesthay, atthay isway, eirthay ispatchday unctionsfay, areway eftlay "
"aloneway.\n"
"\n"
" Eesay alsoway UNPROFILE, REPORT-TIME andway RESET-TIME. "

#: src/code/profile.lisp
msgid ""
"Unwraps the profiling code around the named functions.  Names defaults to\n"
"  the list of all currently profiled functions."
msgstr ""
"Unwrapsway ethay ofilingpray odecay aroundway ethay amednay unctionsfay.  "
"Amesnay efaultsday otay\n"
"  ethay istlay ofway allway urrentlycay ofiledpray unctionsfay."

#: src/code/profile.lisp
msgid ""
"Resets the time counter for the named functions.  Names defaults to the "
"list\n"
"  of all currently profiled functions."
msgstr ""
"Esetsray ethay imetay ountercay orfay ethay amednay unctionsfay.  Amesnay "
"efaultsday otay ethay istlay\n"
"  ofway allway urrentlycay ofiledpray unctionsfay."

#: src/code/profile.lisp
msgid ""
"Reports the time spent in the named functions.  Names defaults to the list\n"
"  of all currently profiled functions."
msgstr ""
"Eportsray ethay imetay entspay inway ethay amednay unctionsfay.  Amesnay "
"efaultsday otay ethay istlay\n"
"  ofway allway urrentlycay ofiledpray unctionsfay."

#: src/code/profile.lisp
msgid ""
"Reports the time spent in the named functions.  Names defaults to the list\n"
"  of all currently profiled functions.  Uses printfunction."
msgstr ""
"Eportsray ethay imetay entspay inway ethay amednay unctionsfay.  Amesnay "
"efaultsday otay ethay istlay\n"
"  ofway allway urrentlycay ofiledpray unctionsfay.  Usesway intfunctionpray."

#: src/code/sort.lisp
msgid ""
"Destructively sorts sequence.  Predicate should returns non-Nil if\n"
"   Arg1 is to precede Arg2."
msgstr ""
"Estructivelyday ortssay equencesay.  Edicatepray ouldshay eturnsray onnay-"
"Ilnay ifway\n"
"   Argway1 isway otay ecedepray Argway2."

#: src/code/sort.lisp
msgid "~S is not a sequence."
msgstr "~S isway otnay away equencesay."

#: src/code/sort.lisp
msgid ""
"The sequences Sequence1 and Sequence2 are destructively merged into\n"
"   a sequence of type Result-Type using the Predicate to order the elements."
msgstr ""
"Ethay equencessay Equencesay1 andway Equencesay2 areway estructivelyday "
"ergedmay intoway\n"
"   away equencesay ofway ypetay Esultray-Ypetay usingway ethay Edicatepray "
"otay orderway ethay elementsway."

#: src/code/time.lisp
msgid ""
"The number of internal time units that fit into a second.  See\n"
"  Get-Internal-Real-Time and Get-Internal-Run-Time."
msgstr ""
"Ethay umbernay ofway internalway imetay unitsway atthay itfay intoway away "
"econdsay.  Eesay\n"
"  Etgay-Internalway-Ealray-Imetay andway Etgay-Internalway-Unray-Imetay."

#: src/code/time.lisp
msgid ""
"Return the real time in the internal time format.  This is useful for\n"
"  finding elapsed time.  See Internal-Time-Units-Per-Second."
msgstr ""
"Eturnray ethay ealray imetay inway ethay internalway imetay ormatfay.  "
"Isthay isway usefulway orfay\n"
"  indingfay elapsedway imetay.  Eesay Internalway-Imetay-Unitsway-Erpay-"
"Econdsay."

#: src/code/time.lisp
msgid ""
"Return the run time in the internal time format.  This is useful for\n"
"  finding CPU usage."
msgstr ""
"Eturnray ethay unray imetay inway ethay internalway imetay ormatfay.  Isthay "
"isway usefulway orfay\n"
"  indingfay CPU usageway."

#: src/code/time.lisp
msgid ""
"Returns a single integer for the current time of\n"
"   day in universal time format."
msgstr ""
"Eturnsray away inglesay integerway orfay ethay urrentcay imetay ofway\n"
"   ayday inway universalway imetay ormatfay."

#: src/code/time.lisp
msgid ""
"Returns nine values specifying the current time as follows:\n"
"   second, minute, hour, date, month, year, day of week (0 = Monday), T\n"
"   (daylight savings times) or NIL (standard time), and timezone."
msgstr ""
"Eturnsray inenay aluesvay ecifyingspay ethay urrentcay imetay asway "
"ollowsfay:\n"
"   econdsay, inutemay, ourhay, ateday, onthmay, earyay, ayday ofway eekway "
"(0 = Ondaymay), T\n"
"   (aylightday avingssay imestay) orway NIL (tandardsay imetay), andway "
"imezonetay."

#: src/code/time.lisp
msgid ""
"Converts a universal-time to decoded time format returning the following\n"
"   nine values: second, minute, hour, date, month, year, day of week (0 =\n"
"   Monday), T (daylight savings time) or NIL (standard time), and timezone.\n"
"   Completely ignores daylight-savings-time when time-zone is supplied."
msgstr ""
"Onvertscay away universalway-imetay otay ecodedday imetay ormatfay "
"eturningray ethay ollowingfay\n"
"   inenay aluesvay: econdsay, inutemay, ourhay, ateday, onthmay, earyay, "
"ayday ofway eekway (0 =\n"
"   Ondaymay), T (aylightday avingssay imetay) orway NIL (tandardsay imetay), "
"andway imezonetay.\n"
"   Ompletelycay ignoresway aylightday-avingssay-imetay enwhay imetay-onezay "
"isway uppliedsay."

#: src/code/time.lisp
msgid ""
"The time values specified in decoded format are converted to \n"
"   universal time, which is returned."
msgstr ""
"Ethay imetay aluesvay ecifiedspay inway ecodedday ormatfay areway "
"onvertedcay otay \n"
"   universalway imetay, ichwhay isway eturnedray."

#: src/code/time.lisp
msgid "Evaluates the Form and prints timing information on *Trace-Output*."
msgstr ""
"Evaluatesway ethay Ormfay andway intspray imingtay informationway onway "
"*Trace-Output*."

#: src/code/time.lisp
msgid ""
"TIME form in a non-null environment, forced to interpret.~@\n"
"\t       Compiling entire form will produce more accurate times."
msgstr ""
"TIME ormfay inway away onnay-ullnay environmentway, orcedfay otay "
"interpretway.~@\n"
"\t       Ompilingcay entireway ormfay illway oducepray oremay accurateway "
"imestay."

#: src/code/time.lisp
msgid ""
"Evaluation took:~%  ~\n"
"\t\t     ~S seconds of real time~%  ~\n"
"\t\t     ~S seconds of user run time~%  ~\n"
"\t\t     ~S seconds of system run time~%  "
msgstr ""
"Evaluationway ooktay:~%  ~\n"
"\t\t     ~S econdssay ofway ealray imetay~%  ~\n"
"\t\t     ~S econdssay ofway userway unray imetay~%  ~\n"
"\t\t     ~S econdssay ofway ystemsay unray imetay~%  "

#: src/code/time.lisp
msgid ""
"~:D ~A cycle~%  ~\n"
"\t\t     ~@[[Run times include ~S seconds GC run time]~%  ~]"
msgid_plural ""
"~:D ~A cycles~%  ~\n"
"\t\t     ~@[[Run times include ~S seconds GC run time]~%  ~]"
msgstr[0] ""
"~:D ~Away yclecay~%  ~\n"
"\t\t     ~@[[Unray imestay includeway ~S econdssay GC unray imetay]~%  ~]"
msgstr[1] ""
"~:D ~Away yclescay~%  ~\n"
"\t\t     ~@[[Unray imestay includeway ~S econdssay GC unray imetay]~%  ~]"

#: src/code/time.lisp
msgid "~S page fault and~%  "
msgid_plural "~S page faults and~%  "
msgstr[0] "~S agepay aultfay andway~%  "
msgstr[1] "~S agepay aultsfay andway~%  "

#: src/code/time.lisp
msgid "~:D byte consed.~%"
msgid_plural "~:D bytes consed.~%"
msgstr[0] "~:D ytebay onsedcay.~%"
msgstr[1] "~:D ytesbay onsedcay.~%"

#: src/code/weak.lisp
msgid "Allocates and returns a weak pointer which points to OBJECT."
msgstr ""
"Allocatesway andway eturnsray away eakway ointerpay ichwhay ointspay otay "
"OBJECT."

#: src/code/weak.lisp
msgid ""
"If WEAK-POINTER is valid, returns the value of WEAK-POINTER and T.\n"
"   If the referent of WEAK-POINTER has been garbage collected, returns\n"
"   the values NIL and NIL."
msgstr ""
"Ifway WEAK-POINTER isway alidvay, eturnsray ethay aluevay ofway WEAK-POINTER "
"andway T.\n"
"   Ifway ethay eferentray ofway WEAK-POINTER ashay eenbay arbagegay "
"ollectedcay, eturnsray\n"
"   ethay aluesvay NIL andway NIL."

#: src/code/weak.lisp
msgid "Updates WEAK-POINTER to point to a new object."
msgstr "Updatesway WEAK-POINTER otay ointpay otay away ewnay objectway."

#: src/code/final.lisp
msgid ""
"Arrange for FUNCTION to be called when there are no more references to\n"
"   OBJECT.  FUNCTION takes no arguments."
msgstr ""
"Arrangeway orfay FUNCTION otay ebay alledcay enwhay erethay areway onay "
"oremay eferencesray otay\n"
"   OBJECT.  FUNCTION akestay onay argumentsway."

#: src/code/final.lisp
msgid "Cancel any finalization registers for OBJECT."
msgstr "Ancelcay anyway inalizationfay egistersray orfay OBJECT."

#: src/code/describe.lisp
msgid "Depth of recursive descriptions allowed."
msgstr "Epthday ofway ecursiveray escriptionsday allowedway."

#: src/code/describe.lisp
msgid ""
"If non-nil, descriptions may provide interpretations of information and\n"
"  pointers to additional information.  Normally nil."
msgstr ""
"Ifway onnay-ilnay, escriptionsday aymay ovidepray interpretationsway ofway "
"informationway andway\n"
"  ointerspay otay additionalway informationway.  Ormallynay ilnay."

#: src/code/describe.lisp
msgid ""
"*print-level* gets bound to this inside describe.  If null, use\n"
"  *print-level*"
msgstr ""
"*print-level* etsgay oundbay otay isthay insideway escribeday.  Ifway "
"ullnay, useway\n"
"  *print-level*"

#: src/code/describe.lisp
msgid ""
"*print-length* gets bound to this inside describe.  If null, use\n"
"  *print-length*."
msgstr ""
"*print-length* etsgay oundbay otay isthay insideway escribeday.  Ifway "
"ullnay, useway\n"
"  *print-length*."

#: src/code/describe.lisp
msgid "Number of spaces that sets off each line of a recursive description."
msgstr ""
"Umbernay ofway acesspay atthay etssay offway eachway inelay ofway away "
"ecursiveray escriptionday."

#: src/code/describe.lisp
msgid "Used to tell whether we are doing a recursive describe."
msgstr ""
"Usedway otay elltay etherwhay eway areway oingday away ecursiveray "
"escribeday."

#: src/code/describe.lisp
msgid "Used to implement recursive description cutoff.  Don't touch."
msgstr ""
"Usedway otay implementway ecursiveray escriptionday utoffcay.  Onday't "
"ouchtay."

#: src/code/describe.lisp
msgid "An output stream used by Describe for indenting and stuff."
msgstr ""
"Anway outputway eamstray usedway ybay Escribeday orfay indentingway andway "
"tuffsay."

#: src/code/describe.lisp
msgid ""
"List of all objects describe within the current top-level call to describe."
msgstr ""
"Istlay ofway allway objectsway escribeday ithinway ethay urrentcay optay-"
"evellay allcay otay escribeday."

#: src/code/describe.lisp
msgid "The last object passed to describe."
msgstr "Ethay astlay objectway assedpay otay escribeday."

#: src/code/describe.lisp
msgid "Prints a description of the object X."
msgstr "Intspray away escriptionday ofway ethay objectway X."

#: src/code/describe.lisp
msgid "*describe-level* should be a nonnegative integer - ~A."
msgstr "*describe-level* ouldshay ebay away onnegativenay integerway - ~Away."

#: src/code/describe.lisp
msgid "~&~S is a ~S."
msgstr "~&~S isway away ~S."

#: src/code/describe.lisp
msgid "~&Its code is #x~4,'0x."
msgstr "~&Itsway odecay isway #x~4,'0x."

#: src/code/describe.lisp
msgid "~&Its name is ~A."
msgstr "~&Itsway amenay isway ~Away."

#: src/code/describe.lisp
msgid "~&It is a ~:[high (leading)~;low (trailing)~] surrogate character."
msgstr ""
"~&Itway isway away ~:[ighhay (eadinglay)~;owlay (ailingtray)~] urrogatesay "
"aracterchay."

#: src/code/describe.lisp
msgid "~&~S is a ~(~A~) of type ~A."
msgstr "~&~S isway away ~(~Away~) ofway ypetay ~Away."

#: src/code/describe.lisp
msgid "~&~S is a ~:[~;displaced ~]vector of length ~D."
msgstr "~&~S isway away ~:[~;isplacedday ~]ectorvay ofway engthlay ~D."

#: src/code/describe.lisp
msgid "~&It has a fill pointer, currently ~d"
msgstr "~&Itway ashay away illfay ointerpay, urrentlycay ~d"

#: src/code/describe.lisp
msgid "~&It has no fill pointer."
msgstr "~&Itway ashay onay illfay ointerpay."

#: src/code/describe.lisp
msgid "~&~S is ~:[an~;a displaced~] array of rank ~A"
msgstr "~&~S isway ~:[anway~;away isplacedday~] arrayway ofway ankray ~Away"

#: src/code/describe.lisp
msgid "~%Its dimensions are ~S."
msgstr "~%Itsway imensionsday areway ~S."

#: src/code/describe.lisp
msgid "~&Its element type is specialized to ~S."
msgstr "~&Itsway elementway ypetay isway ecializedspay otay ~S."

#: src/code/describe.lisp
msgid "~&It is adjustable."
msgstr "~&Itway isway adjustableway."

#: src/code/describe.lisp
msgid "~&It is static."
msgstr "~&Itway isway taticsay."

#: src/code/describe.lisp
msgid "~&It is a prime number."
msgstr "~&Itway isway away imepray umbernay."

#: src/code/describe.lisp
msgid "~&It is a composite number."
msgstr "~&Itway isway away ompositecay umbernay."

#: src/code/describe.lisp
msgid "~&Its components are ~S and ~S."
msgstr "~&Itsway omponentscay areway ~S andway ~S."

#: src/code/describe.lisp
msgid "~&~S is an ~A hash table."
msgstr "~&~S isway anway ~Away ashhay abletay."

#: src/code/describe.lisp
msgid "~&Its size is ~D buckets."
msgstr "~&Itsway izesay isway ~D ucketsbay."

#: src/code/describe.lisp
msgid "~&Its rehash-size is ~S."
msgstr "~&Itsway ehashray-izesay isway ~S."

#: src/code/describe.lisp
msgid "~&Its rehash-threshold is ~S."
msgstr "~&Itsway ehashray-resholdthay isway ~S."

#: src/pcl/env.lisp src/code/describe.lisp
msgid "~&It currently holds ~d entries."
msgstr "~&Itway urrentlycay oldshay ~d entriesway."

#: src/code/describe.lisp
msgid "~&It is weak ~A table."
msgstr "~&Itway isway eakway ~Away abletay."

#: src/code/describe.lisp
msgid "~&~d symbols total: ~d internal and ~d external."
msgstr "~&~d ymbolssay otaltay: ~d internalway andway ~d externalway."

#: src/code/describe.lisp
msgid "~&~@(~A documentation:~)~&  ~A"
msgstr "~&~@(~Away ocumentationday:~)~&  ~Away"

#: src/code/describe.lisp
msgid "~&Its ~(~A~) argument types are:~%  ~S"
msgstr "~&Itsway ~(~Away~) argumentway ypestay areway:~%  ~S"

#: src/code/describe.lisp
msgid "~&Its result type is:~%  ~S"
msgstr "~&Itsway esultray ypetay isway:~%  ~S"

#: src/code/describe.lisp
msgid ""
"~&It is currently declared ~(~A~);~\n"
"\t\t ~:[no~;~] expansion is available."
msgstr ""
"~&Itway isway urrentlycay eclaredday ~(~Away~);~\n"
"\t\t ~:[onay~;~] expansionway isway availableway."

#: src/code/describe.lisp
msgid "~&~@(~@[~A ~]arguments:~%~)"
msgstr "~&~@(~@[~Away ~]argumentsway:~%~)"

#: src/code/describe.lisp
msgid "  There are no arguments."
msgstr "  Erethay areway onay argumentsway."

#: src/code/describe.lisp
msgid "~&Its closure environment is:"
msgstr "~&Itsway osureclay environmentway isway:"

#: src/code/describe.lisp
msgid "~&Its definition is:~%  ~S"
msgstr "~&Itsway efinitionday isway:~%  ~S"

#: src/code/describe.lisp
msgid "~&On ~A it was compiled from:"
msgstr "~&Onway ~Away itway asway ompiledcay omfray:"

#: src/code/describe.lisp
msgid "~&~A~%  Created: "
msgstr "~&~Away~%  Eatedcray: "

#: src/code/describe.lisp
msgid "~&  Comment: ~A"
msgstr "~&  Ommentcay: ~Away"

#: src/code/describe.lisp
msgid "  There is no argument information available."
msgstr "  Erethay isway onay argumentway informationway availableway."

#: src/code/describe.lisp
msgid "Macro-function: ~S"
msgstr "Acromay-unctionfay: ~S"

#: src/code/describe.lisp
msgid "Function: ~S"
msgstr "Unctionfay: ~S"

#: src/code/describe.lisp
msgid "~S is a function."
msgstr "~S isway away unctionfay."

#: src/code/describe.lisp
msgid "~&It is an unknown type of function."
msgstr "~&Itway isway anway unknownway ypetay ofway unctionfay."

#: src/code/describe.lisp
msgid "~&~A is an ~A symbol in the ~A package."
msgstr "~&~Away isway anway ~Away ymbolsay inway ethay ~Away ackagepay."

#: src/code/describe.lisp
msgid "~&~A is an uninterned symbol."
msgstr "~&~Away isway anway uninternedway ymbolsay."

#: src/code/describe.lisp
msgid "~&~@<It is an alien at #x~8,'0X of type ~3I~:_~S.~:>~%"
msgstr ""
"~&~@<Itway isway anway alienway atway #x~8,'0X ofway ypetay ~3Iway~:_~S.~:>~%"

#: src/code/describe.lisp
msgid "~@<Its current value is ~3I~:_~S.~:>"
msgstr "~@<Itsway urrentcay aluevay isway ~3Iway~:_~S.~:>"

#: src/code/describe.lisp
msgid "~&It is a ~A with expansion: ~S."
msgstr "~&Itway isway away ~Away ithway expansionway: ~S."

#: src/code/describe.lisp
msgid "~&It is a ~A; its value is ~S."
msgstr "~&Itway isway away ~Away; itsway aluevay isway ~S."

#: src/code/describe.lisp
msgid "~&It is a ~A; no current value."
msgstr "~&Itway isway away ~Away; onay urrentcay aluevay."

#: src/code/describe.lisp
msgid "~&Its declared type is ~S."
msgstr "~&Itsway eclaredday ypetay isway ~S."

#: src/code/describe.lisp
msgid "Special form"
msgstr "Ecialspay ormfay"

#: src/code/describe.lisp
msgid "Structure"
msgstr "Ucturestray"

#: src/code/describe.lisp
msgid "Type"
msgstr "Ypetay"

#: src/code/describe.lisp
msgid "Setf macro"
msgstr "Etfsay acromay"

#: src/code/describe.lisp
msgid "~&Documentation on the ~(~A~):~%~A"
msgstr "~&Ocumentationday onway ethay ~(~Away~):~%~Away"

#: src/code/describe.lisp
msgid "~&It names a class ~A."
msgstr "~&Itway amesnay away assclay ~Away."

#: src/code/describe.lisp
msgid "~&It names a PCL class ~A."
msgstr "~&Itway amesnay away PCL assclay ~Away."

#: src/code/describe.lisp
msgid "~&It names a type specifier."
msgstr "~&Itway amesnay away ypetay ecifierspay."

#: src/code/describe.lisp
msgid "~&Its ~S property is ~S."
msgstr "~&Itsway ~S opertypray isway ~S."

#: src/code/describe.lisp
msgid "~&It is defined in:~&~A"
msgstr "~&Itway isway efinedday inway:~&~Away"

#: src/code/tty-inspect.lisp
msgid "~%That slot is unbound.~%"
msgstr "~%Atthay otslay isway unboundway.~%"

#: src/code/tty-inspect.lisp
msgid "~%This object contains nothing to inspect.~%~%"
msgstr "~%Isthay objectway ontainscay othingnay otay inspectway.~%~%"

#: src/code/tty-inspect.lisp
msgid "~%Enter a VALID number (~:[0-~D~;0~]).~%~%"
msgstr "~%Enterway away VALID umbernay (~:[0-~D~;0~]).~%~%"

#: src/code/tty-inspect.lisp
msgid "~%Bottom of Stack.~%"
msgstr "~%Ottombay ofway Tacksay.~%"

#: src/code/tty-inspect.lisp
msgid "~%Returning to INSPECTOR.~%"
msgstr "~%Eturningray otay INSPECTOR.~%"

#: src/code/tty-inspect.lisp
msgid "TTY-Inspector Help:"
msgstr "TTY-Inspectorway Elphay:"

#: src/code/tty-inspect.lisp
msgid "  R           -  recompute current object."
msgstr "  R           -  ecomputeray urrentcay objectway."

#: src/code/tty-inspect.lisp
msgid "  D           -  redisplay current object."
msgstr "  D           -  edisplayray urrentcay objectway."

#: src/code/tty-inspect.lisp
msgid "  U           -  Move upward through the object stack."
msgstr "  U           -  Ovemay upwardway roughthay ethay objectway tacksay."

#: src/code/tty-inspect.lisp
msgid "  <number>    -  Inspect this slot."
msgstr "  <umbernay>    -  Inspectway isthay otslay."

#: src/code/tty-inspect.lisp
msgid "  Q, E        -  Quit TTY-INSPECTOR."
msgstr "  Q, E        -  Itquay TTY-INSPECTOR."

#: src/code/tty-inspect.lisp
msgid "  ?, H, Help  -  Show this help."
msgstr "  ?, H, Elphay  -  Owshay isthay elphay."

#: src/code/tty-inspect.lisp
msgid "Unbound"
msgstr "Unboundway"

#: src/code/tty-inspect.lisp
msgid "~s is a symbol.~%"
msgstr "~s isway away ymbolsay.~%"

#: src/code/tty-inspect.lisp
msgid "Value"
msgstr "Aluevay"

#: src/code/tty-inspect.lisp
msgid "Function"
msgstr "Unctionfay"

#: src/code/tty-inspect.lisp
msgid "Plist"
msgstr "Istplay"

#: src/code/tty-inspect.lisp
msgid "Package"
msgstr "Ackagepay"

#: src/code/tty-inspect.lisp
msgid "~s is an instance of ~s.~%"
msgstr "~s isway anway instanceway ofway ~s.~%"

#: src/code/tty-inspect.lisp
msgid "- (slot is unbound)"
msgstr "- (otslay isway unboundway)"

#: src/code/tty-inspect.lisp
msgid "~s is a ~(~A~).~%"
msgstr "~s isway away ~(~Away~).~%"

#: src/code/tty-inspect.lisp
msgid "Function ~s.~@[~%Argument List: ~a~]."
msgstr "Unctionfay ~s.~@[~%Argumentway Istlay: ~away~]."

#: src/code/tty-inspect.lisp
msgid "Object is a ~:[~;displaced ~]vector of length ~d.~%"
msgstr "Objectway isway away ~:[~;isplacedday ~]ectorvay ofway engthlay ~d.~%"

#: src/code/tty-inspect.lisp
msgid "Object is a LIST of length ~d.~%"
msgstr "Objectway isway away LIST ofway engthlay ~d.~%"

#: src/code/tty-inspect.lisp
msgid "Object is a CONS.~%"
msgstr "Objectway isway away CONS.~%"

#: src/code/tty-inspect.lisp
msgid ""
"Object is ~:[a displaced~;an~] array of ~a.~%~\n"
"                       Its dimensions are ~s.~%"
msgstr ""
"Objectway isway ~:[away isplacedday~;anway~] arrayway ofway ~away.~%~\n"
"                       Itsway imensionsday areway ~s.~%"

#: src/code/tty-inspect.lisp
msgid "Object is an atom.~%"
msgstr "Objectway isway anway atomway.~%"

#: src/code/format-time.lisp
msgid ""
"Format-Universal-Time formats a string containing the time and date\n"
"   given by universal-time in a common manner.  The destination is any\n"
"   destination which can be accepted by the Format function.  The\n"
"   timezone keyword is an integer specifying hours west of Greenwich.\n"
"   The style keyword can be :short (numeric date), :long (months and\n"
"   weekdays expressed as words), :abbreviated (like :long but words\n"
"   are abbreviated), :rfc1123 (conforming to RFC 1123), :government\n"
"   (of the form \"XX Mon XX XX:XX:XX\"), or :iso8601 (conforming to\n"
"   ISO 8601), which is the recommended way of printing date and time.\n"
"   The keyword date-first, if nil, will print the time first instead of\n"
"   the date (the default).  The print- keywords, if nil, inhibit the\n"
"   printing of the obvious part of the time/date."
msgstr ""
"Ormatfay-Universalway-Imetay ormatsfay away ingstray ontainingcay ethay "
"imetay andway ateday\n"
"   ivengay ybay universalway-imetay inway away ommoncay annermay.  Ethay "
"estinationday isway anyway\n"
"   estinationday ichwhay ancay ebay acceptedway ybay ethay Ormatfay "
"unctionfay.  Ethay\n"
"   imezonetay eywordkay isway anway integerway ecifyingspay ourshay estway "
"ofway Eenwichgray.\n"
"   Ethay tylesay eywordkay ancay ebay :ortshay (umericnay ateday), :onglay "
"(onthsmay andway\n"
"   eekdaysway expressedway asway ordsway), :abbreviatedway (ikelay :onglay "
"utbay ordsway\n"
"   areway abbreviatedway), :fcray1123 (onformingcay otay RFC 1123), :"
"overnmentgay\n"
"   (ofway ethay ormfay \"XX Onmay XX XX:XX:XX\"), orway :isoway8601 "
"(onformingcay otay\n"
"   ISO 8601), ichwhay isway ethay ecommendedray ayway ofway intingpray "
"ateday andway imetay.\n"
"   Ethay eywordkay ateday-irstfay, ifway ilnay, illway intpray ethay imetay "
"irstfay insteadway ofway\n"
"   ethay ateday (ethay efaultday).  Ethay intpray- eywordskay, ifway ilnay, "
"inhibitway ethay\n"
"   intingpray ofway ethay obviousway artpay ofway ethay imetay/ateday."

#: src/code/format-time.lisp
msgid "~A: Not a valid format destination."
msgstr "~Away: Otnay away alidvay ormatfay estinationday."

#: src/code/format-time.lisp
msgid "~A: Universal-Time should be an integer."
msgstr "~Away: Universalway-Imetay ouldshay ebay anway integerway."

#: src/code/format-time.lisp
msgid "~A: Timezone should be a rational between -24 and 24."
msgstr ""
"~Away: Imezonetay ouldshay ebay away ationalray etweenbay -24 andway 24."

#: src/code/format-time.lisp
msgid "~A: Timezone is not a second (1/3600) multiple."
msgstr "~Away: Imezonetay isway otnay away econdsay (1/3600) ultiplemay."

#: src/code/format-time.lisp
msgid "~A: Unrecognized :style keyword value."
msgstr "~Away: Unrecognizedway :tylesay eywordkay aluevay."

#: src/code/format-time.lisp
msgid ""
"Format-Decoded-Time formats a string containing decoded-time\n"
"   expressed in a humanly-readable manner.  The destination is any\n"
"   destination which can be accepted by the Format function.  The\n"
"   timezone keyword is an integer specifying hours west of Greenwich.\n"
"   The style keyword can be :short (numeric date), :long (months and\n"
"   weekdays expressed as words), or :abbreviated (like :long but words are\n"
"   abbreviated).  The keyword date-first, if nil, will cause the time\n"
"   to be printed first instead of the date (the default).  The print-\n"
"   keywords, if nil, inhibit the printing of certain semi-obvious\n"
"   parts of the string."
msgstr ""
"Ormatfay-Ecodedday-Imetay ormatsfay away ingstray ontainingcay ecodedday-"
"imetay\n"
"   expressedway inway away umanlyhay-eadableray annermay.  Ethay "
"estinationday isway anyway\n"
"   estinationday ichwhay ancay ebay acceptedway ybay ethay Ormatfay "
"unctionfay.  Ethay\n"
"   imezonetay eywordkay isway anway integerway ecifyingspay ourshay estway "
"ofway Eenwichgray.\n"
"   Ethay tylesay eywordkay ancay ebay :ortshay (umericnay ateday), :onglay "
"(onthsmay andway\n"
"   eekdaysway expressedway asway ordsway), orway :abbreviatedway (ikelay :"
"onglay utbay ordsway areway\n"
"   abbreviatedway).  Ethay eywordkay ateday-irstfay, ifway ilnay, illway "
"ausecay ethay imetay\n"
"   otay ebay intedpray irstfay insteadway ofway ethay ateday (ethay "
"efaultday).  Ethay intpray-\n"
"   eywordskay, ifway ilnay, inhibitway ethay intingpray ofway ertaincay "
"emisay-obviousway\n"
"   artspay ofway ethay ingstray."

#: src/code/format-time.lisp
msgid "~A: Seconds should be an integer between 0 and 59."
msgstr "~Away: Econdssay ouldshay ebay anway integerway etweenbay 0 andway 59."

#: src/code/format-time.lisp
msgid "~A: Minutes should be an integer between 0 and 59."
msgstr "~Away: Inutesmay ouldshay ebay anway integerway etweenbay 0 andway 59."

#: src/code/format-time.lisp
msgid "~A: Hours should be an integer between 0 and 23."
msgstr "~Away: Ourshay ouldshay ebay anway integerway etweenbay 0 andway 23."

#: src/code/format-time.lisp
msgid "~A: Day should be an integer between 1 and 31."
msgstr "~Away: Ayday ouldshay ebay anway integerway etweenbay 1 andway 31."

#: src/code/format-time.lisp
msgid "~A: Month should be an integer between 1 and 12."
msgstr "~Away: Onthmay ouldshay ebay anway integerway etweenbay 1 andway 12."

#: src/code/format-time.lisp
msgid "~A: Hours should be an non-negative integer."
msgstr "~Away: Ourshay ouldshay ebay anway onnay-egativenay integerway."

#: src/code/format-time.lisp
msgid "~A: Timezone should be an integer between 0 and 32."
msgstr ""
"~Away: Imezonetay ouldshay ebay anway integerway etweenbay 0 andway 32."

#: src/code/parse-time.lisp
msgid ""
"If t, an error will be signalled if parse-time is unable\n"
"   to determine the time/date format of the string."
msgstr ""
"Ifway t, anway errorway illway ebay ignalledsay ifway arsepay-imetay isway "
"unableway\n"
"   otay etermineday ethay imetay/ateday ormatfay ofway ethay ingstray."

#: src/code/parse-time.lisp
msgid "\"~A\" is not a recognized word or abbreviation."
msgstr "\"~Away\" isway otnay away ecognizedray ordway orway abbreviationway."

#: src/code/parse-time.lisp
msgid ""
"Can't parse time/date string.~%>>> ~A~\n"
"\t\t\t\t   ~%~VT^-- Bogus character encountered here."
msgstr ""
"Ancay't arsepay imetay/ateday ingstray.~%>>> ~Away~\n"
"\t\t\t\t   ~%~VT^-- Ogusbay aracterchay encounteredway erehay."

#: src/code/parse-time.lisp
msgid "Unrecognized symbol: ~A"
msgstr "Unrecognizedway ymbolsay: ~Away"

#: src/code/parse-time.lisp
msgid "~D is not an AM hour, dummy."
msgstr "~D isway otnay anway AM ourhay, ummyday."

#: src/code/parse-time.lisp
msgid "~A isn't AM/PM - this shouldn't happen."
msgstr "~Away isnway't AM/PM - isthay ouldnshay't appenhay."

#: src/code/parse-time.lisp
msgid "Invalid number of days (~D) for month ~D in ~D"
msgstr "Invalidway umbernay ofway aysday (~D) orfay onthmay ~D inway ~D"

#: src/code/parse-time.lisp
msgid "Ignore."
msgstr "Ignoreway."

#: src/code/parse-time.lisp
msgid "Specified day (~@(~A~)) doesn't match actual day (~@(~A~))"
msgstr ""
"Ecifiedspay ayday (~@(~Away~)) oesnday't atchmay actualway ayday (~@(~Away~))"

#: src/code/parse-time.lisp
msgid "Unrecognized symbol in form list: ~A."
msgstr "Unrecognizedway ymbolsay inway ormfay istlay: ~Away."

#: src/code/parse-time.lisp
msgid ""
"Tries very hard to make sense out of the argument time-string and\n"
"   returns a single integer representing the universal time if\n"
"   successful.  If not, it returns nil.  If the :error-on-mismatch\n"
"   keyword is true, parse-time will signal an error instead of\n"
"   returning nil.  Default values for each part of the time/date\n"
"   can be specified by the appropriate :default- keyword.  These\n"
"   keywords can be given a numeric value or the keyword :current\n"
"   to set them to the current value.  The default-default values\n"
"   are 00:00:00 on the current date, current time-zone."
msgstr ""
"Iestray eryvay ardhay otay akemay ensesay outway ofway ethay argumentway "
"imetay-ingstray andway\n"
"   eturnsray away inglesay integerway epresentingray ethay universalway "
"imetay ifway\n"
"   uccessfulsay.  Ifway otnay, itway eturnsray ilnay.  Ifway ethay :errorway-"
"onway-ismatchmay\n"
"   eywordkay isway uetray, arsepay-imetay illway ignalsay anway errorway "
"insteadway ofway\n"
"   eturningray ilnay.  Efaultday aluesvay orfay eachway artpay ofway ethay "
"imetay/ateday\n"
"   ancay ebay ecifiedspay ybay ethay appropriateway :efaultday- eywordkay.  "
"Esethay\n"
"   eywordskay ancay ebay ivengay away umericnay aluevay orway ethay "
"eywordkay :urrentcay\n"
"   otay etsay emthay otay ethay urrentcay aluevay.  Ethay efaultday-"
"efaultday aluesvay\n"
"   areway 00:00:00 onway ethay urrentcay ateday, urrentcay imetay-onezay."

#: src/code/parse-time.lisp
msgid "\"~A\" is not a recognized time/date format."
msgstr "\"~Away\" isway otnay away ecognizedray imetay/ateday ormatfay."

#: src/code/run-program.lisp
msgid "List of process structures for all active processes."
msgstr ""
"Istlay ofway ocesspray ucturesstray orfay allway activeway ocessespray."

#: src/code/run-program.lisp
#, fuzzy
msgid ""
"Return the current status of process.  The result is one of\n"
"  :running,:stopped, :continued, :exited, :signaled."
msgstr ""
"Eturnray ethay urrentcay tatussay ofway ocesspray.  Ethay esultray isway "
"oneway ofway :unningray,\n"
"   :toppedsay, :exitedway, :ignaledsay."

#: src/code/run-program.lisp
msgid "Wait for PROC to quit running for some reason.  Returns PROC."
msgstr ""
"Aitway orfay PROC otay itquay unningray orfay omesay easonray.  Eturnsray "
"PROC."

#: src/code/run-program.lisp
#, fuzzy
msgid "PID of child process."
msgstr "Ouldcay otnay orkfay ildchay ocesspray: ~Away"

#: src/code/run-program.lisp
msgid ""
"Exit code for the process if it is :exited; the termination signal\n"
"  if it is :signaled; 0 if it is :stopped.  It is undefined in all\n"
"  other cases."
msgstr ""

#: src/code/run-program.lisp
msgid "Non-NIL if the process was terminated and a core image was dumped."
msgstr ""

#: src/code/run-program.lisp
#, fuzzy
msgid "The two-way stream connected to the child's Unix pty connection or NIL."
msgstr ""
"Ethay eamstray onnectedcay otay ethay tandardsay inputway (ilefay "
"escriptorday 0)."

#: src/code/run-program.lisp
msgid "Stream to child's input or NIL."
msgstr ""

#: src/code/run-program.lisp
msgid "Stream from child's output or NIL."
msgstr ""

#: src/code/run-program.lisp
msgid "Stream from child's error output or NIL."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"The function to be called whenever process's changes status. This\n"
"  function takes the process as a required argument.  This is\n"
"  setf'able."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"Returns annotations supplibed by users; it is setf'able. This is\n"
"  available for users to associcate information with the process\n"
"  without having to build a-lists or hash tables of process\n"
"  structures."
msgstr ""

#: src/code/run-program.lisp
msgid "TIOCPGRP ioctl failed: ~S"
msgstr "TIOCPGRP ioctlway ailedfay: ~S"

#: src/code/run-program.lisp
msgid ""
"Hand SIGNAL to PROC.  If whom is :pid, use the kill Unix system call.  If\n"
"   whom is :process-group, use the killpg Unix system call.  If whom is\n"
"   :pty-process-group deliver the signal to whichever process group is "
"currently\n"
"   in the foreground."
msgstr ""
"Andhay SIGNAL otay PROC.  Ifway omwhay isway :idpay, useway ethay illkay "
"Unixway ystemsay allcay.  Ifway\n"
"   omwhay isway :ocesspray-oupgray, useway ethay illpgkay Unixway ystemsay "
"allcay.  Ifway omwhay isway\n"
"   :typay-ocesspray-oupgray eliverday ethay ignalsay otay icheverwhay "
"ocesspray oupgray isway urrentlycay\n"
"   inway ethay oregroundfay."

#: src/code/run-program.lisp
msgid "Returns T if the process is still alive, NIL otherwise."
msgstr ""
"Eturnsray T ifway ethay ocesspray isway tillsay aliveway, NIL otherwiseway."

#: src/code/run-program.lisp
msgid ""
"Close all streams connected to PROC and stop maintaining the status slot."
msgstr ""
"Oseclay allway eamsstray onnectedcay otay PROC andway topsay aintainingmay "
"ethay tatussay otslay."

#: src/code/run-program.lisp
msgid ""
"List of file descriptors to close when RUN-PROGRAM exits due to an error."
msgstr ""
"Istlay ofway ilefay escriptorsday otay oseclay enwhay RUN-PROGRAM exitsway "
"ueday otay anway errorway."

#: src/code/run-program.lisp
msgid ""
"List of file descriptors to close when RUN-PROGRAM returns in the parent."
msgstr ""
"Istlay ofway ilefay escriptorsday otay oseclay enwhay RUN-PROGRAM eturnsray "
"inway ethay arentpay."

#: src/code/run-program.lisp
msgid "List of handlers installed by RUN-PROGRAM."
msgstr "Istlay ofway andlershay installedway ybay RUN-PROGRAM."

#: src/code/run-program.lisp
msgid "Returns the master fd, the slave fd, and the name of the tty"
msgstr ""
"Eturnsray ethay astermay dfay, ethay aveslay dfay, andway ethay amenay ofway "
"ethay tytay"

#: src/code/run-program.lisp
msgid "Could not find a pty."
msgstr "Ouldcay otnay indfay away typay."

#: src/code/run-program.lisp
msgid "Could not UNIX:UNIX-DUP ~D: ~A"
msgstr "Ouldcay otnay UNIX:UNIX-DUP ~D: ~Away"

#: src/code/run-program.lisp
#, fuzzy
msgid ""
"RUN-PROGRAM creates a new process and runs the unix program in the\n"
"   file specified by the simple-string PROGRAM.  ARGS are the standard\n"
"   arguments that can be passed to a Unix program, for no arguments\n"
"   use NIL (which means just the name of the program is passed as arg 0).\n"
"\n"
"   RUN-PROGRAM will either return NIL or a PROCESS structure.  See the CMU\n"
"   Common Lisp Users Manual for details about the PROCESS structure.\n"
"\n"
"   The keyword arguments have the following meanings:\n"
"     :env -\n"
"        An A-LIST mapping keyword environment variables to\n"
"\tsimple-string values.  This is the shell environment for\n"
"\tProgram.  Defaults to *environment-list*.\n"
"     :wait -\n"
"        If non-NIL (default), wait until the created process finishes.  If\n"
"        NIL, continue running Lisp until the program finishes.\n"
"     :pty -\n"
"        Either T, NIL, or a stream.  Unless NIL, the subprocess is "
"established\n"
"\tunder a PTY.  If :pty is a stream, all output to this pty is sent to\n"
"\tthis stream, otherwise the PROCESS-PTY slot is filled in with a stream\n"
"\tconnected to pty that can read output and write input.\n"
"     :input -\n"
"        Either T, NIL, a pathname, a stream, or :STREAM.  If T, the "
"standard\n"
"\tinput for the current process is inherited.  If NIL, /dev/null\n"
"\tis used.  If a pathname, the file so specified is used.  If a stream,\n"
"\tall the input is read from that stream and send to the subprocess.  If\n"
"\t:STREAM, the PROCESS-INPUT slot is filled in with a stream that sends \n"
"\tits output to the process. Defaults to NIL.\n"
"     :if-input-does-not-exist (when :input is the name of a file) -\n"
"        can be one of:\n"
"           :error - generate an error.\n"
"           :create - create an empty file.\n"
"           nil (default) - return nil from run-program.\n"
"     :output -\n"
"        Either T, NIL, a pathname, a stream, or :STREAM.  If T, the "
"standard\n"
"\toutput for the current process is inherited.  If NIL, /dev/null\n"
"\tis used.  If a pathname, the file so specified is used.  If a stream,\n"
"\tall the output from the process is written to this stream. If\n"
"\t:STREAM, the PROCESS-OUTPUT slot is filled in with a stream that can\n"
"\tbe read to get the output. Defaults to NIL.\n"
"     :if-output-exists (when :output is the name of a file) -\n"
"        can be one of:\n"
"           :error (default) - generates an error if the file already "
"exists.\n"
"           :supersede - output from the program supersedes the file.\n"
"           :append - output from the program is appended to the file.\n"
"           nil - run-program returns nil without doing anything.\n"
"     :error and :if-error-exists - \n"
"        Same as :output and :if-output-exists, except that :error can also "
"be\n"
"\tspecified as :output in which case all error output is routed to the\n"
"\tsame place as normal output.\n"
"     :status-hook -\n"
"        This is a function the system calls whenever the status of the\n"
"        process changes.  The function takes the process as an argument.\n"
"     :external-format -\n"
"        This is the external-format used for communication with the "
"subprocess.\n"
"     :element-type -\n"
"        When a stream is created for :input or :output, the stream\n"
"        uses this element-type instead of the default 'BASE-CHAR type.\n"
msgstr ""
"RUN-PROGRAM eatescray away ewnay ocesspray andway unsray ethay unixway "
"ogrampray inway ethay\n"
"   ilefay ecifiedspay ybay ethay implesay-ingstray PROGRAM.  ARGS areway "
"ethay tandardsay\n"
"   argumentsway atthay ancay ebay assedpay otay away Unixway ogrampray, "
"orfay onay argumentsway\n"
"   useway NIL (ichwhay eansmay ustjay ethay amenay ofway ethay ogrampray "
"isway assedpay asway argway 0).\n"
"\n"
"   RUN-PROGRAM illway eitherway eturnray NIL orway away PROCESS "
"ucturestray.  Eesay ethay CMU\n"
"   Ommoncay Isplay Usersway Anualmay orfay etailsday aboutway ethay PROCESS "
"ucturestray.\n"
"\n"
"   Ethay eywordkay argumentsway avehay ethay ollowingfay eaningsmay:\n"
"     :envway -\n"
"        Anway Away-LIST appingmay eywordkay environmentway ariablesvay otay "
"implesay-ingstray\n"
"\taluesvay.\n"
"     :aitway -\n"
"        Ifway onnay-NIL (efaultday), aitway untilway ethay eatedcray "
"ocesspray inishesfay.  Ifway\n"
"        NIL, ontinuecay unningray Isplay untilway ethay ogrampray "
"inishesfay.\n"
"     :typay -\n"
"        Eitherway T, NIL, orway away eamstray.  Unlessway NIL, ethay "
"ubprocesssay isway establishwayedway\n"
"\tunderway away PTY.  Ifway :typay isway away eamstray, allway outputway "
"otay isthay typay isway entsay otay\n"
"\tisthay eamstray, otherwiseway ethay PROCESS-PTY otslay isway illedfay "
"inway ithway away eamstray\n"
"\tonnectedcay otay typay atthay ancay eadray outputway andway itewray "
"inputway.\n"
"     :inputway -\n"
"        Eitherway T, NIL, away athnamepay, away eamstray, orway :STREAM.  "
"Ifway T, ethay tandardsay\n"
"\tinputway orfay ethay urrentcay ocesspray isway inheritedway.  Ifway NIL, /"
"evday/ullnay\n"
"\tisway usedway.  Ifway away athnamepay, ethay ilefay osay ecifiedspay isway "
"usedway.  Ifway away eamstray,\n"
"\tallway ethay inputway isway eadray omfray atthay eamstray andway endsay "
"otay ethay ubprocesssay.  Ifway\n"
"\t:STREAM, ethay PROCESS-INPUT otslay isway illedfay inway ithway away "
"eamstray atthay endssay \n"
"\titsway outputway otay ethay ocesspray. Efaultsday otay NIL.\n"
"     :ifway-inputway-oesday-otnay-existway (enwhay :inputway isway ethay "
"amenay ofway away ilefay) -\n"
"        ancay ebay oneway ofway:\n"
"           :errorway - enerategay anway errorway.\n"
"           :eatecray - eatecray anway emptyway ilefay.\n"
"           ilnay (efaultday) - eturnray ilnay omfray unray-ogrampray.\n"
"     :outputway -\n"
"        Eitherway T, NIL, away athnamepay, away eamstray, orway :STREAM.  "
"Ifway T, ethay tandardsay\n"
"\toutputway orfay ethay urrentcay ocesspray isway inheritedway.  Ifway NIL, /"
"evday/ullnay\n"
"\tisway usedway.  Ifway away athnamepay, ethay ilefay osay ecifiedspay isway "
"usedway.  Ifway away eamstray,\n"
"\tallway ethay outputway omfray ethay ocesspray isway ittenwray otay isthay "
"eamstray. Ifway\n"
"\t:STREAM, ethay PROCESS-OUTPUT otslay isway illedfay inway ithway away "
"eamstray atthay ancay\n"
"\tebay eadray otay etgay ethay outputway. Efaultsday otay NIL.\n"
"     :ifway-outputway-existsway (enwhay :outputway isway ethay amenay ofway "
"away ilefay) -\n"
"        ancay ebay oneway ofway:\n"
"           :errorway (efaultday) - eneratesgay anway errorway ifway ethay "
"ilefay alreadyway existsway.\n"
"           :upersedesay - outputway omfray ethay ogrampray upersedessay "
"ethay ilefay.\n"
"           :appendway - outputway omfray ethay ogrampray isway appendedway "
"otay ethay ilefay.\n"
"           ilnay - unray-ogrampray eturnsray ilnay ithoutway oingday "
"anythingway.\n"
"     :errorway andway :ifway-errorway-existsway - \n"
"        Amesay asway :outputway andway :ifway-outputway-existsway, exceptway "
"atthay :errorway ancay alsoway ebay\n"
"\tecifiedspay asway :outputway inway ichwhay asecay allway errorway "
"outputway isway outedray otay ethay\n"
"\tamesay aceplay asway ormalnay outputway.\n"
"     :tatussay-ookhay -\n"
"        Isthay isway away unctionfay ethay ystemsay allscay eneverwhay ethay "
"tatussay ofway ethay\n"
"        ocesspray angeschay.  Ethay unctionfay akestay ethay ocesspray asway "
"anway argumentway.\n"
"     :externalway-ormatfay -\n"
"        Isthay isway ethay externalway-ormatfay usedway orfay "
"ommunicationcay ithway ethay ubprocesayssay.\n"
"     :elementway-ypetay -\n"
"        Enwhay away eamstray isway eatedcray orfay :inputway orway :"
"outputway, ethay eamstray\n"
"        usesway isthay elementway-ypetay insteadway ofway ethay efaultday "
"'BASE-CHAR ypetay.\n"

#: src/code/run-program.lisp
msgid "All args to program must be simple strings -- ~S."
msgstr "Allway argsway otay ogrampray ustmay ebay implesay ingsstray -- ~S."

#: src/code/run-program.lisp
msgid "Could not fork child process: ~A"
msgstr "Ouldcay otnay orkfay ildchay ocesspray: ~Away"

#: src/code/run-program.lisp
msgid "Could not select on sub-process: ~A"
msgstr "Ouldcay otnay electsay onway ubsay-ocesspray: ~Away"

#: src/code/run-program.lisp
msgid "Could not read input from sub-process: ~A"
msgstr "Ouldcay otnay eadray inputway omfray ubsay-ocesspray: ~Away"

#: src/code/run-program.lisp
msgid "Could not open \"/dev/null\": ~A"
msgstr "Ouldcay otnay openway \"/evday/ullnay\": ~Away"

#: src/code/run-program.lisp
msgid "Could not create pipe: ~A"
msgstr "Ouldcay otnay eatecray ipepay: ~Away"

#: src/code/run-program.lisp
msgid "Direction must be either :INPUT or :OUTPUT, not ~S"
msgstr "Irectionday ustmay ebay eitherway :INPUT orway :OUTPUT, otnay ~S"

#: src/code/run-program.lisp
msgid "Could not duplicate file descriptor: ~A"
msgstr "Ouldcay otnay uplicateday ilefay escriptorday: ~Away"

#: src/code/run-program.lisp
msgid "Could not open a temporary file in /tmp"
msgstr "Ouldcay otnay openway away emporarytay ilefay inway /mptay"

#: src/code/run-program.lisp
msgid "Invalid option to run-program: ~S"
msgstr "Invalidway optionway otay unray-ogrampray: ~S"

#: src/code/loop.lisp
msgid ""
"If not NIL, this must be a list of two things:\n"
"a LET-like macro, and a SETQ-like macro, which perform LOOP-style "
"destructuring."
msgstr ""
"Ifway otnay NIL, isthay ustmay ebay away istlay ofway wotay ingsthay:\n"
"away LET-ikelay acromay, andway away SETQ-ikelay acromay, ichwhay erformpay "
"LOOP-tylesay estructurdayingway."

#: src/code/loop.lisp
msgid "LOOP-BODY called with non-synched before- and after-loop lists."
msgstr ""
"LOOP-BODY alledcay ithway onnay-ynchedsay eforebay- andway afterway-ooplay "
"istslay."

#: src/code/loop.lisp
msgid "~?~%Current LOOP context:~{ ~S~}."
msgstr "~?~%Urrentcay LOOP ontextcay:~{ ~S~}."

#: src/code/loop.lisp
msgid "LOOP couldn't verify that ~S is a subtype of the required type ~S."
msgstr ""
"LOOP ouldncay't erifyvay atthay ~S isway away ubtypesay ofway ethay "
"equiredray ypetay ~S."

#: src/code/loop.lisp
msgid "Specified data type ~S is not a subtype of ~S."
msgstr "Ecifiedspay ataday ypetay ~S isway otnay away ubtypesay ofway ~S."

#: src/code/loop.lisp
msgid ""
"Causes the iteration to terminate \"normally\", the same as implicit\n"
"termination by an iteration driving clause, or by use of WHILE or\n"
"UNTIL -- the epilogue code (if any) will be run, and any implicitly\n"
"collected result will be returned as the value of the LOOP."
msgstr ""
"Ausescay ethay iterationway otay erminatetay \"ormallynay\", ethay amesay "
"asway implicitway\n"
"erminationtay ybay anway iterationway ivingdray auseclay, orway ybay useway "
"ofway WHILE orway\n"
"UNTIL -- ethay epilogueway odecay (ifway anyway) illway ebay unray, andway "
"anyway implicitlyway\n"
"ollectedcay esultray illway ebay eturnedray asway ethay aluevay ofway ethay "
"LOOP."

#: src/code/loop.lisp
msgid "~S found where LOOP keyword expected."
msgstr "~S oundfay erewhay LOOP eywordkay expectedway."

#: src/code/loop.lisp
msgid "Secondary clause misplaced at top level in LOOP macro: ~S ~S ~S ..."
msgstr ""
"Econdarysay auseclay isplacedmay atway optay evellay inway LOOP acromay: ~S "
"~S ~S ..."

#: src/code/loop.lisp
msgid "~S is an unknown keyword in LOOP macro."
msgstr "~S isway anway unknownway eywordkay inway LOOP acromay."

#: src/code/loop.lisp
msgid "LOOP source code ran out when another token was expected."
msgstr ""
"LOOP ourcesay odecay anray outway enwhay anotherway okentay asway "
"expectedway."

#: src/code/loop.lisp
msgid "Compound form expected, but found ~A."
msgstr "Ompoundcay ormfay expectedway, utbay oundfay ~Away."

#: src/code/loop.lisp
msgid "LOOP code ran out where a form was expected."
msgstr "LOOP odecay anray outway erewhay away ormfay asway expectedway."

#: src/code/loop.lisp
msgid ""
"LOOP clause is providing a value for the iteration,~@\n"
"\t        however one was already established by a ~S clause."
msgstr ""
"LOOP auseclay isway ovidingpray away aluevay orfay ethay iterationway,~@\n"
"\t        oweverhay oneway asway alreadyway establishedway ybay away ~S "
"auseclay."

#: src/code/loop.lisp
msgid ""
"~:[This LOOP~;The LOOP ~:*~S~] clause is not permitted inside a conditional."
msgstr ""
"~:[Isthay LOOP~;Ethay LOOP ~:*~S~] auseclay isway otnay ermittedpay "
"insideway away onditionalcay."

#: src/code/loop.lisp
msgid "This LOOP clause is not permitted with anonymous collectors."
msgstr ""
"Isthay LOOP auseclay isway otnay ermittedpay ithway anonymousway "
"ollectorscay."

#: src/code/loop.lisp
msgid ""
"This anonymous collection LOOP clause is not permitted with aggregate "
"booleans."
msgstr ""
"Isthay anonymousway ollectioncay LOOP auseclay isway otnay ermittedpay "
"ithway aggregateway ooleansbay."

#: src/code/loop.lisp
msgid ""
"~S found where a LOOP keyword, LOOP type keyword, or LOOP type pattern "
"expected."
msgstr ""
"~S oundfay erewhay away LOOP eywordkay, LOOP ypetay eywordkay, orway LOOP "
"ypetay atternpay expectedway."

#: src/code/loop.lisp
msgid "~S found where a LOOP keyword or LOOP type keyword expected."
msgstr ""
"~S oundfay erewhay away LOOP eywordkay orway LOOP ypetay eywordkay "
"expectedway."

#: src/code/loop.lisp
msgid "Destructuring type pattern ~S contains unrecognized type keyword ~S."
msgstr ""
"Estructuringday ypetay atternpay ~S ontainscay unrecognizedway ypetay "
"eywordkay ~S."

#: src/code/loop.lisp
msgid "Destructuring type pattern ~S doesn't match variable pattern ~S."
msgstr ""
"Estructuringday ypetay atternpay ~S oesnday't atchmay ariablevay atternpay "
"~S."

#: src/code/loop.lisp
msgid "Duplicated LOOP iteration variable ~S."
msgstr "Uplicatedday LOOP iterationway ariablevay ~S."

#: src/code/loop.lisp
msgid "Duplicated variable ~S in LOOP parallel binding."
msgstr "Uplicatedday ariablevay ~S inway LOOP arallelpay indingbay."

#: src/code/loop.lisp
msgid "Bad variable ~S somewhere in LOOP."
msgstr "Adbay ariablevay ~S omewheresay inway LOOP."

#: src/code/loop.lisp
msgid "Variable ~S has already been used"
msgstr "Ariablevay ~S ashay alreadyway eenbay usedway"

#: src/code/loop.lisp
msgid "Invalid LOOP variable passed in: ~S."
msgstr "Invalidway LOOP ariablevay assedpay inway: ~S."

#: src/code/loop.lisp
msgid "~S found where keyword expected getting LOOP clause after ~S."
msgstr ""
"~S oundfay erewhay eywordkay expectedway ettinggay LOOP auseclay afterway ~S."

#: src/code/loop.lisp
msgid "~S does not introduce a LOOP clause that can follow ~S."
msgstr ""
"~S oesday otnay introduceway away LOOP auseclay atthay ancay ollowfay ~S."

#: src/code/loop.lisp
msgid "~S is an invalid name for your LOOP."
msgstr "~S isway anway invalidway amenay orfay ouryay LOOP."

#: src/code/loop.lisp
msgid "The NAMED ~S clause occurs too late."
msgstr "Ethay NAMED ~S auseclay occursway ootay atelay."

#: src/code/loop.lisp
msgid "You may only use one NAMED clause in your loop: NAMED ~S ... NAMED ~S."
msgstr ""
"Ouyay aymay onlyway useway oneway NAMED auseclay inway ouryay ooplay: NAMED "
"~S ... NAMED ~S."

#: src/code/loop.lisp
msgid "Value accumulation recipient name, ~S, is not a symbol."
msgstr ""
"Aluevay accumulationway ecipientray amenay, ~S, isway otnay away ymbolsay."

#: src/code/loop.lisp
msgid "Variable ~S cannot be used in INTO clause"
msgstr "Ariablevay ~S annotcay ebay usedway inway INTO auseclay"

#: src/code/loop.lisp
msgid ""
"Incompatible kinds of LOOP value accumulation specified for collecting~@\n"
"\t\t    ~:[as the value of the LOOP~;~:*INTO ~S~]: ~S and ~S."
msgstr ""
"Incompatibleway indskay ofway LOOP aluevay accumulationway ecifiedspay orfay "
"ollectingcay~@\n"
"\t\t    ~:[asway ethay aluevay ofway ethay LOOP~;~:into*ay ~S~]: ~S andway "
"~S."

#: src/code/loop.lisp
msgid ""
"Unequal datatypes specified in different LOOP value accumulations~@\n"
"\t\t   into ~S: ~S and ~S."
msgstr ""
"Unequalway atatypesday ecifiedspay inway ifferentday LOOP aluevay "
"accumulationsway~@\n"
"\t\t   intoway ~S: ~S andway ~S."

#: src/code/loop.lisp
msgid "Iteration in LOOP follows body code."
msgstr "Iterationway inway LOOP ollowsfay odybay odecay."

#: src/code/loop.lisp
msgid "~S is an unknown keyword in FOR or AS clause in LOOP."
msgstr ""
"~S isway anway unknownway eywordkay inway FOR orway AS auseclay inway LOOP."

#: src/code/loop.lisp
msgid "Use of QUOTE around stepping function in LOOP will be left verbatim."
msgstr ""
"Useway ofway QUOTE aroundway teppingsay unctionfay inway LOOP illway ebay "
"eftlay erbatimvay."

#: src/code/loop.lisp
msgid "~S found where ITS or EACH expected in LOOP iteration path syntax."
msgstr ""
"~S oundfay erewhay ITS orway EACH expectedway inway LOOP iterationway athpay "
"yntaxsay."

#: src/code/loop.lisp
msgid "Unrecognizable LOOP iteration path syntax.  Missing EACH or THE?"
msgstr ""
"Unrecognizableway LOOP iterationway athpay yntaxsay.  Issingmay EACH orway "
"THE?"

#: src/code/loop.lisp
msgid "~S found where a LOOP iteration path name was expected."
msgstr ""
"~S oundfay erewhay away LOOP iterationway athpay amenay asway expectedway."

#: src/code/loop.lisp
msgid "~S is not the name of a LOOP iteration path."
msgstr "~S isway otnay ethay amenay ofway away LOOP iterationway athpay."

#: src/code/loop.lisp
msgid ""
"\"Inclusive\" iteration is not possible with the ~S LOOP iteration path."
msgstr ""
"\"Inclusiveway\" iterationway isway otnay ossiblepay ithway ethay ~S LOOP "
"iterationway athpay."

#: src/code/loop.lisp
msgid "Unused USING variables: ~S."
msgstr "Unusedway USING ariablesvay: ~S."

#: src/code/loop.lisp
msgid ""
"Value passed back by LOOP iteration path function for path ~S has invalid "
"length."
msgstr ""
"Aluevay assedpay ackbay ybay LOOP iterationway athpay unctionfay orfay "
"athpay ~S ashay invalidway engthlay."

#: src/code/loop.lisp
msgid "A ~S prepositional phrase occurs multiply for some LOOP clause."
msgstr ""
"Away ~S epositionalpray rasephay occursway ultiplymay orfay omesay LOOP "
"auseclay."

#: src/code/loop.lisp
msgid "Preposition ~S used when some other preposition has subsumed it."
msgstr ""
"Epositionpray ~S usedway enwhay omesay otherway epositionpray ashay "
"ubsumedsay itway."

#: src/code/loop.lisp
msgid ""
"The variable substitution for ~S occurs twice in a USING phrase,~@\n"
"\t\t        with ~S and ~S."
msgstr ""
"Ethay ariablevay ubstitutionsay orfay ~S occursway wicetay inway away USING "
"rasephay,~@\n"
"\t\t        ithway ~S andway ~S."

#: src/code/loop.lisp
msgid ""
"~S invalid preposition in sequencing or sequence path.~@\n"
"\t       Invalid prepositions specified in iteration path descriptor or "
"something?"
msgstr ""
"~S invalidway epositionpray inway equencingsay orway equencesay athpay.~@\n"
"\t       Invalidway epositionspray ecifiedspay inway iterationway athpay "
"escriptorday orway omethingsay?"

#: src/code/loop.lisp
msgid "Conflicting stepping directions in LOOP sequencing path"
msgstr "Onflictingcay teppingsay irectionsday inway LOOP equencingsay athpay"

#: src/code/loop.lisp
msgid "Missing OF or IN phrase in sequence path"
msgstr "Issingmay OF orway IN rasephay inway equencesay athpay"

#: src/code/loop.lisp
msgid "Don't know where to start stepping."
msgstr "Onday't nowkay erewhay otay tartsay teppingsay."

#: src/code/loop.lisp
msgid "Too many prepositions!"
msgstr "Ootay anymay epositionspray!"

#: src/code/loop.lisp
msgid "Missing OF or IN in ~S iteration path."
msgstr "Issingmay OF orway IN inway ~S iterationway athpay."

#: src/code/loop.lisp
msgid "Unknown preposition ~S"
msgstr "Unknownway epositionpray ~S"

#: src/code/loop.lisp
msgid "Destructuring is not valid for package symbol iteration."
msgstr ""
"Estructuringday isway otnay alidvay orfay ackagepay ymbolsay iterationway."

#: src/code/loop.lisp
#, fuzzy
msgid "Destructuring is not valid for string codepoint iteration."
msgstr ""
"Estructuringday isway otnay alidvay orfay ackagepay ymbolsay iterationway."

#: src/code/loop.lisp
#, fuzzy
msgid "Destructuring is not valid for string glyph iteration."
msgstr ""
"Estructuringday isway otnay alidvay orfay ackagepay ymbolsay iterationway."

#: src/code/stream-vector-io.lisp
msgid "endian-swap ~a is illegal for element-type of vector ~a"
msgstr ""
"endianway-wapsay ~away isway illegalway orfay elementway-ypetay ofway "
"ectorvay ~away"

#: src/code/stream-vector-io.lisp
msgid ""
"Read from Stream into Vector.  The Start and End indices of Vector\n"
"  is in octets, and must be an multiple of the octets per element of\n"
"  the vector element.  The keyword argument :Endian-Swap specifies any\n"
"  endian swapping to be done. "
msgstr ""
"Eadray omfray Eamstray intoway Ectorvay.  Ethay Tartsay andway Endway "
"indicesway ofway Ectorvay\n"
"  isway inway octetsway, andway ustmay ebay anway ultiplemay ofway ethay "
"octetsway erpay elementway ofway\n"
"  ethay ectorvay elementway.  Ethay eywordkay argumentway :Endianway-Wapsay "
"ecifiesspay anyway\n"
"  endianway wappingsay otay ebay oneday. "

#: src/code/stream-vector-io.lisp
msgid "Wrong vector type ~a for read-vector on stream ~a."
msgstr ""
"Ongwray ectorvay ypetay ~away orfay eadray-ectorvay onway eamstray ~away."

#: src/code/stream-vector-io.lisp
msgid ""
"Write Vector to Stream.  The Start and End indices of Vector is in\n"
"  octets, and must be an multiple of the octets per element of the\n"
"  vector element.  The keyword argument :Endian-Swap specifies any\n"
"  endian swapping to be done. "
msgstr ""
"Itewray Ectorvay otay Eamstray.  Ethay Tartsay andway Endway indicesway "
"ofway Ectorvay isway inway\n"
"  octetsway, andway ustmay ebay anway ultiplemay ofway ethay octetsway erpay "
"elementway ofway ethay\n"
"  ectorvay elementway.  Ethay eywordkay argumentway :Endianway-Wapsay "
"ecifiesspay anyway\n"
"  endianway wappingsay otay ebay oneday. "

#: src/code/foreign.lisp
msgid "Could not create temporary file ~S: ~A"
msgstr "Ouldcay otnay eatecray emporarytay ilefay ~S: ~Away"

#: src/code/foreign.lisp
msgid "Make sure the header starts with the ELF magic value."
msgstr ""
"Akemay uresay ethay eaderhay tartssay ithway ethay ELF agicmay aluevay."

#: src/code/foreign.lisp
msgid "Return the `osabi' field in the padding of the ELF file."
msgstr ""
"Eturnray ethay `osabiway' ieldfay inway ethay addingpay ofway ethay ELF "
"ilefay."

#: src/code/foreign.lisp
msgid "Given a file type number, determine whether the file is executable."
msgstr ""
"Ivengay away ilefay ypetay umbernay, etermineday etherwhay ethay ilefay "
"isway executableway."

#: src/code/foreign.lisp
msgid "Make sure the header starts with the mach-o magic value."
msgstr ""
"Akemay uresay ethay eaderhay tartssay ithway ethay achmay-o agicmay aluevay."

#: src/code/foreign.lisp
msgid ""
"Parse symbol table file created by load-foreign script.  Modified\n"
"to skip undefined symbols which don't have an address."
msgstr ""
"Arsepay ymbolsay abletay ilefay eatedcray ybay oadlay-oreignfay riptscay.  "
"Odifiedmay\n"
"otay kipsay undefinedway ymbolssay ichwhay onday't avehay anway addressway."

#: src/code/foreign.lisp
msgid ""
"Load-foreign loads a list of C object files into a running Lisp.  The files\n"
"  argument should be a single file or a list of files.  The files may be\n"
"  specified as namestrings or as pathnames.  The libraries argument should "
"be a\n"
"  list of library files as would be specified to ld.  They will be searched "
"in\n"
"  the order given.  The default is just \"-lc\", i.e., the C library.  The\n"
"  base-file argument is used to specify a file to use as the starting place "
"for\n"
"  defined symbols.  The default is the C start up code for Lisp.  The env\n"
"  argument is the Unix environment variable definitions for the invocation "
"of\n"
"  the linker.  The default is the environment passed to Lisp."
msgstr ""
"Oadlay-oreignfay oadslay away istlay ofway C objectway ilesfay intoway away "
"unningray Isplay.  Ethay ilesfay\n"
"  argumentway ouldshay ebay away inglesay ilefay orway away istlay ofway "
"ilesfay.  Ethay ilesfay aymay ebay\n"
"  ecifiedspay asway amestringsnay orway asway athnamespay.  Ethay "
"ibrarieslay argumentway ouldshay ebay away\n"
"  istlay ofway ibrarylay ilesfay asway ouldway ebay ecifiedspay otay dlay.  "
"Eythay illway ebay earchedsay inway\n"
"  ethay orderway ivengay.  Ethay efaultday isway ustjay \"-clay\", i.e., "
"ethay C ibrarylay.  Ethay\n"
"  asebay-ilefay argumentway isway usedway otay ecifyspay away ilefay otay "
"useway asway ethay tartingsay aceplay orfay\n"
"  efinedday ymbolssay.  Ethay efaultday isway ethay C tartsay upway odecay "
"orfay Isplay.  Ethay envway\n"
"  argumentway isway ethay Unixway environmentway ariablevay efinitionsday "
"orfay ethay invocationway ofway\n"
"  ethay inkerlay.  Ethay efaultday isway ethay environmentway assedpay otay "
"Isplay."

#: src/code/foreign.lisp
msgid "Lazy function call binding"
msgstr "Azylay unctionfay allcay indingbay"

#: src/code/foreign.lisp
msgid "Immediate function call binding"
msgstr "Immediateway unctionfay allcay indingbay"

#: src/code/foreign.lisp
msgid "Mask of binding time value"
msgstr "Askmay ofway indingbay imetay aluevay"

#: src/code/foreign.lisp
msgid ""
"If set the symbols of the loaded object and its dependencies are\n"
"   made visible as if the object were linked directly into the program"
msgstr ""
"Ifway etsay ethay ymbolssay ofway ethay oadedlay objectway andway itsway "
"ependenciesday areway\n"
"   ademay isiblevay asway ifway ethay objectway ereway inkedlay irectlyday "
"intoway ethay ogrampray"

#: src/code/foreign.lisp
msgid ""
"Load C object files into the running Lisp. The FILES argument\n"
"should be a single file or a list of files. The files may be specified\n"
"as namestrings or as pathnames. The LIBRARIES argument should be a\n"
"list of library files as would be specified to ld. They will be\n"
"searched in the order given. The default is just \"-lc\", i.e., the C\n"
"library. The BASE-FILE argument is used to specify a file to use as\n"
"the starting place for defined symbols. The default is the C start up\n"
"code for Lisp. The ENV argument is the Unix environment variable\n"
"definitions for the invocation of the linker. The default is the\n"
"environment passed to Lisp."
msgstr ""
"Oadlay C objectway ilesfay intoway ethay unningray Isplay. Ethay FILES "
"argumentway\n"
"ouldshay ebay away inglesay ilefay orway away istlay ofway ilesfay. Ethay "
"ilesfay aymay ebay ecifiedspay\n"
"asway amestringsnay orway asway athnamespay. Ethay LIBRARIES argumentway "
"ouldshay ebay away\n"
"istlay ofway ibrarylay ilesfay asway ouldway ebay ecifiedspay otay dlay. "
"Eythay illway ebay\n"
"earchedsay inway ethay orderway ivengay. Ethay efaultday isway ustjay \"-"
"clay\", i.e., ethay C\n"
"ibrarylay. Ethay BASE-FILE argumentway isway usedway otay ecifyspay away "
"ilefay otay useway asway\n"
"ethay tartingsay aceplay orfay efinedday ymbolssay. Ethay efaultday isway "
"ethay C tartsay upway\n"
"odecay orfay Isplay. Ethay ENV argumentway isway ethay Unixway "
"environmentway ariablevay\n"
"efinitionsday orfay ethay invocationway ofway ethay inkerlay. Ethay "
"efaultday isway ethay\n"
"environmentway assedpay otay Isplay."

#: src/code/foreign.lisp
msgid "Can't open global symbol table: ~S"
msgstr "Ancay't openway obalglay ymbolsay abletay: ~S"

#: src/code/foreign.lisp
msgid "Can't open object ~S: ~S"
msgstr "Ancay't openway objectway ~S: ~S"

#: src/code/foreign.lisp
msgid "LOAD-OBJECT-FILE: Unresolved symbols in file ~S: ~S"
msgstr "LOAD-OBJECT-FILE: Unresolvedway ymbolssay inway ilefay ~S: ~S"

#: src/code/foreign.lisp
msgid "Couldn't open library ~S: ~S"
msgstr "Ouldncay't openway ibrarylay ~S: ~S"

#: src/code/foreign.lisp
msgid "Reloaded library ~S~%"
msgstr "Eloadedray ibrarylay ~S~%"

#: src/code/foreign.lisp
msgid "Ignore library and continue"
msgstr "Ignoreway ibrarylay andway ontinuecay"

#: src/code/foreign.lisp
msgid "Try reloading again"
msgstr "Ytray eloadingray againway"

#: src/code/foreign.lisp
msgid "Choose new library path"
msgstr "Oosechay ewnay ibrarylay athpay"

#: src/code/foreign.lisp
msgid "Enter new library path: "
msgstr "Enterway ewnay ibrarylay athpay: "

#: src/code/foreign.lisp
msgid ";;; Opening as shared library ~A ...~%"
msgstr ";;; Openingway asway aredshay ibrarylay ~Away ...~%"

#: src/code/foreign.lisp
msgid ";;; Done.~%"
msgstr ";;; Oneday.~%"

#: src/code/foreign.lisp
msgid ";;; Trying as object file ~A...~%"
msgstr ";;; Yingtray asway objectway ilefay ~Away...~%"

#: src/code/foreign.lisp
msgid ";;; Running ~A...~%"
msgstr ";;; Unningray ~Away...~%"

#: src/code/foreign.lisp
msgid "Could not run ~A"
msgstr "Ouldcay otnay unray ~Away"

#: src/code/foreign.lisp
msgid "~A failed:~%~A"
msgstr "~Away ailedfay:~%~Away"

#: src/code/foreign.lisp
msgid "File does not exist: ~A."
msgstr "Ilefay oesday otnay existway: ~Away."

#: src/code/internet.lisp
msgid "AList of socket kinds and protocol values."
msgstr "Alistway ofway ocketsay indskay andway otocolpray aluesvay."

#: src/code/internet.lisp
msgid "Internet protocol :DATA-GRAM is deprecated. Using :DATAGRAM"
msgstr ""
"Internetway otocolpray :DATA-GRAM isway eprecatedday. Usingway :DATAGRAM"

#: src/code/internet.lisp
msgid "Invalid kind (~S) for internet domain sockets."
msgstr "Invalidway indkay (~S) orfay internetway omainday ocketssay."

#: src/code/internet.lisp
msgid ""
"Return a host-entry for the given host. The host may be an address\n"
"  string or an IP address in host order."
msgstr ""
"Eturnray away osthay-entryway orfay ethay ivengay osthay. Ethay osthay aymay "
"ebay anway addressway\n"
"  ingstray orway anway IP addressway inway osthay orderway."

#: src/code/internet.lisp
msgid "Error creating socket: ~A"
msgstr "Errorway eatingcray ocketsay: ~Away"

#: src/code/internet.lisp
msgid "Error connecting socket to [~A]: ~A"
msgstr "Errorway onnectingcay ocketsay otay [~Away]: ~Away"

#: src/code/internet.lisp
msgid "Error binding socket to path ~a: ~a"
msgstr "Errorway indingbay ocketsay otay athpay ~away: ~away"

#: src/code/internet.lisp
msgid "Error listening to socket: ~A"
msgstr "Errorway isteninglay otay ocketsay: ~Away"

#: src/code/internet.lisp
msgid "Error accepting a connection: ~A"
msgstr "Errorway acceptingway away onnectioncay: ~Away"

#: src/code/internet.lisp
msgid "bind Socket to (local) Host and Port"
msgstr "indbay Ocketsay otay (ocallay) Osthay andway Ortpay"

#: src/code/internet.lisp
msgid "Error binding socket to port ~A: ~A"
msgstr "Errorway indingbay ocketsay otay ortpay ~Away: ~Away"

#: src/code/internet.lisp
msgid "Unknown host: ~S."
msgstr "Unknownway osthay: ~S."

#: src/code/internet.lisp
msgid "The host may be an address string or an IP address in host order."
msgstr ""
"Ethay osthay aymay ebay anway addressway ingstray orway anway IP addressway "
"inway osthay orderway."

#: src/code/internet.lisp
msgid "Error connecting socket to [~A:~A]: ~A"
msgstr "Errorway onnectingcay ocketsay otay [~Away:~Away]: ~Away"

#: src/code/internet.lisp
msgid "Get an integer value socket option."
msgstr "Etgay anway integerway aluevay ocketsay optionway."

#: src/code/internet.lisp
msgid "Set an integer value socket option."
msgstr "Etsay anway integerway aluevay ocketsay optionway."

#: src/code/internet.lisp
msgid "Error ~S setting socket option on socket ~D."
msgstr "Errorway ~S ettingsay ocketsay optionway onway ocketsay ~D."

#: src/code/internet.lisp
msgid "Error closing socket: ~A"
msgstr "Errorway osingclay ocketsay: ~Away"

#: src/code/internet.lisp
msgid "Return the peer host address and port in host order."
msgstr ""
"Eturnray ethay eerpay osthay addressway andway ortpay inway osthay orderway."

#: src/code/internet.lisp
msgid "Error ~s getting peer host and port on FD ~d."
msgstr "Errorway ~s ettinggay eerpay osthay andway ortpay onway FD ~d."

#: src/code/internet.lisp
msgid "Error ~s getting socket host and port on FD ~d."
msgstr "Errorway ~s ettinggay ocketsay osthay andway ortpay onway FD ~d."

#: src/code/internet.lisp
msgid "Ignore it"
msgstr "Ignoreway itway"

#: src/code/internet.lisp
msgid "Error recving oob data on ~A: ~A"
msgstr "Errorway ecvingray oobway ataday onway ~Away: ~Away"

#: src/code/internet.lisp
msgid "No oob handler defined for ~S on ~A"
msgstr "Onay oobway andlerhay efinedday orfay ~S onway ~Away"

#: src/code/internet.lisp
msgid "Got a SIGURG, but couldn't find any out-of-band data."
msgstr ""
"Otgay away SIGURG, utbay ouldncay't indfay anyway outway-ofway-andbay ataday."

#: src/code/internet.lisp
msgid "Arrange to funcall HANDLER when CHAR shows up out-of-band on FD."
msgstr ""
"Arrangeway otay uncallfay HANDLER enwhay CHAR owsshay upway outway-ofway-"
"andbay onway FD."

#: src/code/internet.lisp
msgid "Remove any handlers for CHAR on FD."
msgstr "Emoveray anyway andlershay orfay CHAR onway FD."

#: src/code/internet.lisp
msgid "Remove all handlers for FD."
msgstr "Emoveray allway andlershay orfay FD."

#: src/code/internet.lisp
msgid "Error sending ~S OOB to across ~A: ~A"
msgstr "Errorway endingsay ~S OOB otay acrossway ~Away: ~Away"

#: src/code/internet.lisp
msgid ""
"A packaging of the unix recvfrom call.  Returns three values:\n"
"bytecount, source address as integer, and source port.  bytecount\n"
"can of course be negative, to indicate faults."
msgstr ""
"Away ackagingpay ofway ethay unixway ecvfromray allcay.  Eturnsray reethay "
"aluesvay:\n"
"ytecountbay, ourcesay addressway asway integerway, andway ourcesay ortpay.  "
"ytecountbay\n"
"ancay ofway oursecay ebay egativenay, otay indicateway aultsfay."

#: src/code/internet.lisp
msgid "A packaging of the unix sendto call.  Return value like sendto"
msgstr ""
"Away ackagingpay ofway ethay unixway endtosay allcay.  Eturnray aluevay "
"ikelay endtosay"

#: src/code/internet.lisp
msgid ""
"A packaging of the unix shutdown call.  An error is signaled if shutdown "
"fails."
msgstr ""
"Away ackagingpay ofway ethay unixway utdownshay allcay.  Anway errorway "
"isway ignaledsay ifway utdownshay ailsfay."

#: src/code/internet.lisp
msgid "Error on shutdown of socket: ~A"
msgstr "Errorway onway utdownshay ofway ocketsay: ~Away"

#: src/code/internet.lisp
msgid ""
"Return a network stream.  HOST may be an address string or an integer\n"
"IP address."
msgstr ""
"Eturnray away etworknay eamstray.  HOST aymay ebay anway addressway ingstray "
"orway anway integerway\n"
"IP addressway."

#: src/code/internet.lisp
msgid "Unknown host format: ~S."
msgstr "Unknownway osthay ormatfay: ~S."

#: src/code/internet.lisp
msgid "network connection to ~A"
msgstr "etworknay onnectioncay otay ~Away"

#: src/code/internet.lisp
msgid "network connection from ~D.~D.~D.~D:~D"
msgstr "etworknay onnectioncay omfray ~D.~D.~D.~D:~D"

#: src/code/wire.lisp
msgid "The wire the form we are currently evaluating came across."
msgstr ""
"Ethay ireway ethay ormfay eway areway urrentlycay evaluatingway amecay "
"acrossway."

#: src/code/wire.lisp
msgid "Unique identifier for this host."
msgstr "Uniqueway identifierway orfay isthay osthay."

#: src/code/wire.lisp
msgid "Unique identifier for this process."
msgstr "Uniqueway identifierway orfay isthay ocesspray."

#: src/code/wire.lisp
msgid "Hash table mapping local objects to the corresponding remote id."
msgstr ""
"Ashhay abletay appingmay ocallay objectsway otay ethay orrespondingcay "
"emoteray idway."

#: src/code/wire.lisp
msgid "Hash table mapping remote id's to the curresponding local object."
msgstr ""
"Ashhay abletay appingmay emoteray idway's otay ethay urrespondingcay ocallay "
"objectway."

#: src/code/wire.lisp
msgid "Next available id for remote objects."
msgstr "Extnay availableway idway orfay emoteray objectsway."

#: src/code/wire.lisp
msgid "There is a problem with ~A."
msgstr "Erethay isway away oblempray ithway ~Away."

#: src/code/wire.lisp
msgid "Received EOF on ~A."
msgstr "Eceivedray EOF onway ~Away."

#: src/code/wire.lisp
msgid "Error ~A ~A: ~A."
msgstr "Errorway ~Away ~Away: ~Away."

#: src/code/wire.lisp
msgid "Returns T iff the given remote object is defined locally."
msgstr ""
"Eturnsray T iffway ethay ivengay emoteray objectway isway efinedday "
"ocallylay."

#: src/code/wire.lisp
msgid ""
"Returns T iff the two objects refer to the same (eq) object in the same\n"
"  process."
msgstr ""
"Eturnsray T iffway ethay wotay objectsway eferray otay ethay amesay (eqway) "
"objectway inway ethay amesay\n"
"  ocesspray."

#: src/code/wire.lisp
msgid ""
"Return the associated value for the given remote object. It is an error if\n"
"  the remote object was not created in this process or if\n"
"  FORGET-REMOTE-TRANSLATION has been called on this remote object."
msgstr ""
"Eturnray ethay associatedway aluevay orfay ethay ivengay emoteray objectway. "
"Itway isway anway errorway ifway\n"
"  ethay emoteray objectway asway otnay eatedcray inway isthay ocesspray "
"orway ifway\n"
"  FORGET-REMOTE-TRANSLATION ashay eenbay alledcay onway isthay emoteray "
"objectway."

#: src/code/wire.lisp
msgid "~S is defined is a different process."
msgstr "~S isway efinedday isway away ifferentday ocesspray."

#: src/code/wire.lisp
msgid "Use the value of NIL"
msgstr "Useway ethay aluevay ofway NIL"

#: src/code/wire.lisp
msgid "No value for ~S -- FORGET-REMOTE-TRANSLATION was called to early."
msgstr ""
"Onay aluevay orfay ~S -- FORGET-REMOTE-TRANSLATION asway alledcay otay "
"earlyway."

#: src/code/wire.lisp
msgid "Convert the given local object to a remote object."
msgstr ""
"Onvertcay ethay ivengay ocallay objectway otay away emoteray objectway."

#: src/code/wire.lisp
msgid ""
"Forget the translation from the given local to the corresponding remote\n"
"object. Passing that remote object to remote-object-value will new return "
"NIL."
msgstr ""
"Orgetfay ethay anslationtray omfray ethay ivengay ocallay otay ethay "
"orrespondingcay emoteray\n"
"objectway. Assingpay atthay emoteray objectway otay emoteray-objectway-"
"aluevay illway ewnay eturnray NIL."

#: src/code/wire.lisp
msgid ""
"Return T iff anything is in the input buffer or available on the socket."
msgstr ""
"Eturnray T iffway anythingway isway inway ethay inputway ufferbay orway "
"availableway onway ethay ocketsay."

#: src/code/wire.lisp
msgid "listening to"
msgstr "isteninglay otay"

#: src/code/wire.lisp
msgid ""
"Read data off the socket, filling the input buffer. The buffer is cleared\n"
"first. If fill-input-buffer returns, it is guarenteed that there will be at\n"
"least one byte in the input buffer. If EOF was reached, as wire-eof error\n"
"is signaled."
msgstr ""
"Eadray ataday offway ethay ocketsay, illingfay ethay inputway ufferbay. "
"Ethay ufferbay isway earedclay\n"
"irstfay. Ifway illfay-inputway-ufferbay eturnsray, itway isway uarenteedgay "
"atthay erethay illway ebay atway\n"
"eastlay oneway ytebay inway ethay inputway ufferbay. Ifway EOF asway "
"eachedray, asway ireway-eofway errorway\n"
"isway ignaledsay."

#: src/code/wire.lisp
msgid "reading"
msgstr "eadingray"

#: src/code/wire.lisp
msgid "Return the next byte from the wire."
msgstr "Eturnray ethay extnay ytebay omfray ethay ireway."

#: src/code/wire.lisp
msgid ""
"Read a number off the wire. Numbers are 4 bytes in network order.\n"
"The optional argument controls weather or not the number should be "
"considered\n"
"signed (defaults to T)."
msgstr ""
"Eadray away umbernay offway ethay ireway. Umbersnay areway 4 ytesbay inway "
"etworknay orderway.\n"
"Ethay optionalway argumentway ontrolscay eatherway orway otnay ethay "
"umbernay ouldshay ebay onsiderecayd\n"
"ignedsay (efaultsday otay T)."

#: src/code/wire.lisp
msgid ""
"Reads an arbitrary integer sent by WIRE-OUTPUT-BIGNUM from the wire and\n"
"   return it."
msgstr ""
"Eadsray anway arbitraryway integerway entsay ybay WIRE-OUTPUT-BIGNUM omfray "
"ethay ireway andway\n"
"   eturnray itway."

#: src/code/wire.lisp
msgid "Reads a string from the wire. The first four bytes spec the size."
msgstr ""
"Eadsray away ingstray omfray ethay ireway. Ethay irstfay ourfay ytesbay "
"ecspay ethay izesay."

#: src/code/wire.lisp
msgid "Reads the next object from the wire and returns it."
msgstr ""
"Eadsray ethay extnay objectway omfray ethay ireway andway eturnsray itway."

#: src/code/wire.lisp
msgid ""
"Attempt to read symbol, ~A, of wire into non-existent ~\n"
"\t\t       package, ~A."
msgstr ""
"Attemptway otay eadray ymbolsay, ~Away, ofway ireway intoway onnay-"
"existentway ~\n"
"\t\t       ackagepay, ~Away."

#: src/code/wire.lisp
msgid ""
"Send any info still in the output buffer down the wire and clear it. "
"Nothing\n"
"harmfull will happen if called when the output buffer is empty."
msgstr ""
"Endsay anyway infoway tillsay inway ethay outputway ufferbay ownday ethay "
"ireway andway earclay itway. Othingnay\n"
"armfullhay illway appenhay ifway alledcay enwhay ethay outputway ufferbay "
"isway emptyway."

#: src/code/wire.lisp
msgid "writing"
msgstr "itingwray"

#: src/code/wire.lisp
msgid "Not everything wrote."
msgstr "Otnay everythingway otewray."

#: src/code/wire.lisp
msgid "Output the given (8-bit) byte on the wire."
msgstr "Outputway ethay ivengay (8-itbay) ytebay onway ethay ireway."

#: src/code/wire.lisp
msgid "Output the given (32-bit) number on the wire."
msgstr "Outputway ethay ivengay (32-itbay) umbernay onway ethay ireway."

#: src/code/wire.lisp
msgid ""
"Outputs an arbitrary integer, but less effeciently than WIRE-OUTPUT-NUMBER."
msgstr ""
"Outputsway anway arbitraryway integerway, utbay esslay effecientlyway anthay "
"WIRE-OUTPUT-NUMBER."

#: src/code/wire.lisp
msgid ""
"Output the given string. First output the length using WIRE-OUTPUT-NUMBER,\n"
"then output the bytes."
msgstr ""
"Outputway ethay ivengay ingstray. Irstfay outputway ethay engthlay usingway "
"WIRE-OUTPUT-NUMBER,\n"
"enthay outputway ethay ytesbay."

#: src/code/wire.lisp
msgid ""
"Output the given object on the given wire. If cache-it is T, enter this\n"
"object in the cache for future reference."
msgstr ""
"Outputway ethay ivengay objectway onway ethay ivengay ireway. Ifway achecay-"
"itway isway T, enterway isthay\n"
"objectway inway ethay achecay orfay uturefay eferenceray."

#: src/code/wire.lisp
msgid "Error: Cannot output objects of type ~s across a wire."
msgstr ""
"Errorway: Annotcay outputway objectsway ofway ypetay ~s acrossway away "
"ireway."

#: src/code/wire.lisp
msgid "Send the function and args down the wire as a funcall."
msgstr ""
"Endsay ethay unctionfay andway argsway ownday ethay ireway asway away "
"uncallfay."

#: src/code/remote.lisp
msgid "AList of wire . remote-wait structs"
msgstr "Alistway ofway ireway . emoteray-aitway uctsstray"

#: src/code/remote.lisp
msgid ""
"Evaluates the given forms remotly. No values are returned, as the remote\n"
"evaluation is asyncronus."
msgstr ""
"Evaluatesway ethay ivengay ormsfay emotlyray. Onay aluesvay areway "
"eturnedray, asway ethay emoteray\n"
"evaluationway isway asyncronusway."

#: src/code/remote.lisp
msgid ""
"Bind VARS to the multiple values of FORM (which is executed remotely). The\n"
"forms in BODY are only executed if the remote function returned (as apposed\n"
"to aborting due to a throw)."
msgstr ""
"Indbay VARS otay ethay ultiplemay aluesvay ofway FORM (ichwhay isway "
"executedway emotelyray). Ethay\n"
"ormsfay inway BODY areway onlyway executedway ifway ethay emoteray "
"unctionfay eturnedray (asway apposedway\n"
"otay abortingway ueday otay away rowthay)."

#: src/code/remote.lisp
msgid ""
"Execute the single form remotly. The value of the form is returned.\n"
"  The optional form on-server-unwind is only evaluated if the server "
"unwinds\n"
"  instead of returning."
msgstr ""
"Executeway ethay inglesay ormfay emotlyray. Ethay aluevay ofway ethay ormfay "
"isway eturnedray.\n"
"  Ethay optionalway ormfay onway-erversay-unwindway isway onlyway "
"evaluatedway ifway ethay erversay unwindsway\n"
"  insteadway ofway eturningray."

#: src/code/remote.lisp
msgid ""
"Create a request server on the given port.  Whenever anyone connects to it,\n"
"   call the given function with the newly created wire and the address of "
"the\n"
"   connector.  If the function returns NIL, the connection is destroyed;\n"
"   otherwise, it is accepted.  This returns a manifestation of the server "
"that\n"
"   DESTROY-REQUEST-SERVER accepts to kill the request server."
msgstr ""
"Eatecray away equestray erversay onway ethay ivengay ortpay.  Eneverwhay "
"anyoneway onnectscay otay itway,\n"
"   allcay ethay ivengay unctionfay ithway ethay ewlynay eatedcray ireway "
"andway ethay addressway ofway ethay\n"
"   onnectorcay.  Ifway ethay unctionfay eturnsray NIL, ethay onnectioncay "
"isway estroyedday;\n"
"   otherwiseway, itway isway acceptedway.  Isthay eturnsray away "
"anifestationmay ofway ethay erversay atthay\n"
"   DESTROY-REQUEST-SERVER acceptsway otay illkay ethay equestray erversay."

#: src/code/remote.lisp
msgid "Quit accepting connections to the given request server."
msgstr ""
"Itquay acceptingway onnectionscay otay ethay ivengay equestray erversay."

#: src/code/remote.lisp
msgid ""
"Connect to a remote request server addressed with the given host and port\n"
"   pair.  This returns the created wire."
msgstr ""
"Onnectcay otay away emoteray equestray erversay addressedway ithway ethay "
"ivengay osthay andway ortpay\n"
"   airpay.  Isthay eturnsray ethay eatedcray ireway."

#: src/code/defstruct.lisp
msgid ""
"Controls compiling DEFSTRUCT :print-function and :print-method\n"
"   options according to ANSI spec. MUST be NIL to compile CMUCL & PCL"
msgstr ""
"Ontrolscay ompilingcay DEFSTRUCT :intpray-unctionfay andway :intpray-"
"ethodmay\n"
"   optionsway accordingway otay ANSI ecspay. MUST ebay NIL otay ompilecay "
"CMUCL & PCL"

#: src/code/defstruct.lisp
msgid "Allocate a new instance with LENGTH data slots."
msgstr "Allocateway away ewnay instanceway ithway LENGTH ataday otsslay."

#: src/code/defstruct.lisp
msgid "Given an instance, return its length."
msgstr "Ivengay anway instanceway, eturnray itsway engthlay."

#: src/code/defstruct.lisp
msgid "Return the value from the INDEXth slot of INSTANCE.  This is SETFable."
msgstr ""
"Eturnray ethay aluevay omfray ethay Indexthway otslay ofway INSTANCE.  "
"Isthay isway Etfablesay."

#: src/code/defstruct.lisp
msgid "Set the INDEXth slot of INSTANCE to NEW-VALUE."
msgstr "Etsay ethay Indexthway otslay ofway INSTANCE otay NEW-VALUE."

#: src/code/defstruct.lisp
msgid "Class not yet defined or was undefined: ~S"
msgstr "Assclay otnay etyay efinedday orway asway undefinedway: ~S"

#: src/code/defstruct.lisp
msgid "Class is not a structure class: ~S"
msgstr "Assclay isway otnay away ucturestray assclay: ~S"

#: src/code/defstruct.lisp
msgid ""
"DEFSTRUCT {Name | (Name Option*)} {Slot | (Slot [Default] {Key Value}*)}\n"
"   Define the structure type Name.  Instances are created by MAKE-<name>, "
"which\n"
"   takes keyword arguments allowing initial slot values to the specified.\n"
"   A SETF'able function <name>-<slot> is defined for each slot to "
"read&write\n"
"   slot values.  <name>-p is a type predicate.\n"
"\n"
"   Popular DEFSTRUCT options (see manual for others):\n"
"\n"
"   (:CONSTRUCTOR Name)\n"
"   (:PREDICATE Name)\n"
"       Specify an alternate name for the constructor or predicate.\n"
"\n"
"   (:CONSTRUCTOR Name Lambda-List)\n"
"       Explicitly specify the name and arguments to create a BOA "
"constructor\n"
"       (which is more efficient when keyword syntax isn't necessary.)\n"
"\n"
"   (:INCLUDE Supertype Slot-Spec*)\n"
"       Make this type a subtype of the structure type Supertype.  The "
"optional\n"
"       Slot-Specs override inherited slot options.\n"
"\n"
"   Slot options:\n"
"\n"
"   :TYPE Type-Spec\n"
"       Asserts that the value of this slot is always of the specified type.\n"
"\n"
"   :READ-ONLY {T | NIL}\n"
"       If true, no setter function is defined for this slot."
msgstr ""
"DEFSTRUCT {Amenay | (Amenay Option*Way)} {Otslay | (Otslay [Efaultday] "
"{Eykay Aluevay}*)}\n"
"   Efineday ethay ucturestray ypetay Amenay.  Instancesway areway eatedcray "
"ybay MAKE-<amenay>, ichwhay\n"
"   akestay eywordkay argumentsway allowingway initialway otslay aluesvay "
"otay ethay ecifiedspay.\n"
"   Away SETF'ableway unctionfay <amenay>-<otslay> isway efinedday orfay "
"eachway otslay otay eadray&itewray\n"
"   otslay aluesvay.  <amenay>-p isway away ypetay edicatepray.\n"
"\n"
"   Opularpay DEFSTRUCT optionsway (eesay anualmay orfay othersway):\n"
"\n"
"   (:CONSTRUCTOR Amenay)\n"
"   (:PREDICATE Amenay)\n"
"       Ecifyspay anway alternateway amenay orfay ethay onstructorcay orway "
"edicatepray.\n"
"\n"
"   (:CONSTRUCTOR Amenay Ambdalay-Istlay)\n"
"       Explicitlyway ecifyspay ethay amenay andway argumentsway otay "
"eatecray away BOA onstructorcay\n"
"       (ichwhay isway oremay efficientway enwhay eywordkay yntaxsay isnway't "
"ecessarynay.)\n"
"\n"
"   (:INCLUDE Upertypesay Otslay-Ec*Spay)\n"
"       Akemay isthay ypetay away ubtypesay ofway ethay ucturestray ypetay "
"Upertypesay.  Ethay optionalway\n"
"       Otslay-Ecsspay overrideway inheritedway otslay optionsway.\n"
"\n"
"   Otslay optionsway:\n"
"\n"
"   :TYPE Ypetay-Ecspay\n"
"       Assertsway atthay ethay aluevay ofway isthay otslay isway alwaysway "
"ofway ethay ecifiedspay ypetay.\n"
"\n"
"   :READ-ONLY {T | NIL}\n"
"       Ifway uetray, onay ettersay unctionfay isway efinedday orfay isthay "
"otslay."

#: src/code/defstruct.lisp
msgid "defining structure ~A"
msgstr "efiningday ucturestray ~Away"

#: src/code/defstruct.lisp
msgid "Disable package's definition lock then continue"
msgstr "Isableday ackagepay's efinitionday ocklay enthay ontinuecay"

#: src/code/defstruct.lisp
msgid "Defstruct already names a declaration: ~S."
msgstr "Efstructday alreadyway amesnay away eclarationday: ~S."

#: src/code/defstruct.lisp
msgid "Can't have more than one :INCLUDE option."
msgstr "Ancay't avehay oremay anthay oneway :INCLUDE optionway."

#: src/code/defstruct.lisp
msgid "~S is a bad :TYPE for Defstruct."
msgstr "~S isway away adbay :TYPE orfay Efstructday."

#: src/code/defstruct.lisp
msgid "The Defstruct option :NAMED takes no arguments."
msgstr "Ethay Efstructday optionway :NAMED akestay onay argumentsway."

#: src/code/defstruct.lisp
msgid "Unknown DEFSTRUCT option~%  ~S"
msgstr "Unknownway DEFSTRUCT optionway~%  ~S"

#: src/code/defstruct.lisp
msgid "Unrecognized DEFSTRUCT option: ~S"
msgstr "Unrecognizedway DEFSTRUCT optionway: ~S"

#: src/code/defstruct.lisp
msgid "Can't specify :OFFSET unless :TYPE is specified."
msgstr "Ancay't ecifyspay :OFFSET unlessway :TYPE isway ecifiedspay."

#: src/code/defstruct.lisp
msgid "Silly to specify :PRINT-FUNCTION with :TYPE."
msgstr "Illysay otay ecifyspay :PRINT-FUNCTION ithway :TYPE."

#: src/code/defstruct.lisp
msgid "Silly to specify :MAKE-LOAD-FORM-FUN with :TYPE."
msgstr "Illysay otay ecifyspay :MAKE-LOAD-FORM-FUN ithway :TYPE."

#: src/code/defstruct.lisp
msgid "Duplicate slot name ~S."
msgstr "Uplicateday otslay amenay ~S."

#: src/code/defstruct.lisp
msgid "Slot ~S must be read-only in subtype ~S."
msgstr "Otslay ~S ustmay ebay eadray-onlyway inway ubtypesay ~S."

#: src/code/defstruct.lisp
msgid ""
"Keyword slot name indicates probable syntax ~\n"
"\t\t      error in DEFSTRUCT -- ~S."
msgstr ""
"Eywordkay otslay amenay indicatesway obablepray yntaxsay ~\n"
"\t\t      errorway inway DEFSTRUCT -- ~S."

#: src/code/defstruct.lisp
msgid ":TYPE option mismatch between structures ~S and ~S."
msgstr ":TYPE optionway ismatchmay etweenbay ucturesstray ~S andway ~S."

#: src/code/defstruct.lisp
msgid ":TYPE'd defstruct ~S not found for inclusion."
msgstr ":TYPE'd efstructday ~S otnay oundfay orfay inclusionway."

#: src/code/defstruct.lisp
msgid "(:CONSTRUCTOR NIL) combined with other :CONSTRUCTORs."
msgstr "(:CONSTRUCTOR NIL) ombinedcay ithway otherway :Onstructorscay."

#: src/code/defstruct.lisp
msgid ""
"~@<Non-overwritten accessor ~S does not access ~\n"
"                        slot with name ~S (accessing an inherited slot ~\n"
"                        instead).~:@>"
msgstr ""
"~@<Onnay-overwrittenway accessorway ~S oesday otnay accessway ~\n"
"                        otslay ithway amenay ~S (accessingway anway "
"inheritedway otslay ~\n"
"                        insteadway).~:@>"

#: src/code/defstruct.lisp
msgid "Obsolete structure accessor function called."
msgstr "Obsoleteway ucturestray accessorway unctionfay alledcay."

#: src/code/defstruct.lisp
msgid "Structure for accessor ~S is not a ~S:~% ~S"
msgstr "Ucturestray orfay accessorway ~S isway otnay away ~S:~% ~S"

#: src/code/defstruct.lisp
msgid "Structure for setter ~S is not a ~S:~% ~S"
msgstr "Ucturestray orfay ettersay ~S isway otnay away ~S:~% ~S"

#: src/code/defstruct.lisp
msgid "New-Value for setter ~S is not a ~S:~% ~S."
msgstr "Ewnay-Aluevay orfay ettersay ~S isway otnay away ~S:~% ~S."

#: src/code/defstruct.lisp
msgid "Structure for copier is not a ~S:~% ~S"
msgstr "Ucturestray orfay opiercay isway otnay away ~S:~% ~S"

#: src/code/defstruct.lisp
msgid ""
"Shouldn't happen!  Some strange thing in LAYOUT-INFO:~\n"
"\t\t    ~%  ~S"
msgstr ""
"Ouldnshay't appenhay!  Omesay angestray ingthay inway LAYOUT-INFO:~\n"
"\t\t    ~%  ~S"

#: src/code/defstruct.lisp
msgid ""
"Incompatibly redefining slots of structure class ~S~@\n"
"\t  Make sure any uses of affected accessors are recompiled:~@\n"
"\t  ~@[  These slots were moved to new positions:~%    ~S~%~]~\n"
"\t  ~@[  These slots have new incompatible types:~%    ~S~%~]~\n"
"\t  ~@[  These slots were deleted:~%    ~S~%~]"
msgstr ""
"Incompatiblyway edefiningray otsslay ofway ucturestray assclay ~S~@\n"
"\t  Akemay uresay anyway usesway ofway affectedway accessorsway areway "
"ecompiledray:~@\n"
"\t  ~@[  Esethay otsslay ereway ovedmay otay ewnay ositionspay:~%    "
"~S~%~]~\n"
"\t  ~@[  Esethay otsslay avehay ewnay incompatibleway ypestay:~%    ~S~%~]~\n"
"\t  ~@[  Esethay otsslay ereway eletedday:~%    ~S~%~]"

#: src/code/defstruct.lisp
msgid ""
"Redefining class ~S incompatibly with the current ~\n"
"\t\tdefinition."
msgstr ""
"Edefiningray assclay ~S incompatiblyway ithway ethay urrentcay ~\n"
"\t\tefinitionday."

#: src/code/defstruct.lisp
msgid "Invalidate already loaded code and instances, use new definition."
msgstr ""
"Invalidateway alreadyway oadedlay odecay andway instancesway, useway ewnay "
"efinitionday."

#: src/code/defstruct.lisp
msgid "Previously loaded ~S accessors will no longer work."
msgstr "Eviouslypray oadedlay ~S accessorsway illway onay ongerlay orkway."

#: src/code/defstruct.lisp
msgid ""
"Any old ~S instances will be in a bad way.~@\n"
"\t       I hope you know what you're doing..."
msgstr ""
"Anyway oldway ~S instancesway illway ebay inway away adbay ayway.~@\n"
"\t       Iway opehay ouyay nowkay atwhay ouyay'eray oingday..."

#: src/code/defstruct.lisp
msgid "Removing old subclasses of ~S:~%  ~S"
msgstr "Emovingray oldway ubclassessay ofway ~S:~%  ~S"

#: src/code/defstruct.lisp
msgid "Return a copy of Structure with the same (EQL) slot values."
msgstr ""
"Eturnray away opycay ofway Ucturestray ithway ethay amesay (EQL) otslay "
"aluesvay."

#: src/code/defstruct.lisp
msgid "Copying an obsolete structure:~%  ~S"
msgstr "Opyingcay anway obsoleteway ucturestray:~%  ~S"

#: src/code/defstruct.lisp
msgid "Structures of type ~S cannot be dumped as constants."
msgstr "Ucturesstray ofway ypetay ~S annotcay ebay umpedday asway onstantscay."

#: src/code/defmacro.lisp
msgid "A list of tests that do argument counting at expansion time."
msgstr ""
"Away istlay ofway eststay atthay oday argumentway ountingcay atway "
"expansionway imetay."

#: src/code/defmacro.lisp
msgid "Let bindings that are done to make lambda-list parsing possible."
msgstr ""
"Etlay indingsbay atthay areway oneday otay akemay ambdalay-istlay arsingpay "
"ossiblepay."

#: src/code/defmacro.lisp
msgid "Let bindings that the user has explicitly supplied."
msgstr "Etlay indingsbay atthay ethay userway ashay explicitlyway uppliedsay."

#: src/code/defmacro.lisp
msgid "Unsupplied optional and keyword arguments get this value defaultly."
msgstr ""
"Unsuppliedway optionalway andway eywordkay argumentsway etgay isthay aluevay "
"efaultlyday."

#: src/code/defmacro.lisp
msgid ""
"Returns as multiple-values a parsed body, any local-declarations that\n"
"   should be made where this body is inserted, and a doc-string if there is\n"
"   one."
msgstr ""
"Eturnsray asway ultiplemay-aluesvay away arsedpay odybay, anyway ocallay-"
"eclarationsday atthay\n"
"   ouldshay ebay ademay erewhay isthay odybay isway insertedway, andway away "
"ocday-ingstray ifway erethay isway\n"
"   oneway."

#: src/code/defmacro.lisp
msgid "&Whole must appear first in ~S lambda-list."
msgstr "&Olewhay ustmay appearway irstfay inway ~S ambdalay-istlay."

#: src/code/defmacro.lisp
msgid "&environment not valid with ~S."
msgstr "&environmentway otnay alidvay ithway ~S."

#: src/code/defmacro.lisp
msgid "&environment only valid at top level of lambda-list."
msgstr ""
"&environmentway onlyway alidvay atway optay evellay ofway ambdalay-istlay."

#: src/code/defmacro.lisp
msgid "Invalid ~a"
msgstr "Invalidway ~away"

#: src/code/defmacro.lisp
msgid "Ignore extra noise."
msgstr "Ignoreway extraway oisenay."

#: src/code/defmacro.lisp
msgid ""
"More than variable, initform, and suppliedp ~\n"
"\t\t\t    in &optional binding - ~S"
msgstr ""
"Oremay anthay ariablevay, initformway, andway uppliedpsay ~\n"
"\t\t\t    inway &optionalway indingbay - ~S"

#: src/code/defmacro.lisp
msgid "Non-symbol in lambda-list - ~S."
msgstr "Onnay-ymbolsay inway ambdalay-istlay - ~S."

#: src/code/defmacro.lisp
msgid "Illegal optional variable name: ~S"
msgstr "Illegalway optionalway ariablevay amenay: ~S"

#: src/code/defmacro.lisp
msgid ""
"Takes a non-keyword symbol, symbol, and returns the corresponding keyword."
msgstr ""
"Akestay away onnay-eywordkay ymbolsay, ymbolsay, andway eturnsray ethay "
"orrespondingcay eywordkay."

#: src/code/defmacro.lisp
msgid "Illegal or ill-formed ~A argument in ~A~@[ ~S~]."
msgstr ""
"Illegalway orway illway-ormedfay ~Away argumentway inway ~Away~@[ ~S~]."

#: src/code/defmacro.lisp
msgid "Error while parsing arguments to ~A in ~S:~%"
msgstr "Errorway ilewhay arsingpay argumentsway otay ~Away inway ~S:~%"

#: src/code/defmacro.lisp
msgid "Error while parsing arguments to ~A ~S:~%"
msgstr "Errorway ilewhay arsingpay argumentsway otay ~Away ~S:~%"

#: src/code/defmacro.lisp
msgid "Bogus sublist:~%  ~S~%to satisfy lambda-list:~%  ~:S~%"
msgstr "Ogusbay ublistsay:~%  ~S~%otay atisfysay ambdalay-istlay:~%  ~:S~%"

#: src/code/defmacro.lisp
msgid ""
"Invalid number of elements in:~%  ~:S~%~\n"
"\t     to satisfy lambda-list:~%  ~:S~%"
msgstr ""
"Invalidway umbernay ofway elementsway inway:~%  ~:S~%~\n"
"\t     otay atisfysay ambdalay-istlay:~%  ~:S~%"

#: src/code/defmacro.lisp
msgid "Expected at least ~D"
msgstr "Expectedway atway eastlay ~D"

#: src/code/defmacro.lisp
msgid "Expected exactly ~D"
msgstr "Expectedway exactlyway ~D"

#: src/code/defmacro.lisp
msgid "Expected between ~D and ~D"
msgstr "Expectedway etweenbay ~D andway ~D"

#: src/code/defmacro.lisp
msgid ", but got ~D."
msgstr ", utbay otgay ~D."

#: src/compiler/globaldb.lisp
msgid ""
"Define-Info-Class Class\n"
"  Define a new class of global information."
msgstr ""
"Efineday-Infoway-Assclay Assclay\n"
"  Efineday away ewnay assclay ofway obalglay informationway."

#: src/compiler/globaldb.lisp
msgid ""
"Define-Info-Type Class Type default Type-Spec\n"
"  Define a new type of global information for Class.  Type is the symbol "
"name\n"
"  of the type, Default is the value for that type when it hasn't been set, "
"and\n"
"  Type-Spec is a type-specifier which values of the type must satisfy.  The\n"
"  default expression is evaluated each time the information is needed, with\n"
"  Name bound to the name for which the information is being looked up.  If "
"the\n"
"  default evaluates to something with the second value true, then the "
"second\n"
"  value of Info will also be true."
msgstr ""
"Efineday-Infoway-Ypetay Assclay Ypetay efaultday Ypetay-Ecspay\n"
"  Efineday away ewnay ypetay ofway obalglay informationway orfay Assclay.  "
"Ypetay isway ethay ymbolsay amenay\n"
"  ofway ethay ypetay, Efaultday isway ethay aluevay orfay atthay ypetay "
"enwhay itway asnhay't eenbay etsay, andway\n"
"  Ypetay-Ecspay isway away ypetay-ecifierspay ichwhay aluesvay ofway ethay "
"ypetay ustmay atisfysay.  Ethay\n"
"  efaultday expressionway isway evaluatedway eachway imetay ethay "
"informationway isway eedednay, ithway\n"
"  Amenay oundbay otay ethay amenay orfay ichwhay ethay informationway isway "
"eingbay ookedlay upway.  Ifway ethay\n"
"  efaultday evaluatesway otay omethingsay ithway ethay econdsay aluevay "
"uetray, enthay ethay econdsay\n"
"  aluevay ofway Infoway illway alsoway ebay uetray."

#: src/compiler/globaldb.lisp
msgid "Type not defined yet."
msgstr "Ypetay otnay efinedday etyay."

#: src/compiler/globaldb.lisp
msgid "~S is not a defined info class."
msgstr "~S isway otnay away efinedday infoway assclay."

#: src/compiler/globaldb.lisp
msgid "~S is not a defined info type."
msgstr "~S isway otnay away efinedday infoway ypetay."

#: src/compiler/globaldb.lisp
msgid "Out of INFO type numbers!"
msgstr "Outway ofway INFO ypetay umbersnay!"

#: src/compiler/globaldb.lisp
msgid "Redefine it."
msgstr "Edefineray itway."

#: src/compiler/globaldb.lisp
msgid "Changing type number for ~A ~A."
msgstr "Angingchay ypetay umbernay orfay ~Away ~Away."

#: src/compiler/globaldb.lisp
msgid "Go for it."
msgstr "Ogay orfay itway."

#: src/compiler/globaldb.lisp
msgid "Reusing type number for ~A ~A."
msgstr "Eusingray ypetay umbernay orfay ~Away ~Away."

#: src/compiler/globaldb.lisp
msgid ""
"Return the information of the specified Type and Class for Name.\n"
"   The second value is true if there is any such information recorded.  If\n"
"   there is no information, the first value is the default and the second "
"value\n"
"   is NIL."
msgstr ""
"Eturnray ethay informationway ofway ethay ecifiedspay Ypetay andway Assclay "
"orfay Amenay.\n"
"   Ethay econdsay aluevay isway uetray ifway erethay isway anyway uchsay "
"informationway ecordedray.  Ifway\n"
"   erethay isway onay informationway, ethay irstfay aluevay isway ethay "
"efaultday andway ethay econdsay aluevay\n"
"   isway NIL."

#: src/compiler/globaldb.lisp
msgid "Set the global information for Name."
msgstr "Etsay ethay obalglay informationway orfay Amenay."

#: src/compiler/globaldb.lisp
msgid ""
"DO-INFO (Env &Key Name Class Type Value) Form*\n"
"  Iterate over all the values stored in the Info-Env Env.  Name is bound to\n"
"  the entry's name, Class and Type are bound to the class and type\n"
"  (represented as strings), and Value is bound to the entry's value."
msgstr ""
"DO-INFO (Envway &Eykay Amenay Assclay Ypetay Aluevay) Orm*Fay\n"
"  Iterateway overway allway ethay aluesvay toredsay inway ethay Infoway-"
"Envway Envway.  Amenay isway oundbay otay\n"
"  ethay entryway's amenay, Assclay andway Ypetay areway oundbay otay ethay "
"assclay andway ypetay\n"
"  (epresentedray asway ingsstray), andway Aluevay isway oundbay otay ethay "
"entryway's aluevay."

#: src/compiler/globaldb.lisp
msgid ""
"Return a new compact info environment that holds the same information as\n"
"  Env."
msgstr ""
"Eturnray away ewnay ompactcay infoway environmentway atthay oldshay ethay "
"amesay informationway asway\n"
"  Envway."

#: src/compiler/knownfun.lisp src/compiler/globaldb.lisp
msgid "No info environment?"
msgstr "Onay infoway environmentway?"

#: src/compiler/knownfun.lisp src/compiler/globaldb.lisp
msgid "Cannot modify this environment: ~S."
msgstr "Annotcay odifymay isthay environmentway: ~S."

#: src/compiler/globaldb.lisp
msgid "0 is not a legal INFO name."
msgstr "0 isway otnay away egallay INFO amenay."

#: src/compiler/globaldb.lisp
msgid ""
"Clear the information of the specified Type and Class for Name in the\n"
"  current environment, allowing any inherited info to become visible.  We\n"
"  return true if there was any info."
msgstr ""
"Earclay ethay informationway ofway ethay ecifiedspay Ypetay andway Assclay "
"orfay Amenay inway ethay\n"
"  urrentcay environmentway, allowingway anyway inheritedway infoway otay "
"ecomebay isiblevay.  Eway\n"
"  eturnray uetray ifway erethay asway anyway infoway."

#: src/code/macros.lisp
msgid ""
"This function is to parse the declarations and doc-string out of the body "
"of\n"
"  a defun-like form.  Body is the list of stuff which is to be parsed.\n"
"  Environment is ignored.  If Doc-String-Allowed is true, then a doc string\n"
"  will be parsed out of the body and returned.  If it is false then a "
"string\n"
"  will terminate the search for declarations.  Three values are returned: "
"the\n"
"  tail of Body after the declarations and doc strings, a list of declare "
"forms,\n"
"  and the doc-string, or NIL if none."
msgstr ""
"Isthay unctionfay isway otay arsepay ethay eclarationsday andway ocday-"
"ingstray outway ofway ethay odybay ofway\n"
"  away efunday-ikelay ormfay.  Odybay isway ethay istlay ofway tuffsay "
"ichwhay isway otay ebay arsedpay.\n"
"  Environmentway isway ignoredway.  Ifway Ocday-Ingstray-Allowedway isway "
"uetray, enthay away ocday ingstray\n"
"  illway ebay arsedpay outway ofway ethay odybay andway eturnedray.  Ifway "
"itway isway alsefay enthay away ingstray\n"
"  illway erminatetay ethay earchsay orfay eclarationsday.  Reethay aluesvay "
"areway eturnedray: ethay\n"
"  ailtay ofway Odybay afterway ethay eclarationsday andway ocday ingsstray, "
"away istlay ofway eclareday ormsfay,\n"
"  andway ethay ocday-ingstray, orway NIL ifway onenay."

#: src/code/macros.lisp
msgid "defining macro ~A"
msgstr "efiningday acromay ~Away"

#: src/code/macros.lisp
msgid "Disable the package's definition-lock then continue"
msgstr "Isableday ethay ackagepay's efinitionday-ocklay enthay ontinuecay"

#: src/code/macros.lisp
msgid "Define a compiler-macro for NAME."
msgstr "Efineday away ompilercay-acromay orfay NAME."

#: src/code/macros.lisp
msgid "~S is not a valid function name."
msgstr "~S isway otnay away alidvay unctionfay amenay."

#: src/compiler/ir1tran.lisp src/code/macros.lisp
msgid "Symbol macro name is not a symbol: ~S."
msgstr "Ymbolsay acromay amenay isway otnay away ymbolsay: ~S."

#: src/code/macros.lisp
msgid "Symbol macro name already declared special: ~S."
msgstr "Ymbolsay acromay amenay alreadyway eclaredday ecialspay: ~S."

#: src/code/macros.lisp
msgid "Symbol macro name already declared constant: ~S."
msgstr "Ymbolsay acromay amenay alreadyway eclaredday onstantcay: ~S."

#: src/code/macros.lisp
msgid "Syntax like DEFMACRO, but defines a new type."
msgstr "Yntaxsay ikelay DEFMACRO, utbay efinesday away ewnay ypetay."

#: src/code/macros.lisp
msgid "~S -- Type name not a symbol."
msgstr "~S -- Ypetay amenay otnay away ymbolsay."

#: src/code/macros.lisp
msgid "defining type ~A"
msgstr "efiningday ypetay ~Away"

#: src/code/macros.lisp
msgid "Disable package's definition-lock then continue"
msgstr "Isableday ackagepay's efinitionday-ocklay enthay ontinuecay"

#: src/code/macros.lisp
msgid "Deftype already names a declaration: ~S."
msgstr "Eftypeday alreadyway amesnay away eclarationday: ~S."

#: src/code/macros.lisp
msgid "Illegal to redefine standard type: ~S."
msgstr "Illegalway otay edefineray tandardsay ypetay: ~S."

#: src/code/macros.lisp
msgid "Redefining class ~S to be a DEFTYPE."
msgstr "Edefiningray assclay ~S otay ebay away DEFTYPE."

#: src/code/macros.lisp
msgid ""
"Syntax like DEFMACRO, but creates a Setf-Expansion generator.  The body\n"
"  must be a form that returns the five magical values."
msgstr ""
"Yntaxsay ikelay DEFMACRO, utbay eatescray away Etfsay-Expansionway "
"eneratorgay.  Ethay odybay\n"
"  ustmay ebay away ormfay atthay eturnsray ethay ivefay agicalmay aluesvay."

#: src/code/macros.lisp
msgid "~S -- Access-function name not a symbol in DEFINE-SETF-EXPANDER."
msgstr ""
"~S -- Accessway-unctionfay amenay otnay away ymbolsay inway DEFINE-SETF-"
"EXPANDER."

#: src/code/macros.lisp
msgid "Obsolete, use define-setf-expander."
msgstr "Obsoleteway, useway efineday-etfsay-expanderway."

#: src/code/macros.lisp
msgid ""
"Defining setf macro for destruct slot accessor; redefining as ~\n"
"\t        a normal function:~%  ~S"
msgstr ""
"Efiningday etfsay acromay orfay estructday otslay accessorway; edefiningray "
"asway ~\n"
"\t        away ormalnay unctionfay:~%  ~S"

#: src/code/macros.lisp
msgid "Defining setf macro for ~S, but ~S is fbound."
msgstr "Efiningday etfsay acromay orfay ~S, utbay ~S isway boundfay."

#: src/code/macros.lisp
msgid "Bind the variables in LAMBDA-LIST to the contents of ARG-LIST."
msgstr ""
"Indbay ethay ariablesvay inway LAMBDA-LIST otay ethay ontentscay ofway ARG-"
"LIST."

#: src/code/macros.lisp
msgid ""
"For defining global constants at top level.  The DEFCONSTANT says that the\n"
"  value is constant and may be compiled into code.  If the variable already "
"has\n"
"  a value, and this is not equal to the init, an error is signalled.  The "
"third\n"
"  argument is an optional documentation string for the variable."
msgstr ""
"Orfay efiningday obalglay onstantscay atway optay evellay.  Ethay "
"DEFCONSTANT ayssay atthay ethay\n"
"  aluevay isway onstantcay andway aymay ebay ompiledcay intoway odecay.  "
"Ifway ethay ariablevay alreadyway ashay\n"
"  away aluevay, andway isthay isway otnay equalway otay ethay initway, anway "
"errorway isway ignalledsay.  Ethay irdthay\n"
"  argumentway isway anway optionalway ocumentationday ingstray orfay ethay "
"ariablevay."

#: src/code/macros.lisp
msgid "Go ahead and change the value."
msgstr "Ogay aheadway andway angechay ethay aluevay."

#: src/code/macros.lisp
msgid "Constant ~S being redefined."
msgstr "Onstantcay ~S eingbay edefinedray."

#: src/code/macros.lisp
msgid ""
"For defining global variables at top level.  Declares the variable\n"
"  SPECIAL and, optionally, initializes it.  If the variable already has a\n"
"  value, the old value is not clobbered.  The third argument is an optional\n"
"  documentation string for the variable."
msgstr ""
"Orfay efiningday obalglay ariablesvay atway optay evellay.  Eclaresday ethay "
"ariablevay\n"
"  SPECIAL andway, optionallyway, initializesway itway.  Ifway ethay "
"ariablevay alreadyway ashay away\n"
"  aluevay, ethay oldway aluevay isway otnay obberedclay.  Ethay irdthay "
"argumentway isway anway optionalway\n"
"  ocumentationday ingstray orfay ethay ariablevay."

#: src/code/macros.lisp
msgid ""
"Defines a parameter that is not normally changed by the program,\n"
"  but that may be changed without causing an error.  Declares the\n"
"  variable special and sets its value to VAL.  The third argument is\n"
"  an optional documentation string for the parameter."
msgstr ""
"Efinesday away arameterpay atthay isway otnay ormallynay angedchay ybay "
"ethay ogrampray,\n"
"  utbay atthay aymay ebay angedchay ithoutway ausingcay anway errorway.  "
"Eclaresday ethay\n"
"  ariablevay ecialspay andway etssay itsway aluevay otay VAL.  Ethay irdthay "
"argumentway isway\n"
"  anway optionalway ocumentationday ingstray orfay ethay arameterpay."

#: src/code/macros.lisp
msgid ""
"First arg is a predicate.  If it is non-null, the rest of the forms are\n"
"  evaluated as a PROGN."
msgstr ""
"Irstfay argway isway away edicatepray.  Ifway itway isway onnay-ullnay, "
"ethay estray ofway ethay ormsfay areway\n"
"  evaluatedway asway away PROGN."

#: src/code/macros.lisp
msgid ""
"First arg is a predicate.  If it is null, the rest of the forms are\n"
"  evaluated as a PROGN."
msgstr ""
"Irstfay argway isway away edicatepray.  Ifway itway isway ullnay, ethay "
"estray ofway ethay ormsfay areway\n"
"  evaluatedway asway away PROGN."

#: src/code/macros.lisp
msgid "Cond clause should be a non-empty list: ~S."
msgstr "Ondcay auseclay ouldshay ebay away onnay-emptyway istlay: ~S."

#: src/code/macros.lisp
msgid "Varlist is not a list of symbols: ~S."
msgstr "Arlistvay isway otnay away istlay ofway ymbolssay: ~S."

#: src/code/macros.lisp
msgid ""
"Evaluates FORM and returns the Nth value (zero based).  This involves no\n"
"  consing when N is a trivial constant integer."
msgstr ""
"Evaluatesway FORM andway eturnsray ethay Thnay aluevay (erozay asedbay).  "
"Isthay involvesway onay\n"
"  onsingcay enwhay N isway away ivialtray onstantcay integerway."

#: src/code/macros.lisp
msgid ""
"Returns five values needed by the SETF machinery: a list of temporary\n"
"   variables, a list of values with which to fill them, a list of "
"temporaries\n"
"   for the new values, the setting function, and the accessing function."
msgstr ""
"Eturnsray ivefay aluesvay eedednay ybay ethay SETF achinerymay: away istlay "
"ofway emporarytay\n"
"   ariablesvay, away istlay ofway aluesvay ithway ichwhay otay illfay "
"emthay, away istlay ofway emporarietays\n"
"   orfay ethay ewnay aluesvay, ethay ettingsay unctionfay, andway ethay "
"accessingway unctionfay."

#: src/code/macros.lisp
msgid "Obsolete: use GET-SETF-EXPANSION."
msgstr "Obsoleteway: useway GET-SETF-EXPANSION."

#: src/code/macros.lisp
msgid "Obsolete: use GET-SETF-EXPANSION and handle multiple store values."
msgstr ""
"Obsoleteway: useway GET-SETF-EXPANSION andway andlehay ultiplemay toresay "
"aluesvay."

#: src/code/macros.lisp
msgid ""
"GET-SETF-METHOD used for a form with multiple store ~\n"
"\t      variables:~%  ~S"
msgstr ""
"GET-SETF-METHOD usedway orfay away ormfay ithway ultiplemay toresay ~\n"
"\t      ariablesvay:~%  ~S"

#: src/code/macros.lisp
msgid ""
"Associates a SETF update function or macro with the specified access\n"
"  function or macro.  The format is complex.  See the manual for\n"
"  details."
msgstr ""
"Associatesway away SETF updateway unctionfay orway acromay ithway ethay "
"ecifiedspay accessway\n"
"  unctionfay orway acromay.  Ethay ormatfay isway omplexcay.  Eesay ethay "
"anualmay orfay\n"
"  etailsday."

#: src/code/macros.lisp
msgid "Ill-formed DEFSETF for ~S."
msgstr "Illway-ormedfay DEFSETF orfay ~S."

#: src/code/macros.lisp
msgid ""
"Takes pairs of arguments like SETQ.  The first is a place and the second\n"
"  is the value that is supposed to go into that place.  Returns the last\n"
"  value.  The place argument may be any of the access forms for which SETF\n"
"  knows a corresponding setting form."
msgstr ""
"Akestay airspay ofway argumentsway ikelay SETQ.  Ethay irstfay isway away "
"aceplay andway ethay econdsay\n"
"  isway ethay aluevay atthay isway upposedsay otay ogay intoway atthay "
"aceplay.  Eturnsray ethay astlay\n"
"  aluevay.  Ethay aceplay argumentway aymay ebay anyway ofway ethay "
"accessway ormsfay orfay ichwhay SETF\n"
"  nowskay away orrespondingcay ettingsay ormfay."

#: src/code/macros.lisp
msgid "Odd number of args to SETF."
msgstr "Oddway umbernay ofway argsway otay SETF."

#: src/code/macros.lisp
msgid ""
"This is to SETF as PSETQ is to SETQ.  Args are alternating place\n"
"  expressions and values to go into those places.  All of the subforms and\n"
"  values are determined, left to right, and only then are the locations\n"
"  updated.  Returns NIL."
msgstr ""
"Isthay isway otay SETF asway PSETQ isway otay SETQ.  Argsway areway "
"alternatingway aceplay\n"
"  expressionsway andway aluesvay otay ogay intoway osethay acesplay.  Allway "
"ofway ethay ubformssay andway\n"
"  aluesvay areway eterminedday, eftlay otay ightray, andway onlyway enthay "
"areway ethay ocationslay\n"
"  updatedway.  Eturnsray NIL."

#: src/code/macros.lisp
msgid "Odd number of args to PSETF."
msgstr "Oddway umbernay ofway argsway otay PSETF."

#: src/code/macros.lisp
msgid ""
"One or more SETF-style place expressions, followed by a single\n"
"   value expression.  Evaluates all of the expressions in turn, then\n"
"   assigns the value of each expression to the place on its left,\n"
"   returning the value of the leftmost."
msgstr ""
"Oneway orway oremay SETF-tylesay aceplay expressionsway, ollowedfay ybay "
"away inglesay\n"
"   aluevay expressionway.  Evaluatesway allway ofway ethay expressionsway "
"inway urntay, enthay\n"
"   assignsway ethay aluevay ofway eachway expressionway otay ethay aceplay "
"onway itsway eftlay,\n"
"   eturningray ethay aluevay ofway ethay eftmostlay."

#: src/code/macros.lisp
msgid ""
"Takes any number of SETF-style place expressions.  Evaluates all of the\n"
"   expressions in turn, then assigns to each place the value of the form to\n"
"   its right.  The rightmost form gets the value of the leftmost.\n"
"   Returns NIL."
msgstr ""
"Akestay anyway umbernay ofway SETF-tylesay aceplay expressionsway.  "
"Evaluatesway allway ofway ethay\n"
"   expressionsway inway urntay, enthay assignsway otay eachway aceplay ethay "
"aluevay ofway ethay ormfay otay\n"
"   itsway ightray.  Ethay ightmostray ormfay etsgay ethay aluevay ofway "
"ethay eftmostlay.\n"
"   Eturnsray NIL."

#: src/code/macros.lisp
msgid "Creates a new read-modify-write macro like PUSH or INCF."
msgstr ""
"Eatescray away ewnay eadray-odifymay-itewray acromay ikelay PUSH orway INCF."

#: src/code/macros.lisp
msgid "Non-symbol &rest arg in definition of ~S."
msgstr "Onnay-ymbolsay &estray argway inway efinitionday ofway ~S."

#: src/code/macros.lisp
msgid "Illegal stuff after &rest arg in Define-Modify-Macro."
msgstr ""
"Illegalway tuffsay afterway &estray argway inway Efineday-Odifymay-Acromay."

#: src/code/macros.lisp
msgid "~S not allowed in Define-Modify-Macro lambda list."
msgstr "~S otnay allowedway inway Efineday-Odifymay-Acromay ambdalay istlay."

#: src/code/macros.lisp
msgid "Illegal stuff in lambda list of Define-Modify-Macro."
msgstr ""
"Illegalway tuffsay inway ambdalay istlay ofway Efineday-Odifymay-Acromay."

#: src/code/macros.lisp
msgid ""
"Takes an object and a location holding a list.  Conses the object onto\n"
"  the list, returning the modified list.  OBJ is evaluated before PLACE."
msgstr ""
"Akestay anway objectway andway away ocationlay oldinghay away istlay.  "
"Onsescay ethay objectway ontoway\n"
"  ethay istlay, eturningray ethay odifiedmay istlay.  OBJ isway evaluatedway "
"eforebay PLACE."

#: src/code/macros.lisp
msgid ""
"Takes an object and a location holding a list.  If the object is already\n"
"  in the list, does nothing.  Else, conses the object onto the list.  "
"Returns\n"
"  NIL.  If there is a :TEST keyword, this is used for the comparison."
msgstr ""
"Akestay anway objectway andway away ocationlay oldinghay away istlay.  Ifway "
"ethay objectway isway alreadyway\n"
"  inway ethay istlay, oesday othingnay.  Elseway, onsescay ethay objectway "
"ontoway ethay istlay.  Eturnsray\n"
"  NIL.  Ifway erethay isway away :TEST eywordkay, isthay isway usedway orfay "
"ethay omparisoncay."

#: src/code/macros.lisp
msgid ""
"The argument is a location holding a list.  Pops one item off the front\n"
"  of the list and returns it."
msgstr ""
"Ethay argumentway isway away ocationlay oldinghay away istlay.  Opspay "
"oneway itemway offway ethay ontfray\n"
"  ofway ethay istlay andway eturnsray itway."

#: src/code/macros.lisp
msgid ""
"The first argument is some location holding a number. This number is\n"
"  incremented by the second argument, DELTA, which defaults to 1."
msgstr ""
"Ethay irstfay argumentway isway omesay ocationlay oldinghay away umbernay. "
"Isthay umbernay isway\n"
"  incrementedway ybay ethay econdsay argumentway, DELTA, ichwhay efaultsday "
"otay 1."

#: src/code/macros.lisp
msgid ""
"The first argument is some location holding a number. This number is\n"
"  decremented by the second argument, DELTA, which defaults to 1."
msgstr ""
"Ethay irstfay argumentway isway omesay ocationlay oldinghay away umbernay. "
"Isthay umbernay isway\n"
"  ecrementedday ybay ethay econdsay argumentway, DELTA, ichwhay efaultsday "
"otay 1."

#: src/code/macros.lisp
msgid ""
"Place may be any place expression acceptable to SETF, and is expected\n"
"  to hold a property list or ().  This list is destructively altered to\n"
"  remove the property specified by the indicator.  Returns T if such a\n"
"  property was present, NIL if not."
msgstr ""
"Aceplay aymay ebay anyway aceplay expressionway acceptableway otay SETF, "
"andway isway expectedway\n"
"  otay oldhay away opertypray istlay orway ().  Isthay istlay isway "
"estructivelyday alteredway otay\n"
"  emoveray ethay opertypray ecifiedspay ybay ethay indicatorway.  Eturnsray "
"T ifway uchsay away\n"
"  opertypray asway esentpray, NIL ifway otnay."

#: src/code/macros.lisp
msgid "Setf of Apply is only defined for function args like #'symbol."
msgstr ""
"Etfsay ofway Applyway isway onlyway efinedday orfay unctionfay argsway "
"ikelay #'ymbolsay."

#: src/code/macros.lisp
msgid ""
"The first argument is a byte specifier.  The second is any place form\n"
"  acceptable to SETF.  Replaces the specified byte of the number in this\n"
"  place with bits from the low-order end of the new value."
msgstr ""
"Ethay irstfay argumentway isway away ytebay ecifierspay.  Ethay econdsay "
"isway anyway aceplay ormfay\n"
"  acceptableway otay SETF.  Eplacesray ethay ecifiedspay ytebay ofway ethay "
"umbernay inway isthay\n"
"  aceplay ithway itsbay omfray ethay owlay-orderway endway ofway ethay ewnay "
"aluevay."

#: src/code/macros.lisp
msgid ""
"The first argument is a byte specifier.  The second is any place form\n"
"  acceptable to SETF.  Replaces the specified byte of the number in this "
"place\n"
"  with bits from the corresponding position in the new value."
msgstr ""
"Ethay irstfay argumentway isway away ytebay ecifierspay.  Ethay econdsay "
"isway anyway aceplay ormfay\n"
"  acceptableway otay SETF.  Eplacesray ethay ecifiedspay ytebay ofway ethay "
"umbernay inway isthay aceplay\n"
"  ithway itsbay omfray ethay orrespondingcay ositionpay inway ethay ewnay "
"aluevay."

#: src/code/macros.lisp
msgid "~S -- Bad clause in ~S."
msgstr "~S -- Adbay auseclay inway ~S."

#: src/code/macros.lisp
msgid ""
"~<~A is a key designator only in the final otherwise-clause. ~\n"
"                                              Use (~A) to use it as a normal-"
"clause or move the clause to the ~\n"
"                                              correct position.~:@>"
msgstr ""

#: src/code/macros.lisp
#, fuzzy
msgid "Bad style to use ~S in ~S"
msgstr "Onay otslay amednay ~S inway ~S"

#: src/code/macros.lisp
msgid "Supply a new value for ~S."
msgstr "Upplysay away ewnay aluevay orfay ~S."

#: src/code/macros.lisp
msgid ""
"CASE Keyform {({(Key*) | Key} Form*)}*\n"
"  Evaluates the Forms in the first clause with a Key EQL to the value\n"
"  of Keyform.  If a singleton key is T or Otherwise then the clause is\n"
"  a default clause."
msgstr ""
"CASE Eyformkay {({(Ey*Kay) | Eykay} Orm*Fay)}*\n"
"  Evaluatesway ethay Ormsfay inway ethay irstfay auseclay ithway away Eykay "
"EQL otay ethay aluevay\n"
"  ofway Eyformkay.  Ifway away ingletonsay eykay isway T orway Otherwiseway "
"enthay ethay auseclay isway\n"
"  away efaultday auseclay."

#: src/code/macros.lisp
msgid ""
"CCASE Keyform {({(Key*) | Key} Form*)}*\n"
"  Evaluates the Forms in the first clause with a Key EQL to the value of\n"
"  Keyform.  If none of the keys matches then a correctable error is\n"
"  signalled."
msgstr ""
"CCASE Eyformkay {({(Ey*Kay) | Eykay} Orm*Fay)}*\n"
"  Evaluatesway ethay Ormsfay inway ethay irstfay auseclay ithway away Eykay "
"EQL otay ethay aluevay ofway\n"
"  Eyformkay.  Ifway onenay ofway ethay eyskay atchesmay enthay away "
"orrectablecay errorway isway\n"
"  ignalledsay."

#: src/code/macros.lisp
msgid ""
"ECASE Keyform {({(Key*) | Key} Form*)}*\n"
"  Evaluates the Forms in the first clause with a Key EQL to the value of\n"
"  Keyform.  If none of the keys matches then an error is signalled."
msgstr ""
"ECASE Eyformkay {({(Ey*Kay) | Eykay} Orm*Fay)}*\n"
"  Evaluatesway ethay Ormsfay inway ethay irstfay auseclay ithway away Eykay "
"EQL otay ethay aluevay ofway\n"
"  Eyformkay.  Ifway onenay ofway ethay eyskay atchesmay enthay anway "
"errorway isway ignalledsay."

#: src/code/macros.lisp
msgid ""
"TYPECASE Keyform {(Type Form*)}*\n"
"  Evaluates the Forms in the first clause for which TYPEP of Keyform\n"
"  and Type is true.  If a singleton key is T or Otherwise then the\n"
"  clause is a default clause."
msgstr ""
"TYPECASE Eyformkay {(Ypetay Orm*Fay)}*\n"
"  Evaluatesway ethay Ormsfay inway ethay irstfay auseclay orfay ichwhay "
"TYPEP ofway Eyformkay\n"
"  andway Ypetay isway uetray.  Ifway away ingletonsay eykay isway T orway "
"Otherwiseway enthay ethay\n"
"  auseclay isway away efaultday auseclay."

#: src/code/macros.lisp
msgid ""
"CTYPECASE Keyform {(Type Form*)}*\n"
"  Evaluates the Forms in the first clause for which TYPEP of Keyform and "
"Type\n"
"  is true.  If no form is satisfied then a correctable error is signalled."
msgstr ""
"CTYPECASE Eyformkay {(Ypetay Orm*Fay)}*\n"
"  Evaluatesway ethay Ormsfay inway ethay irstfay auseclay orfay ichwhay "
"TYPEP ofway Eyformkay andway Ypetay\n"
"  isway uetray.  Ifway onay ormfay isway atisfiedsay enthay away "
"orrectablecay errorway isway ignalledsay."

#: src/code/macros.lisp
msgid ""
"ETYPECASE Keyform {(Type Form*)}*\n"
"  Evaluates the Forms in the first clause for which TYPEP of Keyform and "
"Type\n"
"  is true.  If no form is satisfied then an error is signalled."
msgstr ""
"ETYPECASE Eyformkay {(Ypetay Orm*Fay)}*\n"
"  Evaluatesway ethay Ormsfay inway ethay irstfay auseclay orfay ichwhay "
"TYPEP ofway Eyformkay andway Ypetay\n"
"  isway uetray.  Ifway onay ormfay isway atisfiedsay enthay anway errorway "
"isway ignalledsay."

#: src/code/macros.lisp
msgid ""
"Signals an error if the value of test-form is nil.  Continuing from this\n"
"   error using the CONTINUE restart will allow the user to alter the value "
"of\n"
"   some locations known to SETF, starting over with test-form.  Returns nil."
msgstr ""
"Ignalssay anway errorway ifway ethay aluevay ofway esttay-ormfay isway "
"ilnay.  Ontinuingcay omfray isthay\n"
"   errorway usingway ethay CONTINUE estartray illway allowway ethay userway "
"otay alterway ethay aluevay ofway\n"
"   omesay ocationslay nownkay otay SETF, tartingsay overway ithway esttay-"
"ormfay.  Eturnsray ilnay."

#: src/code/macros.lisp
msgid "The assertion ~S failed."
msgstr "Ethay assertionway ~S ailedfay."

#: src/code/macros.lisp
msgid "Retry assertion"
msgstr "Etryray assertionway"

#: src/code/macros.lisp
msgid " with new value for ~{~S~^, ~}."
msgid_plural " with new values for ~{~S~^, ~}."
msgstr[0] " ithway ewnay aluevay orfay ~{~S~^, ~}."
msgstr[1] " ithway ewnay aluesvay orfay ~{~S~^, ~}."

#: src/code/macros.lisp
msgid ""
"The old value of ~S is ~S.~\n"
"\t\t  ~%Do you want to supply a new value? "
msgstr ""
"Ethay oldway aluevay ofway ~S isway ~S.~\n"
"\t\t  ~%Oday ouyay antway otay upplysay away ewnay aluevay? "

#: src/code/macros.lisp
msgid "~&Type a form to be evaluated:~%"
msgstr "~&Ypetay away ormfay otay ebay evaluatedway:~%"

#: src/code/macros.lisp
msgid ""
"Signals an error of type type-error if the contents of place are not of the\n"
"   specified type.  If an error is signaled, this can only return if\n"
"   STORE-VALUE is invoked.  It will store into place and start over."
msgstr ""
"Ignalssay anway errorway ofway ypetay ypetay-errorway ifway ethay ontentscay "
"ofway aceplay areway otnay ofway ethay\n"
"   ecifiedspay ypetay.  Ifway anway errorway isway ignaledsay, isthay ancay "
"onlyway eturnray ifway\n"
"   STORE-VALUE isway invokedway.  Itway illway toresay intoway aceplay "
"andway tartsay overway."

#: src/code/macros.lisp
msgid "Supply a new value of ~S."
msgstr "Upplysay away ewnay aluevay ofway ~S."

#: src/code/macros.lisp
msgid "The value of ~S is ~S, which is not ~A."
msgstr "Ethay aluevay ofway ~S isway ~S, ichwhay isway otnay ~Away."

#: src/code/macros.lisp
msgid "The value of ~S is ~S, which is not of type ~S."
msgstr "Ethay aluevay ofway ~S isway ~S, ichwhay isway otnay ofway ypetay ~S."

#: src/code/macros.lisp
msgid ""
"The file whose name is Filespec is opened using the Open-args and\n"
"  bound to the variable Var. If the call to open is unsuccessful, the\n"
"  forms are not evaluated.  The Forms are executed, and when they\n"
"  terminate, normally or otherwise, the file is closed."
msgstr ""
"Ethay ilefay osewhay amenay isway Ilespecfay isway openedway usingway ethay "
"Openway-argsway andway\n"
"  oundbay otay ethay ariablevay Arvay. Ifway ethay allcay otay openway isway "
"unsuccessfulway, ethay\n"
"  ormsfay areway otnay evaluatedway.  Ethay Ormsfay areway executedway, "
"andway enwhay eythay\n"
"  erminatetay, ormallynay orway otherwiseway, ethay ilefay isway osedclay."

#: src/code/macros.lisp
msgid ""
"The form stream should evaluate to a stream.  VAR is bound\n"
"   to the stream and the forms are evaluated as an implicit\n"
"   progn.  The stream is closed upon exit."
msgstr ""
"Ethay ormfay eamstray ouldshay evaluateway otay away eamstray.  VAR isway "
"oundbay\n"
"   otay ethay eamstray andway ethay ormsfay areway evaluatedway asway anway "
"implicitway\n"
"   ognpray.  Ethay eamstray isway osedclay uponway exitway."

#: src/code/macros.lisp
msgid ""
"Binds the Var to an input stream that returns characters from String and\n"
"  executes the body.  See manual for details."
msgstr ""
"Indsbay ethay Arvay otay anway inputway eamstray atthay eturnsray "
"aracterschay omfray Ingstray andway\n"
"  executesway ethay odybay.  Eesay anualmay orfay etailsday."

#: src/code/macros.lisp
msgid ""
"If STRING is specified, it must be a string with a fill pointer;\n"
"   the output is incrementally appended to the string (as if by use of\n"
"   VECTOR-PUSH-EXTEND)."
msgstr ""
"Ifway STRING isway ecifiedspay, itway ustmay ebay away ingstray ithway away "
"illfay ointerpay;\n"
"   ethay outputway isway incrementallyway appendedway otay ethay ingstray "
"(asway ifway ybay useway ofway\n"
"   VECTOR-PUSH-EXTEND)."

#: src/code/macros.lisp
msgid ""
"DO ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Iteration construct.  Each Var is initialized in parallel to the value of "
"the\n"
"  specified Init form.  On subsequent iterations, the Vars are assigned the\n"
"  value of the Step form (if any) in paralell.  The Test is evaluated "
"before\n"
"  each evaluation of the body Forms.  When the Test is true, the Exit-Forms\n"
"  are evaluated as a PROGN, with the result being the value of the DO.  A "
"block\n"
"  named NIL is established around the entire expansion, allowing RETURN to "
"be\n"
"  used as an laternate exit mechanism."
msgstr ""
"DO ({(Arvay [Initway] [Tepsay])}*) (Esttay Exitway-Orm*Fay) Eclaration*Day "
"Orm*Fay\n"
"  Iterationway onstructcay.  Eachway Arvay isway initializedway inway "
"arallelpay otay ethay aluevay ofway ethay\n"
"  ecifiedspay Initway ormfay.  Onway ubsequentsay iterationsway, ethay "
"Arsvay areway assignedway ethay\n"
"  aluevay ofway ethay Tepsay ormfay (ifway anyway) inway aralellpay.  Ethay "
"Esttay isway evaluatedway eforebay\n"
"  eachway evaluationway ofway ethay odybay Ormsfay.  Enwhay ethay Esttay "
"isway uetray, ethay Exitway-Ormsfay\n"
"  areway evaluatedway asway away PROGN, ithway ethay esultray eingbay ethay "
"aluevay ofway ethay DO.  Away ockblay\n"
"  amednay NIL isway establishedway aroundway ethay entireway expansionway, "
"allowingway RETURN otay ebay\n"
"  usedway asway anway aternatelay exitway echanismmay."

#: src/code/macros.lisp
msgid ""
"DO* ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Iteration construct.  Each Var is initialized sequentially (like LET*) to "
"the\n"
"  value of the specified Init form.  On subsequent iterations, the Vars are\n"
"  sequentially assigned the value of the Step form (if any).  The Test is\n"
"  evaluated before each evaluation of the body Forms.  When the Test is "
"true,\n"
"  the Exit-Forms are evaluated as a PROGN, with the result being the value\n"
"  of the DO.  A block named NIL is established around the entire expansion,\n"
"  allowing RETURN to be used as an laternate exit mechanism."
msgstr ""
"O*Day ({(Arvay [Initway] [Tepsay])}*) (Esttay Exitway-Orm*Fay) "
"Eclaration*Day Orm*Fay\n"
"  Iterationway onstructcay.  Eachway Arvay isway initializedway "
"equentiallysay (ikelay Et*Lay) otay ethay\n"
"  aluevay ofway ethay ecifiedspay Initway ormfay.  Onway ubsequentsay "
"iterationsway, ethay Arsvay areway\n"
"  equentiallysay assignedway ethay aluevay ofway ethay Tepsay ormfay (ifway "
"anyway).  Ethay Esttay isway\n"
"  evaluatedway eforebay eachway evaluationway ofway ethay odybay Ormsfay.  "
"Enwhay ethay Esttay isway uetray,\n"
"  ethay Exitway-Ormsfay areway evaluatedway asway away PROGN, ithway ethay "
"esultray eingbay ethay aluevay\n"
"  ofway ethay DO.  Away ockblay amednay NIL isway establishedway aroundway "
"ethay entireway expansionway,\n"
"  allowingway RETURN otay ebay usedway asway anway aternatelay exitway "
"echanismmay."

#: src/code/macros.lisp
msgid ""
"PSETQ {var value}*\n"
"   Set the variables to the values, like SETQ, except that assignments\n"
"   happen in parallel, i.e. no assignments take place until all the\n"
"   forms have been evaluated."
msgstr ""
"PSETQ {arvay aluevay}*\n"
"   Etsay ethay ariablesvay otay ethay aluesvay, ikelay SETQ, exceptway "
"atthay assignmentsway\n"
"   appenhay inway arallelpay, i.e. onay assignmentsway aketay aceplay "
"untilway allway ethay\n"
"   ormsfay avehay eenbay evaluatedway."

#: src/code/macros.lisp
msgid "variable ~S in PSETQ is not a SYMBOL"
msgstr "ariablevay ~S inway PSETQ isway otnay away SYMBOL"

#: src/code/macros.lisp
msgid "Unknown declaration context: ~S."
msgstr "Unknownway eclarationday ontextcay: ~S."

#: src/code/macros.lisp
msgid ""
"Context declaration spec should have context and at ~\n"
"\t  least one DECLARE form:~%  ~S"
msgstr ""
"Ontextcay eclarationday ecspay ouldshay avehay ontextcay andway atway ~\n"
"\t  eastlay oneway DECLARE ormfay:~%  ~S"

#: src/code/macros.lisp
msgid ""
"WITH-COMPILATION-UNIT ({Key Value}*) Form*\n"
"  This form affects compilations that take place within its dynamic extent.  "
"It\n"
"  is intended to be wrapped around the compilation of all files in the same\n"
"  system.  These keywords are defined:\n"
"    :OVERRIDE Boolean-Form\n"
"        One of the effects of this form is to delay undefined warnings \n"
"        until the end of the form, instead of giving them at the end of "
"each\n"
"        compilation.  If OVERRIDE is NIL (the default), then the outermost\n"
"        WITH-COMPILATION-UNIT form grabs the undefined warnings.  "
"Specifying\n"
"        OVERRIDE true causes that form to grab any enclosed warnings, even "
"if\n"
"        it is enclosed by another WITH-COMPILATION-UNIT.\n"
"    :OPTIMIZE Decl-Form\n"
"        Decl-Form should evaluate to an OPTIMIZE declaration specifier.  "
"This\n"
"        declaration changes the `global' policy for compilations within the\n"
"        body.\n"
"    :OPTIMIZE-INTERFACE Decl-Form\n"
"        Like OPTIMIZE, except that it specifies the value of the CMU "
"extension\n"
"        OPTIMIZE-INTERFACE policy (which controls argument type and syntax\n"
"        checking.)\n"
"    :CONTEXT-DECLARATIONS List-of-Context-Decls-Form\n"
"        This is a CMU extension which allows compilation to be controlled\n"
"        by pattern matching on the context in which a definition appears.  "
"The\n"
"        argument should evaluate to a list of lists of the form:\n"
"            (Context-Spec Declare-Form+)\n"
"        In the indicated context, the specified declare forms are inserted "
"at\n"
"        the head of each definition.  The declare forms for all contexts "
"that\n"
"\tmatch are appended together, with earlier declarations getting\n"
"\tpredecence over later ones.  A simple example:\n"
"            :context-declarations\n"
"            '((:external (declare (optimize (safety 2)))))\n"
"        This will cause all functions that are named by external symbols to "
"be\n"
"        compiled with SAFETY 2.  The full syntax of context specs is:\n"
"\t:INTERNAL, :EXTERNAL\n"
"\t    True if the symbols is internal (external) in its home package.\n"
"\t:UNINTERNED\n"
"\t    True if the symbol has no home package.\n"
"\t:ANONYMOUS\n"
"\t    True if the function doesn't have any interesting name (not\n"
"\t    DEFMACRO, DEFUN, LABELS or FLET).\n"
"\t:MACRO, :FUNCTION\n"
"\t    :MACRO is a global (DEFMACRO) macro.  :FUNCTION is anything else.\n"
"\t:LOCAL, :GLOBAL\n"
"\t    :LOCAL is a LABELS or FLET.  :GLOBAL is anything else.\n"
"\t(:OR Context-Spec*)\n"
"\t    True in any specified context.\n"
"\t(:AND Context-Spec*)\n"
"\t    True only when all specs are true.\n"
"\t(:NOT Context-Spec)\n"
"\t    True when the spec is false.\n"
"        (:MEMBER Name*)\n"
"\t    True when the name is one of these names (EQUAL test.)\n"
"\t(:MATCH Pattern*)\n"
"\t    True when any of the patterns is a substring of the name.  The name\n"
"\t    is wrapped with $'s, so $FOO matches names beginning with FOO,\n"
"\t    etc."
msgstr ""
"WITH-COMPILATION-UNIT ({Eykay Aluevay}*) Orm*Fay\n"
"  Isthay ormfay affectsway ompilationscay atthay aketay aceplay ithinway "
"itsway ynamicday extentway.  Itway\n"
"  isway intendedway otay ebay appedwray aroundway ethay ompilationcay ofway "
"allway ilesfay inway ethay amesay\n"
"  ystemsay.  Esethay eywordskay areway efinedday:\n"
"    :OVERRIDE Ooleanbay-Ormfay\n"
"        Oneway ofway ethay effectsway ofway isthay ormfay isway otay elayday "
"undefinedway arningsway \n"
"        untilway ethay endway ofway ethay ormfay, insteadway ofway ivinggay "
"emthay atway ethay endway ofway eachway\n"
"        ompilationcay.  Ifway OVERRIDE isway NIL (ethay efaultday), enthay "
"ethay outermostway\n"
"        WITH-COMPILATION-UNIT ormfay absgray ethay undefinedway arningsway.  "
"Ecifyingspay\n"
"        OVERRIDE uetray ausescay atthay ormfay otay abgray anyway "
"enclosedway arningsway, evenway ifway\n"
"        itway isway enclosedway ybay anotherway WITH-COMPILATION-UNIT.\n"
"    :OPTIMIZE Eclday-Ormfay\n"
"        Eclday-Ormfay ouldshay evaluateway otay anway OPTIMIZE eclarationday "
"ecifierspay.  Isthay\n"
"        eclarationday angeschay ethay `obalglay' olicypay orfay "
"ompilationscay ithinway ethay\n"
"        odybay.\n"
"    :OPTIMIZE-INTERFACE Eclday-Ormfay\n"
"        Ikelay OPTIMIZE, exceptway atthay itway ecifiesspay ethay aluevay "
"ofway ethay CMU extensionway\n"
"        OPTIMIZE-INTERFACE olicypay (ichwhay ontrolscay argumentway ypetay "
"andway yntaxsay\n"
"        eckingchay.)\n"
"    :CONTEXT-DECLARATIONS Istlay-ofway-Ontextcay-Eclsday-Ormfay\n"
"        Isthay isway away CMU extensionway ichwhay allowsway ompilationcay "
"otay ebay ontrolledcay\n"
"        ybay atternpay atchingmay onway ethay ontextcay inway ichwhay away "
"efinitionday appearsway.  Ethay\n"
"        argumentway ouldshay evaluateway otay away istlay ofway istslay "
"ofway ethay ormfay:\n"
"            (Ontextcay-Ecspay Eclareday-Ormfay+)\n"
"        Inway ethay indicatedway ontextcay, ethay ecifiedspay eclareday "
"ormsfay areway insertedway atway\n"
"        ethay eadhay ofway eachway efinitionday.  Ethay eclareday ormsfay "
"orfay allway ontextscay atthay\n"
"\tatchmay areway appendedway ogethertay, ithway earlierway eclarationsday "
"ettinggay\n"
"\tedecencepray overway aterlay onesway.  Away implesay exampleway:\n"
"            :ontextcay-eclarationsday\n"
"            '((:externalway (eclareday (optimizeway (afetysay 2)))))\n"
"        Isthay illway ausecay allway unctionsfay atthay areway amednay ybay "
"externalway ymbolssay otay ebay\n"
"        ompiledcay ithway SAFETY 2.  Ethay ullfay yntaxsay ofway ontextcay "
"ecsspay isway:\n"
"\t:INTERNAL, :EXTERNAL\n"
"\t    Uetray ifway ethay ymbolssay isway internalway (externalway) inway "
"itsway omehay ackagepay.\n"
"\t:UNINTERNED\n"
"\t    Uetray ifway ethay ymbolsay ashay onay omehay ackagepay.\n"
"\t:ANONYMOUS\n"
"\t    Uetray ifway ethay unctionfay oesnday't avehay anyway interestingway "
"amenay (otnay\n"
"\t    DEFMACRO, DEFUN, LABELS orway FLET).\n"
"\t:MACRO, :FUNCTION\n"
"\t    :MACRO isway away obalglay (DEFMACRO) acromay.  :FUNCTION isway "
"anythingway elseway.\n"
"\t:LOCAL, :GLOBAL\n"
"\t    :LOCAL isway away LABELS orway FLET.  :GLOBAL isway anythingway "
"elseway.\n"
"\t(:OR Ontextcay-Ec*Spay)\n"
"\t    Uetray inway anyway ecifiedspay ontextcay.\n"
"\t(:AND Ontextcay-Ec*Spay)\n"
"\t    Uetray onlyway enwhay allway ecsspay areway uetray.\n"
"\t(:NOT Ontextcay-Ecspay)\n"
"\t    Uetray enwhay ethay ecspay isway alsefay.\n"
"        (:MEMBER Ame*Nay)\n"
"\t    Uetray enwhay ethay amenay isway oneway ofway esethay amesnay (EQUAL "
"esttay.)\n"
"\t(:MATCH Attern*Pay)\n"
"\t    Uetray enwhay anyway ofway ethay atternspay isway away ubstringsay "
"ofway ethay amenay.  Ethay amenay\n"
"\t    isway appedwray ithway $'s, osay $FOO atchesmay amesnay eginningbay "
"ithway FOO,\n"
"\t    etcway."

#: src/code/macros.lisp
msgid "Odd number of key/value pairs: ~S."
msgstr "Oddway umbernay ofway eykay/aluevay airspay: ~S."

#: src/code/macros.lisp
msgid "Ignoring unknown option: ~S."
msgstr "Ignoringway unknownway optionway: ~S."

#: src/code/intl.lisp
msgid ""
"The message-lookup domain used by INTL:GETTEXT and INTL:NGETTEXT.\n"
"  Use (INTL:TEXTDOMAIN \"whatever\") in each source file to set this."
msgstr ""
"Ethay essagemay-ookuplay omainday usedway ybay INTL:GETTEXT andway INTL:"
"NGETTEXT.\n"
"  Useway (INTL:TEXTDOMAIN \"ateverwhay\") inway eachway ourcesay ilefay otay "
"etsay isthay."

#: src/code/intl.lisp
msgid "Encountered illegal token: ="
msgstr "Encounteredway illegalway okentay: ="

#: src/code/intl.lisp
msgid "Encountered illegal token: ~C"
msgstr "Encounteredway illegalway okentay: ~C"

#: src/code/intl.lisp
msgid "Expected : in ?: construct"
msgstr "Expectedway : inway ?: onstructcay"

#: src/code/intl.lisp
msgid "Expected close-paren."
msgstr "Expectedway oseclay-arenpay."

#: src/code/intl.lisp
msgid "Unexpected token: ~S."
msgstr "Unexpectedway okentay: ~S."

#: src/code/intl.lisp
msgid "Expecting end of expression.  ~S."
msgstr "Expectingway endway ofway expressionway.  ~S."

#: src/code/intl.lisp
msgid ""
"Look up STRING in the current message domain and return its translation."
msgstr ""
"Ooklay upway STRING inway ethay urrentcay essagemay omainday andway eturnray "
"itsway anslationtray."

#: src/code/intl.lisp
msgid "Look up the singular or plural form of a message in the current domain."
msgstr ""
"Ooklay upway ethay ingularsay orway uralplay ormfay ofway away essagemay "
"inway ethay urrentcay omainday."

#: src/code/intl.lisp
msgid ""
"Look up STRING in the specified message domain and return its translation."
msgstr ""
"Ooklay upway STRING inway ethay ecifiedspay essagemay omainday andway "
"eturnray itsway anslationtray."

#: src/code/intl.lisp
msgid ""
"Look up the singular or plural form of a message in the specified domain."
msgstr ""
"Ooklay upway ethay ingularsay orway uralplay ormfay ofway away essagemay "
"inway ethay ecifiedspay omainday."

#: src/code/intl.lisp
msgid "_@ is a reserved reader macro prefix."
msgstr "_@ isway away eservedray eaderray acromay efixpray."

#: src/code/intl.lisp
msgid "~&Dumping ~D messages for domain ~S~%"
msgstr "~&Umpingday ~D essagesmay orfay omainday ~S~%"

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with\n"
"  all lower case alphabetic characters converted to uppercase using\n"
"  full case conversion."
msgstr ""
"Ivengay away ingstray, eturnsray away ewnay ingstray atthay isway away "
"opycay ofway itway ithway\n"
"  allway owerlay asecay alphabeticway aracterschay onvertedcay otay "
"uppercaseway usingway\n"
"  ullfay asecay onversioncay."

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with\n"
"  all lower case alphabetic characters converted to uppercase.  Casing\n"
"  is :simple or :full for simple or full case conversion,\n"
"  respectively."
msgstr ""
"Ivengay away ingstray, eturnsray away ewnay ingstray atthay isway away "
"opycay ofway itway ithway\n"
"  allway owerlay asecay alphabeticway aracterschay onvertedcay otay "
"uppercaseway.  Asingcay\n"
"  isway :implesay orway :ullfay orfay implesay orway ullfay asecay "
"onversioncay,\n"
"  espectivelyray."

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with\n"
"  all uppercase alphabetic characters converted to lowercase using\n"
"  full case conversion.."
msgstr ""
"Ivengay away ingstray, eturnsray away ewnay ingstray atthay isway away "
"opycay ofway itway ithway\n"
"  allway uppercaseway alphabeticway aracterschay onvertedcay otay "
"owercaselay usingway\n"
"  ullfay asecay onversioncay.."

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with all\n"
"  uppercase alphabetic characters converted to lowercase.  Casing is\n"
"  :simple or :full for simple or full case conversion, respectively."
msgstr ""
"Ivengay away ingstray, eturnsray away ewnay ingstray atthay isway away "
"opycay ofway itway ithway allway\n"
"  uppercaseway alphabeticway aracterschay onvertedcay otay owercaselay.  "
"Asingcay isway\n"
"  :implesay orway :ullfay orfay implesay orway ullfay asecay onversioncay, "
"espectivelyray."

#: src/code/unicode.lisp
msgid ""
"Given a string, S, and a starting index, return the index of the\n"
"  next character that is not part of the word containing the character\n"
"  at the index, or the length of S if the word containing the\n"
"  character extends to the end of S.  If the index is negative or\n"
"  valid index into S, the returned value will be strictly greater than\n"
"  the index."
msgstr ""
"Ivengay away ingstray, S, andway away tartingsay indexway, eturnray ethay "
"indexway ofway ethay\n"
"  extnay aracterchay atthay isway otnay artpay ofway ethay ordway "
"ontainingcay ethay aracterchay\n"
"  atway ethay indexway, orway ethay engthlay ofway S ifway ethay ordway "
"ontainingcay ethay\n"
"  aracterchay extendsway otay ethay endway ofway S.  Ifway ethay indexway "
"isway egativenay orway\n"
"  alidvay indexway intoway S, ethay eturnedray aluevay illway ebay "
"ictlystray eatergray anthay\n"
"  ethay indexway."

#: src/code/unicode.lisp
msgid "Returns CHAR converted to title-case if that is possible."
msgstr ""
"Eturnsray CHAR onvertedcay otay itletay-asecay ifway atthay isway ossiblepay."

#: src/code/unicode.lisp
msgid ""
"The argument must be a character object; title-case-p returns T if the\n"
"  argument is a title-case character, NIL otherwise."
msgstr ""
"Ethay argumentway ustmay ebay away aracterchay objectway; itletay-asecay-p "
"eturnsray T ifway ethay\n"
"  argumentway isway away itletay-asecay aracterchay, NIL otherwiseway."

#: src/code/unicode.lisp
msgid ""
"Capitalize String using the Unicode word-break algorithm to find\n"
"  the words in String.  The beginning is capitalized depending on the\n"
"  value of Casing"
msgstr ""
"Apitalizecay Ingstray usingway ethay Unicodeway ordway-eakbray algorithmway "
"otay indfay\n"
"  ethay ordsway inway Ingstray.  Ethay eginningbay isway apitalizedcay "
"ependingday onway ethay\n"
"  aluevay ofway Asingcay"

#: src/code/unicode.lisp
msgid ""
"Capitalize String using the Common Lisp word-break algorithm to find\n"
"  the words in String.  The beginning is capitalized depending on the\n"
"  value of Casing"
msgstr ""
"Apitalizecay Ingstray usingway ethay Ommoncay Isplay ordway-eakbray "
"algorithmway otay indfay\n"
"  ethay ordsway inway Ingstray.  Ethay eginningbay isway apitalizedcay "
"ependingday onway ethay\n"
"  aluevay ofway Asingcay"

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a copy of the string with the first\n"
"  character of each ``word'' converted to upper-case, and remaining\n"
"  chars in the word converted to lower case. Casing is :simple, :full\n"
"  or :title for simple, full or title case conversion, respectively.  If\n"
"  Unicode-Word-Break is non-Nil, then the Unicode word-breaking\n"
"  algorithm is used to determine the word boundaries.  Otherwise, A\n"
"  ``word'' is defined to be a string of case-modifiable characters\n"
"  delimited by non-case-modifiable chars.  "
msgstr ""
"Ivengay away ingstray, eturnsray away opycay ofway ethay ingstray ithway "
"ethay irstfay\n"
"  aracterchay ofway eachway ``ordway'' onvertedcay otay upperway-asecay, "
"andway emainingray\n"
"  arschay inway ethay ordway onvertedcay otay owerlay asecay. Asingcay "
"isway :implesay, :ullfay\n"
"  orway :itletay orfay implesay, ullfay orway itletay asecay onversioncay, "
"espectivelyray.  Ifway\n"
"  Unicodeway-Ordway-Eakbray isway onnay-Ilnay, enthay ethay Unicodeway "
"ordway-eakingbray\n"
"  algorithmway isway usedway otay etermineday ethay ordway oundariesbay.  "
"Otherwiseway, Away\n"
"  ``ordway'' isway efinedday otay ebay away ingstray ofway asecay-"
"odifiablemay aracterschay\n"
"  elimitedday ybay onnay-asecay-odifiablemay arschay.  "

#: src/code/unicode.lisp
msgid ""
"Decompose the Hangul syllable codepoint CP to an equivalent sequence\n"
"  of conjoining jamo and print the decomposed result to the stream\n"
"  STREAM."
msgstr ""

#: src/code/unicode.lisp
msgid "Test if CODEPOINT is a Hangul syllable"
msgstr ""

#: src/code/unicode.lisp
msgid ""
"Decompose any Hangul syllables in STRING to an equivalent sequence of\n"
"  conjoining jamo characters."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Policy Node Condition*\n"
"  Test whether some conditions apply to the current compiler policy for "
"Node.\n"
"  Each condition is a predicate form which accesses the policy values by\n"
"  referring to them as the variables SPEED, SPACE, SAFETY, CSPEED, BREVITY "
"and\n"
"  DEBUG.  The results of all the conditions are combined with AND and "
"returned\n"
"  as the result.\n"
"\n"
"  Node is a form which is evaluated to obtain the node which the policy is "
"for.\n"
"  If Node is NIL, then we use the current policy as defined by *default-"
"cookie*\n"
"  and *current-cookie*.  This option is only well defined during IR1\n"
"  conversion."
msgstr ""
"Olicypay Odenay Ondition*Cay\n"
"  Esttay etherwhay omesay onditionscay applyway otay ethay urrentcay "
"ompilercay olicypay orfay Odenay.\n"
"  Eachway onditioncay isway away edicatepray ormfay ichwhay accessesway "
"ethay olicypay aluesvay ybay\n"
"  eferringray otay emthay asway ethay ariablesvay SPEED, SPACE, SAFETY, "
"CSPEED, BREVITY andway\n"
"  DEBUG.  Ethay esultsray ofway allway ethay onditionscay areway ombinedcay "
"ithway AND andway eturnedray\n"
"  asway ethay esultray.\n"
"\n"
"  Odenay isway away ormfay ichwhay isway evaluatedway otay obtainway ethay "
"odenay ichwhay ethay olicypay isway orfay.\n"
"  Ifway Odenay isway NIL, enthay eway useway ethay urrentcay olicypay asway "
"efinedday ybay default-cook*ayie*way\n"
"  andway *current-cookie*.  Isthay optionway isway onlyway ellway efinedday "
"uringday IR1\n"
"  onversioncay."

#: src/compiler/macros.lisp
msgid "Can't funcall the SYMBOL-FUNCTION of special forms."
msgstr "Ancay't uncallfay ethay SYMBOL-FUNCTION ofway ecialspay ormsfay."

#: src/compiler/macros.lisp
msgid ""
"Def-IR1-Translator Name (Lambda-List Start-Var Cont-Var {Key Value}*)\n"
"                      [Doc-String] Form*\n"
"  Define a function that converts a Special-Form or other magical thing "
"into\n"
"  IR1.  Lambda-List is a defmacro style lambda list.  Start-Var and Cont-"
"Var\n"
"  are bound to the start and result continuations for the resulting IR1.\n"
"  This keyword is defined:\n"
"      Kind\n"
"          The function kind to associate with Name (default :special-form)."
msgstr ""
"Efday-IR1-Anslatortray Amenay (Ambdalay-Istlay Tartsay-Arvay Ontcay-Arvay "
"{Eykay Aluevay}*)\n"
"                      [Ocday-Ingstray] Orm*Fay\n"
"  Efineday away unctionfay atthay onvertscay away Ecialspay-Ormfay orway "
"otherway agicalmay ingthay intoway\n"
"  IR1.  Ambdalay-Istlay isway away efmacroday tylesay ambdalay istlay.  "
"Tartsay-Arvay andway Ontcay-Arvay\n"
"  areway oundbay otay ethay tartsay andway esultray ontinuationscay orfay "
"ethay esultingray IR1.\n"
"  Isthay eywordkay isway efinedday:\n"
"      Indkay\n"
"          Ethay unctionfay indkay otay associateway ithway Amenay "
"(efaultday :ecialspay-ormfay)."

#: src/compiler/macros.lisp
msgid ""
"Def-Source-Transform Name Lambda-List Form*\n"
"  Define a macro-like source-to-source transformation for the function "
"Name.\n"
"  A source transform may \"pass\" by returning a non-nil second value.  If "
"the\n"
"  transform passes, then the form is converted as a normal function call.  "
"If\n"
"  the supplied arguments are not compatible with the specified lambda-list,\n"
"  then the transform automatically passes.\n"
"  \n"
"  Source-Transforms may only be defined for functions.  Source "
"transformation\n"
"  is not attempted if the function is declared Notinline.  Source "
"transforms\n"
"  should not examine their arguments.  If it matters how the function is "
"used,\n"
"  then Deftransform should be used to define an IR1 transformation.\n"
"  \n"
"  If the desirability of the transformation depends on the current Optimize\n"
"  parameters, then the Policy macro should be used to determine when to pass."
msgstr ""
"Efday-Ourcesay-Ansformtray Amenay Ambdalay-Istlay Orm*Fay\n"
"  Efineday away acromay-ikelay ourcesay-otay-ourcesay ansformationtray orfay "
"ethay unctionfay Amenay.\n"
"  Away ourcesay ansformtray aymay \"asspay\" ybay eturningray away onnay-"
"ilnay econdsay aluevay.  Ifway ethay\n"
"  ansformtray assespay, enthay ethay ormfay isway onvertedcay asway away "
"ormalnay unctionfay allcay.  Ifway\n"
"  ethay uppliedsay argumentsway areway otnay ompatiblecay ithway ethay "
"ecifiedspay ambdalay-istlay,\n"
"  enthay ethay ansformtray automaticallyway assespay.\n"
"  \n"
"  Ourcesay-Ansformstray aymay onlyway ebay efinedday orfay unctionsfay.  "
"Ourcesay ansformatiotrayn\n"
"  isway otnay attemptedway ifway ethay unctionfay isway eclaredday "
"Otinlinenay.  Ourcesay ansformstray\n"
"  ouldshay otnay examineway eirthay argumentsway.  Ifway itway attersmay "
"owhay ethay unctionfay isway usedway,\n"
"  enthay Eftransformday ouldshay ebay usedway otay efineday anway IR1 "
"ansformationtray.\n"
"  \n"
"  Ifway ethay esirabilityday ofway ethay ansformationtray ependsday onway "
"ethay urrentcay Optimizeway\n"
"  arameterspay, enthay ethay Olicypay acromay ouldshay ebay usedway otay "
"etermineday enwhay otay asspay."

#: src/compiler/macros.lisp
msgid ""
"Def-Primitive-Translator Name Lambda-List Form*\n"
"  Define a function that converts a use of (%PRIMITIVE Name ...) into Lisp\n"
"  code.  Lambda-List is a defmacro style lambda list."
msgstr ""
"Efday-Imitivepray-Anslatortray Amenay Ambdalay-Istlay Orm*Fay\n"
"  Efineday away unctionfay atthay onvertscay away useway ofway (%PRIMITIVE "
"Amenay ...) intoway Isplay\n"
"  odecay.  Ambdalay-Istlay isway away efmacroday tylesay ambdalay istlay."

#: src/compiler/macros.lisp
msgid ""
"Deftransform Name (Lambda-List [Arg-Types] [Result-Type] {Key Value}*)\n"
"               Declaration* [Doc-String] Form*\n"
"  Define an IR1 transformation for Name.  An IR1 transformation computes a\n"
"  lambda that replaces the function variable reference for the call.  A\n"
"  transform may pass (decide not to transform the call) by calling the Give-"
"Up\n"
"  function.  Lambda-List both determines how the current call is parsed and\n"
"  specifies the Lambda-List for the resulting lambda.\n"
"\n"
"  We parse the call and bind each of the lambda-list variables to the\n"
"  continuation which represents the value of the argument.  When parsing "
"the\n"
"  call, we ignore the defaults, and always bind the variables for "
"unsupplied\n"
"  arguments to NIL.  If a required argument is missing, an unknown keyword "
"is\n"
"  supplied, or an argument keyword is not a constant, then the transform\n"
"  automatically passes.  The Declarations apply to the bindings made by\n"
"  Deftransform at transformation time, rather than to the variables of the\n"
"  resulting lambda.  Bound-but-not-referenced warnings are suppressed for "
"the\n"
"  lambda-list variables.  The Doc-String is used when printing efficiency "
"notes\n"
"  about the defined transform.\n"
"\n"
"  Normally, the body evaluates to a form which becomes the body of an\n"
"  automatically constructed lambda.  We make Lambda-List the lambda-list "
"for\n"
"  the lambda, and automatically insert declarations of the argument and "
"result\n"
"  types.  If the second value of the body is non-null, then it is a list of\n"
"  declarations which are to be inserted at the head of the lambda.  "
"Automatic\n"
"  lambda generation may be inhibited by explicitly returning a lambda from "
"the\n"
"  body.\n"
"\n"
"  The Arg-Types and Result-Type are used to create a function type which "
"the\n"
"  call must satisfy before transformation is attempted.  The function type\n"
"  specifier is constructed by wrapping (FUNCTION ...) around these values, "
"so\n"
"  the lack of a restriction may be specified by omitting the argument or\n"
"  supplying *.  The argument syntax specified in the Arg-Types need not be "
"the\n"
"  same as that in the Lambda-List, but the transform will never happen if\n"
"  the syntaxes can't be satisfied simultaneously.  If there is an existing\n"
"  transform for the same function that has the same type, then it is "
"replaced\n"
"  with the new definition.\n"
"\n"
"  These are the legal keyword options:\n"
"    :Result - A variable which is bound to the result continuation.\n"
"    :Node   - A variable which is bound to the combination node for the "
"call.\n"
"    :Policy - A form which is supplied to the Policy macro to determine "
"whether\n"
"              this transformation is appropriate.  If the result is false, "
"then\n"
"              the transform automatically passes.\n"
"    :Eval-Name\n"
"    \t    - The name and argument/result types are actually forms to be\n"
"              evaluated.  Useful for getting closures that transform "
"similar\n"
"              functions.\n"
"    :Defun-Only\n"
"            - Don't actually instantiate a transform, instead just DEFUN\n"
"              Name with the specified transform definition function.  This "
"may\n"
"              be later instantiated with %Deftransform.\n"
"    :Important\n"
"            - If supplied and non-NIL, note this transform as "
"``important,''\n"
"              which means effeciency notes will be generated when this\n"
"              transform fails even if brevity=speed (but not if "
"brevity>speed)\n"
"    :When {:Native | :Byte | :Both}\n"
"            - Indicates whether this transform applies to native code,\n"
"              byte-code or both (default :native.)"
msgstr ""
"Eftransformday Amenay (Ambdalay-Istlay [Argway-Ypestay] [Esultray-Ypetay] "
"{Eykay Aluevay}*)\n"
"               Eclaration*Day [Ocday-Ingstray] Orm*Fay\n"
"  Efineday anway IR1 ansformationtray orfay Amenay.  Anway IR1 "
"ansformationtray omputescay away\n"
"  ambdalay atthay eplacesray ethay unctionfay ariablevay eferenceray orfay "
"ethay allcay.  Away\n"
"  ansformtray aymay asspay (ecideday otnay otay ansformtray ethay allcay) "
"ybay allingcay ethay Ivegay-Upway\n"
"  unctionfay.  Ambdalay-Istlay othbay eterminesday owhay ethay urrentcay "
"allcay isway arsedpay andway\n"
"  ecifiesspay ethay Ambdalay-Istlay orfay ethay esultingray ambdalay.\n"
"\n"
"  Eway arsepay ethay allcay andway indbay eachway ofway ethay ambdalay-"
"istlay ariablesvay otay ethay\n"
"  ontinuationcay ichwhay epresentsray ethay aluevay ofway ethay "
"argumentway.  Enwhay arsingpay ethay\n"
"  allcay, eway ignoreway ethay efaultsday, andway alwaysway indbay ethay "
"ariablesvay orfay unsuppliedway\n"
"  argumentsway otay NIL.  Ifway away equiredray argumentway isway issingmay, "
"anway unknownway eywordkay isway\n"
"  uppliedsay, orway anway argumentway eywordkay isway otnay away onstantcay, "
"enthay ethay ansformtray\n"
"  automaticallyway assespay.  Ethay Eclarationsday applyway otay ethay "
"indingsbay ademay ybay\n"
"  Eftransformday atway ansformationtray imetay, atherray anthay otay ethay "
"ariablesvay ofway ethay\n"
"  esultingray ambdalay.  Oundbay-utbay-otnay-eferencedray arningsway areway "
"uppressedsay orfay ethay\n"
"  ambdalay-istlay ariablesvay.  Ethay Ocday-Ingstray isway usedway enwhay "
"intingpray efficiencyway otesnay\n"
"  aboutway ethay efinedday ansformtray.\n"
"\n"
"  Ormallynay, ethay odybay evaluatesway otay away ormfay ichwhay ecomesbay "
"ethay odybay ofway anway\n"
"  automaticallyway onstructedcay ambdalay.  Eway akemay Ambdalay-Istlay "
"ethay ambdalay-istlay orfay\n"
"  ethay ambdalay, andway automaticallyway insertway eclarationsday ofway "
"ethay argumentway andway esultray\n"
"  ypestay.  Ifway ethay econdsay aluevay ofway ethay odybay isway onnay-"
"ullnay, enthay itway isway away istlay ofway\n"
"  eclarationsday ichwhay areway otay ebay insertedway atway ethay eadhay "
"ofway ethay ambdalay.  Automatiwayc\n"
"  ambdalay enerationgay aymay ebay inhibitedway ybay explicitlyway "
"eturningray away ambdalay omfray ethay\n"
"  odybay.\n"
"\n"
"  Ethay Argway-Ypestay andway Esultray-Ypetay areway usedway otay eatecray "
"away unctionfay ypetay ichwhay ethay\n"
"  allcay ustmay atisfysay eforebay ansformationtray isway attemptedway.  "
"Ethay unctionfay ypetay\n"
"  ecifierspay isway onstructedcay ybay appingwray (FUNCTION ...) aroundway "
"esethay aluesvay, osay\n"
"  ethay acklay ofway away estrictionray aymay ebay ecifiedspay ybay "
"omittingway ethay argumentway orway\n"
"  upplyingsay *.  Ethay argumentway yntaxsay ecifiedspay inway ethay Argway-"
"Ypestay eednay otnay ebay ethay\n"
"  amesay asway atthay inway ethay Ambdalay-Istlay, utbay ethay ansformtray "
"illway evernay appenhay ifway\n"
"  ethay yntaxessay ancay't ebay atisfiedsay imultaneouslysay.  Ifway erethay "
"isway anway existingway\n"
"  ansformtray orfay ethay amesay unctionfay atthay ashay ethay amesay "
"ypetay, enthay itway isway eplacedray\n"
"  ithway ethay ewnay efinitionday.\n"
"\n"
"  Esethay areway ethay egallay eywordkay optionsway:\n"
"    :Esultray - Away ariablevay ichwhay isway oundbay otay ethay esultray "
"ontinuationcay.\n"
"    :Odenay   - Away ariablevay ichwhay isway oundbay otay ethay "
"ombinationcay odenay orfay ethay allcay.\n"
"    :Olicypay - Away ormfay ichwhay isway uppliedsay otay ethay Olicypay "
"acromay otay etermineday etherwhay\n"
"              isthay ansformationtray isway appropriateway.  Ifway ethay "
"esultray isway alsefay, enthay\n"
"              ethay ansformtray automaticallyway assespay.\n"
"    :Evalway-Amenay\n"
"    \t    - Ethay amenay andway argumentway/esultray ypestay areway "
"actuallyway ormsfay otay ebay\n"
"              evaluatedway.  Usefulway orfay ettinggay osuresclay atthay "
"ansformtray imilarsay\n"
"              unctionsfay.\n"
"    :Efunday-Onlyway\n"
"            - Onday't actuallyway instantiateway away ansformtray, "
"insteadway ustjay DEFUN\n"
"              Amenay ithway ethay ecifiedspay ansformtray efinitionday "
"unctionfay.  Isthay aymay\n"
"              ebay aterlay instantiatedway ithway %Eftransformday.\n"
"    :Importantway\n"
"            - Ifway uppliedsay andway onnay-NIL, otenay isthay ansformtray "
"asway ``importantway,''\n"
"              ichwhay eansmay effeciencyway otesnay illway ebay eneratedgay "
"enwhay isthay\n"
"              ansformtray ailsfay evenway ifway evitybray=eedspay (utbay "
"otnay ifway evitybray>eespayd)\n"
"    :Enwhay {:Ativenay | :Ytebay | :Othbay}\n"
"            - Indicatesway etherwhay isthay ansformtray appliesway otay "
"ativenay odecay,\n"
"              ytebay-odecay orway othbay (efaultday :ativenay.)"

#: src/compiler/macros.lisp
msgid "Can't specify both DEFUN-ONLY and EVAL-NAME."
msgstr "Ancay't ecifyspay othbay DEFUN-ONLY andway EVAL-NAME."

#: src/compiler/macros.lisp
msgid ""
"Defknown Name Arg-Types Result-Type [Attributes] {Key Value}* \n"
"  Declare the function Name to be a known function.  We construct a type\n"
"  specifier for the function by wrapping (FUNCTION ...) around the Arg-"
"Types\n"
"  and Result-Type.  Attributes is a an unevaluated list of the boolean\n"
"  attributes that the function has.  These attributes are meaningful here:\n"
"      call\n"
"         May call functions that are passed as arguments.  In order to "
"determine\n"
"         what other effects are present, we must find the effects of all "
"arguments\n"
"         that may be functions.\n"
"        \n"
"      unsafe\n"
"         May incorporate arguments in the result or somehow pass them "
"upward.\n"
"        \n"
"      unwind\n"
"         May fail to return during correct execution.  Errors are O.K.\n"
"        \n"
"      any\n"
"         The (default) worst case.  Includes all the other bad things, plus "
"any\n"
"         other possible bad thing.\n"
"        \n"
"      foldable\n"
"         May be constant-folded.  The function has no side effects, but may "
"be\n"
"         affected by side effects on the arguments.  e.g. SVREF, MAPC.\n"
"        \n"
"      flushable\n"
"         May be eliminated if value is unused.  The function has no side "
"effects\n"
"         except possibly CONS.  If a function is defined to signal errors, "
"then\n"
"         it is not flushable even if it is movable or foldable.\n"
"        \n"
"      movable\n"
"         May be moved with impunity.  Has no side effects except possibly "
"CONS,\n"
"         and is affected only by its arguments.\n"
"\n"
"      predicate\n"
"          A true predicate likely to be open-coded.  This is a hint to IR1\n"
"\t  conversion that it should ensure calls always appear as an IF test.\n"
"\t  Not usually specified to Defknown, since this is implementation\n"
"\t  dependent, and is usually automatically set by the Define-VOP\n"
"\t  :Conditional option.\n"
"\n"
"  Name may also be a list of names, in which case the same information is "
"given\n"
"  to all the names.  The keywords specify the initial values for various\n"
"  optimizers that the function might have."
msgstr ""
"Efknownday Amenay Argway-Ypestay Esultray-Ypetay [Attributesway] {Eykay "
"Aluevay}* \n"
"  Eclareday ethay unctionfay Amenay otay ebay away nownkay unctionfay.  Eway "
"onstructcay away ypetay\n"
"  ecifierspay orfay ethay unctionfay ybay appingwray (FUNCTION ...) "
"aroundway ethay Argway-Ypestay\n"
"  andway Esultray-Ypetay.  Attributesway isway away anway unevaluatedway "
"istlay ofway ethay ooleanbay\n"
"  attributesway atthay ethay unctionfay ashay.  Esethay attributesway areway "
"eaningfulmay erehay:\n"
"      allcay\n"
"         Aymay allcay unctionsfay atthay areway assedpay asway "
"argumentsway.  Inway orderway otay etermineday\n"
"         atwhay otherway effectsway areway esentpray, eway ustmay indfay "
"ethay effectsway ofway allway argumentsway\n"
"         atthay aymay ebay unctionsfay.\n"
"        \n"
"      unsafeway\n"
"         Aymay incorporateway argumentsway inway ethay esultray orway "
"omehowsay asspay emthay upwardway.\n"
"        \n"
"      unwindway\n"
"         Aymay ailfay otay eturnray uringday orrectcay executionway.  "
"Errorsway areway O.K.\n"
"        \n"
"      anyway\n"
"         Ethay (efaultday) orstway asecay.  Includesway allway ethay "
"otherway adbay ingsthay, usplay anyway\n"
"         otherway ossiblepay adbay ingthay.\n"
"        \n"
"      oldablefay\n"
"         Aymay ebay onstantcay-oldedfay.  Ethay unctionfay ashay onay idesay "
"effectsway, utbay aymay ebay\n"
"         affectedway ybay idesay effectsway onway ethay argumentsway.  e.g. "
"SVREF, MAPC.\n"
"        \n"
"      ushableflay\n"
"         Aymay ebay eliminatedway ifway aluevay isway unusedway.  Ethay "
"unctionfay ashay onay idesay effectsway\n"
"         exceptway ossiblypay CONS.  Ifway away unctionfay isway efinedday "
"otay ignalsay errorsway, enthay\n"
"         itway isway otnay ushableflay evenway ifway itway isway ovablemay "
"orway oldablefay.\n"
"        \n"
"      ovablemay\n"
"         Aymay ebay ovedmay ithway impunityway.  Ashay onay idesay "
"effectsway exceptway ossiblypay CONS,\n"
"         andway isway affectedway onlyway ybay itsway argumentsway.\n"
"\n"
"      edicatepray\n"
"          Away uetray edicatepray ikelylay otay ebay openway-odedcay.  "
"Isthay isway away inthay otay IR1\n"
"\t  onversioncay atthay itway ouldshay ensureway allscay alwaysway appearway "
"asway anway IF esttay.\n"
"\t  Otnay usuallyway ecifiedspay otay Efknownday, incesay isthay isway "
"implementationway\n"
"\t  ependentday, andway isway usuallyway automaticallyway etsay ybay ethay "
"Efineday-VOP\n"
"\t  :Onditionalcay optionway.\n"
"\n"
"  Amenay aymay alsoway ebay away istlay ofway amesnay, inway ichwhay asecay "
"ethay amesay informationway isway ivengay\n"
"  otay allway ethay amesnay.  Ethay eywordskay ecifyspay ethay initialway "
"aluesvay orfay ariousvay\n"
"  optimizersway atthay ethay unctionfay ightmay avehay."

#: src/compiler/macros.lisp
msgid "Function cannot have both good and bad attributes: ~S"
msgstr ""
"Unctionfay annotcay avehay othbay oodgay andway adbay attributesway: ~S"

#: src/compiler/macros.lisp
msgid ""
"Defoptimizer (Function Kind) (Lambda-List [Node-Var] Var*)\n"
"                Declaration* Form*\n"
"  Define some Kind of optimizer for the named Function.  Function must be a\n"
"  known function.  Lambda-List is used to parse the arguments to the\n"
"  combination as in Deftransform.  If the argument syntax is invalid or "
"there\n"
"  are non-constant keys, then we simply return NIL.\n"
"\n"
"  The function is DEFUN'ed as Function-Kind-OPTIMIZER.  Possible kinds are\n"
"  DERIVE-TYPE, OPTIMIZER, LTN-ANNOTATE and IR2-CONVERT.  If a symbol is\n"
"  specified instead of a (Function Kind) list, then we just do a DEFUN with "
"the\n"
"  symbol as its name, and don't do anything with the definition.  This is\n"
"  useful for creating optimizers to be passed by name to DEFKNOWN.\n"
"\n"
"  If supplied, Node-Var is bound to the combination node being optimized.  "
"If\n"
"  additional Vars are supplied, then they are used as the rest of the "
"optimizer\n"
"  function's lambda-list.  LTN-ANNOTATE methods are passed an additional "
"POLICY\n"
"  argument, and IR2-CONVERT methods are passed an additional IR2-BLOCK\n"
"  argument."
msgstr ""
"Efoptimizerday (Unctionfay Indkay) (Ambdalay-Istlay [Odenay-Arvay] Ar*Vay)\n"
"                Eclaration*Day Orm*Fay\n"
"  Efineday omesay Indkay ofway optimizerway orfay ethay amednay Unctionfay.  "
"Unctionfay ustmay ebay away\n"
"  nownkay unctionfay.  Ambdalay-Istlay isway usedway otay arsepay ethay "
"argumentsway otay ethay\n"
"  ombinationcay asway inway Eftransformday.  Ifway ethay argumentway "
"yntaxsay isway invalidway orway erethay\n"
"  areway onnay-onstantcay eyskay, enthay eway implysay eturnray NIL.\n"
"\n"
"  Ethay unctionfay isway DEFUN'edway asway Unctionfay-Indkay-OPTIMIZER.  "
"Ossiblepay indskay areway\n"
"  DERIVE-TYPE, OPTIMIZER, LTN-ANNOTATE andway IR2-CONVERT.  Ifway away "
"ymbolsay isway\n"
"  ecifiedspay insteadway ofway away (Unctionfay Indkay) istlay, enthay eway "
"ustjay oday away DEFUN ithway ethay\n"
"  ymbolsay asway itsway amenay, andway onday't oday anythingway ithway ethay "
"efinitionday.  Isthay isway\n"
"  usefulway orfay eatingcray optimizersway otay ebay assedpay ybay amenay "
"otay DEFKNOWN.\n"
"\n"
"  Ifway uppliedsay, Odenay-Arvay isway oundbay otay ethay ombinationcay "
"odenay eingbay optimizedway.  Ifway\n"
"  additionalway Arsvay areway uppliedsay, enthay eythay areway usedway asway "
"ethay estray ofway ethay optimizerway\n"
"  unctionfay's ambdalay-istlay.  LTN-ANNOTATE ethodsmay areway assedpay "
"anway additionalway POLICY\n"
"  argumentway, andway IR2-CONVERT ethodsmay areway assedpay anway "
"additionalway IR2-BLOCK\n"
"  argumentway."

#: src/compiler/macros.lisp
msgid ""
"Do-Blocks (Block-Var Component [Ends] [Result-Form]) {Declaration}* {Form}*\n"
"  Iterate over the blocks in a component, binding Block-Var to each block "
"in\n"
"  turn.  The value of Ends determines whether to iterate over dummy head "
"and\n"
"  tail blocks:\n"
"    NIL   -- Skip Head and Tail (the default)\n"
"    :Head -- Do head but skip tail\n"
"    :Tail -- Do tail but skip head\n"
"    :Both -- Do both head and tail\n"
"\n"
"  If supplied, Result-Form is the value to return."
msgstr ""
"Oday-Ocksblay (Ockblay-Arvay Omponentcay [Endsway] [Esultray-Ormfay]) "
"{Eclarationday}* {Ormfay}*\n"
"  Iterateway overway ethay ocksblay inway away omponentcay, indingbay "
"Ockblay-Arvay otay eachway ockblay inway\n"
"  urntay.  Ethay aluevay ofway Endsway eterminesday etherwhay otay "
"iterateway overway ummyday eadhay andway\n"
"  ailtay ocksblay:\n"
"    NIL   -- Kipsay Eadhay andway Ailtay (ethay efaultday)\n"
"    :Eadhay -- Oday eadhay utbay kipsay ailtay\n"
"    :Ailtay -- Oday ailtay utbay kipsay eadhay\n"
"    :Othbay -- Oday othbay eadhay andway ailtay\n"
"\n"
"  Ifway uppliedsay, Esultray-Ormfay isway ethay aluevay otay eturnray."

#: src/compiler/macros.lisp
msgid "Losing Ends value: ~S."
msgstr "Osinglay Endsway aluevay: ~S."

#: src/compiler/macros.lisp
msgid ""
"Do-Blocks-Backwards (Block-Var Component [Ends] [Result-Form]) {Declaration}"
"* {Form}*\n"
"  Like Do-Blocks, only iterate over the blocks in reverse order."
msgstr ""
"Oday-Ocksblay-Ackwardsbay (Ockblay-Arvay Omponentcay [Endsway] [Esultray-"
"Ormfay]) {Eclarationday}* {Ormfay}*\n"
"  Ikelay Oday-Ocksblay, onlyway iterateway overway ethay ocksblay inway "
"everseray orderway."

#: src/compiler/macros.lisp
msgid ""
"Do-Uses (Node-Var Continuation [Result]) {Declaration}* {Form}*\n"
"  Iterate over the uses of Continuation, binding Node to each one "
"succesively."
msgstr ""
"Oday-Usesway (Odenay-Arvay Ontinuationcay [Esultray]) {Eclarationday}* "
"{Ormfay}*\n"
"  Iterateway overway ethay usesway ofway Ontinuationcay, indingbay Odenay "
"otay eachway oneway uccesivelsayy."

#: src/compiler/macros.lisp
msgid ""
"Do-Nodes (Node-Var Cont-Var Block {Key Value}*) {Declaration}* {Form}*\n"
"  Iterate over the nodes in Block, binding Node-Var to the each node and\n"
"  Cont-Var to the node's Cont.  The only keyword option is Restart-P, which\n"
"  causes iteration to be restarted when a node is deleted out from under us "
"(if\n"
"  not supplied, this is an error.)"
msgstr ""
"Oday-Odesnay (Odenay-Arvay Ontcay-Arvay Ockblay {Eykay Aluevay}*) "
"{Eclarationday}* {Ormfay}*\n"
"  Iterateway overway ethay odesnay inway Ockblay, indingbay Odenay-Arvay "
"otay ethay eachway odenay andway\n"
"  Ontcay-Arvay otay ethay odenay's Ontcay.  Ethay onlyway eywordkay "
"optionway isway Estartray-P, ichwhay\n"
"  ausescay iterationway otay ebay estartedray enwhay away odenay isway "
"eletedday outway omfray underway usway (ifway\n"
"  otnay uppliedsay, isthay isway anway errorway.)"

#: src/compiler/macros.lisp
msgid ""
"Do-Nodes-Backwards (Node-Var Cont-Var Block) {Declaration}* {Form}*\n"
"  Like Do-Nodes, only iterates in reverse order."
msgstr ""
"Oday-Odesnay-Ackwardsbay (Odenay-Arvay Ontcay-Arvay Ockblay) {Eclarationday}"
"* {Ormfay}*\n"
"  Ikelay Oday-Odesnay, onlyway iteratesway inway everseray orderway."

#: src/compiler/macros.lisp
msgid ""
"With-IR1-Environment Node Form*\n"
"  Bind the IR1 context variables so that IR1 conversion can be done after "
"the\n"
"  main conversion pass has finished."
msgstr ""
"Ithway-IR1-Environmentway Odenay Orm*Fay\n"
"  Indbay ethay IR1 ontextcay ariablesvay osay atthay IR1 onversioncay ancay "
"ebay oneday afterway ethay\n"
"  ainmay onversioncay asspay ashay inishedfay."

#: src/compiler/macros.lisp
msgid ""
"LEXENV-FIND Name Slot {Key Value}*\n"
"  Look up Name in the lexical environment namespace designated by Slot,\n"
"  returning the <value, T>, or <NIL, NIL> if no entry.  The :TEST keyword\n"
"  may be used to determine the name equality predicate."
msgstr ""
"LEXENV-FIND Amenay Otslay {Eykay Aluevay}*\n"
"  Ooklay upway Amenay inway ethay exicallay environmentway amespacenay "
"esignatedday ybay Otslay,\n"
"  eturningray ethay <aluevay, T>, orway <NIL, NIL> ifway onay entryway.  "
"Ethay :TEST eywordkay\n"
"  aymay ebay usedway otay etermineday ethay amenay equalityway edicatepray."

#: src/compiler/macros.lisp
msgid "If true, defprinter print functions print each slot on a separate line."
msgstr ""
"Ifway uetray, efprinterday intpray unctionsfay intpray eachway otslay onway "
"away eparatesay inelay."

#: src/compiler/macros.lisp
msgid ""
"Defprinter Name Slot-Desc*\n"
"  Define some kind of reasonable defstruct structure-print function.  Name\n"
"  is the name of the structure.  We define a function %PRINT-name which\n"
"  prints the slots in the structure in the way described by the Slot-Descs.\n"
"  Each Slot-Desc can be a slot name, indicating that the slot should simply\n"
"  be printed.  A Slot-Desc may also be a list of a slot name and other "
"stuff.\n"
"  The other stuff is composed of keywords followed by expressions.  The\n"
"  expressions are evaluated with the variable which is the slot name bound\n"
"  to the value of the slot.  These keywords are defined:\n"
"  \n"
"  :PRIN1    Print the value of the expression instead of the slot value.\n"
"  :PRINC    Like :PRIN1, only princ the value\n"
"  :TEST     Only print something if the test is true.\n"
"  \n"
"  If no printing thing is specified then the slot value is printed as "
"PRIN1.\n"
"  \n"
"  The structure being printed is bound to Structure and the stream is bound "
"to\n"
"  Stream."
msgstr ""
"Efprinterday Amenay Otslay-Esc*Day\n"
"  Efineday omesay indkay ofway easonableray efstructday ucturestray-intpray "
"unctionfay.  Amenay\n"
"  isway ethay amenay ofway ethay ucturestray.  Eway efineday away unctionfay "
"%PRINT-amenay ichwhay\n"
"  intspray ethay otsslay inway ethay ucturestray inway ethay ayway "
"escribedday ybay ethay Otslay-Escsday.\n"
"  Eachway Otslay-Escday ancay ebay away otslay amenay, indicatingway atthay "
"ethay otslay ouldshay implysay\n"
"  ebay intedpray.  Away Otslay-Escday aymay alsoway ebay away istlay ofway "
"away otslay amenay andway otherway tuffsay.\n"
"  Ethay otherway tuffsay isway omposedcay ofway eywordskay ollowedfay ybay "
"expressionsway.  Ethay\n"
"  expressionsway areway evaluatedway ithway ethay ariablevay ichwhay isway "
"ethay otslay amenay oundbay\n"
"  otay ethay aluevay ofway ethay otslay.  Esethay eywordskay areway "
"efinedday:\n"
"  \n"
"  :PRIN1    Intpray ethay aluevay ofway ethay expressionway insteadway ofway "
"ethay otslay aluevay.\n"
"  :PRINC    Ikelay :PRIN1, onlyway incpray ethay aluevay\n"
"  :TEST     Onlyway intpray omethingsay ifway ethay esttay isway uetray.\n"
"  \n"
"  Ifway onay intingpray ingthay isway ecifiedspay enthay ethay otslay "
"aluevay isway intedpray asway PRIN1.\n"
"  \n"
"  Ethay ucturestray eingbay intedpray isway oundbay otay Ucturestray andway "
"ethay eamstray isway oundbay otay\n"
"  Eamstray."

#: src/compiler/macros.lisp
msgid "Losing Defprinter option: ~S."
msgstr "Osinglay Efprinterday optionway: ~S."

#: src/compiler/macros.lisp
msgid "Unknown attribute name: ~S."
msgstr "Unknownway attributeway amenay: ~S."

#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/vmdef.lisp src/compiler/node.lisp src/compiler/macros.lisp
msgid ""
"Automagically generated boolean attribute test function.  See\n"
"\t    Def-Boolean-Attribute."
msgstr ""
"Automagicallyway eneratedgay ooleanbay attributeway esttay unctionfay.  "
"Eesay\n"
"\t    Efday-Ooleanbay-Attributeway."

#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/vmdef.lisp src/compiler/node.lisp src/compiler/macros.lisp
msgid ""
"Automagically generated boolean attribute setter.  See\n"
"\t    Def-Boolean-Attribute."
msgstr ""
"Automagicallyway eneratedgay ooleanbay attributeway ettersay.  Eesay\n"
"\t    Efday-Ooleanbay-Attributeway."

#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/vmdef.lisp src/compiler/node.lisp src/compiler/macros.lisp
msgid ""
"Automagically generated boolean attribute creation function.  See\n"
"\t    Def-Boolean-Attribute."
msgstr ""
"Automagicallyway eneratedgay ooleanbay attributeway eationcray unctionfay.  "
"Eesay\n"
"\t    Efday-Ooleanbay-Attributeway."

#: src/compiler/macros.lisp
msgid ""
"Def-Boolean-Attribute Name Attribute-Name*\n"
"  Define a new class of boolean attributes, with the attributes havin the\n"
"  specified Attribute-Names.  Name is the name of the class, which is used "
"to\n"
"  generate some macros to manipulate sets of the attributes: \n"
"\n"
"    NAME-attributep attributes attribute-name*\n"
"      Return true if one of the named attributes is present, false "
"otherwise.\n"
"      When set with SETF, updates the place Attributes setting or clearing "
"the\n"
"      specified attributes.\n"
"\n"
"    NAME-attributes attribute-name*\n"
"      Return a set of the named attributes."
msgstr ""
"Efday-Ooleanbay-Attributeway Amenay Attributeway-Ame*Nay\n"
"  Efineday away ewnay assclay ofway ooleanbay attributesway, ithway ethay "
"attributesway avinhay ethay\n"
"  ecifiedspay Attributeway-Amesnay.  Amenay isway ethay amenay ofway ethay "
"assclay, ichwhay isway usedway otay\n"
"  enerategay omesay acrosmay otay anipulatemay etssay ofway ethay "
"attributesway: \n"
"\n"
"    NAME-attributepway attributesway attributeway-ame*nay\n"
"      Eturnray uetray ifway oneway ofway ethay amednay attributesway isway "
"esentpray, alsefay otherwiseway.\n"
"      Enwhay etsay ithway SETF, updatesway ethay aceplay Attributesway "
"ettingsay orway earingclay ethay\n"
"      ecifiedspay attributesway.\n"
"\n"
"    NAME-attributesway attributeway-ame*nay\n"
"      Eturnray away etsay ofway ethay amednay attributesway."

#: src/compiler/macros.lisp
msgid ""
"Returns the union of all the sets of boolean attributes which are its\n"
"  arguments."
msgstr ""
"Eturnsray ethay unionway ofway allway ethay etssay ofway ooleanbay "
"attributesway ichwhay areway itsway\n"
"  argumentsway."

#: src/compiler/macros.lisp
msgid ""
"Returns the intersection of all the sets of boolean attributes which are "
"its\n"
"  arguments."
msgstr ""
"Eturnsray ethay intersectionway ofway allway ethay etssay ofway ooleanbay "
"attributesway ichwhay areway itsway\n"
"  argumentsway."

#: src/compiler/macros.lisp
msgid ""
"Returns true if the attributes present in Attr1 are indentical to those in\n"
"  Attr2."
msgstr ""
"Eturnsray uetray ifway ethay attributesway esentpray inway Attrway1 areway "
"indenticalway otay osethay inway\n"
"  Attrway2."

#: src/compiler/macros.lisp
msgid "~S is not the name of an event."
msgstr "~S isway otnay ethay amenay ofway anway eventway."

#: src/compiler/macros.lisp
msgid "Return the number of times that Event has happened."
msgstr ""
"Eturnray ethay umbernay ofway imestay atthay Eventway ashay appenedhay."

#: src/compiler/macros.lisp
msgid ""
"Return the function that is called when Event happens.  If this is null,\n"
"  there is no action.  The function is passed the node to which the event\n"
"  happened, or NIL if there is no relevant node.  This may be set with SETF."
msgstr ""
"Eturnray ethay unctionfay atthay isway alledcay enwhay Eventway appenshay.  "
"Ifway isthay isway ullnay,\n"
"  erethay isway onay actionway.  Ethay unctionfay isway assedpay ethay "
"odenay otay ichwhay ethay eventway\n"
"  appenedhay, orway NIL ifway erethay isway onay elevantray odenay.  Isthay "
"aymay ebay etsay ithway SETF."

#: src/compiler/macros.lisp
msgid ""
"Return the non-negative integer which represents the level of significance\n"
"  of the event Name.  This is used to determine whether to print a message "
"when\n"
"  the event happens.  This may be set with SETF."
msgstr ""
"Eturnray ethay onnay-egativenay integerway ichwhay epresentsray ethay "
"evellay ofway ignificancesay\n"
"  ofway ethay eventway Amenay.  Isthay isway usedway otay etermineday "
"etherwhay otay intpray away essagemay enwhay\n"
"  ethay eventway appenshay.  Isthay aymay ebay etsay ithway SETF."

#: src/compiler/macros.lisp
msgid ""
"Defevent Name Description\n"
"  Define a new kind of event.  Name is a symbol which names the event and\n"
"  Description is a string which describes the event.  Level (default 0) is "
"the\n"
"  level of significance associated with this event; it is used to determine\n"
"  whether to print a Note when the event happens."
msgstr ""
"Efeventday Amenay Escriptionday\n"
"  Efineday away ewnay indkay ofway eventway.  Amenay isway away ymbolsay "
"ichwhay amesnay ethay eventway andway\n"
"  Escriptionday isway away ingstray ichwhay escribesday ethay eventway.  "
"Evellay (efaultday 0) isway ethay\n"
"  evellay ofway ignificancesay associatedway ithway isthay eventway; itway "
"isway usedway otay etermineday\n"
"  etherwhay otay intpray away Otenay enwhay ethay eventway appenshay."

#: src/compiler/macros.lisp
msgid ""
"This variable is a non-negative integer specifying the lowest level of\n"
"  event that will print a Note when it occurs."
msgstr ""
"Isthay ariablevay isway away onnay-egativenay integerway ecifyingspay ethay "
"owestlay evellay ofway\n"
"  eventway atthay illway intpray away Otenay enwhay itway occursway."

#: src/compiler/macros.lisp
msgid ""
"Event Name Node\n"
"  Note that the event with the specified Name has happened.  Node is "
"evaluated\n"
"  to determine the node to which the event happened."
msgstr ""
"Eventway Amenay Odenay\n"
"  Otenay atthay ethay eventway ithway ethay ecifiedspay Amenay ashay "
"appenedhay.  Odenay isway evaluatedway\n"
"  otay etermineday ethay odenay otay ichwhay ethay eventway appenedhay."

#: src/compiler/macros.lisp
msgid ""
"Print a listing of events and their counts, sorted by the count.  Events\n"
"  that happened fewer than Min-Count times will not be printed.  Stream is "
"the\n"
"  stream to write to."
msgstr ""
"Intpray away istinglay ofway eventsway andway eirthay ountscay, ortedsay "
"ybay ethay ountcay.  Eventsway\n"
"  atthay appenedhay ewerfay anthay Inmay-Ountcay imestay illway otnay ebay "
"intedpray.  Eamstray isway ethay\n"
"  eamstray otay itewray otay."

#: src/compiler/macros.lisp
msgid ""
"Find Element in a null-terminated List linked by the accessor function\n"
"  Next.  Key, Test and Test-Not are the same as for generic sequence\n"
"  functions."
msgstr ""
"Indfay Elementway inway away ullnay-erminatedtay Istlay inkedlay ybay ethay "
"accessorway unctionfay\n"
"  Extnay.  Eykay, Esttay andway Esttay-Otnay areway ethay amesay asway orfay "
"enericgay equencesay\n"
"  unctionsfay."

#: src/compiler/debug.lisp src/compiler/pack.lisp src/compiler/represent.lisp
#: src/compiler/copyprop.lisp src/compiler/life.lisp src/compiler/macros.lisp
msgid "Silly to supply both :Test and :Test-Not."
msgstr "Illysay otay upplysay othbay :Esttay andway :Esttay-Otnay."

#: src/compiler/macros.lisp
msgid ""
"Return the position of Element (or NIL if absent) in a null-terminated List\n"
"  linked by the accessor function Next.  Key, Test and Test-Not are the same "
"as\n"
"  for generic sequence functions."
msgstr ""
"Eturnray ethay ositionpay ofway Elementway (orway NIL ifway absentway) inway "
"away ullnay-erminatedtay Istlay\n"
"  inkedlay ybay ethay accessorway unctionfay Extnay.  Eykay, Esttay andway "
"Esttay-Otnay areway ethay amesay asway\n"
"  orfay enericgay equencesay unctionsfay."

#: src/compiler/macros.lisp
msgid ""
"Map Function over the elements in a null-terminated List linked by the\n"
"  accessor function Next, returning a list of the results."
msgstr ""
"Apmay Unctionfay overway ethay elementsway inway away ullnay-erminatedtay "
"Istlay inkedlay ybay ethay\n"
"  accessorway unctionfay Extnay, eturningray away istlay ofway ethay "
"esultsray."

#: src/compiler/macros.lisp
msgid ""
"Deletef-In Next Place Item\n"
"  Delete Item from a null-terminated list linked by the accessor function "
"Next\n"
"  that is stored in Place.  Item must appear exactly once in the list."
msgstr ""
"Eletefday-Inway Extnay Aceplay Itemway\n"
"  Eleteday Itemway omfray away ullnay-erminatedtay istlay inkedlay ybay "
"ethay accessorway unctionfay Extnay\n"
"  atthay isway toredsay inway Aceplay.  Itemway ustmay appearway exactlyway "
"onceway inway ethay istlay."

#: src/compiler/macros.lisp
msgid ""
"Push Item onto a list linked by the accessor function Next that is stored "
"in\n"
"  Place."
msgstr ""
"Ushpay Itemway ontoway away istlay inkedlay ybay ethay accessorway "
"unctionfay Extnay atthay isway toredsay inway\n"
"  Aceplay."

#: src/compiler/macros.lisp
msgid "Redefining modular version ~S of ~S for width ~S."
msgstr "Edefiningray odularmay ersionvay ~S ofway ~S orfay idthway ~S."

#: src/compiler/macros.lisp
msgid ""
"Lambda list keyword ~S is not supported for ~\n"
"              modular function lambda lists."
msgstr ""
"Ambdalay istlay eywordkay ~S isway otnay upportedsay orfay ~\n"
"              odularmay unctionfay ambdalay istslay."

#: src/compiler/generic/vm-macs.lisp
msgid "No more slots can follow a :rest-p slot."
msgstr "Onay oremay otsslay ancay ollowfay away :estray-p otslay."

#: src/compiler/generic/vm-macs.lisp
msgid ""
"Number of slots used by each ~S~\n"
"\t\t\t\t  ~@[~* including the header~]."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway ~S~\n"
"\t\t\t\t  ~@[~* includingway ethay eaderhay~]."

#: src/compiler/backend.lisp
msgid ""
"Machine specific support routine ~S ~\n"
"\t\t\t\t  undefined for ~S"
msgstr ""
"Achinemay ecificspay upportsay outineray ~S ~\n"
"\t\t\t\t  undefinedway orfay ~S"

#: src/compiler/backend.lisp
msgid "Unknown VM support routine: ~A"
msgstr "Unknownway VM upportsay outineray: ~Away"

#: src/compiler/backend.lisp
msgid "The backend for the machine we are running on. Do not change this."
msgstr ""
"Ethay ackendbay orfay ethay achinemay eway areway unningray onway. Oday "
"otnay angechay isthay."

#: src/compiler/backend.lisp
msgid "The backend we are attempting to compile."
msgstr "Ethay ackendbay eway areway attemptingway otay ompilecay."

#: src/compiler/backend.lisp
msgid "The backend we are using to compile with."
msgstr "Ethay ackendbay eway areway usingway otay ompilecay ithway."

#: src/compiler/backend.lisp
msgid "Compute the *FEATURES* list to use with BACKEND."
msgstr "Omputecay ethay *FEATURES* istlay otay useway ithway BACKEND."

#: src/compiler/backend.lisp
msgid ""
"Same as EXT:FEATUREP, except use the features found in *TARGET-BACKEND*."
msgstr ""
"Amesay asway EXT:FEATUREP, exceptway useway ethay eaturesfay oundfay inway "
"*TARGET-BACKEND*."

#: src/compiler/backend.lisp
msgid "Same as EXT:FEATUREP, except use the features found in *BACKEND*."
msgstr ""
"Amesay asway EXT:FEATUREP, exceptway useway ethay eaturesfay oundfay inway "
"*BACKEND*."

#: src/compiler/backend.lisp
msgid ""
"Same as EXT:FEATUREP, except use the features found in *NATIVE-BACKEND*."
msgstr ""
"Amesay asway EXT:FEATUREP, exceptway useway ethay eaturesfay oundfay inway "
"*NATIVE-BACKEND*."

#: src/compiler/generic/objdef.lisp
msgid "Number of bits at the low end of a pointer used for type information."
msgstr ""
"Umbernay ofway itsbay atway ethay owlay endway ofway away ointerpay usedway "
"orfay ypetay informationway."

#: src/compiler/generic/objdef.lisp
msgid "Mask to extract the low tag bits from a pointer."
msgstr "Askmay otay extractway ethay owlay agtay itsbay omfray away ointerpay."

#: src/compiler/generic/objdef.lisp
msgid ""
"Exclusive upper bound on the value of the low tag bits from a\n"
"  pointer."
msgstr ""
"Exclusiveway upperway oundbay onway ethay aluevay ofway ethay owlay agtay "
"itsbay omfray away\n"
"  ointerpay."

#: src/compiler/generic/objdef.lisp
msgid "Number of bits used in the header word of a data block for typeing."
msgstr ""
"Umbernay ofway itsbay usedway inway ethay eaderhay ordway ofway away ataday "
"ockblay orfay ypeingtay."

#: src/compiler/generic/objdef.lisp
msgid "Mask to extract the type from a header word."
msgstr "Askmay otay extractway ethay ypetay omfray away eaderhay ordway."

#: src/compiler/generic/objdef.lisp
msgid "most-positive-fixnum in the target architecture."
msgstr "ostmay-ositivepay-ixnumfay inway ethay argettay architectureway."

#: src/compiler/generic/objdef.lisp
msgid "most-negative-fixnum in the target architecture."
msgstr "ostmay-egativenay-ixnumfay inway ethay argettay architectureway."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each CONS."
msgstr "Umbernay ofway otsslay usedway ybay eachway CONS."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each RATIO including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway RATIO includingway ethay "
"eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each SINGLE-FLOAT including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway SINGLE-FLOAT includingway ethay "
"eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each DOUBLE-FLOAT including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway DOUBLE-FLOAT includingway ethay "
"eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each COMPLEX including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway COMPLEX includingway ethay "
"eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each FDEFN including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway FDEFN includingway ethay "
"eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each VALUE-CELL including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway VALUE-CELL includingway ethay "
"eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each SAP including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway SAP includingway ethay eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each WEAK-POINTER including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway WEAK-POINTER includingway ethay "
"eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each SCAVENGER-HOOK including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway SCAVENGER-HOOK includingway "
"ethay eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each BINDING."
msgstr "Umbernay ofway otsslay usedway ybay eachway BINDING."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each UNWIND-BLOCK."
msgstr "Umbernay ofway otsslay usedway ybay eachway UNWIND-BLOCK."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each CATCH-BLOCK."
msgstr "Umbernay ofway otsslay usedway ybay eachway CATCH-BLOCK."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each SYMBOL including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway SYMBOL includingway ethay "
"eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each COMPLEX-SINGLE-FLOAT including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway COMPLEX-SINGLE-FLOAT "
"includingway ethay eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each COMPLEX-DOUBLE-FLOAT including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway COMPLEX-DOUBLE-FLOAT "
"includingway ethay eaderhay."

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each DOUBLE-DOUBLE-FLOAT including the header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway DOUBLE-DOUBLE-FLOAT includingway "
"ethay eaderhay."

#: src/compiler/generic/objdef.lisp
msgid ""
"Number of slots used by each COMPLEX-DOUBLE-DOUBLE-FLOAT including the "
"header."
msgstr ""
"Umbernay ofway otsslay usedway ybay eachway COMPLEX-DOUBLE-DOUBLE-FLOAT "
"includingway ethay eaderhay."

#: src/compiler/generic/interr.lisp
msgid "Unknown internal error: ~S"
msgstr "Unknownway internalway errorway: ~S"

#: src/compiler/bit-util.lisp
msgid "local-tn-limit not a vm:word-bits multiple."
msgstr "ocallay-ntay-imitlay otnay away mvay:ordway-itsbay ultiplemay."

#: src/compiler/pack.lisp src/compiler/life.lisp src/compiler/bit-util.lisp
msgid ""
"Argument and/or result bit arrays not the same length:~\n"
"\t\t\t ~%  ~S~%  ~S  ~%  ~S"
msgstr ""
"Argumentway andway/orway esultray itbay arraysway otnay ethay amesay "
"engthlay:~\n"
"\t\t\t ~%  ~S~%  ~S  ~%  ~S"

#: src/compiler/ctype.lisp
msgid "Function called with ~R argument, but wants exactly ~R."
msgid_plural "Function called with ~R arguments, but wants exactly ~R."
msgstr[0] ""
"Unctionfay alledcay ithway ~R argumentway, utbay antsway exactlyway ~R."
msgstr[1] ""
"Unctionfay alledcay ithway ~R argumentsway, utbay antsway exactlyway ~R."

#: src/compiler/ctype.lisp
msgid "Function called with ~R argument, but wants at least ~R."
msgid_plural "Function called with ~R arguments, but wants at least ~R."
msgstr[0] ""
"Unctionfay alledcay ithway ~R argumentway, utbay antsway atway eastlay ~R."
msgstr[1] ""
"Unctionfay alledcay ithway ~R argumentsway, utbay antsway atway eastlay ~R."

#: src/compiler/ctype.lisp
msgid "Function called with ~R argument, but wants at most ~R."
msgid_plural "Function called with ~R arguments, but wants at most ~R."
msgstr[0] ""
"Unctionfay alledcay ithway ~R argumentway, utbay antsway atway ostmay ~R."
msgstr[1] ""
"Unctionfay alledcay ithway ~R argumentsway, utbay antsway atway ostmay ~R."

#: src/compiler/ctype.lisp
msgid "Function has an odd number of arguments in the keyword portion."
msgstr ""
"Unctionfay ashay anway oddway umbernay ofway argumentsway inway ethay "
"eywordkay ortionpay."

#: src/compiler/ctype.lisp
msgid "Can't tell whether the result is a ~S."
msgstr "Ancay't elltay etherwhay ethay esultray isway away ~S."

#: src/compiler/ctype.lisp
msgid "The result is a ~S, not a ~S."
msgstr "Ethay esultray isway away ~S, otnay away ~S."

#: src/compiler/ctype.lisp
msgid "Can't tell whether the ~:R argument is a ~S."
msgstr "Ancay't elltay etherwhay ethay ~:R argumentway isway away ~S."

#: src/compiler/ctype.lisp
msgid "The ~:R argument is a ~S, not a ~S."
msgstr "Ethay ~:R argumentway isway away ~S, otnay away ~S."

#: src/compiler/ctype.lisp
msgid "The ~:R argument never returns a value."
msgstr "Ethay ~:R argumentway evernay eturnsray away aluevay."

#: src/compiler/ctype.lisp
msgid "The ~:R argument is not a constant."
msgstr "Ethay ~:R argumentway isway otnay away onstantcay."

#: src/compiler/ctype.lisp
msgid ""
"Can't tell whether the ~:R argument is a ~\n"
"\t\t             constant ~S:~%  ~S"
msgstr ""
"Ancay't elltay etherwhay ethay ~:R argumentway isway away ~\n"
"\t\t             onstantcay ~S:~%  ~S"

#: src/compiler/ctype.lisp
msgid "The ~:R argument is not a constant ~S:~%  ~S"
msgstr "Ethay ~:R argumentway isway otnay away onstantcay ~S:~%  ~S"

#: src/compiler/ctype.lisp
msgid "The ~:R argument (in keyword position) is not a constant."
msgstr ""
"Ethay ~:R argumentway (inway eywordkay ositionpay) isway otnay away "
"onstantcay."

#: src/compiler/ctype.lisp
msgid "The value of ~S is not a constant"
msgstr "Ethay aluevay ofway ~S isway otnay away onstantcay"

#: src/compiler/ctype.lisp
msgid "~S is not a known argument keyword."
msgstr "~S isway otnay away nownkay argumentway eywordkay."

#: src/compiler/ctype.lisp
msgid "Function previously called with ~R argument, but wants at least ~R."
msgid_plural ""
"Function previously called with ~R arguments, but wants at least ~R."
msgstr[0] ""
"Unctionfay eviouslypray alledcay ithway ~R argumentway, utbay antsway atway "
"eastlay ~R."
msgstr[1] ""
"Unctionfay eviouslypray alledcay ithway ~R argumentsway, utbay antsway atway "
"eastlay ~R."

#: src/compiler/ctype.lisp
msgid "Function previously called with ~R argument, but wants at most ~R."
msgid_plural ""
"Function previously called with ~R arguments, but wants at most ~R."
msgstr[0] ""
"Unctionfay eviouslypray alledcay ithway ~R argumentway, utbay antsway atway "
"ostmay ~R."
msgstr[1] ""
"Unctionfay eviouslypray alledcay ithway ~R argumentsway, utbay antsway atway "
"ostmay ~R."

#: src/compiler/ctype.lisp
msgid ""
"Function previously called with an odd number of arguments in ~\n"
"\t      the keyword portion."
msgstr ""
"Unctionfay eviouslypray alledcay ithway anway oddway umbernay ofway "
"argumentsway inway ~\n"
"\t      ethay eywordkay ortionpay."

#: src/compiler/ctype.lisp
msgid "Can't tell whether previous ~? argument type ~S is a ~S."
msgstr ""
"Ancay't elltay etherwhay eviouspray ~? argumentway ypetay ~S isway away ~S."

#: src/compiler/ctype.lisp
msgid "~:(~?~) argument should be a ~S but was a ~S in a previous call."
msgstr ""
"~:(~?~) argumentway ouldshay ebay away ~S utbay asway away ~S inway away "
"eviouspray allcay."

#: src/compiler/ctype.lisp
msgid "Function previously called with unknown argument keyword ~S."
msgstr ""
"Unctionfay eviouslypray alledcay ithway unknownway argumentway eywordkay ~S."

#: src/compiler/ctype.lisp
msgid ""
"Definition's declared type for variable ~A:~%  ~S~@\n"
"\t\t   conflicts with this type from ~A:~%  ~S"
msgstr ""
"Efinitionday's eclaredday ypetay orfay ariablevay ~Away:~%  ~S~@\n"
"\t\t   onflictscay ithway isthay ypetay omfray ~Away:~%  ~S"

#. updated to allow better translations.
#: src/compiler/ctype.lisp
msgid "Definition has ~R ~A arg, but ~A has ~R."
msgid_plural "Definition has ~R ~A args, but ~A has ~R."
msgstr[0] "Efinitionday ashay ~R ~Away argway, utbay ~Away ashay ~R."
msgstr[1] "Efinitionday ashay ~R ~Away argsway, utbay ~Away ashay ~R."

#: src/compiler/ctype.lisp
msgid "fixed"
msgstr "ixedfay"

#: src/compiler/ctype.lisp
msgid "optional"
msgstr "optionalway"

#: src/compiler/ctype.lisp
msgid ""
"Definition ~:[doesn't have~;has~] ~A, but ~\n"
"\t\t~A ~:[doesn't~;does~]."
msgstr ""
"Efinitionday ~:[oesnday't avehay~;ashay~] ~Away, utbay ~\n"
"\t\t~Away ~:[oesnday't~;oesday~]."

#: src/compiler/ctype.lisp
msgid "keyword args"
msgstr "eywordkay argsway"

#: src/compiler/ctype.lisp
msgid "rest args"
msgstr "estray argsway"

#: src/compiler/ctype.lisp
msgid "Defining a ~S keyword not present in ~A."
msgstr "Efiningday away ~S eywordkay otnay esentpray inway ~Away."

#: src/compiler/ctype.lisp
msgid "Definition lacks the ~S keyword present in ~A."
msgstr "Efinitionday ackslay ethay ~S eywordkay esentpray inway ~Away."

#: src/compiler/ctype.lisp
msgid "Definition has no ~A, but the ~A did."
msgstr "Efinitionday ashay onay ~Away, utbay ethay ~Away idday."

#: src/compiler/ctype.lisp
msgid "optional args"
msgstr "optionalway argsway"

#: src/compiler/ctype.lisp
msgid "rest arg"
msgstr "estray argway"

#: src/compiler/ctype.lisp
msgid "Definition has ~R arg, but the ~A has ~R."
msgid_plural "Definition has ~R args, but the ~A has ~R."
msgstr[0] "Efinitionday ashay ~R argway, utbay ethay ~Away ashay ~R."
msgstr[1] "Efinitionday ashay ~R argsway, utbay ethay ~Away ashay ~R."

#: src/compiler/ctype.lisp
msgid ""
"The result type from ~A:~%  ~S~@\n"
"\t   conflicts with the definition's result type assertion:~%  ~S"
msgstr ""
"Ethay esultray ypetay omfray ~Away:~%  ~S~@\n"
"\t   onflictscay ithway ethay efinitionday's esultray ypetay assertionway:"
"~%  ~S"

#: src/compiler/ctype.lisp
msgid ""
"Assignment to argument: ~S~%  ~\n"
"\t\t\t       prevents use of assertion from function ~\n"
"\t\t\t       type ~A:~%  ~S~%"
msgstr ""
"Assignmentway otay argumentway: ~S~%  ~\n"
"\t\t\t       eventspray useway ofway assertionway omfray unctionfay ~\n"
"\t\t\t       ypetay ~Away:~%  ~S~%"

#: src/compiler/ctype.lisp
msgid "previous declaration"
msgstr "eviouspray eclarationday"

#: src/compiler/vmdef.lisp
msgid "~S is not a defined template."
msgstr "~S isway otnay away efinedday emplatetay."

#: src/compiler/vmdef.lisp
msgid "~S is not a defined storage class."
msgstr "~S isway otnay away efinedday toragesay assclay."

#: src/compiler/vmdef.lisp
msgid "~S is not a defined storage base."
msgstr "~S isway otnay away efinedday toragesay asebay."

#: src/compiler/meta-vmdef.lisp src/compiler/vmdef.lisp
msgid "~S is not a defined primitive type."
msgstr "~S isway otnay away efinedday imitivepray ypetay."

#: src/compiler/vmdef.lisp
msgid ""
"NOTE-THIS-LOCATION VOP Kind\n"
"  Note that the current code location is an interesting (to the debugger)\n"
"  location of the specified Kind.  VOP is the VOP responsible for this "
"code.\n"
"  This VOP must specify some non-null :SAVE-P value (perhaps :COMPUTE-ONLY) "
"so\n"
"  that the live set is computed."
msgstr ""
"NOTE-THIS-LOCATION VOP Indkay\n"
"  Otenay atthay ethay urrentcay odecay ocationlay isway anway interestingway "
"(otay ethay ebuggerday)\n"
"  ocationlay ofway ethay ecifiedspay Indkay.  VOP isway ethay VOP "
"esponsibleray orfay isthay odecay.\n"
"  Isthay VOP ustmay ecifyspay omesay onnay-ullnay :SAVE-P aluevay "
"(erhapspay :COMPUTE-ONLY) osay\n"
"  atthay ethay ivelay etsay isway omputedcay."

#: src/compiler/vmdef.lisp
msgid ""
"NOTE-NEXT-INSTRUCTION VOP Kind\n"
"   Similar to NOTE-THIS-LOCATION, except the use the location of the next\n"
"   instruction for the code location, wherever the scheduler decided to put\n"
"   it."
msgstr ""
"NOTE-NEXT-INSTRUCTION VOP Indkay\n"
"   Imilarsay otay NOTE-THIS-LOCATION, exceptway ethay useway ethay "
"ocationlay ofway ethay extnay\n"
"   instructionway orfay ethay odecay ocationlay, ereverwhay ethay "
"edulerschay ecidedday otay utpay\n"
"   itway."

#: src/compiler/meta-vmdef.lisp
msgid ""
"Define-Storage-Base Name Kind {Key Value}*\n"
"  Define a storage base having the specified Name.  Kind may be :Finite,\n"
"  :Unbounded or :Non-Packed.  The following keywords are legal:\n"
"\n"
"  :Size <Size>\n"
"      Specify the number of locations in a :Finite SB or the initial size of "
"a\n"
"      :Unbounded SB."
msgstr ""
"Efineday-Toragesay-Asebay Amenay Indkay {Eykay Aluevay}*\n"
"  Efineday away toragesay asebay avinghay ethay ecifiedspay Amenay.  Indkay "
"aymay ebay :Initefay,\n"
"  :Unboundedway orway :Onnay-Ackedpay.  Ethay ollowingfay eywordskay areway "
"egallay:\n"
"\n"
"  :Izesay <Izesay>\n"
"      Ecifyspay ethay umbernay ofway ocationslay inway away :Initefay SB "
"orway ethay initialway izesay ofway away\n"
"      :Unboundedway SB."

#: src/compiler/meta-vmdef.lisp
msgid "Size specification meaningless in a ~S SB."
msgstr "Izesay ecificationspay eaninglessmay inway away ~S SB."

#: src/compiler/meta-vmdef.lisp
msgid "Size not specified in a ~S SB."
msgstr "Izesay otnay ecifiedspay inway away ~S SB."

#: src/compiler/meta-vmdef.lisp
msgid ""
"Define-Storage-Class Name Number Storage-Base {Key Value}*\n"
"  Define a storage class Name that uses the named Storage-Base.  Number is "
"a\n"
"  small, non-negative integer that is used as an alias.  The following\n"
"  keywords are defined:\n"
"\n"
"  :Element-Size Size\n"
"      The size of objects in this SC in whatever units the SB uses.  This\n"
"      defaults to 1.\n"
"\n"
"  :Alignment Size\n"
"      The alignment restrictions for this SC.  TNs will only be allocated "
"at\n"
"      offsets that are an even multiple of this number.  Defaults to 1.\n"
"\n"
"  :Locations (Location*)\n"
"      If the SB is :Finite, then this is a list of the offsets within the "
"SB\n"
"      that are in this SC.\n"
"\n"
"  :Reserve-Locations (Location*)\n"
"      A subset of the Locations that the register allocator should try to\n"
"      reserve for operand loading (instead of to hold variable values.)\n"
"\n"
"  :Save-P {T | NIL}\n"
"      If T, then values stored in this SC must be saved in one of the\n"
"      non-save-p :Alternate-SCs across calls.\n"
"\n"
"  :Alternate-SCs (SC*)\n"
"      Indicates other SCs that can be used to hold values from this SC "
"across\n"
"      calls or when storage in this SC is exhausted.  The SCs should be\n"
"      specified in order of decreasing \"goodness\".  There must be at "
"least\n"
"      one SC in an unbounded SB, unless this SC is only used for restricted "
"or\n"
"      wired TNs.\n"
"\n"
"  :Constant-SCs (SC*)\n"
"      A list of the names of all the constant SCs that can be loaded into "
"this\n"
"      SC by a move function."
msgstr ""
"Efineday-Toragesay-Assclay Amenay Umbernay Toragesay-Asebay {Eykay Aluevay}"
"*\n"
"  Efineday away toragesay assclay Amenay atthay usesway ethay amednay "
"Toragesay-Asebay.  Umbernay isway away\n"
"  mallsay, onnay-egativenay integerway atthay isway usedway asway anway "
"aliasway.  Ethay ollowingfay\n"
"  eywordskay areway efinedday:\n"
"\n"
"  :Elementway-Izesay Izesay\n"
"      Ethay izesay ofway objectsway inway isthay SC inway ateverwhay "
"unitsway ethay SB usesway.  Isthay\n"
"      efaultsday otay 1.\n"
"\n"
"  :Alignmentway Izesay\n"
"      Ethay alignmentway estrictionsray orfay isthay SC.  Nstay illway "
"onlyway ebay allocatedway atway\n"
"      offsetsway atthay areway anway evenway ultiplemay ofway isthay "
"umbernay.  Efaultsday otay 1.\n"
"\n"
"  :Ocationslay (Ocation*Lay)\n"
"      Ifway ethay SB isway :Initefay, enthay isthay isway away istlay ofway "
"ethay offsetsway ithinway ethay SB\n"
"      atthay areway inway isthay SC.\n"
"\n"
"  :Eserveray-Ocationslay (Ocation*Lay)\n"
"      Away ubsetsay ofway ethay Ocationslay atthay ethay egisterray "
"allocatorway ouldshay ytray otay\n"
"      eserveray orfay operandway oadinglay (insteadway ofway otay oldhay "
"ariablevay aluesvay.)\n"
"\n"
"  :Avesay-P {T | NIL}\n"
"      Ifway T, enthay aluesvay toredsay inway isthay SC ustmay ebay avedsay "
"inway oneway ofway ethay\n"
"      onnay-avesay-p :Alternateway-Sscay acrossway allscay.\n"
"\n"
"  :Alternateway-Sscay (*Scay)\n"
"      Indicatesway otherway Sscay atthay ancay ebay usedway otay oldhay "
"aluesvay omfray isthay SC acrossway\n"
"      allscay orway enwhay toragesay inway isthay SC isway exhaustedway.  "
"Ethay Sscay ouldshay ebay\n"
"      ecifiedspay inway orderway ofway ecreasingday \"oodnessgay\".  Erethay "
"ustmay ebay atway eastlay\n"
"      oneway SC inway anway unboundedway SB, unlessway isthay SC isway "
"onlyway usedway orfay estrictedray orway\n"
"      iredway Nstay.\n"
"\n"
"  :Onstantcay-Sscay (*Scay)\n"
"      Away istlay ofway ethay amesnay ofway allway ethay onstantcay Sscay "
"atthay ancay ebay oadedlay intoway isthay\n"
"      SC ybay away ovemay unctionfay."

#: src/compiler/meta-vmdef.lisp
msgid "Alignment is not a power of two: ~S"
msgstr "Alignmentway isway otnay away owerpay ofway wotay: ~S"

#: src/compiler/meta-vmdef.lisp
msgid "SC element ~D out of bounds for ~S."
msgstr "SC elementway ~D outway ofway oundsbay orfay ~S."

#: src/compiler/meta-vmdef.lisp
msgid ":Locations is meaningless in a ~S SB."
msgstr ":Ocationslay isway eaninglessmay inway away ~S SB."

#: src/compiler/meta-vmdef.lisp
msgid "Reserve-Locations not a subset of Locations."
msgstr "Eserveray-Ocationslay otnay away ubsetsay ofway Ocationslay."

#: src/compiler/meta-vmdef.lisp
msgid "Meaningless to specify alternate or constant SCs in a ~S SB."
msgstr ""
"Eaninglessmay otay ecifyspay alternateway orway onstantcay Sscay inway away "
"~S SB."

#: src/compiler/meta-vmdef.lisp
msgid ""
"Define-Move-Function (Name Cost) lambda-list ({(From-SC*) (To-SC*)}*) form*\n"
"  Define the function Name and note it as the function used for moving "
"operands\n"
"  from the From-SCs to the To-SCs.  Cost is the cost of this move "
"operation.\n"
"  The function is called with three arguments: the VOP (for context), and "
"the\n"
"  source and destination TNs.  An ASSEMBLE form is wrapped around the body.\n"
"  All uses of DEFINE-MOVE-FUNCTION should be compiled before any uses of\n"
"  DEFINE-VOP."
msgstr ""
"Efineday-Ovemay-Unctionfay (Amenay Ostcay) ambdalay-istlay ({(Omfray-*Scay) "
"(Otay-*Scay)}*) orm*fay\n"
"  Efineday ethay unctionfay Amenay andway otenay itway asway ethay "
"unctionfay usedway orfay ovingmay operandsway\n"
"  omfray ethay Omfray-Sscay otay ethay Otay-Sscay.  Ostcay isway ethay "
"ostcay ofway isthay ovemay operationway.\n"
"  Ethay unctionfay isway alledcay ithway reethay argumentsway: ethay VOP "
"(orfay ontextcay), andway ethay\n"
"  ourcesay andway estinationday Nstay.  Anway ASSEMBLE ormfay isway "
"appedwray aroundway ethay odybay.\n"
"  Allway usesway ofway DEFINE-MOVE-FUNCTION ouldshay ebay ompiledcay "
"eforebay anyway usesway ofway\n"
"  DEFINE-VOP."

#: src/compiler/meta-vmdef.lisp
msgid "Malformed SCs spec: ~S."
msgstr "Alformedmay Sscay ecspay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid ""
"Define-Move-VOP Name {:Move | :Move-Argument} {(From-SC*) (To-SC*)}*\n"
"  Make Name be the VOP used to move values in the specified From-SCs to the\n"
"  representation of the To-SCs.  If kind is :Move-Argument, then the VOP "
"takes\n"
"  an extra argument, which is the frame pointer of the frame to move into."
msgstr ""
"Efineday-Ovemay-VOP Amenay {:Ovemay | :Ovemay-Argumentway} {(Omfray-*Scay) "
"(Otay-*Scay)}*\n"
"  Akemay Amenay ebay ethay VOP usedway otay ovemay aluesvay inway ethay "
"ecifiedspay Omfray-Sscay otay ethay\n"
"  epresentationray ofway ethay Otay-Sscay.  Ifway indkay isway :Ovemay-"
"Argumentway, enthay ethay VOP akestay\n"
"  anway extraway argumentway, ichwhay isway ethay amefray ointerpay ofway "
"ethay amefray otay ovemay intoway."

#: src/compiler/meta-vmdef.lisp
msgid "Unknown kind ~S."
msgstr "Unknownway indkay ~S."

#: src/compiler/meta-vmdef.lisp
msgid ""
"Def-Primitive-Type Name (SC*) {Key Value}*\n"
"   Define a primitive type Name.  Each SC specifies a Storage Class that "
"values\n"
"   of this type may be allocated in.  The following keyword options are\n"
"   defined:\n"
"  \n"
"  :Type\n"
"      The type descriptor for the Lisp type that is equivalent to this type\n"
"      (defaults to Name.)"
msgstr ""
"Efday-Imitivepray-Ypetay Amenay (*Scay) {Eykay Aluevay}*\n"
"   Efineday away imitivepray ypetay Amenay.  Eachway SC ecifiesspay away "
"Toragesay Assclay atthay aluesvay\n"
"   ofway isthay ypetay aymay ebay allocatedway inway.  Ethay ollowingfay "
"eywordkay optionsway areway\n"
"   efinedday:\n"
"  \n"
"  :Ypetay\n"
"      Ethay ypetay escriptorday orfay ethay Isplay ypetay atthay isway "
"equivalentway otay isthay ypetay\n"
"      (efaultsday otay Amenay.)"

#: src/compiler/meta-vmdef.lisp
msgid ""
"DEF-PRIMITIVE-TYPE-ALIAS Name Result\n"
"  Define name to be an alias for Result in VOP operand type restrictions."
msgstr ""
"DEF-PRIMITIVE-TYPE-ALIAS Amenay Esultray\n"
"  Efineday amenay otay ebay anway aliasway orfay Esultray inway VOP "
"operandway ypetay estrictionsray."

#: src/compiler/meta-vmdef.lisp
msgid ""
"Primitive-Type-VOP Vop (Kind*) Type*\n"
"  Annotate all the specified primitive Types with the named VOP under each "
"of\n"
"  the specified kinds:\n"
"\n"
"  :Check\n"
"      A one argument one result VOP that moves the argument to the result,\n"
"      checking that the value is of this type in the process."
msgstr ""
"Imitivepray-Ypetay-VOP Opvay (Ind*Kay) Ype*Tay\n"
"  Annotateway allway ethay ecifiedspay imitivepray Ypestay ithway ethay "
"amednay VOP underway eachway ofway\n"
"  ethay ecifiedspay indskay:\n"
"\n"
"  :Eckchay\n"
"      Away oneway argumentway oneway esultray VOP atthay ovesmay ethay "
"argumentway otay ethay esultray,\n"
"      eckingchay atthay ethay aluevay isway ofway isthay ypetay inway ethay "
"ocesspray."

#: src/compiler/meta-vmdef.lisp
msgid "Unknown kind: ~S."
msgstr "Unknownway indkay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Operand ~S isn't one of these kinds: ~S."
msgstr "Operandway ~S isnway't oneway ofway esethay indskay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "~S is not an operand to ~S."
msgstr "~S isway otnay anway operandway otay ~S."

#: src/compiler/meta-vmdef.lisp
msgid "~S is not the name of a defined VOP."
msgstr "~S isway otnay ethay amenay ofway away efinedday VOP."

#: src/compiler/meta-vmdef.lisp
msgid "~:R argument missing: ~S."
msgstr "~:R argumentway issingmay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Extra junk at end of ~S."
msgstr "Extraway unkjay atway endway ofway ~S."

#: src/compiler/meta-vmdef.lisp
msgid "~:R argument is not a ~S: ~S."
msgstr "~:R argumentway isway otnay away ~S: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Malformed time specifier: ~S."
msgstr "Alformedmay imetay ecifierspay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Unknown phase in time specifier: ~S."
msgstr "Unknownway asephay inway imetay ecifierspay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Cannot target a ~S operand: ~S."
msgstr "Annotcay argettay away ~S operandway: ~S."

#: src/compiler/debug-dump.lisp src/compiler/checkgen.lisp
#: src/compiler/ir1util.lisp src/compiler/meta-vmdef.lisp
msgid "Shouldn't happen?"
msgstr "Ouldnshay't appenhay?"

#: src/compiler/meta-vmdef.lisp
msgid ""
"No move function defined to ~:[save~;load~] SC ~S~\n"
"\t\t\t  ~:[to~;from~] from SC ~S."
msgstr ""
"Onay ovemay unctionfay efinedday otay ~:[avesay~;oadlay~] SC ~S~\n"
"\t\t\t  ~:[otay~;omfray~] omfray SC ~S."

#: src/compiler/meta-vmdef.lisp
msgid ""
"Can't tell whether to ~:[save~;load~] with ~S~@\n"
"\t\t\t\t or ~S when operand is in SC ~S."
msgstr ""
"Ancay't elltay etherwhay otay ~:[avesay~;oadlay~] ithway ~S~@\n"
"\t\t\t\t orway ~S enwhay operandway isway inway SC ~S."

#: src/compiler/meta-vmdef.lisp
msgid ""
"SC ~S has no alternate~:[~; or constant~] SCs, yet it is~@\n"
"\t          mentioned in the restriction for operand ~S."
msgstr ""
"SC ~S ashay onay alternateway~:[~; orway onstantcay~] Sscay, etyay itway "
"isway~@\n"
"\t          entionedmay inway ethay estrictionray orfay operandway ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Malformed operand specifier: ~S."
msgstr "Alformedmay operandway ecifierspay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "More operand isn't last: ~S."
msgstr "Oremay operandway isnway't astlay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Can only specify :FROM in a result: ~S"
msgstr "Ancay onlyway ecifyspay :FROM inway away esultray: ~S"

#: src/compiler/meta-vmdef.lisp
msgid "Can only specify :TO in an argument: ~S"
msgstr "Ancay onlyway ecifyspay :TO inway anway argumentway: ~S"

#: src/compiler/meta-vmdef.lisp
msgid "Unknown keyword in operand specifier: ~S."
msgstr "Unknownway eywordkay inway operandway ecifierspay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Cannot specify :TARGET in a :MORE operand."
msgstr "Annotcay ecifyspay :TARGET inway away :MORE operandway."

#: src/compiler/meta-vmdef.lisp
msgid "Cannot specify :LOAD-IF in a :MORE operand."
msgstr "Annotcay ecifyspay :LOAD-IF inway away :MORE operandway."

#: src/compiler/meta-vmdef.lisp
msgid "Malformed temporary spec: ~S."
msgstr "Alformedmay emporarytay ecspay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Malformed options list: ~S."
msgstr "Alformedmay optionsway istlay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Odd number of arguments in keyword options: ~S."
msgstr "Oddway umbernay ofway argumentsway inway eywordkay optionsway: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Temporary spec allocates no temps:~%  ~S"
msgstr "Emporarytay ecspay allocatesway onay empstay:~%  ~S"

#: src/compiler/meta-vmdef.lisp
msgid "Bad temporary name: ~S."
msgstr "Adbay emporarytay amenay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Must specify exactly one SC for a temporary."
msgstr "Ustmay ecifyspay exactlyway oneway SC orfay away emporarytay."

#: src/compiler/meta-vmdef.lisp
msgid "Unknown temporary option: ~S."
msgstr "Unknownway emporarytay optionway: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Temporary lifetime doesn't begin before it ends: ~S."
msgstr "Emporarytay ifetimelay oesnday't eginbay eforebay itway endsway: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Must specifiy :SC for all temporaries: ~S"
msgstr "Ustmay ecifiyspay :SC orfay allway emporariestay: ~S"

#: src/compiler/meta-vmdef.lisp
msgid "Malformed option specification: ~S."
msgstr "Alformedmay optionway ecificationspay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Unknown option specifier: ~S."
msgstr "Unknownway optionway ecifierspay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid ""
"No move function defined to move ~:[from~;to~] SC ~\n"
"\t              ~S~%~:[to~;from~] alternate or constant SC ~S."
msgstr ""
"Onay ovemay unctionfay efinedday otay ovemay ~:[omfray~;otay~] SC ~\n"
"\t              ~S~%~:[otay~;omfray~] alternateway orway onstantcay SC ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Bad thing to be a operand type: ~S."
msgstr "Adbay ingthay otay ebay away operandway ypetay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Bad PRIMITIVE-TYPE name in ~S: ~S"
msgstr "Adbay PRIMITIVE-TYPE amenay inway ~S: ~S"

#: src/compiler/meta-vmdef.lisp
msgid ""
"Can't include primitive-type ~\n"
"\t\t\t\t             alias ~S in a :OR restriction: ~S."
msgstr ""
"Ancay't includeway imitivepray-ypetay ~\n"
"\t\t\t\t             aliasway ~S inway away :OR estrictionray: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Can't :CONSTANT for a result."
msgstr "Ancay't :CONSTANT orfay away esultray."

#: src/compiler/meta-vmdef.lisp
msgid "Bad :CONSTANT argument type spec: ~S."
msgstr "Adbay :CONSTANT argumentway ypetay ecspay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid ""
"In the ~A ~:[result~;argument~] to VOP ~S,~@\n"
"\t            none of the SCs allowed by the operand type ~S can ~\n"
"\t\t    directly be loaded~@\n"
"\t\t    into any of the restriction's SCs:~%  ~S~:[~;~@\n"
"\t\t    [* type operand must allow T's SCs.]~]"
msgstr ""
"Inway ethay ~Away ~:[esultray~;argumentway~] otay VOP ~S,~@\n"
"\t            onenay ofway ethay Sscay allowedway ybay ethay operandway "
"ypetay ~S ancay ~\n"
"\t\t    irectlyday ebay oadedlay~@\n"
"\t\t    intoway anyway ofway ethay estrictionray's Sscay:~%  ~S~:[~;~@\n"
"\t\t    [* ypetay operandway ustmay allowway T's Sscay.]~]"

#: src/compiler/meta-vmdef.lisp
msgid ""
"~:[Result~;Argument~] ~A to VOP ~S~@\n"
"\t         has SC restriction ~S which is ~\n"
"\t\t not allowed by the operand type:~%  ~S"
msgstr ""
"~:[Esultray~;Argumentway~] ~Away otay VOP ~S~@\n"
"\t         ashay SC estrictionray ~S ichwhay isway ~\n"
"\t\t otnay allowedway ybay ethay operandway ypetay:~%  ~S"

#: src/compiler/meta-vmdef.lisp
msgid "Expected ~D ~:[result~;argument~] type: ~S."
msgid_plural "Expected ~D ~:[result~;argument~] types: ~S."
msgstr[0] "Expectedway ~D ~:[esultray~;argumentway~] ypetay: ~S."
msgstr[1] "Expectedway ~D ~:[esultray~;argumentway~] ypestay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "Can't use :CONSTANT on VOP more args."
msgstr "Ancay't useway :CONSTANT onway VOP oremay argsway."

#: src/compiler/meta-vmdef.lisp
msgid "Expected ~D variant values: ~S."
msgstr "Expectedway ~D ariantvay aluesvay: ~S."

#: src/compiler/meta-vmdef.lisp
#, fuzzy
msgid ""
"Define-VOP (Name [Inherits]) Spec*\n"
"  Define the symbol Name to be a Virtual OPeration in the compiler.  If\n"
"  specified, Inherits is the name of a VOP that we default unspecified\n"
"  information from.  Each Spec is a list beginning with a keyword "
"indicating\n"
"  the interpretation of the other forms in the Spec:\n"
"  \n"
"  :Args {(Name {Key Value}*)}*\n"
"  :Results {(Name {Key Value}*)}*\n"
"      The Args and Results are specifications of the operand TNs passed to "
"the\n"
"      VOP.  If there is an inherited VOP, any unspecified options are "
"defaulted\n"
"      from the inherited argument (or result) of the same name.  The "
"following\n"
"      operand options are defined: \n"
"\n"
"      :SCs (SC*)\n"
"\t  :SCs specifies good SCs for this operand.  Other SCs will be\n"
"\t  penalized according to move costs.  A load TN will be allocated if\n"
"\t  necessary, guaranteeing that the operand is always one of the\n"
"\t  specified SCs.\n"
"\n"
"      :Load-TN Load-Name\n"
"          Load-Name is bound to the load TN allocated for this operand, or "
"to\n"
"\t  NIL if no load TN was allocated.\n"
"\n"
"      :Load-If Expression\n"
"          Controls whether automatic operand loading is done.  Expression "
"is\n"
"\t  evaluated with the fixed operand TNs bound.  If Expression is true,\n"
"\t  then loading is done and the variable is bound to the load TN in\n"
"\t  the generator body.  Otherwise, loading is not done, and the variable\n"
"\t  is bound to the actual operand.\n"
"\n"
"      :More T-or-NIL\n"
"\t  If specified, Name is bound to the TN-Ref for the first argument or\n"
"\t  result following the fixed arguments or results.  A more operand must\n"
"\t  appear last, and cannot be targeted or restricted.\n"
"\n"
"      :Target Operand\n"
"\t  This operand is targeted to the named operand, indicating a desire to\n"
"\t  pack in the same location.  Not legal for results.\n"
"\n"
"      :From Time-Spec\n"
"      :To Time-Spec\n"
"\t  Specify the beginning or end of the operand's lifetime.  :From can\n"
"\t  only be used with results, and :To only with arguments.  The default\n"
"\t  for the N'th argument/result is (:ARGUMENT N)/(:RESULT N).  (The\n"
"          first argument/result is number 0.) These options are necessary\n"
"          primarily when operands are read or written out of order.\n"
"   \n"
"  :Conditional\n"
"      This is used in place of :RESULTS with conditional branch VOPs.  "
"There\n"
"      are no result values: the result is a transfer of control.  The "
"target\n"
"      label is passed as the first :INFO arg.  The second :INFO arg is true "
"if\n"
"      the sense of the test should be negated.  A side-effect is to set the\n"
"      PREDICATE attribute for functions in the :TRANSLATE option.\n"
"  \n"
"  :Temporary ({Key Value}*) Name*\n"
"      Allocate a temporary TN for each Name, binding that variable to the "
"TN\n"
"      within the body of the generators.  In addition to :Target (which is \n"
"      is the same as for operands), the following options are\n"
"      defined:\n"
"\n"
"      :SC SC-Name\n"
"      :Offset SB-Offset\n"
"\t  Force the temporary to be allocated in the specified SC with the\n"
"\t  specified offset.  Offset is evaluated at macroexpand time.  If\n"
"\t  Offset is emitted, the register allocator chooses a free location in\n"
"\t  SC.  If both SC and Offset are omitted, then the temporary is packed\n"
"\t  according to its primitive type.\n"
"\n"
"      :From Time-Spec\n"
"      :To Time-Spec\n"
"\t  Similar to the argument/result option, this specifies the start and\n"
"\t  end of the temporarys' lives.  The defaults are :Load and :Save, i.e.\n"
"\t  the duration of the VOP.  The other intervening phases are :Argument,\n"
"\t  :Eval and :Result.  Non-zero sub-phases can be specified by a list,\n"
"\t  e.g. by default the second argument's life ends at (:Argument 1).\n"
" \n"
"  :Generator Cost Form*\n"
"      Specifies the translation into assembly code. Cost is the estimated "
"cost\n"
"      of the code emitted by this generator. The body is arbitrary Lisp "
"code\n"
"      that emits the assembly language translation of the VOP.  An Assemble\n"
"      form is wrapped around the body, so code may be emitted by using the\n"
"      local Inst macro.  During the evaluation of the body, the names of "
"the\n"
"      operands and temporaries are bound to the actual TNs.\n"
"  \n"
"  :Effects Effect*\n"
"  :Affected Effect*\n"
"      Specifies the side effects that this VOP has and the side effects "
"that\n"
"      effect its execution.  If unspecified, these default to the worst "
"case.\n"
"  \n"
"  :Info Name*\n"
"      Define some magic arguments that are passed directly to the code\n"
"      generator.  The corresponding trailing arguments to VOP or %Primitive "
"are\n"
"      stored in the VOP structure.  Within the body of the generators, the\n"
"      named variables are bound to these values.  Except in the case of\n"
"      :Conditional VOPs, :Info arguments cannot be specified for VOPS that "
"are\n"
"      the direct translation for a function (specified by :Translate).\n"
"\n"
"  :Ignore Name*\n"
"      Causes the named variables to be declared IGNORE in the generator "
"body.\n"
"\n"
"  :Variant Thing*\n"
"  :Variant-Vars Name*\n"
"      These options provide a way to parameterize families of VOPs that "
"differ\n"
"      only trivially.  :Variant makes the specified evaluated Things be the\n"
"      \"variant\" associated with this VOP.  :Variant-Vars causes the named\n"
"      variables to be bound to the corresponding Things within the body of "
"the\n"
"      generator.\n"
"\n"
"  :Variant-Cost Cost\n"
"      Specifies the cost of this VOP, overriding the cost of any inherited\n"
"      generator.\n"
"\n"
"  :Note {String | NIL}\n"
"      A short noun-like phrase describing what this VOP \"does\", i.e. the\n"
"      implementation strategy.  If supplied, efficency notes will be "
"generated\n"
"      when type uncertainty prevents :TRANSLATE from working.  NIL inhibits "
"any\n"
"      efficency note.\n"
"\n"
"  :Arg-Types    {* | PType | (:OR PType*) | (:CONSTANT Type)}*\n"
"  :Result-Types {* | PType | (:OR PType*)}*\n"
"      Specify the template type restrictions used for automatic "
"translation.\n"
"      If there is a :More operand, the last type is the more type.  :"
"CONSTANT\n"
"      specifies that the argument must be a compile-time constant of the\n"
"      specified Lisp type.  The constant values of :CONSTANT arguments are\n"
"      passed as additional :INFO arguments rather than as :ARGS.\n"
"  \n"
"  :Translate Name*\n"
"      This option causes the VOP template to be entered as an IR2 "
"translation\n"
"      for the named functions.\n"
"\n"
"  :Policy {:Small | :Fast | :Safe | :Fast-Safe}\n"
"      Specifies the policy under which this VOP is the best translation.\n"
"\n"
"  :Guard Form\n"
"      Specifies a Form that is evaluated in the global environment.  If\n"
"      form returns NIL, then emission of this VOP is prohibited even when\n"
"      all other restrictions are met.\n"
"\n"
"  :VOP-Var Name\n"
"  :Node-Var Name\n"
"      In the generator, bind the specified variable to the VOP or the Node "
"that\n"
"      generated this VOP.\n"
"\n"
"  :Save-P {NIL | T | :Compute-Only | :Force-To-Stack}\n"
"      Indicates how a VOP wants live registers saved.\n"
"\n"
"  :Move-Args {NIL | :Full-Call | :Local-Call | :Known-Return}\n"
"      Indicates if and how the more args should be moved into a different\n"
"      frame."
msgstr ""
"Efineday-VOP (Amenay [Inheritsway]) Ec*Spay\n"
"  Efineday ethay ymbolsay Amenay otay ebay away Irtualvay Operationway inway "
"ethay ompilercay.  Ifway\n"
"  ecifiedspay, Inheritsway isway ethay amenay ofway away VOP atthay eway "
"efaultday unspecifiedway\n"
"  informationway omfray.  Eachway Ecspay isway away istlay eginningbay "
"ithway away eywordkay indicatingway\n"
"  ethay interpretationway ofway ethay otherway ormsfay inway ethay Ecspay:\n"
"  \n"
"  :Argsway {(Amenay {Eykay Aluevay}*)}*\n"
"  :Esultsray {(Amenay {Eykay Aluevay}*)}*\n"
"      Ethay Argsway andway Esultsray areway ecificationsspay ofway ethay "
"operandway Nstay assedpay otay ethay\n"
"      VOP.  Ifway erethay isway anway inheritedway VOP, anyway "
"unspecifiedway optionsway areway efaultedday\n"
"      omfray ethay inheritedway argumentway (orway esultray) ofway ethay "
"amesay amenay.  Ethay ollowingfay\n"
"      operandway optionsway areway efinedday: \n"
"\n"
"      :Sscay (*Scay)\n"
"\t  :Sscay ecifiesspay oodgay Sscay orfay isthay operandway.  Otherway Sscay "
"illway ebay\n"
"\t  enalizedpay accordingway otay ovemay ostscay.  Away oadlay TN illway "
"ebay allocatedway ifway\n"
"\t  ecessarynay, uaranteeinggay atthay ethay operandway isway alwaysway "
"oneway ofway ethay\n"
"\t  ecifiedspay Sscay.\n"
"\n"
"      :Oadlay-TN Oadlay-Amenay\n"
"          Oadlay-Amenay isway oundbay otay ethay oadlay TN allocatedway "
"orfay isthay operandway, orway otay\n"
"\t  NIL ifway onay oadlay TN asway allocatedway.\n"
"\n"
"      :Oadlay-Ifway Expressionway\n"
"          Ontrolscay etherwhay automaticway operandway oadinglay isway "
"oneday.  Expressionway isway\n"
"\t  evaluatedway ithway ethay ixedfay operandway Nstay oundbay.  Ifway "
"Expressionway isway uetray,\n"
"\t  enthay oadinglay isway oneday andway ethay ariablevay isway oundbay otay "
"ethay oadlay TN inway\n"
"\t  ethay eneratorgay odybay.  Otherwiseway, oadinglay isway otnay oneday, "
"andway ethay ariablevay\n"
"\t  isway oundbay otay ethay actualway operandway.\n"
"\n"
"      :Oremay T-orway-NIL\n"
"\t  Ifway ecifiedspay, Amenay isway oundbay otay ethay TN-Efray orfay ethay "
"irstfay argumentway orway\n"
"\t  esultray ollowingfay ethay ixedfay argumentsway orway esultsray.  Away "
"oremay operandway ustmay\n"
"\t  appearway astlay, andway annotcay ebay argetedtay orway estrictedray.\n"
"\n"
"      :Argettay Operandway\n"
"\t  Isthay operandway isway argetedtay otay ethay amednay operandway, "
"indicatingway away esireday otay\n"
"\t  ackpay inway ethay amesay ocationlay.  Otnay egallay orfay esultsray.\n"
"\n"
"      :Omfray Imetay-Ecspay\n"
"      :Otay Imetay-Ecspay\n"
"\t  Ecifyspay ethay eginningbay orway endway ofway ethay operandway's "
"ifetimelay.  :Omfray ancay\n"
"\t  onlyway ebay usedway ithway esultsray, andway :Otay onlyway ithway "
"argumentsway.  Ethay efaultday\n"
"\t  orfay ethay N'thay argumentway/esultray isway (:ARGUMENT N)/(:RESULT "
"N).  Esethay\n"
"\t  optionsway areway ecessarynay imarilypray enwhay operandsway areway "
"eadray orway ittenwray outway\n"
"\t  ofway orderway.\n"
"   \n"
"  :Onditionalcay\n"
"      Isthay isway usedway inway aceplay ofway :RESULTS ithway onditionalcay "
"anchbray Opsvay.  Erethay\n"
"      areway onay esultray aluesvay: ethay esultray isway away ansfertray "
"ofway ontrolcay.  Ethay argettay\n"
"      abellay isway assedpay asway ethay irstfay :INFO argway.  Ethay "
"econdsay :INFO argway isway uetray ifway\n"
"      ethay ensesay ofway ethay esttay ouldshay ebay egatednay.  Away idesay-"
"effectway isway otay etsay ethay\n"
"      PREDICATE attributeway orfay unctionsfay inway ethay :TRANSLATE "
"optionway.\n"
"  \n"
"  :Emporarytay ({Eykay Aluevay}*) Ame*Nay\n"
"      Allocateway away emporarytay TN orfay eachway Amenay, indingbay atthay "
"ariablevay otay ethay TN\n"
"      ithinway ethay odybay ofway ethay eneratorsgay.  Inway additionway "
"otay :Argettay (ichwhay isway \n"
"      isway ethay amesay asway orfay operandsway), ethay ollowingfay "
"optionsway areway\n"
"      efinedday:\n"
"\n"
"      :SC SC-Amenay\n"
"      :Offsetway SB-Offsetway\n"
"\t  Orcefay ethay emporarytay otay ebay allocatedway inway ethay ecifiedspay "
"SC ithway ethay\n"
"\t  ecifiedspay offsetway.  Offsetway isway evaluatedway atway acroexpandmay "
"imetay.  Ifway\n"
"\t  Offsetway isway emittedway, ethay egisterray allocatorway ooseschay away "
"eefray ocationlay inway\n"
"\t  SC.  Ifway othbay SC andway Offsetway areway omittedway, enthay ethay "
"emporarytay isway ackedpay\n"
"\t  accordingway otay itsway imitivepray ypetay.\n"
"\n"
"      :Omfray Imetay-Ecspay\n"
"      :Otay Imetay-Ecspay\n"
"\t  Imilarsay otay ethay argumentway/esultray optionway, isthay ecifiesspay "
"ethay tartsay andway\n"
"\t  endway ofway ethay emporarystay' iveslay.  Ethay efaultsday areway :"
"Oadlay andway :Avesay, i.e.\n"
"\t  ethay urationday ofway ethay VOP.  Ethay otherway interveningway "
"asesphay areway :Argumentway,\n"
"\t  :Evalway andway :Esultray.  Onnay-erozay ubsay-asesphay ancay ebay "
"ecifiedspay ybay away istlay,\n"
"\t  e.g. ybay efaultday ethay econdsay argumentway's ifelay endsway atway (:"
"Argumentway 1).\n"
" \n"
"  :Eneratorgay Ostcay Orm*Fay\n"
"      Ecifiesspay ethay anslationtray intoway assemblyway odecay. Ostcay "
"isway ethay estimatedway ostcay\n"
"      ofway ethay odecay emittedway ybay isthay eneratorgay. Ethay odybay "
"isway arbitraryway Isplay odecay\n"
"      atthay emitsway ethay assemblyway anguagelay anslationtray ofway ethay "
"VOP.  Anway Assembleway\n"
"      ormfay isway appedwray aroundway ethay odybay, osay odecay aymay ebay "
"emittedway ybay usingway ethay\n"
"      ocallay Instway acromay.  Uringday ethay evaluationway ofway ethay "
"odybay, ethay amesnay ofway ethay\n"
"      operandsway andway emporariestay areway oundbay otay ethay actualway "
"Nstay.\n"
"  \n"
"  :Effectsway Effect*Way\n"
"  :Affectedway Effect*Way\n"
"      Ecifiesspay ethay idesay effectsway atthay isthay VOP ashay andway "
"ethay idesay effectsway atthay\n"
"      effectway itsway executionway.  Ifway unspecifiedway, esethay "
"efaultday otay ethay orstway asecay.\n"
"  \n"
"  :Infoway Ame*Nay\n"
"      Efineday omesay agicmay argumentsway atthay areway assedpay irectlyday "
"otay ethay odecay\n"
"      eneratorgay.  Ethay orrespondingcay ailingtray argumentsway otay VOP "
"orway %Imitivepray areway\n"
"      toredsay inway ethay VOP ucturestray.  Ithinway ethay odybay ofway "
"ethay eneratorsgay, ethay\n"
"      amednay ariablesvay areway oundbay otay esethay aluesvay.  Exceptway "
"inway ethay asecay ofway\n"
"      :Onditionalcay Opsvay, :Infoway argumentsway annotcay ebay ecifiedspay "
"orfay VOPS atthay areway\n"
"      ethay irectday anslationtray orfay away unctionfay (ecifiedspay ybay :"
"Anslatetray).\n"
"\n"
"  :Ignoreway Ame*Nay\n"
"      Ausescay ethay amednay ariablesvay otay ebay eclaredday IGNORE inway "
"ethay eneratorgay odybay.\n"
"\n"
"  :Ariantvay Ing*Thay\n"
"  :Ariantvay-Arsvay Ame*Nay\n"
"      Esethay optionsway ovidepray away ayway otay arameterizepay amiliesfay "
"ofway Opsvay atthay ifferday\n"
"      onlyway iviallytray.  :Ariantvay akesmay ethay ecifiedspay "
"evaluatedway Ingsthay ebay ethay\n"
"      \"ariantvay\" associatedway ithway isthay VOP.  :Ariantvay-Arsvay "
"ausescay ethay amednay\n"
"      ariablesvay otay ebay oundbay otay ethay orrespondingcay Ingsthay "
"ithinway ethay odybay ofway ethay\n"
"      eneratorgay.\n"
"\n"
"  :Ariantvay-Ostcay Ostcay\n"
"      Ecifiesspay ethay ostcay ofway isthay VOP, overridingway ethay ostcay "
"ofway anyway inheritedway\n"
"      eneratorgay.\n"
"\n"
"  :Otenay {Ingstray | NIL}\n"
"      Away ortshay ounnay-ikelay rasephay escribingday atwhay isthay VOP "
"\"oesday\", i.e. ethay\n"
"      implementationway ategystray.  Ifway uppliedsay, efficencyway otesnay "
"illway ebay eneratedgay\n"
"      enwhay ypetay uncertaintyway eventspray :TRANSLATE omfray orkingway.  "
"NIL inhibitsway anyway\n"
"      efficencyway otenay.\n"
"\n"
"  :Argway-Ypestay    {* | Typepay | (:OR Type*Pay) | (:CONSTANT Ypetay)}*\n"
"  :Esultray-Ypestay {* | Typepay | (:OR Type*Pay)}*\n"
"      Ecifyspay ethay emplatetay ypetay estrictionsray usedway orfay "
"automaticway anslationtray.\n"
"      Ifway erethay isway away :Oremay operandway, ethay astlay ypetay isway "
"ethay oremay ypetay.  :CONSTANT\n"
"      ecifiesspay atthay ethay argumentway ustmay ebay away ompilecay-imetay "
"onstantcay ofway ethay\n"
"      ecifiedspay Isplay ypetay.  Ethay onstantcay aluesvay ofway :CONSTANT "
"argumentsway areway\n"
"      assedpay asway additionalway :INFO argumentsway atherray anthay asway :"
"ARGS.\n"
"  \n"
"  :Anslatetray Ame*Nay\n"
"      Isthay optionway ausescay ethay VOP emplatetay otay ebay enteredway "
"asway anway IR2 anslatiotrayn\n"
"      orfay ethay amednay unctionsfay.\n"
"\n"
"  :Olicypay {:Mallsay | :Astfay | :Afesay | :Astfay-Afesay}\n"
"      Ecifiesspay ethay olicypay underway ichwhay isthay VOP isway ethay "
"estbay anslationtray.\n"
"\n"
"  :Uardgay Ormfay\n"
"      Ecifiesspay away Ormfay atthay isway evaluatedway inway ethay obalglay "
"environmentway.  Ifway\n"
"      ormfay eturnsray NIL, enthay emissionway ofway isthay VOP isway "
"ohibitedpray evenway enwhay\n"
"      allway otherway estrictionsray areway etmay.\n"
"\n"
"  :VOP-Arvay Amenay\n"
"  :Odenay-Arvay Amenay\n"
"      Inway ethay eneratorgay, indbay ethay ecifiedspay ariablevay otay "
"ethay VOP orway ethay Odenay atthay\n"
"      eneratedgay isthay VOP.\n"
"\n"
"  :Avesay-P {NIL | T | :Omputecay-Onlyway | :Orcefay-Otay-Tacksay}\n"
"      Indicatesway owhay away VOP antsway ivelay egistersray avedsay.\n"
"\n"
"  :Ovemay-Argsway {NIL | :Ullfay-Allcay | :Ocallay-Allcay | :Nownkay-"
"Eturnray}\n"
"      Indicatesway ifway andway owhay ethay oremay argsway ouldshay ebay "
"ovedmay intoway away ifferentday\n"
"      amefray."

#: src/compiler/meta-vmdef.lisp
msgid ""
"Emit-Template Node Block Template Args Results [Info]\n"
"  Call the emit function for Template, linking the result in at the end of\n"
"  Block."
msgstr ""
"Emitway-Emplatetay Odenay Ockblay Emplatetay Argsway Esultsray [Infoway]\n"
"  Allcay ethay emitway unctionfay orfay Emplatetay, inkinglay ethay esultray "
"inway atway ethay endway ofway\n"
"  Ockblay."

#: src/compiler/meta-vmdef.lisp
msgid ""
"VOP Name Node Block Arg* Info* Result*\n"
"  Emit the VOP (or other template) Name at the end of the IR2-Block Block,\n"
"  using Node for the source context.  The interpretation of the remaining\n"
"  arguments depends on the number of operands of various kinds that are\n"
"  declared in the template definition.  VOP cannot be used for templates "
"that\n"
"  have more-args or more-results, since the number of arguments and results "
"is\n"
"  indeterminate for these templates.  Use VOP* instead.\n"
"  \n"
"  Args and Results are the TNs that are to be referenced by the template\n"
"  as arguments and results.  If the template has codegen-info arguments, "
"then\n"
"  the appropriate number of Info forms following the Arguments are used for\n"
"  codegen info."
msgstr ""
"VOP Amenay Odenay Ockblay Arg*Way Info*Way Esult*Ray\n"
"  Emitway ethay VOP (orway otherway emplatetay) Amenay atway ethay endway "
"ofway ethay IR2-Ockblay Ockblay,\n"
"  usingway Odenay orfay ethay ourcesay ontextcay.  Ethay interpretationway "
"ofway ethay emainingray\n"
"  argumentsway ependsday onway ethay umbernay ofway operandsway ofway "
"ariousvay indskay atthay areway\n"
"  eclaredday inway ethay emplatetay efinitionday.  VOP annotcay ebay usedway "
"orfay emplatestay atthay\n"
"  avehay oremay-argsway orway oremay-esultsray, incesay ethay umbernay ofway "
"argumentsway andway esultsray isway\n"
"  indeterminateway orfay esethay emplatestay.  Useway Op*Vay insteadway.\n"
"  \n"
"  Argsway andway Esultsray areway ethay Nstay atthay areway otay ebay "
"eferencedray ybay ethay emplatetay\n"
"  asway argumentsway andway esultsray.  Ifway ethay emplatetay ashay "
"odegencay-infoway argumentsway, enthay\n"
"  ethay appropriateway umbernay ofway Infoway ormsfay ollowingfay ethay "
"Argumentsway areway usedway orfay\n"
"  odegencay infoway."

#: src/compiler/meta-vmdef.lisp
msgid "Cannot use VOP with variable operand count templates."
msgstr "Annotcay useway VOP ithway ariablevay operandway ountcay emplatestay."

#: src/compiler/meta-vmdef.lisp
msgid "Called with ~D operands, but was expecting ~D."
msgstr "Alledcay ithway ~D operandsway, utbay asway expectingway ~D."

#: src/compiler/meta-vmdef.lisp
msgid ""
"VOP* Name Node Block (Arg* More-Args) (Result* More-Results) Info*\n"
"  Like VOP, but allows for emission of templates with arbitrary numbers of\n"
"  arguments, and for emission of templates using already-created TN-Ref "
"lists.\n"
"\n"
"  The Arguments and Results are TNs to be referenced as the first arguments\n"
"  and results to the template.  More-Args and More-Results are heads of TN-"
"Ref\n"
"  lists that are added onto the end of the TN-Refs for the explicitly "
"supplied\n"
"  operand TNs.  The TN-Refs for the more operands must have the TN and Write-"
"P\n"
"  slots correctly initialized.\n"
"\n"
"  As with VOP, the Info forms are evaluated and passed as codegen info\n"
"  arguments."
msgstr ""
"Op*Vay Amenay Odenay Ockblay (Arg*Way Oremay-Argsway) (Esult*Ray Oremay-"
"Esultsray) Info*Way\n"
"  Ikelay VOP, utbay allowsway orfay emissionway ofway emplatestay ithway "
"arbitraryway umbersnay ofway\n"
"  argumentsway, andway orfay emissionway ofway emplatestay usingway "
"alreadyway-eatedcray TN-Efray istslay.\n"
"\n"
"  Ethay Argumentsway andway Esultsray areway Nstay otay ebay eferencedray "
"asway ethay irstfay argumentsway\n"
"  andway esultsray otay ethay emplatetay.  Oremay-Argsway andway Oremay-"
"Esultsray areway eadshay ofway TN-Efray\n"
"  istslay atthay areway addedway ontoway ethay endway ofway ethay TN-Efsray "
"orfay ethay explicitlyway uppliedsay\n"
"  operandway Nstay.  Ethay TN-Efsray orfay ethay oremay operandsway ustmay "
"avehay ethay TN andway Itewray-P\n"
"  otsslay orrectlycay initializedway.\n"
"\n"
"  Asway ithway VOP, ethay Infoway ormsfay areway evaluatedway andway "
"assedpay asway odegencay infoway\n"
"  argumentsway."

#: src/compiler/meta-vmdef.lisp
msgid "Too many fixed arguments."
msgstr "Ootay anymay ixedfay argumentsway."

#: src/compiler/meta-vmdef.lisp
msgid "Too many fixed results."
msgstr "Ootay anymay ixedfay esultsray."

#: src/compiler/meta-vmdef.lisp
msgid "Expected ~D info args."
msgstr "Expectedway ~D infoway argsway."

#: src/compiler/meta-vmdef.lisp
msgid ""
"SC-Case TN {({(SC-Name*) | SC-Name | T} Form*)}*\n"
"  Case off of TN's SC.  The first clause containing TN's SC is evaulated,\n"
"  returning the values of the last form.  A clause beginning with T "
"specifies a\n"
"  default.  If it appears, it must be last.  If no default is specified, and "
"no\n"
"  clause matches, then an error is signalled."
msgstr ""
"SC-Asecay TN {({(SC-Ame*Nay) | SC-Amenay | T} Orm*Fay)}*\n"
"  Asecay offway ofway TN's SC.  Ethay irstfay auseclay ontainingcay TN's SC "
"isway evaulatedway,\n"
"  eturningray ethay aluesvay ofway ethay astlay ormfay.  Away auseclay "
"eginningbay ithway T ecifiespays away\n"
"  efaultday.  Ifway itway appearsway, itway ustmay ebay astlay.  Ifway onay "
"efaultday isway ecifiedspay, andway onay\n"
"  auseclay atchesmay, enthay anway errorway isway ignalledsay."

#: src/compiler/meta-vmdef.lisp
msgid "Illegal SC-Case clause: ~S."
msgstr "Illegalway SC-Asecay auseclay: ~S."

#: src/compiler/meta-vmdef.lisp
msgid "T case is not last in SC-Case."
msgstr "T asecay isway otnay astlay inway SC-Asecay."

#: src/compiler/meta-vmdef.lisp
msgid ""
"SC-Is TN SC*\n"
"  Returns true if TNs SC is any of the named SCs, false otherwise."
msgstr ""
"SC-Isway TN *Scay\n"
"  Eturnsray uetray ifway Nstay SC isway anyway ofway ethay amednay Sscay, "
"alsefay otherwiseway."

#: src/compiler/meta-vmdef.lisp
msgid ""
"Do-IR2-Blocks (Block-Var Component [Result]) Form*\n"
"  Iterate over the IR2 blocks in component, in emission order."
msgstr ""
"Oday-IR2-Ocksblay (Ockblay-Arvay Omponentcay [Esultray]) Orm*Fay\n"
"  Iterateway overway ethay IR2 ocksblay inway omponentcay, inway emissionway "
"orderway."

#: src/compiler/meta-vmdef.lisp
msgid ""
"DO-LIVE-TNS (TN-Var Live Block [Result]) Form*\n"
"  Iterate over all the TNs live at some point, with the live set represented "
"by\n"
"  a local conflicts bit-vector and the IR2-Block containing the location."
msgstr ""
"DO-LIVE-TNS (TN-Arvay Ivelay Ockblay [Esultray]) Orm*Fay\n"
"  Iterateway overway allway ethay Nstay ivelay atway omesay ointpay, ithway "
"ethay ivelay etsay epresentedray ybay\n"
"  away ocallay onflictscay itbay-ectorvay andway ethay IR2-Ockblay "
"ontainingcay ethay ocationlay."

#: src/compiler/meta-vmdef.lisp
msgid ""
"DO-ENVIRONMENT-IR2-BLOCKS (Block-Var Env [Result]) Form*\n"
"  Iterate over all the IR2 blocks in the environment Env, in emit order."
msgstr ""
"DO-ENVIRONMENT-IR2-BLOCKS (Ockblay-Arvay Envway [Esultray]) Orm*Fay\n"
"  Iterateway overway allway ethay IR2 ocksblay inway ethay environmentway "
"Envway, inway emitway orderway."

#: src/compiler/disassem.lisp
msgid ""
"The width of the column in which instruction-names are printed.\n"
"  NIL means use the default.  A value of zero gives the effect of not\n"
"  aligning the arguments at all."
msgstr ""
"Ethay idthway ofway ethay olumncay inway ichwhay instructionway-amesnay "
"areway intedpray.\n"
"  NIL eansmay useway ethay efaultday.  Away aluevay ofway erozay ivesgay "
"ethay effectway ofway otnay\n"
"  aligningway ethay argumentsway atway allway."

#: src/compiler/disassem.lisp
msgid "The column in which end-of-line comments for notes are started."
msgstr ""
"Ethay olumncay inway ichwhay endway-ofway-inelay ommentscay orfay otesnay "
"areway tartedsay."

#: src/compiler/disassem.lisp
msgid ""
"Specify global disassembler params for C:*TARGET-BACKEND*.\n"
"  Keyword arguments include:\n"
"      \n"
"  :INSTRUCTION-ALIGNMENT number\n"
"      Minimum alignment of instructions, in bits.\n"
"      \n"
"  :ADDRESS-SIZE number\n"
"      Size of a machine address, in bits.\n"
"      \n"
"  :OPCODE-COLUMN-WIDTH\n"
"      Width of the column used for printing the opcode portion of the\n"
"      instruction, or NIL to use the default."
msgstr ""
"Ecifyspay obalglay isassemblerday aramspay orfay C:*TARGET-BACKEND*.\n"
"  Eywordkay argumentsway includeway:\n"
"      \n"
"  :INSTRUCTION-ALIGNMENT umbernay\n"
"      Inimummay alignmentway ofway instructionsway, inway itsbay.\n"
"      \n"
"  :ADDRESS-SIZE umbernay\n"
"      Izesay ofway away achinemay addressway, inway itsbay.\n"
"      \n"
"  :OPCODE-COLUMN-WIDTH\n"
"      Idthway ofway ethay olumncay usedway orfay intingpray ethay opcodeway "
"ortionpay ofway ethay\n"
"      instructionway, orway NIL otay useway ethay efaultday."

#: src/compiler/disassem.lisp
msgid ""
"DEFINE-ARGUMENT-TYPE Name {Key Value}*\n"
"  Define a disassembler argument type NAME (which can then be referenced in\n"
"  another argument definition using the :TYPE keyword argument).  Keyword\n"
"  arguments are:\n"
"\n"
"  :SIGN-EXTEND boolean\n"
"      If non-NIL, the raw value of this argument is sign-extended.\n"
"\n"
"  :TYPE arg-type-name\n"
"      Inherit any properties of given argument-type.\n"
"\n"
"  :PREFILTER function\n"
"      A function which is called (along with all other prefilters, in the\n"
"      order that their arguments appear in the instruction- format) before\n"
"      any printing is done, to filter the raw value.  Any uses of READ-"
"SUFFIX\n"
"      must be done inside a prefilter.\n"
"      \n"
"  :PRINTER function-string-or-vector\n"
"      A function, string, or vector which is used to print an argument of\n"
"      this type.\n"
"      \n"
"  :USE-LABEL \n"
"      If non-NIL, the value of an argument of this type is used as an\n"
"      address, and if that address occurs inside the disassembled code, it "
"is\n"
"      replaced by a label.  If this is a function, it is called to filter "
"the\n"
"      value."
msgstr ""
"DEFINE-ARGUMENT-TYPE Amenay {Eykay Aluevay}*\n"
"  Efineday away isassemblerday argumentway ypetay NAME (ichwhay ancay enthay "
"ebay eferencedray inway\n"
"  anotherway argumentway efinitionday usingway ethay :TYPE eywordkay "
"argumentway).  Eywordkay\n"
"  argumentsway areway:\n"
"\n"
"  :SIGN-EXTEND ooleanbay\n"
"      Ifway onnay-NIL, ethay awray aluevay ofway isthay argumentway isway "
"ignsay-extendedway.\n"
"\n"
"  :TYPE argway-ypetay-amenay\n"
"      Inheritway anyway opertiespray ofway ivengay argumentway-ypetay.\n"
"\n"
"  :PREFILTER unctionfay\n"
"      Away unctionfay ichwhay isway alledcay (alongway ithway allway "
"otherway efilterspray, inway ethay\n"
"      orderway atthay eirthay argumentsway appearway inway ethay "
"instructionway- ormatfay) eforebay\n"
"      anyway intingpray isway oneday, otay ilterfay ethay awray aluevay.  "
"Anyway usesway ofway READ-SUFFIX\n"
"      ustmay ebay oneday insideway away efilterpray.\n"
"      \n"
"  :PRINTER unctionfay-ingstray-orway-ectorvay\n"
"      Away unctionfay, ingstray, orway ectorvay ichwhay isway usedway otay "
"intpray anway argumentway ofway\n"
"      isthay ypetay.\n"
"      \n"
"  :USE-LABEL \n"
"      Ifway onnay-NIL, ethay aluevay ofway anway argumentway ofway isthay "
"ypetay isway usedway asway anway\n"
"      addressway, andway ifway atthay addressway occursway insideway ethay "
"isassembledday odecay, itway isway\n"
"      eplacedray ybay away abellay.  Ifway isthay isway away unctionfay, "
"itway isway alledcay otay ilterfay ethay\n"
"      aluevay."

#: src/compiler/disassem.lisp
msgid ""
"DEFINE-INSTRUCTION-FORMAT (Name Length {Format-Key Value}*) Arg-Def*\n"
"  Define an instruction format NAME for the disassembler's use.  LENGTH is\n"
"  the length of the format in bits.\n"
"  Possible FORMAT-KEYs:\n"
"\n"
"  :INCLUDE other-format-name\n"
"      Inherit all arguments and properties of the given format.  Any\n"
"      arguments defined in the current format definition will either modify\n"
"      the copy of an existing argument (keeping in the same order with\n"
"      respect to when pre-filter's are called), if it has the same name as\n"
"      one, or be added to the end.\n"
"  :DEFAULT-PRINTER printer-list\n"
"      Use the given PRINTER-LIST as a format to print any instructions of\n"
"      this format when they don't specify something else.\n"
"\n"
"  Each ARG-DEF defines one argument in the format, and is of the form\n"
"    (Arg-Name {Arg-Key Value}*)\n"
"\n"
"  Possible ARG-KEYs (the values are evaulated unless otherwise specified):\n"
"  \n"
"  :FIELDS byte-spec-list\n"
"      The argument takes values from these fields in the instruction.  If\n"
"      the list is of length one, then the corresponding value is supplied "
"by\n"
"      itself; otherwise it is a list of the values.  The list may be NIL.\n"
"  :FIELD byte-spec\n"
"      The same as :FIELDS (list byte-spec).\n"
"\n"
"  :VALUE value\n"
"      If the argument only has one field, this is the value it should have,\n"
"      otherwise it's a list of the values of the individual fields.  This "
"can\n"
"      be overridden in an instruction-definition or a format definition\n"
"      including this one by specifying another, or NIL to indicate that "
"it's\n"
"      variable.\n"
"\n"
"  :SIGN-EXTEND boolean\n"
"      If non-NIL, the raw value of this argument is sign-extended,\n"
"      immediately after being extracted from the instruction (before any\n"
"      prefilters are run, for instance).  If the argument has multiple\n"
"      fields, they are all sign-extended.\n"
"\n"
"  :TYPE arg-type-name\n"
"      Inherit any properties of the given argument-type.\n"
"\n"
"  :PREFILTER function\n"
"      A function which is called (along with all other prefilters, in the\n"
"      order that their arguments appear in the instruction-format) before\n"
"      any printing is done, to filter the raw value.  Any uses of READ-"
"SUFFIX\n"
"      must be done inside a prefilter.\n"
"\n"
"  :PRINTER function-string-or-vector\n"
"      A function, string, or vector which is used to print this argument.\n"
"      \n"
"  :USE-LABEL \n"
"      If non-NIL, the value of this argument is used as an address, and if\n"
"      that address occurs inside the disassembled code, it is replaced by a\n"
"      label.  If this is a function, it is called to filter the value."
msgstr ""
"DEFINE-INSTRUCTION-FORMAT (Amenay Engthlay {Ormatfay-Eykay Aluevay}*) Argway-"
"Ef*Day\n"
"  Efineday anway instructionway ormatfay NAME orfay ethay isassemblerday's "
"useway.  LENGTH isway\n"
"  ethay engthlay ofway ethay ormatfay inway itsbay.\n"
"  Ossiblepay FORMAT-Eyskay:\n"
"\n"
"  :INCLUDE otherway-ormatfay-amenay\n"
"      Inheritway allway argumentsway andway opertiespray ofway ethay ivengay "
"ormatfay.  Anyway\n"
"      argumentsway efinedday inway ethay urrentcay ormatfay efinitionday "
"illway eitherway odifymay\n"
"      ethay opycay ofway anway existingway argumentway (eepingkay inway "
"ethay amesay orderway ithway\n"
"      espectray otay enwhay epray-ilterfay's areway alledcay), ifway itway "
"ashay ethay amesay amenay asway\n"
"      oneway, orway ebay addedway otay ethay endway.\n"
"  :DEFAULT-PRINTER interpray-istlay\n"
"      Useway ethay ivengay PRINTER-LIST asway away ormatfay otay intpray "
"anyway instructionsway ofway\n"
"      isthay ormatfay enwhay eythay onday't ecifyspay omethingsay elseway.\n"
"\n"
"  Eachway ARG-DEF efinesday oneway argumentway inway ethay ormatfay, andway "
"isway ofway ethay ormfay\n"
"    (Argway-Amenay {Argway-Eykay Aluevay}*)\n"
"\n"
"  Ossiblepay ARG-Eyskay (ethay aluesvay areway evaulatedway unlessway "
"otherwiseway ecifiedspay):\n"
"  \n"
"  :FIELDS ytebay-ecspay-istlay\n"
"      Ethay argumentway akestay aluesvay omfray esethay ieldsfay inway ethay "
"instructionway.  Ifway\n"
"      ethay istlay isway ofway engthlay oneway, enthay ethay orrespondingcay "
"aluevay isway uppliedsay ybay\n"
"      itselfway; otherwiseway itway isway away istlay ofway ethay aluesvay.  "
"Ethay istlay aymay ebay NIL.\n"
"  :FIELD ytebay-ecspay\n"
"      Ethay amesay asway :FIELDS (istlay ytebay-ecspay).\n"
"\n"
"  :VALUE aluevay\n"
"      Ifway ethay argumentway onlyway ashay oneway ieldfay, isthay isway "
"ethay aluevay itway ouldshay avehay,\n"
"      otherwiseway itway's away istlay ofway ethay aluesvay ofway ethay "
"individualway ieldsfay.  Isthay ancay\n"
"      ebay overriddenway inway anway instructionway-efinitionday orway away "
"ormatfay efinitionday\n"
"      includingway isthay oneway ybay ecifyingspay anotherway, orway NIL "
"otay indicateway atthay itway's\n"
"      ariablevay.\n"
"\n"
"  :SIGN-EXTEND ooleanbay\n"
"      Ifway onnay-NIL, ethay awray aluevay ofway isthay argumentway isway "
"ignsay-extendedway,\n"
"      immediatelyway afterway eingbay extractedway omfray ethay "
"instructionway (eforebay anyway\n"
"      efilterspray areway unray, orfay instanceway).  Ifway ethay "
"argumentway ashay ultiplemay\n"
"      ieldsfay, eythay areway allway ignsay-extendedway.\n"
"\n"
"  :TYPE argway-ypetay-amenay\n"
"      Inheritway anyway opertiespray ofway ethay ivengay argumentway-"
"ypetay.\n"
"\n"
"  :PREFILTER unctionfay\n"
"      Away unctionfay ichwhay isway alledcay (alongway ithway allway "
"otherway efilterspray, inway ethay\n"
"      orderway atthay eirthay argumentsway appearway inway ethay "
"instructionway-ormatfay) eforebay\n"
"      anyway intingpray isway oneday, otay ilterfay ethay awray aluevay.  "
"Anyway usesway ofway READ-SUFFIX\n"
"      ustmay ebay oneday insideway away efilterpray.\n"
"\n"
"  :PRINTER unctionfay-ingstray-orway-ectorvay\n"
"      Away unctionfay, ingstray, orway ectorvay ichwhay isway usedway otay "
"intpray isthay argumentway.\n"
"      \n"
"  :USE-LABEL \n"
"      Ifway onnay-NIL, ethay aluevay ofway isthay argumentway isway usedway "
"asway anway addressway, andway ifway\n"
"      atthay addressway occursway insideway ethay isassembledday odecay, "
"itway isway eplacedray ybay away\n"
"      abellay.  Ifway isthay isway away unctionfay, itway isway alledcay "
"otay ilterfay ethay aluevay."

#: src/compiler/disassem.lisp
msgid "~d bits is not a byte-multiple"
msgstr "~d itsbay isway otnay away ytebay-ultiplemay"

#: src/compiler/disassem.lisp
msgid "Returns non-NIL if ADDRESS is aligned on a SIZE byte boundary."
msgstr ""
"Eturnsray onnay-NIL ifway ADDRESS isway alignedway onway away SIZE ytebay "
"oundarybay."

#: src/compiler/disassem.lisp
msgid "Return ADDRESS aligned *upward* to a SIZE byte boundary."
msgstr "Eturnray ADDRESS alignedway *upward* otay away SIZE ytebay oundarybay."

#: src/compiler/disassem.lisp
msgid ""
"If CAR is eq to the car of OLD-CONS and CDR is eq to the CDR, return\n"
"  OLD-CONS, otherwise return (cons CAR CDR)."
msgstr ""
"Ifway CAR isway eqway otay ethay arcay ofway OLD-CONS andway CDR isway eqway "
"otay ethay CDR, eturnray\n"
"  OLD-CONS, otherwiseway eturnray (onscay CAR CDR)."

#: src/compiler/disassem.lisp
msgid ""
"A simple (one list arg) mapcar that avoids consing up a new list\n"
"  as long as the results of calling FUN on the elements of LIST are\n"
"  eq to the original."
msgstr ""
"Away implesay (oneway istlay argway) apcarmay atthay avoidsway onsingcay "
"upway away ewnay istlay\n"
"  asway onglay asway ethay esultsray ofway allingcay FUN onway ethay "
"elementsway ofway LIST areway\n"
"  eqway otay ethay originalway."

#: src/compiler/disassem.lisp
msgid "Can't dump functions, so function ref form must be quoted: ~s"
msgstr ""
"Ancay't umpday unctionsfay, osay unctionfay efray ormfay ustmay ebay "
"otedquay: ~s"

#: src/compiler/disassem.lisp
msgid "Unknown argument ~s"
msgstr "Unknownway argumentway ~s"

#: src/compiler/disassem.lisp
msgid "~s must not have multiple values"
msgstr "~s ustmay otnay avehay ultiplemay aluesvay"

#: src/compiler/disassem.lisp
msgid "Unknown arg-form kind ~s"
msgstr "Unknownway argway-ormfay indkay ~s"

#: src/compiler/disassem.lisp
msgid ""
"Cannot label a multiple-field argument ~\n"
"\t\t\t      unless using a function: ~s"
msgstr ""
"Annotcay abellay away ultiplemay-ieldfay argumentway ~\n"
"\t\t\t      unlessway usingway away unctionfay: ~s"

#: src/compiler/disassem.lisp
msgid "Bogus!  Can't use the :printed value of an arg!"
msgstr "Ogusbay!  Ancay't useway ethay :intedpray aluevay ofway anway argway!"

#: src/compiler/disassem.lisp
msgid ""
"number of constants doesn't match number of fields ~\n"
"\t\t\t  in: (~s :constant~{ ~s~})"
msgstr ""
"umbernay ofway onstantscay oesnday't atchmay umbernay ofway ieldsfay ~\n"
"\t\t\t  inway: (~s :onstantcay~{ ~s~})"

#: src/compiler/disassem.lisp
msgid ""
"Can't compare differently sized fields: ~\n"
"\t\t          (~s :same-as ~s)"
msgstr ""
"Ancay't omparecay ifferentlyday izedsay ieldsfay: ~\n"
"\t\t          (~s :amesay-asway ~s)"

#: src/compiler/disassem.lisp
msgid "Bogus test-form: ~s"
msgstr "Ogusbay esttay-ormfay: ~s"

#: src/compiler/disassem.lisp
msgid "Returns the first non-keyword symbol in a depth-first search of TREE."
msgstr ""
"Eturnsray ethay irstfay onnay-eywordkay ymbolsay inway away epthday-irstfay "
"earchsay ofway TREE."

#: src/compiler/disassem.lisp
msgid "Illegal printer: ~s"
msgstr "Illegalway interpray: ~s"

#: src/compiler/disassem.lisp
msgid "Unknown printer element: ~s"
msgstr "Unknownway interpray elementway: ~s"

#: src/compiler/disassem.lisp
msgid "First arg to :USING must be a string or #'function"
msgstr ""
"Irstfay argway otay :USING ustmay ebay away ingstray orway #'unctionfay"

#: src/compiler/disassem.lisp
msgid "No suitable choice found in ~s"
msgstr "Onay uitablesay oicechay oundfay inway ~s"

#: src/compiler/disassem.lisp
msgid ""
"Returns a version of the disassembly-template PRINTER with compile-time\n"
"  tests (e.g. :constant without a value), and any :CHOOSE operators "
"resolved\n"
"  properly for the args ARGS.  (:CHOOSE Sub*) simply returns the first Sub "
"in\n"
"  which every field reference refers to a valid arg."
msgstr ""
"Eturnsray away ersionvay ofway ethay isassemblyday-emplatetay PRINTER ithway "
"ompilecay-imetay\n"
"  eststay (e.g. :onstantcay ithoutway away aluevay), andway anyway :CHOOSE "
"operatorsway esolvedray\n"
"  operlypray orfay ethay argsway ARGS.  (:CHOOSE Ub*Say) implysay eturnsray "
"ethay irstfay Ubsay inway\n"
"  ichwhay everyway ieldfay eferenceray efersray otay away alidvay argway."

#: src/compiler/disassem.lisp
msgid "Unknown argument type: ~s"
msgstr "Unknownway argumentway ypetay: ~s"

#: src/compiler/disassem.lisp
msgid ""
"~@<In arg ~s:  ~3i~:_~\n"
"          Can't specify fields except using DEFINE-INSTRUCTION-FORMAT.~:>"
msgstr ""
"~@<Inway argway ~s:  ~3i~:_~\n"
"          Ancay't ecifyspay ieldsfay exceptway usingway DEFINE-INSTRUCTION-"
"FORMAT.~:>"

#: src/compiler/disassem.lisp
msgid ""
"~@<In arg ~s:  ~3i~:_~\n"
"\t\t\t\t     Field ~s doesn't fit in an ~\n"
"\t\t\t\t     instruction-format ~d bits wide.~:>"
msgstr ""
"~@<Inway argway ~s:  ~3i~:_~\n"
"\t\t\t\t     Ieldfay ~s oesnday't itfay inway anway ~\n"
"\t\t\t\t     instructionway-ormatfay ~d itsbay ideway.~:>"

#: src/compiler/disassem.lisp
msgid ""
"Generate a form to specify global disassembler params.  See the\n"
"  documentation for SET-DISASSEM-PARAMS for more info."
msgstr ""
"Enerategay away ormfay otay ecifyspay obalglay isassemblerday aramspay.  "
"Eesay ethay\n"
"  ocumentationday orfay SET-DISASSEM-PARAMS orfay oremay infoway."

#: src/compiler/disassem.lisp
msgid ""
"Generate a form to define a disassembler argument type.  See\n"
"  DEFINE-ARGUMENT-TYPE for more info."
msgstr ""
"Enerategay away ormfay otay efineday away isassemblerday argumentway "
"ypetay.  Eesay\n"
"  DEFINE-ARGUMENT-TYPE orfay oremay infoway."

#: src/compiler/disassem.lisp
msgid ""
"Generate a form to define an instruction format.  See\n"
"  DEFINE-INSTRUCTION-FORMAT for more info."
msgstr ""
"Enerategay away ormfay otay efineday anway instructionway ormatfay.  Eesay\n"
"  DEFINE-INSTRUCTION-FORMAT orfay oremay infoway."

#: src/compiler/disassem.lisp
msgid "Field ~s in arg ~s overlaps some other field"
msgstr "Ieldfay ~s inway argway ~s overlapsway omesay otherway ieldfay"

#: src/compiler/disassem.lisp
msgid "Unknown instruction format ~s"
msgstr "Unknownway instructionway ormatfay ~s"

#: src/compiler/disassem.lisp
msgid ""
"Returns non-NIL if the instruction SPECIAL is a more specific version of\n"
"  GENERAL (i.e., the same instruction, but with more constraints)."
msgstr ""
"Eturnsray onnay-NIL ifway ethay instructionway SPECIAL isway away oremay "
"ecificspay ersionvay ofway\n"
"  GENERAL (i.e., ethay amesay instructionway, utbay ithway oremay "
"onstraintscay)."

#: src/compiler/disassem.lisp
msgid ""
"Returns an integer corresponding to the specifivity of the instruction INST."
msgstr ""
"Eturnsray anway integerway orrespondingcay otay ethay ecifivityspay ofway "
"ethay instructionway INST."

#: src/compiler/disassem.lisp
msgid ""
"Order the list of instructions INSTS with more specific (more constant\n"
"  bits, or same-as argument constains) ones first.  Returns the ordered list."
msgstr ""
"Orderway ethay istlay ofway instructionsway INSTS ithway oremay ecificspay "
"(oremay onstantcay\n"
"  itsbay, orway amesay-asway argumentway onstainscay) onesway irstfay.  "
"Eturnsray ethay orderedway istlay."

#: src/compiler/disassem.lisp
msgid "Instructions either aren't related or conflict in some way:~%"
msgstr ""
"Instructionsway eitherway arenway't elatedray orway onflictcay inway omesay "
"ayway:~%"

#: src/compiler/disassem.lisp
msgid ""
"Given a list of instructions INSTS, Sees if one of these instructions is a\n"
"  more general form of all the others, in which case they are put into its\n"
"  specializers list, and it is returned.  Otherwise an error is signaled."
msgstr ""
"Ivengay away istlay ofway instructionsway INSTS, Eessay ifway oneway ofway "
"esethay instructionsway isway away\n"
"  oremay eneralgay ormfay ofway allway ethay othersway, inway ichwhay asecay "
"eythay areway utpay intoway itsway\n"
"  ecializersspay istlay, andway itway isway eturnedray.  Otherwiseway anway "
"errorway isway ignaledsay."

#: src/compiler/disassem.lisp
msgid "Multiple specializing masters: ~s"
msgstr "Ultiplemay ecializingspay astersmay: ~s"

#: src/compiler/disassem.lisp
msgid "Returns non-NIL if all constant-bits in INST match CHUNK."
msgstr ""
"Eturnsray onnay-NIL ifway allway onstantcay-itsbay inway INST atchmay CHUNK."

#: src/compiler/disassem.lisp
msgid ""
"Given an instruction object, INST, and a bit-pattern, CHUNK, picks the\n"
"  most specific instruction on INST's specializer list who's constraints "
"are\n"
"  met by CHUNK.  If none do, then INST is returned."
msgstr ""
"Ivengay anway instructionway objectway, INST, andway away itbay-atternpay, "
"CHUNK, ickspay ethay\n"
"  ostmay ecificspay instructionway onway INST's ecializerspay istlay owhay's "
"onstraintscay areway\n"
"  etmay ybay CHUNK.  Ifway onenay oday, enthay INST isway eturnedray."

#: src/compiler/disassem.lisp
msgid ""
"Returns the instruction object within INST-SPACE corresponding to the\n"
"  bit-pattern CHUNK, or NIL if there isn't one."
msgstr ""
"Eturnsray ethay instructionway objectway ithinway INST-SPACE orrespondingcay "
"otay ethay\n"
"  itbay-atternpay CHUNK, orway NIL ifway erethay isnway't oneway."

#: src/compiler/disassem.lisp
msgid ""
"Returns an instruction-space object corresponding to the list of\n"
"  instructions INSTS.  If the optional parameter INITIAL-MASK is supplied, "
"only\n"
"  bits it has set are used."
msgstr ""
"Eturnsray anway instructionway-acespay objectway orrespondingcay otay ethay "
"istlay ofway\n"
"  instructionsway INSTS.  Ifway ethay optionalway arameterpay INITIAL-MASK "
"isway uppliedsay, onlyway\n"
"  itsbay itway ashay etsay areway usedway."

#: src/compiler/disassem.lisp
msgid "Prints a nicely formatted version of INST-SPACE."
msgstr "Intspray away icelynay ormattedfay ersionvay ofway INST-SPACE."

#: src/compiler/disassem.lisp
msgid "Print the inst space for the specified backend"
msgstr "Intpray ethay instway acespay orfay ethay ecifiedspay ackendbay"

#: src/compiler/disassem.lisp
msgid "Converts a word-offset NUM to a byte-offset."
msgstr "Onvertscay away ordway-offsetway NUM otay away ytebay-offsetway."

#: src/compiler/disassem.lisp
msgid "Converts a byte-offset NUM to a word-offset."
msgstr "Onvertscay away ytebay-offsetway NUM otay away ordway-offsetway."

#: src/compiler/disassem.lisp
msgid "Get the value of the property called NAME in DSTATE.  Also setf'able."
msgstr ""
"Etgay ethay aluevay ofway ethay opertypray alledcay NAME inway DSTATE.  "
"Alsoway etfsay'ableway."

#: src/compiler/disassem.lisp
msgid "Returns the absolute address of the current instruction in DSTATE."
msgstr ""
"Eturnsray ethay absoluteway addressway ofway ethay urrentcay instructionway "
"inway DSTATE."

#: src/compiler/disassem.lisp
msgid "Returns the absolute address of the next instruction in DSTATE."
msgstr ""
"Eturnsray ethay absoluteway addressway ofway ethay extnay instructionway "
"inway DSTATE."

#: src/compiler/disassem.lisp
msgid ""
"Offset of FUNCTION from the start of its code-component's instruction area."
msgstr ""
"Offsetway ofway FUNCTION omfray ethay tartsay ofway itsway odecay-"
"omponentcay's instructionway areaway."

#: src/compiler/disassem.lisp
msgid "Offset of FUNCTION from the start of its code-component."
msgstr ""
"Offsetway ofway FUNCTION omfray ethay tartsay ofway itsway odecay-"
"omponentcay."

#: src/compiler/disassem.lisp
msgid "Returns the length of the instruction area in CODE-COMPONENT."
msgstr ""
"Eturnsray ethay engthlay ofway ethay instructionway areaway inway CODE-"
"COMPONENT."

#: src/compiler/disassem.lisp
msgid "Returns the address of the instruction area in CODE-COMPONENT."
msgstr ""
"Eturnsray ethay addressway ofway ethay instructionway areaway inway CODE-"
"COMPONENT."

#: src/compiler/disassem.lisp
msgid "Returns the first function in CODE-COMPONENT."
msgstr "Eturnsray ethay irstfay unctionfay inway CODE-COMPONENT."

#: src/compiler/disassem.lisp
msgid "Possible ~A header word"
msgstr "Ossiblepay ~Away eaderhay ordway"

#: src/compiler/disassem.lisp
msgid ""
"Print the function-header (entry-point) pseudo-instruction at the current\n"
"  location in DSTATE to STREAM."
msgstr ""
"Intpray ethay unctionfay-eaderhay (entryway-ointpay) seudopay-instructionway "
"atway ethay urrentcay\n"
"  ocationlay inway DSTATE otay STREAM."

#: src/compiler/disassem.lisp
msgid ""
"Iterate through the instructions in SEGMENT, calling FUNCTION\n"
"  for each instruction, with arguments of CHUNK, STREAM, and DSTATE."
msgstr ""
"Iterateway roughthay ethay instructionsway inway SEGMENT, allingcay "
"FUNCTION\n"
"  orfay eachway instructionway, ithway argumentsway ofway CHUNK, STREAM, "
"andway DSTATE."

#: src/compiler/disassem.lisp
msgid ""
"Make an initial non-printing disassembly pass through DSTATE, noting any\n"
"  addresses that are referenced by instructions in this segment."
msgstr ""
"Akemay anway initialway onnay-intingpray isassemblyday asspay roughthay "
"DSTATE, otingnay anyway\n"
"  addressesway atthay areway eferencedray ybay instructionsway inway isthay "
"egmentsay."

#: src/compiler/disassem.lisp
msgid ""
"If any labels in DSTATE have been added since the last call to this\n"
"  function, give them label-numbers, enter them in the hash-table, and make\n"
"  sure the label list is in sorted order."
msgstr ""
"Ifway anyway abelslay inway DSTATE avehay eenbay addedway incesay ethay "
"astlay allcay otay isthay\n"
"  unctionfay, ivegay emthay abellay-umbersnay, enterway emthay inway ethay "
"ashhay-abletay, andway akemay\n"
"  uresay ethay abellay istlay isway inway ortedsay orderway."

#: src/compiler/disassem.lisp
msgid "Get the instruction-space from PARAMS, creating it if necessary."
msgstr ""
"Etgay ethay instructionway-acespay omfray PARAMS, eatingcray itway ifway "
"ecessarynay."

#: src/compiler/disassem.lisp
msgid ""
"Print the current address in DSTATE to STREAM, plus any labels that\n"
"  correspond to it, and leave the cursor in the instruction column."
msgstr ""
"Intpray ethay urrentcay addressway inway DSTATE otay STREAM, usplay anyway "
"abelslay atthay\n"
"  orrespondcay otay itway, andway eavelay ethay ursorcay inway ethay "
"instructionway olumncay."

#: src/compiler/disassem.lisp
msgid ""
"Print a newline to STREAM, inserting any pending notes in DSTATE as\n"
"  end-of-line comments.  If there is more than one note, a separate line\n"
"  will be used for each one."
msgstr ""
"Intpray away ewlinenay otay STREAM, insertingway anyway endingpay otesnay "
"inway DSTATE asway\n"
"  endway-ofway-inelay ommentscay.  Ifway erethay isway oremay anthay oneway "
"otenay, away eparatesay inelay\n"
"  illway ebay usedway orfay eachway oneway."

#: src/compiler/disassem.lisp
msgid "Disassemble NUM bytes to STREAM as simple `BYTE' instructions"
msgstr ""
"Isassembleday NUM ytesbay otay STREAM asway implesay `BYTE' instructionsway"

#: src/compiler/disassem.lisp
msgid "Disassemble NUM machine-words to STREAM as simple `WORD' instructions"
msgstr ""
"Isassembleday NUM achinemay-ordsway otay STREAM asway implesay `WORD' "
"instructionsway"

#: src/compiler/disassem.lisp
msgid "Make a disassembler-state object."
msgstr "Akemay away isassemblerday-tatesay objectway."

#: src/compiler/disassem.lisp
msgid ""
"Return a memory segment located at the system-area-pointer returned by\n"
"  SAP-MAKER and LENGTH bytes long in the disassem-state object DSTATE.\n"
"  Optional keyword arguments include :VIRTUAL-LOCATION (by default the same "
"as\n"
"  the address), :DEBUG-FUNCTION, :SOURCE-FORM-CACHE (a source-form-cache\n"
"  object), and :HOOKS (a list of offs-hook objects)."
msgstr ""
"Eturnray away emorymay egmentsay ocatedlay atway ethay ystemsay-areaway-"
"ointerpay eturnedray ybay\n"
"  SAP-MAKER andway LENGTH ytesbay onglay inway ethay isassemday-tatesay "
"objectway DSTATE.\n"
"  Optionalway eywordkay argumentsway includeway :VIRTUAL-LOCATION (ybay "
"efaultday ethay amesay asway\n"
"  ethay addressway), :DEBUG-FUNCTION, :SOURCE-FORM-CACHE (away ourcesay-"
"ormfay-achecay\n"
"  objectway), andway :HOOKS (away istlay ofway offsway-ookhay objectsway)."

#: src/compiler/disassem.lisp
msgid "Code-header ~s: size: ~s, trace-table-offset: ~s~%"
msgstr "Odecay-eaderhay ~s: izesay: ~s, acetray-abletay-offsetway: ~s~%"

#: src/compiler/disassem.lisp
msgid "Fun-header ~s at offset ~d (words): ~s~a => ~s~%"
msgstr "Unfay-eaderhay ~s atway offsetway ~d (ordsway): ~s~away => ~s~%"

#: src/compiler/disassem.lisp
msgid "The source file ~s no longer seems to exist"
msgstr "Ethay ourcesay ilefay ~s onay ongerlay eemssay otay existway"

#: src/compiler/disassem.lisp
msgid "No start positions map"
msgstr "Onay tartsay ositionspay apmay"

#: src/compiler/disassem.lisp
msgid ""
"Source file ~s has been modified; ~@\n"
"\t\t\t\t\t Using form offset instead of file index"
msgstr ""
"Ourcesay ilefay ~s ashay eenbay odifiedmay; ~@\n"
"\t\t\t\t\t Usingway ormfay offsetway insteadway ofway ilefay indexway"

#: src/compiler/disassem.lisp
msgid ""
"Bogus form-number in form!  The source file has probably ~@\n"
"\t\t  been changed too much to cope with"
msgstr ""
"Ogusbay ormfay-umbernay inway ormfay!  Ethay ourcesay ilefay ashay "
"obablypray ~@\n"
"\t\t  eenbay angedchay ootay uchmay otay opecay ithway"

#: src/compiler/disassem.lisp
msgid "Return the vector of debug-variables currently associated with DSTATE."
msgstr ""
"Eturnray ethay ectorvay ofway ebugday-ariablesvay urrentlycay associatedway "
"ithway DSTATE."

#: src/compiler/disassem.lisp
msgid ""
"Given the OFFSET of a location within the location-group called LG-NAME,\n"
"  see if there's a current mapping to a source variable in DSTATE, and if "
"so,\n"
"  return the offset of that variable in the current debug-variable vector."
msgstr ""
"Ivengay ethay OFFSET ofway away ocationlay ithinway ethay ocationlay-oupgray "
"alledcay LG-NAME,\n"
"  eesay ifway erethay's away urrentcay appingmay otay away ourcesay "
"ariablevay inway DSTATE, andway ifway osay,\n"
"  eturnray ethay offsetway ofway atthay ariablevay inway ethay urrentcay "
"ebugday-ariablevay ectorvay."

#: src/compiler/disassem.lisp
msgid ""
"Return a new vector which has the same contents as the old one VEC, plus\n"
"  new cells (for a total size of NEW-LEN).  The additional elements are\n"
"  initailized to INITIAL-ELEMENT."
msgstr ""
"Eturnray away ewnay ectorvay ichwhay ashay ethay amesay ontentscay asway "
"ethay oldway oneway VEC, usplay\n"
"  ewnay ellscay (orfay away otaltay izesay ofway NEW-LEN).  Ethay "
"additionalway elementsway areway\n"
"  initailizedway otay INITIAL-ELEMENT."

#: src/compiler/disassem.lisp
msgid ""
"Returns a STORAGE-INFO struction describing the object-to-source\n"
"  variable mappings from DEBUG-FUNCTION."
msgstr ""
"Eturnsray away STORAGE-INFO uctionstray escribingday ethay objectway-otay-"
"ourcesay\n"
"  ariablevay appingsmay omfray DEBUG-FUNCTION."

#: src/compiler/disassem.lisp
msgid ""
"Add hooks to track to track the source code in SEGMENT during\n"
"  disassembly.  SFCACHE can be either NIL or it can be a SOURCE-FORM-CACHE\n"
"  structure, in which case it is used to cache forms from files."
msgstr ""
"Addway ookshay otay acktray otay acktray ethay ourcesay odecay inway SEGMENT "
"uringday\n"
"  isassemblyday.  SFCACHE ancay ebay eitherway NIL orway itway ancay ebay "
"away SOURCE-FORM-CACHE\n"
"  ucturestray, inway ichwhay asecay itway isway usedway otay achecay ormsfay "
"omfray ilesfay."

#: src/compiler/disassem.lisp
msgid "No-arg-parsing entry point"
msgstr "Onay-argway-arsingpay entryway ointpay"

#: src/compiler/disassem.lisp
msgid "~s entry point"
msgstr "~s entryway ointpay"

#: src/compiler/disassem.lisp
msgid "Return the PC of FUNCTION's header."
msgstr "Eturnray ethay PC ofway FUNCTION's eaderhay."

#: src/compiler/disassem.lisp
msgid "If non-NIL, disassemble flets/labels too"
msgstr "Ifway onnay-NIL, isassembleday etsflay/abelslay ootay"

#: src/compiler/disassem.lisp
msgid ""
"Returns a list of the segments of memory containing machine code\n"
"  instructions for FUNCTION."
msgstr ""
"Eturnsray away istlay ofway ethay egmentssay ofway emorymay ontainingcay "
"achinemay odecay\n"
"  instructionsway orfay FUNCTION."

#: src/compiler/disassem.lisp
msgid ""
"Returns a list of the segments of memory containing machine code\n"
"  instructions for the code-component CODE.  If START-OFFS and/or LENGTH is\n"
"  supplied, only that part of the code-segment is used (but these are\n"
"  constrained to lie within the code-segment)."
msgstr ""
"Eturnsray away istlay ofway ethay egmentssay ofway emorymay ontainingcay "
"achinemay odecay\n"
"  instructionsway orfay ethay odecay-omponentcay CODE.  Ifway START-OFFS "
"andway/orway LENGTH isway\n"
"  uppliedsay, onlyway atthay artpay ofway ethay odecay-egmentsay isway "
"usedway (utbay esethay areway\n"
"  onstrainedcay otay ielay ithinway ethay odecay-egmentsay)."

#: src/compiler/disassem.lisp
msgid ""
"Return the address of the instructions for function and its length.\n"
"  The length is computed using a heuristic, and so may not be accurate."
msgstr ""
"Eturnray ethay addressway ofway ethay instructionsway orfay unctionfay "
"andway itsway engthlay.\n"
"  Ethay engthlay isway omputedcay usingway away euristichay, andway osay "
"aymay otnay ebay accurateway."

#: src/compiler/disassem.lisp
msgid ""
"Returns two values:  the amount by which the last instruction in the\n"
"  segment goes past the end of the segment, and the offset of the end of "
"the\n"
"  segment from the beginning of that instruction.  If all instructions fit\n"
"  perfectly, this will return 0 and 0."
msgstr ""
"Eturnsray wotay aluesvay:  ethay amountway ybay ichwhay ethay astlay "
"instructionway inway ethay\n"
"  egmentsay oesgay astpay ethay endway ofway ethay egmentsay, andway ethay "
"offsetway ofway ethay endway ofway ethay\n"
"  egmentsay omfray ethay eginningbay ofway atthay instructionway.  Ifway "
"allway instructionsway itfay\n"
"  erfectlypay, isthay illway eturnray 0 andway 0."

#: src/compiler/disassem.lisp
msgid ""
"Computes labels for all the memory segments in SEGLIST and adds them to\n"
"  DSTATE.  It's important to call this function with all the segments "
"you're\n"
"  interested in, so it can find references from one to another."
msgstr ""
"Omputescay abelslay orfay allway ethay emorymay egmentssay inway SEGLIST "
"andway addsway emthay otay\n"
"  DSTATE.  Itway's importantway otay allcay isthay unctionfay ithway allway "
"ethay egmentssay ouyay'eray\n"
"  interestedway inway, osay itway ancay indfay eferencesray omfray oneway "
"otay anotherway."

#: src/compiler/disassem.lisp
msgid "Disassemble the machine code instructions in SEGMENT to STREAM."
msgstr ""
"Isassembleday ethay achinemay odecay instructionsway inway SEGMENT otay "
"STREAM."

#: src/compiler/disassem.lisp
msgid ""
"Disassemble the machine code instructions in each memory segment in\n"
"  SEGMENTS in turn to STREAM."
msgstr ""
"Isassembleday ethay achinemay odecay instructionsway inway eachway emorymay "
"egmentsay inway\n"
"  SEGMENTS inway urntay otay STREAM."

#: src/compiler/disassem.lisp
msgid "Disassemble the machine code instructions for FUNCTION."
msgstr "Isassembleday ethay achinemay odecay instructionsway orfay FUNCTION."

#: src/compiler/disassem.lisp
msgid "Cannot compile a lexical closure"
msgstr "Annotcay ompilecay away exicallay osureclay"

#: src/compiler/disassem.lisp
msgid "Can't make a compiled function from ~S"
msgstr "Ancay't akemay away ompiledcay unctionfay omfray ~S"

#: src/compiler/disassem.lisp
msgid "Default value for :radix argument for disassem:disassemble"
msgstr ""

#: src/compiler/disassem.lisp
#, fuzzy
msgid ""
"Disassemble the machine code associated with OBJECT, which can be a\n"
"  function, a lambda expression, or a symbol with a function definition.  "
"If\n"
"  it is not already compiled, the compiler is called to produce something "
"to\n"
"  disassemble.\n"
"\n"
"  :Stream stream\n"
"      The dissassembly is written to this stream.\n"
"  :Use-labels\n"
"      Labels are generated instead of using instruction addresses.\n"
"  :Base\n"
"  :Case\n"
"  :Radix\n"
"      The disassembler uses the specified base, case, and radix when\n"
"      printing the disassembled code.  The default values are 16,\n"
"      :downcase, and *disassemble-print-radix*, respectively."
msgstr ""
"Isassembleday ethay achinemay odecay associatedway ithway OBJECT, ichwhay "
"ancay ebay away\n"
"  unctionfay, away ambdalay expressionway, orway away ymbolsay ithway away "
"unctionfay efinitionday.  Ifway\n"
"  itway isway otnay alreadyway ompiledcay, ethay ompilercay isway alledcay "
"otay oducepray omethingsay otay\n"
"  isassembleday.\n"
"\n"
"  :Eamstray eamstray\n"
"      Ethay issassemblyday isway ittenwray otay isthay eamstray.\n"
"  :Useway-abelslay\n"
"      Abelslay areway eneratedgay insteadway ofway usingway instructionway "
"addressesway.\n"
"  :Asebay\n"
"  :Asecay\n"
"  :Adixray\n"
"      Ethay isassemblerday usesway ethay ecifiedspay asebay, asecay, andway "
"adixray enwhay\n"
"      intingpray ethay isassembledday odecay.  Ethay efaultday aluesvay "
"areway 16,\n"
"      :owncaseday, andway *print-radix*, espectivelyray."

#: src/compiler/disassem.lisp
msgid ""
"Disassembles the given area of memory starting at ADDRESS and\n"
"  LENGTH (octets) long.  Note that if CODE-COMPONENT is NIL and this\n"
"  memory could move during a GC, you'd better disable it around the\n"
"  call to this function.  ADDRESS can be either an integer or a\n"
"  system-area-pointer.\n"
"\n"
"  :Stream stream\n"
"      The dissassembly is written to this stream.\n"
"  :Use-labels\n"
"      Labels are generated instead of using instruction addresses.\n"
"  :Base\n"
"  :Case\n"
"  :Radix\n"
"      The disassembler uses the specified base, case, and radix when\n"
"      printing the disassembled code.  The default values are 16,\n"
"      :downcase, and *print-radix*, respectively. "
msgstr ""
"Isassemblesday ethay ivengay areaway ofway emorymay tartingsay atway ADDRESS "
"andway\n"
"  LENGTH (octetsway) onglay.  Otenay atthay ifway CODE-COMPONENT isway NIL "
"andway isthay\n"
"  emorymay ouldcay ovemay uringday away GC, ouyay'd etterbay isableday itway "
"aroundway ethay\n"
"  allcay otay isthay unctionfay.  ADDRESS ancay ebay eitherway anway "
"integerway orway away\n"
"  ystemsay-areaway-ointerpay.\n"
"\n"
"  :Eamstray eamstray\n"
"      Ethay issassemblyday isway ittenwray otay isthay eamstray.\n"
"  :Useway-abelslay\n"
"      Abelslay areway eneratedgay insteadway ofway usingway instructionway "
"addressesway.\n"
"  :Asebay\n"
"  :Asecay\n"
"  :Adixray\n"
"      Ethay isassemblerday usesway ethay ecifiedspay asebay, asecay, andway "
"adixray enwhay\n"
"      intingpray ethay isassembledday odecay.  Ethay efaultday aluesvay "
"areway 16,\n"
"      :owncaseday, andway *print-radix*, espectivelyray. "

#: src/compiler/disassem.lisp
msgid " Address ~x not in the code component ~s."
msgstr " Addressway ~x otnay inway ethay odecay omponentcay ~s."

#: src/compiler/disassem.lisp
msgid ""
"Disassemble the machine code instructions associated with\n"
"  CODE-COMPONENT (this may include multiple entry points)."
msgstr ""
"Isassembleday ethay achinemay odecay instructionsway associatedway ithway\n"
"  CODE-COMPONENT (isthay aymay includeway ultiplemay entryway ointspay)."

#: src/compiler/disassem.lisp
msgid ""
"Disassemble the machine code instructions associated with\n"
"  ASSEM-SEGMENT (of type new-assem:segment)."
msgstr ""
"Isassembleday ethay achinemay odecay instructionsway associatedway ithway\n"
"  ASSEM-SEGMENT (ofway ypetay ewnay-assemway:egmentsay)."

#: src/compiler/disassem.lisp
msgid ""
"An alist of (SYMBOL-SLOT-OFFSET . ACCESS-FUNCTION-NAME) for slots in a\n"
"symbol object that we know about."
msgstr ""
"Anway alistway ofway (SYMBOL-SLOT-OFFSET . ACCESS-FUNCTION-NAME) orfay "
"otsslay inway away\n"
"ymbolsay objectway atthay eway nowkay aboutway."

#: src/compiler/disassem.lisp
msgid ""
"Given ADDRESS, try and figure out if which slot of which symbol is being\n"
"  refered to.  Of course we can just give up, so it's not a big deal...\n"
"  Returns two values, the symbol and the name of the access function of the\n"
"  slot."
msgstr ""
"Ivengay ADDRESS, ytray andway igurefay outway ifway ichwhay otslay ofway "
"ichwhay ymbolsay isway eingbay\n"
"  eferedray otay.  Ofway oursecay eway ancay ustjay ivegay upway, osay "
"itway's otnay away igbay ealday...\n"
"  Eturnsray wotay aluesvay, ethay ymbolsay andway ethay amenay ofway ethay "
"accessway unctionfay ofway ethay\n"
"  otslay."

#: src/compiler/disassem.lisp
msgid ""
"Given a BYTE-OFFSET from NIL, try and figure out if which slot of which\n"
"  symbol is being refered to.  Of course we can just give up, so it's not a "
"big\n"
"  deal...  Returns two values, the symbol and the access function."
msgstr ""
"Ivengay away BYTE-OFFSET omfray NIL, ytray andway igurefay outway ifway "
"ichwhay otslay ofway ichwhay\n"
"  ymbolsay isway eingbay eferedray otay.  Ofway oursecay eway ancay ustjay "
"ivegay upway, osay itway's otnay away igbay\n"
"  ealday...  Eturnsray wotay aluesvay, ethay ymbolsay andway ethay accessway "
"unctionfay."

#: src/compiler/disassem.lisp
msgid "Returns the lisp object located BYTE-OFFSET from NIL."
msgstr "Eturnsray ethay isplay objectway ocatedlay BYTE-OFFSET omfray NIL."

#: src/compiler/disassem.lisp
msgid ""
"Returns two values; the lisp-object located at BYTE-OFFSET in the constant\n"
"  area of the code-object in the current segment and T, or NIL and NIL if\n"
"  there is no code-object in the current segment."
msgstr ""
"Eturnsray wotay aluesvay; ethay isplay-objectway ocatedlay atway BYTE-OFFSET "
"inway ethay onstantcay\n"
"  areaway ofway ethay odecay-objectway inway ethay urrentcay egmentsay "
"andway T, orway NIL andway NIL ifway\n"
"  erethay isway onay odecay-objectway inway ethay urrentcay egmentsay."

#: src/compiler/disassem.lisp
msgid "Build an address-name hash-table from the name-address hash"
msgstr ""
"Uildbay anway addressway-amenay ashhay-abletay omfray ethay amenay-"
"addressway ashhay"

#: src/compiler/disassem.lisp
msgid ""
"Returns the name of the primitive lisp assembler routine or foreign\n"
"  symbol located at ADDRESS, or NIL if there isn't one."
msgstr ""
"Eturnsray ethay amenay ofway ethay imitivepray isplay assemblerway outineray "
"orway oreignfay\n"
"  ymbolsay ocatedlay atway ADDRESS, orway NIL ifway erethay isnway't oneway."

#: src/compiler/disassem.lisp
msgid ""
"Store NOTE (which can be either a string or a function with a single\n"
"  stream argument) to be printed as an end-of-line comment after the "
"current\n"
"  instruction is disassembled."
msgstr ""
"Toresay NOTE (ichwhay ancay ebay eitherway away ingstray orway away "
"unctionfay ithway away inglesay\n"
"  eamstray argumentway) otay ebay intedpray asway anway endway-ofway-inelay "
"ommentcay afterway ethay urrentcay\n"
"  instructionway isway isassembledday."

#: src/compiler/disassem.lisp
msgid ""
"Store a note about the lisp constant located BYTE-OFFSET bytes from the\n"
"  current code-component, to be printed as an end-of-line comment after the\n"
"  current instruction is disassembled."
msgstr ""
"Toresay away otenay aboutway ethay isplay onstantcay ocatedlay BYTE-OFFSET "
"ytesbay omfray ethay\n"
"  urrentcay odecay-omponentcay, otay ebay intedpray asway anway endway-ofway-"
"inelay ommentcay afterway ethay\n"
"  urrentcay instructionway isway isassembledday."

#: src/compiler/disassem.lisp
msgid ""
"Store a note about the lisp constant located at ADDR in the\n"
"  current code-component, to be printed as an end-of-line comment after the\n"
"  current instruction is disassembled."
msgstr ""
"Toresay away otenay aboutway ethay isplay onstantcay ocatedlay atway ADDR "
"inway ethay\n"
"  urrentcay odecay-omponentcay, otay ebay intedpray asway anway endway-ofway-"
"inelay ommentcay afterway ethay\n"
"  urrentcay instructionway isway isassembledday."

#: src/compiler/disassem.lisp
msgid ""
"If the memory address located NIL-BYTE-OFFSET bytes from the constant NIL\n"
"  is a valid slot in a symbol, store a note describing which symbol and "
"slot,\n"
"  to be printed as an end-of-line comment after the current instruction is\n"
"  disassembled.  Returns non-NIL iff a note was recorded."
msgstr ""
"Ifway ethay emorymay addressway ocatedlay NIL-BYTE-OFFSET ytesbay omfray "
"ethay onstantcay NIL\n"
"  isway away alidvay otslay inway away ymbolsay, toresay away otenay "
"escribingday ichwhay ymbolsay andway otslay,\n"
"  otay ebay intedpray asway anway endway-ofway-inelay ommentcay afterway "
"ethay urrentcay instructionway isway\n"
"  isassembledday.  Eturnsray onnay-NIL iffway away otenay asway ecordedray."

#: src/compiler/disassem.lisp
msgid ""
"If the memory address located NIL-BYTE-OFFSET bytes from the constant NIL\n"
"  is a valid lisp object, store a note describing which symbol and slot, to\n"
"  be printed as an end-of-line comment after the current instruction is\n"
"  disassembled.  Returns non-NIL iff a note was recorded."
msgstr ""
"Ifway ethay emorymay addressway ocatedlay NIL-BYTE-OFFSET ytesbay omfray "
"ethay onstantcay NIL\n"
"  isway away alidvay isplay objectway, toresay away otenay escribingday "
"ichwhay ymbolsay andway otslay, otay\n"
"  ebay intedpray asway anway endway-ofway-inelay ommentcay afterway ethay "
"urrentcay instructionway isway\n"
"  isassembledday.  Eturnsray onnay-NIL iffway away otenay asway ecordedray."

#: src/compiler/disassem.lisp
msgid ""
"If ADDRESS is the address of a primitive assembler routine or\n"
"  foreign symbol, store a note describing which one, to be printed as\n"
"  an end-of-line comment after the current instruction is disassembled.\n"
"  Returns non-NIL iff a note was recorded.  If NOTE-ADDRESS-P is non-NIL, a\n"
"  note of the address is also made."
msgstr ""
"Ifway ADDRESS isway ethay addressway ofway away imitivepray assemblerway "
"outineray orway\n"
"  oreignfay ymbolsay, toresay away otenay escribingday ichwhay oneway, otay "
"ebay intedpray asway\n"
"  anway endway-ofway-inelay ommentcay afterway ethay urrentcay "
"instructionway isway isassembledday.\n"
"  Eturnsray onnay-NIL iffway away otenay asway ecordedray.  Ifway NOTE-"
"ADDRESS-P isway onnay-NIL, away\n"
"  otenay ofway ethay addressway isway alsoway ademay."

#: src/compiler/disassem.lisp
msgid ""
"If NIL-BYTE-OFFSET is the offset of static function, store a note\n"
"  describing which one, to be printed as an end-of-line comment after\n"
"  the current instruction is disassembled.  Returns non-NIL iff a note\n"
"  was recorded."
msgstr ""
"Ifway NIL-BYTE-OFFSET isway ethay offsetway ofway taticsay unctionfay, "
"toresay away otenay\n"
"  escribingday ichwhay oneway, otay ebay intedpray asway anway endway-ofway-"
"inelay ommentcay afterway\n"
"  ethay urrentcay instructionway isway isassembledday.  Eturnsray onnay-NIL "
"iffway away otenay\n"
"  asway ecordedray."

#: src/compiler/disassem.lisp
msgid ""
"If there's a valid mapping from OFFSET in the storage class SC-NAME to a\n"
"  source variable, make a note of the source-variable name, to be printed "
"as\n"
"  an end-of-line comment after the current instruction is disassembled.\n"
"  Returns non-NIL iff a note was recorded."
msgstr ""
"Ifway erethay's away alidvay appingmay omfray OFFSET inway ethay toragesay "
"assclay SC-NAME otay away\n"
"  ourcesay ariablevay, akemay away otenay ofway ethay ourcesay-ariablevay "
"amenay, otay ebay intedpray asway\n"
"  anway endway-ofway-inelay ommentcay afterway ethay urrentcay "
"instructionway isway isassembledday.\n"
"  Eturnsray onnay-NIL iffway away otenay asway ecordedray."

#: src/compiler/disassem.lisp
msgid ""
"If there's a valid mapping from OFFSET in the storage-base called SB-NAME\n"
"  to a source variable, make a note equating ASSOC-WITH with the\n"
"  source-variable name, to be printed as an end-of-line comment after the\n"
"  current instruction is disassembled.  Returns non-NIL iff a note was\n"
"  recorded."
msgstr ""
"Ifway erethay's away alidvay appingmay omfray OFFSET inway ethay toragesay-"
"asebay alledcay SB-NAME\n"
"  otay away ourcesay ariablevay, akemay away otenay equatingway ASSOC-WITH "
"ithway ethay\n"
"  ourcesay-ariablevay amenay, otay ebay intedpray asway anway endway-ofway-"
"inelay ommentcay afterway ethay\n"
"  urrentcay instructionway isway isassembledday.  Eturnsray onnay-NIL iffway "
"away otenay asway\n"
"  ecordedray."

#: src/compiler/disassem.lisp
msgid ""
"When called from an error break instruction's :DISASSEM-CONTROL (or\n"
"  :DISASSEM-PRINTER) function, will correctly deal with printing the\n"
"  arguments to the break.\n"
"\n"
"  ERROR-PARSE-FUN should be a function that accepts:\n"
"    1) a SYSTEM-AREA-POINTER\n"
"    2) a BYTE-OFFSET from the SAP to begin at\n"
"    3) optionally, LENGTH-ONLY, which if non-NIL, means to only return\n"
"       the byte length of the arguments (to avoid unnecessary consing)\n"
"  It should read information from the SAP starting at BYTE-OFFSET, and "
"return\n"
"  four values:\n"
"    1) the error number\n"
"    2) the total length, in bytes, of the information\n"
"    3) a list of SC-OFFSETs of the locations of the error parameters\n"
"    4) a list of the length (as read from the SAP), in bytes, of each of "
"the\n"
"       return-values."
msgstr ""
"Enwhay alledcay omfray anway errorway eakbray instructionway's :DISASSEM-"
"CONTROL (orway\n"
"  :DISASSEM-PRINTER) unctionfay, illway orrectlycay ealday ithway intingpray "
"ethay\n"
"  argumentsway otay ethay eakbray.\n"
"\n"
"  ERROR-PARSE-FUN ouldshay ebay away unctionfay atthay acceptsway:\n"
"    1) away SYSTEM-AREA-POINTER\n"
"    2) away BYTE-OFFSET omfray ethay SAP otay eginbay atway\n"
"    3) optionallyway, LENGTH-ONLY, ichwhay ifway onnay-NIL, eansmay otay "
"onlyway eturnray\n"
"       ethay ytebay engthlay ofway ethay argumentsway (otay avoidway "
"unnecessaryway onsingcay)\n"
"  Itway ouldshay eadray informationway omfray ethay SAP tartingsay atway "
"BYTE-OFFSET, andway eturnray\n"
"  ourfay aluesvay:\n"
"    1) ethay errorway umbernay\n"
"    2) ethay otaltay engthlay, inway ytesbay, ofway ethay informationway\n"
"    3) away istlay ofway SC-Offsetsway ofway ethay ocationslay ofway ethay "
"errorway arameterspay\n"
"    4) away istlay ofway ethay engthlay (asway eadray omfray ethay SAP), "
"inway ytesbay, ofway eachway ofway ethay\n"
"       eturnray-aluesvay."

#: src/compiler/new-assem.lisp
msgid "Set up the assembler."
msgstr "Etsay upway ethay assemblerway."

#: src/compiler/new-assem.lisp
msgid ""
"Execute BODY (as a progn) without scheduling any of the instructions\n"
"   generated inside it.  DO NOT throw or return-from out of it."
msgstr ""
"Executeway BODY (asway away ognpray) ithoutway edulingschay anyway ofway "
"ethay instructionsway\n"
"   eneratedgay insideway itway.  DO NOT rowthay orway eturnray-omfray outway "
"ofway itway."

#: src/compiler/new-assem.lisp
msgid "Emit BYTE to SEGMENT."
msgstr "Emitway BYTE otay SEGMENT."

#: src/compiler/new-assem.lisp
msgid "Output AMOUNT zeros (in bytes) to SEGMENT."
msgstr "Outputway AMOUNT eroszay (inway ytesbay) otay SEGMENT."

#: src/compiler/new-assem.lisp
msgid "Attempt to emit ~S for the second time."
msgstr "Attemptway otay emitway ~S orfay ethay econdsay imetay."

#: src/compiler/new-assem.lisp
msgid ""
"Note that the instruction stream has to be back-patched when label "
"positions\n"
"   are finally known.  SIZE bytes are reserved in SEGMENT, and function "
"will\n"
"   be called with two arguments: the segment and the position.  The "
"function\n"
"   should look at the position and the position of any labels it wants to\n"
"   and emit the correct sequence.  (And it better be the same size as "
"SIZE).\n"
"   SIZE can be zero, which is useful if you just want to find out where "
"things\n"
"   ended up."
msgstr ""
"Otenay atthay ethay instructionway eamstray ashay otay ebay ackbay-atchedpay "
"enwhay abellay ositionspay\n"
"   areway inallyfay nownkay.  SIZE ytesbay areway eservedray inway SEGMENT, "
"andway unctionfay illway\n"
"   ebay alledcay ithway wotay argumentsway: ethay egmentsay andway ethay "
"ositionpay.  Ethay unctionfay\n"
"   ouldshay ooklay atway ethay ositionpay andway ethay ositionpay ofway "
"anyway abelslay itway antsway otay\n"
"   andway emitway ethay orrectcay equencesay.  (Andway itway etterbay ebay "
"ethay amesay izesay asway SIZE).\n"
"   SIZE ancay ebay erozay, ichwhay isway usefulway ifway ouyay ustjay antway "
"otay indfay outway erewhay ingsthay\n"
"   endedway upway."

#: src/compiler/new-assem.lisp
msgid ""
"Note that the instruction stream here depends on the actual positions of\n"
"   various labels, so can't be output until label positions are known.  "
"Space\n"
"   is made in SEGMENT for at least SIZE bytes.  When all output has been\n"
"   generated, the MAYBE-SHRINK functions for all choosers are called with\n"
"   three arguments: the segment, the position, and a magic value.  The "
"MAYBE-\n"
"   SHRINK decides if it can use a shorter sequence, and if so, emits that\n"
"   sequence to the segment and returns T.  If it can't do better than the\n"
"   worst case, it should return NIL (without emitting anything).  When "
"calling\n"
"   LABEL-POSITION, it should pass it the position and the magic-value it "
"was\n"
"   passed so that LABEL-POSITION can return the correct result.  If the "
"chooser\n"
"   never decides to use a shorter sequence, the WORST-CASE-FUN will be "
"called,\n"
"   just like a BACK-PATCH.  (See EMIT-BACK-PATCH.)"
msgstr ""
"Otenay atthay ethay instructionway eamstray erehay ependsday onway ethay "
"actualway ositionspay ofway\n"
"   ariousvay abelslay, osay ancay't ebay outputway untilway abellay "
"ositionspay areway nownkay.  Acespay\n"
"   isway ademay inway SEGMENT orfay atway eastlay SIZE ytesbay.  Enwhay "
"allway outputway ashay eenbay\n"
"   eneratedgay, ethay MAYBE-SHRINK unctionsfay orfay allway ooserschay "
"areway alledcay ithway\n"
"   reethay argumentsway: ethay egmentsay, ethay ositionpay, andway away "
"agicmay aluevay.  Ethay MAYBE-\n"
"   SHRINK ecidesday ifway itway ancay useway away ortershay equencesay, "
"andway ifway osay, emitsway atthay\n"
"   equencesay otay ethay egmentsay andway eturnsray T.  Ifway itway ancay't "
"oday etterbay anthay ethay\n"
"   orstway asecay, itway ouldshay eturnray NIL (ithoutway emittingway "
"anythingway).  Enwhay allingcay\n"
"   LABEL-POSITION, itway ouldshay asspay itway ethay ositionpay andway ethay "
"agicmay-aluevay itway asway\n"
"   assedpay osay atthay LABEL-POSITION ancay eturnray ethay orrectcay "
"esultray.  Ifway ethay ooserchay\n"
"   evernay ecidesday otay useway away ortershay equencesay, ethay WORST-CASE-"
"FUN illway ebay alledcay,\n"
"   ustjay ikelay away BACK-PATCH.  (Eesay EMIT-BACK-PATCH.)"

#: src/compiler/new-assem.lisp
msgid "~S emitted ~D bytes, but claimed it's max was ~D"
msgstr "~S emittedway ~D ytesbay, utbay aimedclay itway's axmay asway ~D"

#: src/compiler/new-assem.lisp
msgid ""
"~S shrunk by ~D bytes, but claimed that it ~\n"
"\t\t\t    preserve ~D bits of alignment."
msgstr ""
"~S runkshay ybay ~D ytesbay, utbay aimedclay atthay itway ~\n"
"\t\t\t    eservepray ~D itsbay ofway alignmentway."

#: src/compiler/new-assem.lisp
msgid "Chooser ~S passed, but not before emitting ~D bytes."
msgstr "Ooserchay ~S assedpay, utbay otnay eforebay emittingway ~D ytesbay."

#: src/compiler/new-assem.lisp
msgid ""
"Alignment ~S needs more space now?  It was ~D, ~\n"
"\t\t\t    and is ~D now."
msgstr ""
"Alignmentway ~S eedsnay oremay acespay ownay?  Itway asway ~D, ~\n"
"\t\t\t    andway isway ~D ownay."

#: src/compiler/new-assem.lisp
msgid "~S emitted ~D bytes, but claimed it's was ~D"
msgstr "~S emittedway ~D ytesbay, utbay aimedclay itway's asway ~D"

#: src/compiler/new-assem.lisp
msgid "Execute BODY (as a progn) with SEGMENT as the current segment."
msgstr ""
"Executeway BODY (asway away ognpray) ithway SEGMENT asway ethay urrentcay "
"egmentsay."

#: src/compiler/new-assem.lisp
msgid "Duplicate nested labels: ~S"
msgstr "Uplicateday estednay abelslay: ~S"

#: src/compiler/new-assem.lisp
msgid "Emit the specified instruction to the current segment."
msgstr ""
"Emitway ethay ecifiedspay instructionway otay ethay urrentcay egmentsay."

#: src/compiler/new-assem.lisp
msgid "Unknown instruction: ~S"
msgstr "Unknownway instructionway: ~S"

#: src/compiler/new-assem.lisp
msgid "Emit LABEL at this location in the current segment."
msgstr "Emitway LABEL atway isthay ocationlay inway ethay urrentcay egmentsay."

#: src/compiler/new-assem.lisp
msgid "Emit an alignment restriction to the current segment."
msgstr ""
"Emitway anway alignmentway estrictionray otay ethay urrentcay egmentsay."

#: src/compiler/new-assem.lisp
msgid ""
"Return the current position for LABEL.  Chooser maybe-shrink functions\n"
"   should supply IF-AFTER and DELTA to assure correct results."
msgstr ""
"Eturnray ethay urrentcay ositionpay orfay LABEL.  Ooserchay aybemay-rinkshay "
"unctionsfay\n"
"   ouldshay upplysay IF-AFTER andway DELTA otay assureway orrectcay "
"esultsray."

#: src/compiler/new-assem.lisp
msgid ""
"Append OTHER-SEGMENT to the end of SEGMENT.  Don't use OTHER-SEGMENT\n"
"   for anything after this."
msgstr ""
"Appendway OTHER-SEGMENT otay ethay endway ofway SEGMENT.  Onday't useway "
"OTHER-SEGMENT\n"
"   orfay anythingway afterway isthay."

#: src/compiler/new-assem.lisp
msgid ""
"Does any final processing of SEGMENT and returns the total number of bytes\n"
"   covered by this segment."
msgstr ""
"Oesday anyway inalfay ocessingpray ofway SEGMENT andway eturnsray ethay "
"otaltay umbernay ofway ytesbay\n"
"   overedcay ybay isthay egmentsay."

#: src/compiler/new-assem.lisp
msgid ""
"Call FUNCTION on all the output accumulated in SEGMENT.  FUNCTION is called\n"
"   zero or more times with two arguments: a SAP and a number of bytes."
msgstr ""
"Allcay FUNCTION onway allway ethay outputway accumulatedway inway SEGMENT.  "
"FUNCTION isway alledcay\n"
"   erozay orway oremay imestay ithway wotay argumentsway: away SAP andway "
"away umbernay ofway ytesbay."

#: src/compiler/new-assem.lisp
msgid "Releases any output buffers held on to by segment."
msgstr ""
"Eleasesray anyway outputway uffersbay eldhay onway otay ybay egmentsay."

#: src/compiler/new-assem.lisp
msgid ""
"Byte spec ~S either overlaps another byte spec, or ~\n"
"\t\t    extends past the end in emitter ~S."
msgstr ""
"Ytebay ecspay ~S eitherway overlapsway anotherway ytebay ecspay, orway ~\n"
"\t\t    extendsway astpay ethay endway inway emitterway ~S."

#: src/compiler/new-assem.lisp
msgid "There are holes in emitter ~S."
msgstr "Erethay areway oleshay inway emitterway ~S."

#: src/compiler/new-assem.lisp
msgid "~D isn't an even multiple of ~D in emitter ~S"
msgstr "~D isnway't anway evenway ultiplemay ofway ~D inway emitterway ~S"

#: src/compiler/new-assem.lisp
msgid "Can only specify one emitter per instruction."
msgstr "Ancay onlyway ecifyspay oneway emitterway erpay instructionway."

#: src/compiler/new-assem.lisp
msgid "Can only specify delay once per instruction."
msgstr "Ancay onlyway ecifyspay elayday onceway erpay instructionway."

#: src/compiler/new-assem.lisp
msgid "Can only specify :vop-var once."
msgstr "Ancay onlyway ecifyspay :opvay-arvay onceway."

#: src/compiler/alloc.lisp
msgid ""
"defallocators {((name lambda-list [real-lambda-list]) thread-slot\n"
"                   (deinit-form*)\n"
"\t\t   (reinit-form*))}*"
msgstr ""
"efallocatorsday {((amenay ambdalay-istlay [ealray-ambdalay-istlay]) readthay-"
"otslay\n"
"                   (einitday-orm*fay)\n"
"\t\t   (einitray-orm*fay))}*"

#: src/compiler/knownfun.lisp
msgid "optimize"
msgstr "optimizeway"

#: src/compiler/knownfun.lisp
msgid "~S is not a known function."
msgstr "~S isway otnay away nownkay unctionfay."

#: src/compiler/main.lisp
msgid "The default value for the :Block-Compile argument to COMPILE-FILE."
msgstr ""
"Ethay efaultday aluevay orfay ethay :Ockblay-Ompilecay argumentway otay "
"COMPILE-FILE."

#: src/compiler/main.lisp
msgid "The default value for the :Byte-Compile argument to COMPILE-FILE."
msgstr ""
"Ethay efaultday aluevay orfay ethay :Ytebay-Ompilecay argumentway otay "
"COMPILE-FILE."

#: src/compiler/main.lisp
msgid ""
"Similar to *BYTE-COMPILE-DEFAULT*, but controls the compilation of top-"
"level\n"
"  forms (evaluated at load-time) when the :BYTE-COMPILE argument is :MAYBE\n"
"  (the default.)  When true, we decide to byte-compile."
msgstr ""
"Imilarsay otay *BYTE-COMPILE-DEFAULT*, utbay ontrolscay ethay ompilationcay "
"ofway optay-evellay\n"
"  ormsfay (evaluatedway atway oadlay-imetay) enwhay ethay :BYTE-COMPILE "
"argumentway isway :MAYBE\n"
"  (ethay efaultday.)  Enwhay uetray, eway ecideday otay ytebay-ompilecay."

#: src/compiler/main.lisp
msgid "Whether loop analysis should be done or not."
msgstr "Etherwhay ooplay analysisway ouldshay ebay oneday orway otnay."

#: src/compiler/main.lisp
msgid "Whether the compiler should record cross-reference information."
msgstr ""
"Etherwhay ethay ompilercay ouldshay ecordray osscray-eferenceray "
"informationway."

#: src/compiler/main.lisp
msgid "The default for the :VERBOSE argument to COMPILE-FILE."
msgstr "Ethay efaultday orfay ethay :VERBOSE argumentway otay COMPILE-FILE."

#: src/compiler/main.lisp
msgid "The default for the :PRINT argument to COMPILE-FILE."
msgstr "Ethay efaultday orfay ethay :PRINT argumentway otay COMPILE-FILE."

#: src/compiler/main.lisp
msgid "The default for the :PROGRESS argument to COMPILE-FILE."
msgstr "Ethay efaultday orfay ethay :PROGRESS argumentway otay COMPILE-FILE."

#: src/compiler/main.lisp
msgid ""
"The defaulted pathname of the file currently being compiled, or NIL if not\n"
"  compiling."
msgstr ""
"Ethay efaultedday athnamepay ofway ethay ilefay urrentlycay eingbay "
"ompiledcay, orway NIL ifway otnay\n"
"  ompilingcay."

#: src/compiler/main.lisp
msgid ""
"The TRUENAME of the file currently being compiled, or NIL if not\n"
"  compiling."
msgstr ""
"Ethay TRUENAME ofway ethay ilefay urrentlycay eingbay ompiledcay, orway NIL "
"ifway otnay\n"
"  ompilingcay."

#: src/compiler/main.lisp
msgid ""
"The user supplied source-info for the current compilation.  \n"
"  This is the :source-info argument to COMPILE-FROM-STREAM and will be\n"
"  stored in the INFO slot of the DEBUG-SOURCE in code components and \n"
"  in the user USER-INFO slot of STREAM-SOURCE-LOCATIONs."
msgstr ""
"Ethay userway uppliedsay ourcesay-infoway orfay ethay urrentcay "
"ompilationcay.  \n"
"  Isthay isway ethay :ourcesay-infoway argumentway otay COMPILE-FROM-STREAM "
"andway illway ebay\n"
"  toredsay inway ethay INFO otslay ofway ethay DEBUG-SOURCE inway odecay "
"omponentscay andway \n"
"  inway ethay userway USER-INFO otslay ofway STREAM-SOURCE-Ocationslay."

#: src/compiler/main.lisp
msgid ""
"The upper limit on the number of times that we will consecutively do IR1\n"
"  optimization that doesn't introduce any new code.  A finite limit is\n"
"  necessary, since type inference may take arbitrarily long to converge."
msgstr ""
"Ethay upperway imitlay onway ethay umbernay ofway imestay atthay eway illway "
"onsecutivelycay oday IR1\n"
"  optimizationway atthay oesnday't introduceway anyway ewnay odecay.  Away "
"initefay imitlay isway\n"
"  ecessarynay, incesay ypetay inferenceway aymay aketay arbitrarilyway "
"onglay otay onvergecay."

#: src/compiler/main.lisp
msgid "~|~%Disassembly of code for ~S~2%"
msgstr "~|~%Isassemblyday ofway odecay orfay ~S~2%"

#: src/compiler/main.lisp
msgid "~:[~;Byte ~]Compiling ~A: "
msgstr "~:[~;Ytebay ~]Ompilingcay ~Away: "

#: src/compiler/main.lisp
msgid "Undefined ~(~A~) ~S~@[ ~A~]"
msgstr "Undefinedway ~(~Away~) ~S~@[ ~Away~]"

#: src/compiler/main.lisp
msgid "~D more use~:P of undefined ~(~A~) ~S."
msgstr "~D oremay useway~:P ofway undefinedway ~(~Away~) ~S."

#: src/compiler/main.lisp
msgid ""
"~:[This ~(~A~) is~;These ~(~A~)s are~] undefined:~\n"
"\t\t~%  ~{~<~%  ~1:;~S~>~^ ~}"
msgstr ""
"~:[Isthay ~(~Away~) isway~;Esethay ~(~Away~)s areway~] undefinedway:~\n"
"\t\t~%  ~{~<~%  ~1:;~S~>~^ ~}"

#: src/compiler/main.lisp
msgid ""
"~2&; Compilation unit ~:[finished~;aborted~].~\n"
"      ~[~:;~:*~&;   ~D fatal error~:P~]~\n"
"      ~[~:;~:*~&;   ~D error~:P~]~\n"
"      ~[~:;~:*~&;   ~D warning~:P~]~\n"
"      ~[~:;~:*~&;   ~D note~:P~]~2%"
msgstr ""
"~2&; Ompilationcay unitway ~:[inishedfay~;abortedway~].~\n"
"      ~[~:;~:*~&;   ~D atalfay errorway~:P~]~\n"
"      ~[~:;~:*~&;   ~D errorway~:P~]~\n"
"      ~[~:;~:*~&;   ~D arningway~:P~]~\n"
"      ~[~:;~:*~&;   ~D otenay~:P~]~2%"

#: src/compiler/main.lisp
msgid "~|~%;;;; Component: ~S~2%"
msgstr "~|~%;;;; Omponentcay: ~S~2%"

#: src/compiler/main.lisp
msgid "~%~|~%;;;; IR2 component: ~S~2%"
msgstr "~%~|~%;;;; IR2 omponentcay: ~S~2%"

#: src/compiler/main.lisp
msgid "Entries:~%"
msgstr "Entriesway:~%"

#: src/compiler/main.lisp
msgid "~4TL~D: ~S~:[~; [Closure]~]~%"
msgstr "~4TL~D: ~S~:[~; [Osureclay]~]~%"

#: src/compiler/main.lisp
msgid "Read error at ~D:~% \"~A/\\~A\"~%~A"
msgstr "Eadray errorway atway ~D:~% \"~Away/\\~Away\"~%~Away"

#: src/compiler/main.lisp
msgid "Unable to recover from read error."
msgstr "Unableway otay ecoverray omfray eadray errorway."

#: src/compiler/main.lisp
msgid "Read error in form starting at ~D:~%~@[ \"~A\"~%~]~A"
msgstr ""
"Eadray errorway inway ormfay tartingsay atway ~D:~%~@[ \"~Away\"~%~]~Away"

#: src/compiler/ir1tran.lisp src/compiler/main.lisp
msgid "(during macroexpansion)~%~A"
msgstr "(uringday acroexpansionmay)~%~Away"

#: src/compiler/main.lisp
msgid ""
"If non-Nil, use git to derive the file-comment.  This info includes\n"
"  the sha1 hash, the time and the author of the change.  Otherwise,\n"
"  just use the supplied file-comment."
msgstr ""
"Ifway onnay-Ilnay, useway itgay otay eriveday ethay ilefay-ommentcay.  "
"Isthay infoway includesway\n"
"  ethay ashay1 ashhay, ethay imetay andway ethay authorway ofway ethay "
"angechay.  Otherwiseway,\n"
"  ustjay useway ethay uppliedsay ilefay-ommentcay."

#: src/compiler/main.lisp
msgid "Bad FILE-COMMENT form: ~S."
msgstr "Adbay FILE-COMMENT ormfay: ~S."

#: src/compiler/main.lisp
msgid "Ignoring extra file comment:~%  ~S."
msgstr "Ignoringway extraway ilefay ommentcay:~%  ~S."

#: src/compiler/main.lisp
msgid "~&; Comment: ~A~2&"
msgstr "~&; Ommentcay: ~Away~2&"

#: src/compiler/main.lisp
msgid "EVAL-WHEN form is too short: ~S."
msgstr "EVAL-WHEN ormfay isway ootay ortshay: ~S."

#: src/compiler/main.lisp
msgid "MACROLET form is too short: ~S."
msgstr "MACROLET ormfay isway ootay ortshay: ~S."

#: src/compiler/main.lisp
msgid "Load Time Value of ~S"
msgstr "Oadlay Imetay Aluevay ofway ~S"

#: src/compiler/main.lisp
msgid "(while making load form for ~S)~%~A"
msgstr "(ilewhay akingmay oadlay ormfay orfay ~S)~%~Away"

#: src/compiler/main.lisp
msgid "Circular references in creation form for ~S"
msgstr "Ircularcay eferencesray inway eationcray ormfay orfay ~S"

#: src/compiler/main.lisp
msgid "Creation Form for ~A"
msgstr "Eationcray Ormfay orfay ~Away"

#: src/compiler/main.lisp
msgid "Init Form~:[~;s~] for ~{~A~^, ~}"
msgstr "Initway Ormfay~:[~;s~] orfay ~{~Away~^, ~}"

#: src/compiler/main.lisp
msgid "~2&Fatal error, aborting compilation...~%"
msgstr "~2&Atalfay errorway, abortingway ompilationcay...~%"

#: src/compiler/main.lisp
msgid "Can't compile with no source files."
msgstr "Ancay't ompilecay ithway onay ourcesay ilesfay."

#: src/compiler/main.lisp
msgid ""
"Similar to COMPILE-FILE, but compiles text from Stream into the current "
"lisp\n"
"  environment.  Stream is closed when compilation is complete.  These "
"keywords\n"
"  are supported:\n"
"\n"
"  :Error-Stream\n"
"      The stream to write compiler error output to (default *ERROR-"
"OUTPUT*.)\n"
"  :Trace-Stream\n"
"      The stream that we write compiler trace output to, or NIL (the "
"default)\n"
"      to inhibit trace output.\n"
"  :Block-Compile {T, NIL, :SPECIFIED}\n"
"        If true, then function names may be resolved at compile time.\n"
"  :Source-Info\n"
"        Some object to be placed in the DEBUG-SOURCE-INFO.\n"
"  :Byte-Compile {T, NIL, :MAYBE}\n"
"        If true, then may compile to interpreted byte code."
msgstr ""
"Imilarsay otay COMPILE-FILE, utbay ompilescay exttay omfray Eamstray intoway "
"ethay urrentcay isplay\n"
"  environmentway.  Eamstray isway osedclay enwhay ompilationcay isway "
"ompletecay.  Esethay eywordskay\n"
"  areway upportedsay:\n"
"\n"
"  :Errorway-Eamstray\n"
"      Ethay eamstray otay itewray ompilercay errorway outputway otay "
"(efaultday *ERROR-OUTPUT*.)\n"
"  :Acetray-Eamstray\n"
"      Ethay eamstray atthay eway itewray ompilercay acetray outputway otay, "
"orway NIL (ethay efaultday)\n"
"      otay inhibitway acetray outputway.\n"
"  :Ockblay-Ompilecay {T, NIL, :SPECIFIED}\n"
"        Ifway uetray, enthay unctionfay amesnay aymay ebay esolvedray atway "
"ompilecay imetay.\n"
"  :Ourcesay-Infoway\n"
"        Omesay objectway otay ebay acedplay inway ethay DEBUG-SOURCE-INFO.\n"
"  :Ytebay-Ompilecay {T, NIL, :MAYBE}\n"
"        Ifway uetray, enthay aymay ompilecay otay interpretedway ytebay "
"odecay."

#: src/compiler/main.lisp
msgid "~2&; Python version ~A, VM version ~A on ~A.~%"
msgstr "~2&; Ythonpay ersionvay ~Away, VM ersionvay ~Away onway ~Away.~%"

#: src/compiler/main.lisp
msgid "; Compiling: ~A ~A~%"
msgstr "; Ompilingcay: ~Away ~Away~%"

#: src/compiler/main.lisp
msgid "~&; Compilation ~:[aborted after~;finished in~] ~A.~&"
msgstr "~&; Ompilationcay ~:[abortedway afterway~;inishedfay inway~] ~Away.~&"

#: src/compiler/main.lisp
msgid ""
"Compiles Source, producing a corresponding FASL file.  Source may be a list\n"
"  of files, in which case the files are compiled as a unit, producing a "
"single\n"
"  FASL file.  The output file names are defaulted from the first (or only)\n"
"  input file name.  (The use of a list for Source is a CMUCL extension, not\n"
"  specified in CLHS.)\n"
"\n"
"  These keywords are supported:\n"
"\n"
"  :Output-File\n"
"     The name of the FASL to output, NIL for none, T for the default.\n"
"     (Note the difference between the treatment of NIL :Output-File\n"
"     here and in COMPILE-FILE-PATHNAME.)  The returned pathname of the\n"
"     output file may differ from the pathname of the :Output-File\n"
"     parameter, e.g. when the latter is a designator for a directory.\n"
"  :Load\n"
"     Load the compiled file; T here requires :Output-File to be\n"
"     non-NIL, as well.  The default for :Load is NIL.\n"
"  :Error-File\n"
"     The name of the error listing file, NIL for none (the default), T for ."
"err.\n"
"  :Trace-File\n"
"     If specified, internal data structures are dumped to this file.  T for\n"
"     the .trace default.\n"
"  :Error-Output\n"
"     If a stream, then error output is sent there as well as to the listing\n"
"     file.  NIL suppresses this additional error output.  The default is T,\n"
"     which means use *ERROR-OUTPUT*.\n"
"  :Block-Compile {NIL | :SPECIFIED | T}\n"
"     Determines whether multiple functions are compiled together as a unit,\n"
"     resolving function references at compile time.  NIL means that global\n"
"     function names are never resolved at compilation time.  :SPECIFIED "
"means\n"
"     that names are resolved at compile-time when convenient (as in a\n"
"     self-recursive call), but the compiler doesn't combine top-level "
"DEFUNs.\n"
"     With :SPECIFIED, an explicit START-BLOCK declaration will enable block\n"
"     compilation.  A value of T indicates that all forms in the file(s) "
"should\n"
"     be compiled as a unit.  The default is the value of\n"
"     EXT:*BLOCK-COMPILE-DEFAULT*, which is initially :SPECIFIED.\n"
"  :Entry-Points\n"
"     This specifies a list of function names for functions in the file(s) "
"that\n"
"     must be given global definitions.  This only applies to block\n"
"     compilation, and is useful mainly when :BLOCK-COMPILE T is specified on "
"a\n"
"     file that lacks START-BLOCK declarations.  If the value is NIL (the\n"
"     default) then all functions will be globally defined.\n"
"  :Byte-Compile {T | NIL | :MAYBE}\n"
"     Determines whether to compile into interpreted byte code instead of\n"
"     machine instructions.  Byte code is several times smaller, but much\n"
"     slower.  If :MAYBE, then only byte-compile when SPEED is 0 and\n"
"     DEBUG <= 1.  The default is the value of EXT:*BYTE-COMPILE-DEFAULT*,\n"
"     which is initially :MAYBE.\n"
"  :Xref\n"
"     If non-NIL, enable recording of cross-reference information.  The "
"default\n"
"     is the value of C:*RECORD-XREF-INFO*\n"
"  :External-Format\n"
"     The external format to use when opening the source file.\n"
"  :Decoding-Error\n"
"     How to handle decoding errors in the external format when reading the\n"
"     source file.  Default (T) is to signal an error.  NIL means silently\n"
"     continue, replacing the invalid sequence with a suitable replacment\n"
"     character."
msgstr ""
"Ompilescay Ourcesay, oducingpray away orrespondingcay FASL ilefay.  Ourcesay "
"aymay ebay away istlay\n"
"  ofway ilesfay, inway ichwhay asecay ethay ilesfay areway ompiledcay asway "
"away unitway, oducingpray away inglesay\n"
"  FASL ilefay.  Ethay outputway ilefay amesnay areway efaultedday omfray "
"ethay irstfay (orway onlyway)\n"
"  inputway ilefay amenay.  (Ethay useway ofway away istlay orfay Ourcesay "
"isway away CMUCL extensionway, otnay\n"
"  ecifiedspay inway CLHS.)\n"
"\n"
"  Esethay eywordskay areway upportedsay:\n"
"\n"
"  :Outputway-Ilefay\n"
"     Ethay amenay ofway ethay FASL otay outputway, NIL orfay onenay, T orfay "
"ethay efaultday.\n"
"     (Otenay ethay ifferenceday etweenbay ethay eatmenttray ofway NIL :"
"Outputway-Ilefay\n"
"     erehay andway inway COMPILE-FILE-PATHNAME.)  Ethay eturnedray "
"athnamepay ofway ethay\n"
"     outputway ilefay aymay ifferday omfray ethay athnamepay ofway ethay :"
"Outputway-Ilefay\n"
"     arameterpay, e.g. enwhay ethay atterlay isway away esignatorday orfay "
"away irectoryday.\n"
"  :Oadlay\n"
"     Oadlay ethay ompiledcay ilefay; T erehay equiresray :Outputway-Ilefay "
"otay ebay\n"
"     onnay-NIL, asway ellway.  Ethay efaultday orfay :Oadlay isway NIL.\n"
"  :Errorway-Ilefay\n"
"     Ethay amenay ofway ethay errorway istinglay ilefay, NIL orfay onenay "
"(ethay efaultday), T orfay .errway.\n"
"  :Acetray-Ilefay\n"
"     Ifway ecifiedspay, internalway ataday ucturesstray areway umpedday otay "
"isthay ilefay.  T orfay\n"
"     ethay .acetray efaultday.\n"
"  :Errorway-Outputway\n"
"     Ifway away eamstray, enthay errorway outputway isway entsay erethay "
"asway ellway asway otay ethay istinglay\n"
"     ilefay.  NIL uppressessay isthay additionalway errorway outputway.  "
"Ethay efaultday isway T,\n"
"     ichwhay eansmay useway *ERROR-OUTPUT*.\n"
"  :Ockblay-Ompilecay {NIL | :SPECIFIED | T}\n"
"     Eterminesday etherwhay ultiplemay unctionsfay areway ompiledcay "
"ogethertay asway away unitway,\n"
"     esolvingray unctionfay eferencesray atway ompilecay imetay.  NIL "
"eansmay atthay obalglay\n"
"     unctionfay amesnay areway evernay esolvedray atway ompilationcay "
"imetay.  :SPECIFIED eansmay\n"
"     atthay amesnay areway esolvedray atway ompilecay-imetay enwhay "
"onvenientcay (asway inway away\n"
"     elfsay-ecursiveray allcay), utbay ethay ompilercay oesnday't ombinecay "
"optay-evellay Efunsday.\n"
"     Ithway :SPECIFIED, anway explicitway START-BLOCK eclarationday illway "
"enableway ockblay\n"
"     ompilationcay.  Away aluevay ofway T indicatesway atthay allway ormsfay "
"inway ethay ilefay(s) ouldshay\n"
"     ebay ompiledcay asway away unitway.  Ethay efaultday isway ethay "
"aluevay ofway\n"
"     EXT:*BLOCK-COMPILE-DEFAULT*, ichwhay isway initiallyway :SPECIFIED.\n"
"  :Entryway-Ointspay\n"
"     Isthay ecifiesspay away istlay ofway unctionfay amesnay orfay "
"unctionsfay inway ethay ilefay(s) atthay\n"
"     ustmay ebay ivengay obalglay efinitionsday.  Isthay onlyway appliesway "
"otay ockblay\n"
"     ompilationcay, andway isway usefulway ainlymay enwhay :BLOCK-COMPILE T "
"isway ecifiedspay onway away\n"
"     ilefay atthay ackslay START-BLOCK eclarationsday.  Ifway ethay aluevay "
"isway NIL (ethay\n"
"     efaultday) enthay allway unctionsfay illway ebay oballyglay efinedday.\n"
"  :Ytebay-Ompilecay {T | NIL | :MAYBE}\n"
"     Eterminesday etherwhay otay ompilecay intoway interpretedway ytebay "
"odecay insteadway ofway\n"
"     achinemay instructionsway.  Ytebay odecay isway everalsay imestay "
"mallersay, utbay uchmay\n"
"     owerslay.  Ifway :MAYBE, enthay onlyway ytebay-ompilecay enwhay SPEED "
"isway 0 andway\n"
"     DEBUG <= 1.  Ethay efaultday isway ethay aluevay ofway EXT:*BYTE-"
"COMPILE-DEFAULT*,\n"
"     ichwhay isway initiallyway :MAYBE.\n"
"  :Refxay\n"
"     Ifway onnay-NIL, enableway ecordingray ofway osscray-eferenceray "
"informationway.  Ethay efaultday\n"
"     isway ethay aluevay ofway C:*RECORD-XREF-INFO*\n"
"  :Externalway-Ormatfay\n"
"     Ethay externalway ormatfay otay useway enwhay openingway ethay ourcesay "
"ilefay.\n"
"  :Ecodingday-Errorway\n"
"     Owhay otay andlehay ecodingday errorsway inway ethay externalway "
"ormatfay enwhay eadingray ethay\n"
"     ourcesay ilefay.  Efaultday (T) isway otay ignalsay anway errorway.  "
"NIL eansmay ilentlysay\n"
"     ontinuecay, eplacingray ethay invalidway equencesay ithway away "
"uitablesay eplacmentray\n"
"     aracterchay."

#: src/compiler/main.lisp
msgid "~2&; ~A written.~%"
msgstr "~2&; ~Away ittenwray.~%"

#: src/compiler/main.lisp
msgid "Can't :LOAD with no output file."
msgstr "Ancay't :LOAD ithway onay outputway ilefay."

#: src/compiler/main.lisp
msgid "~S was defined in a non-null environment."
msgstr "~S asway efinedday inway away onnay-ullnay environmentway."

#: src/compiler/main.lisp
msgid "Can't find a definition for ~S."
msgstr "Ancay't indfay away efinitionday orfay ~S."

#: src/compiler/main.lisp
msgid ""
"Compiles the function (or macro-function) whose name is NAME.  If\n"
"  DEFINITION is supplied, it should be a lambda expression which will\n"
"  be compiled.  IF NAME names a macro, then the compiled expression\n"
"  replaces the existing macro-function.  If NAME names a function, the\n"
"  compiled expression is placed in the function cell of NAME.  If NAME\n"
"  is NIL, the compiled code object is returned."
msgstr ""
"Ompilescay ethay unctionfay (orway acromay-unctionfay) osewhay amenay isway "
"NAME.  Ifway\n"
"  DEFINITION isway uppliedsay, itway ouldshay ebay away ambdalay "
"expressionway ichwhay illway\n"
"  ebay ompiledcay.  IF NAME amesnay away acromay, enthay ethay ompiledcay "
"expressionway\n"
"  eplacesray ethay existingway acromay-unctionfay.  Ifway NAME amesnay away "
"unctionfay, ethay\n"
"  ompiledcay expressionway isway acedplay inway ethay unctionfay ellcay "
"ofway NAME.  Ifway NAME\n"
"  isway NIL, ethay ompiledcay odecay objectway isway eturnedray."

#: src/compiler/main.lisp
msgid ""
"Attempt to replace Name's definition with an interpreted version of that\n"
"  definition.  If no interpreted definition is to be found, then signal an\n"
"  error."
msgstr ""
"Attemptway otay eplaceray Amenay's efinitionday ithway anway interpretedway "
"ersionvay ofway atthay\n"
"  efinitionday.  Ifway onay interpretedway efinitionday isway otay ebay "
"oundfay, enthay ignalsay anway\n"
"  errorway."

#: src/compiler/main.lisp
msgid "~S is already interpreted."
msgstr "~S isway alreadyway interpretedway."

#: src/compiler/main.lisp
msgid ""
"Return a pathname describing what file COMPILE-FILE would write to\n"
"  given these arguments.  The returned pathname of the output file may\n"
"  differ from the pathname of the :Output-File parameter, e.g. when\n"
"  the latter is a designator for a directory. The CMUCL caveat: NIL is\n"
"  accepted for :Output-File there but not here, which is probably not\n"
"  in line with CLHS."
msgstr ""
"Eturnray away athnamepay escribingday atwhay ilefay COMPILE-FILE ouldway "
"itewray otay\n"
"  ivengay esethay argumentsway.  Ethay eturnedray athnamepay ofway ethay "
"outputway ilefay aymay\n"
"  ifferday omfray ethay athnamepay ofway ethay :Outputway-Ilefay "
"arameterpay, e.g. enwhay\n"
"  ethay atterlay isway away esignatorday orfay away irectoryday. Ethay CMUCL "
"aveatcay: NIL isway\n"
"  acceptedway orfay :Outputway-Ilefay erethay utbay otnay erehay, ichwhay "
"isway obablypray otnay\n"
"  inway inelay ithway CLHS."

#: src/compiler/main.lisp
msgid ""
"The ~A parameter is a ~S, which is an invalid value ~@\n"
"            to COMPILE-FILE-PATHNAME."
msgstr ""
"Ethay ~Away arameterpay isway away ~S, ichwhay isway anway invalidway "
"aluevay ~@\n"
"            otay COMPILE-FILE-PATHNAME."

#: src/compiler/ir1tran.lisp
msgid ""
"If true, argument and result type information derived from compilation of\n"
"  DEFUNs is used when compiling calls to that function.  If false, only\n"
"  information from FTYPE proclamations will be used."
msgstr ""
"Ifway uetray, argumentway andway esultray ypetay informationway erivedday "
"omfray ompilationcay ofway\n"
"  Efunsday isway usedway enwhay ompilingcay allscay otay atthay unctionfay.  "
"Ifway alsefay, onlyway\n"
"  informationway omfray FTYPE oclamationspray illway ebay usedway."

#: src/compiler/ir1tran.lisp
msgid ""
"If NIL, never trust dynamic-extent declarations.\n"
"\n"
"   If T, always trust dynamic-extent declarations.\n"
"\n"
"   Otherwise, the value of this variable must be a function of four\n"
"   arguments SAFETY, SPACE, SPEED, and DEBUG.  If the function returns\n"
"   true when called, dynamic-extent declarations are trusted,\n"
"   otherwise they are not trusted."
msgstr ""
"Ifway NIL, evernay usttray ynamicday-extentway eclarationsday.\n"
"\n"
"   Ifway T, alwaysway usttray ynamicday-extentway eclarationsday.\n"
"\n"
"   Otherwiseway, ethay aluevay ofway isthay ariablevay ustmay ebay away "
"unctionfay ofway ourfay\n"
"   argumentsway SAFETY, SPACE, SPEED, andway DEBUG.  Ifway ethay unctionfay "
"eturnsray\n"
"   uetray enwhay alledcay, ynamicday-extentway eclarationsday areway "
"ustedtray,\n"
"   otherwiseway eythay areway otnay ustedtray."

#: src/compiler/ir1tran.lisp
msgid "~@<Invalid name ~s in a dynamic-extent declaration.~@:>"
msgstr ""
"~@<Invalidway amenay ~s inway away ynamicday-extentway eclarationday.~@:>"

#: src/compiler/ir1tran.lisp
msgid "Can't find slot ~S."
msgstr "Ancay't indfay otslay ~S."

#: src/compiler/ir1tran.lisp
msgid "Found macro name ~S ~A."
msgstr "Oundfay acromay amenay ~S ~Away."

#: src/compiler/ir1tran.lisp
msgid "Found special-form name ~S ~A."
msgstr "Oundfay ecialspay-ormfay amenay ~S ~Away."

#: src/compiler/ir1tran.lisp
msgid "Cannot dump objects of type ~S into fasl files."
msgstr "Annotcay umpday objectsway ofway ypetay ~S intoway aslfay ilesfay."

#: src/compiler/ir1tran.lisp
msgid "~S has already ended."
msgstr "~S ashay alreadyway endedway."

#: src/compiler/ir1tran.lisp
msgid "~S already has successors."
msgstr "~S alreadyway ashay uccessorssay."

#: src/compiler/ir1tran.lisp
msgid "~S is already a predecessor of ~S."
msgstr "~S isway alreadyway away edecessorpray ofway ~S."

#: src/compiler/ir1tran.lisp
msgid "Misplaced declaration."
msgstr "Isplacedmay eclarationday."

#: src/compiler/ir1tran.lisp
msgid "Illegal function call."
msgstr "Illegalway unctionfay allcay."

#: src/compiler/ir1tran.lisp
msgid "Reading an ignored variable: ~S."
msgstr "Eadingray anway ignoredway ariablevay: ~S."

#: src/compiler/ir1tran.lisp
msgid "~&dynamic-extent args ~:s in ~s~%"
msgstr "~&ynamicday-extentway argsway ~:s inway ~s~%"

#: src/compiler/ir1tran.lisp
msgid ""
"Conflicting type declarations ~\n"
"\t\t\t\t   ~S and ~S for ~S."
msgstr ""
"Onflictingcay ypetay eclarationsday ~\n"
"\t\t\t\t   ~S andway ~S orfay ~S."

#: src/compiler/ir1tran.lisp
msgid "Can't declare type of Alien variable: ~S."
msgstr "Ancay't eclareday ypetay ofway Alienway ariablevay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Declaring symbol-macro ~S special."
msgstr "Eclaringday ymbolsay-acromay ~S ecialspay."

#: src/compiler/ir1tran.lisp
msgid "Ignored variable ~S is being declared special."
msgstr "Ignoredway ariablevay ~S isway eingbay eclaredday ecialspay."

#: src/compiler/ir1tran.lisp
msgid ""
"Ignoring ~A declaration not at ~\n"
"\t\t\t\t   definition of local function:~%  ~S"
msgstr ""
"Ignoringway ~Away eclarationday otnay atway ~\n"
"\t\t\t\t   efinitionday ofway ocallay unctionfay:~%  ~S"

#: src/compiler/ir1tran.lisp
msgid "Unrecognizable function or variable name: ~S"
msgstr "Unrecognizableway unctionfay orway ariablevay amenay: ~S"

#: src/compiler/ir1tran.lisp
msgid "Ignoring free ignore declaration for ~S."
msgstr "Ignoringway eefray ignoreway eclarationday orfay ~S."

#: src/compiler/ir1tran.lisp
msgid "Ignore declaration for unknown variable ~S."
msgstr "Ignoreway eclarationday orfay unknownway ariablevay ~S."

#: src/compiler/ir1tran.lisp
msgid "Declaring special variable ~S to be ignored."
msgstr "Eclaringday ecialspay ariablevay ~S otay ebay ignoredway."

#: src/compiler/ir1tran.lisp
msgid "If true, processing of the VALUES declaration is inhibited."
msgstr ""
"Ifway uetray, ocessingpray ofway ethay VALUES eclarationday isway "
"inhibitedway."

#: src/compiler/ir1tran.lisp
msgid "No type specified in FTYPE declaration: ~S."
msgstr "Onay ypetay ecifiedspay inway FTYPE eclarationday: ~S."

#: src/compiler/ir1tran.lisp
msgid "Abbreviated type declaration: ~S."
msgstr "Abbreviatedway ypetay eclarationday: ~S."

#: src/compiler/ir1tran.lisp
msgid "Unrecognized declaration: ~S."
msgstr "Unrecognizedway eclarationday: ~S."

#: src/compiler/ir1tran.lisp
msgid "Malformed declaration specifier ~S in ~S."
msgstr "Alformedmay eclarationday ecifierspay ~S inway ~S."

#: src/compiler/ir1tran.lisp
msgid "Declaring an alien variable to be special: ~S"
msgstr "Eclaringday anway alienway ariablevay otay ebay ecialspay: ~S"

#: src/compiler/ir1tran.lisp
msgid "Declaring a constant to be special: ~S."
msgstr "Eclaringday away onstantcay otay ebay ecialspay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Lambda-variable is not a symbol: ~S."
msgstr "Ambdalay-ariablevay isway otnay away ymbolsay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Repeated variable in lambda-list: ~S."
msgstr "Epeatedray ariablevay inway ambdalay-istlay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Name of lambda-variable is a constant: ~S."
msgstr "Amenay ofway ambdalay-ariablevay isway away onstantcay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Multiple uses of keyword ~S in lambda-list."
msgstr "Ultiplemay usesway ofway eywordkay ~S inway ambdalay-istlay."

#: src/compiler/ir1tran.lisp
msgid "Found a ~S when expecting a lambda expression:~%  ~S"
msgstr "Oundfay away ~S enwhay expectingway away ambdalay expressionway:~%  ~S"

#: src/compiler/ir1tran.lisp
msgid "Expecting a lambda, but form begins with ~S:~%  ~S"
msgstr "Expectingway away ambdalay, utbay ormfay eginsbay ithway ~S:~%  ~S"

#: src/compiler/ir1tran.lisp
msgid "Lambda-list absent or not a list:~%  ~S"
msgstr "Ambdalay-istlay absentway orway otnay away istlay:~%  ~S"

#: src/compiler/ir1tran.lisp
msgid "ir1-convert-lambda: called by: ~S, parent-form: ~S~%"
msgstr "irway1-onvertcay-ambdalay: alledcay ybay: ~S, arentpay-ormfay: ~S~%"

#: src/compiler/ir1tran.lisp
msgid "Arg specifier is too long: ~S."
msgstr "Argway ecifierspay isway ootay onglay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Malformed &aux binding specifier: ~S."
msgstr "Alformedmay &auxway indingbay ecifierspay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Malformed keyword arg specifier: ~S."
msgstr "Alformedmay eywordkay argway ecifierspay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"Progn Form*\n"
"  Evaluates each Form in order, returing the values of the last form.  With "
"no\n"
"  forms, returns NIL."
msgstr ""
"Ognpray Orm*Fay\n"
"  Evaluatesway eachway Ormfay inway orderway, eturingray ethay aluesvay "
"ofway ethay astlay ormfay.  Ithway onay\n"
"  ormsfay, eturnsray NIL."

#: src/compiler/ir2tran.lisp src/compiler/ltv.lisp src/compiler/ir1tran.lisp
msgid "Can't funcall the SYMBOL-FUNCTION of the special form ~A."
msgstr ""
"Ancay't uncallfay ethay SYMBOL-FUNCTION ofway ethay ecialspay ormfay ~Away."

#: src/compiler/ir1tran.lisp
msgid ""
"If Predicate Then [Else]\n"
"  If Predicate evaluates to non-null, evaluate Then and returns its values,\n"
"  otherwise evaluate Else and return its values.  Else defaults to NIL."
msgstr ""
"Ifway Edicatepray Enthay [Elseway]\n"
"  Ifway Edicatepray evaluatesway otay onnay-ullnay, evaluateway Enthay "
"andway eturnsray itsway aluesvay,\n"
"  otherwiseway evaluateway Elseway andway eturnray itsway aluesvay.  Elseway "
"efaultsday otay NIL."

#: src/compiler/ir1tran.lisp
msgid "Block name is not a symbol: ~S."
msgstr "Ockblay amenay isway otnay away ymbolsay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"Block Name Form*\n"
"  Evaluate the Forms as a PROGN.  Within the lexical scope of the body,\n"
"  (RETURN-FROM Name Value-Form) can be used to exit the form, returning the\n"
"  result of Value-Form."
msgstr ""
"Ockblay Amenay Orm*Fay\n"
"  Evaluateway ethay Ormsfay asway away PROGN.  Ithinway ethay exicallay "
"opescay ofway ethay odybay,\n"
"  (RETURN-FROM Amenay Aluevay-Ormfay) ancay ebay usedway otay exitway ethay "
"ormfay, eturningray ethay\n"
"  esultray ofway Aluevay-Ormfay."

#: src/compiler/ir1tran.lisp
msgid "Return for unknown block: ~S."
msgstr "Eturnray orfay unknownway ockblay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"Return-From Block-Name Value-Form\n"
"  Evaluate the Value-Form, returning its values from the lexically "
"enclosing\n"
"  BLOCK Block-Name.  This is constrained to be used only within the dynamic\n"
"  extent of the BLOCK."
msgstr ""
"Eturnray-Omfray Ockblay-Amenay Aluevay-Ormfay\n"
"  Evaluateway ethay Aluevay-Ormfay, eturningray itsway aluesvay omfray ethay "
"exicallylay enclosingway\n"
"  BLOCK Ockblay-Amenay.  Isthay isway onstrainedcay otay ebay usedway "
"onlyway ithinway ethay ynamicday\n"
"  extentway ofway ethay BLOCK."

#: src/compiler/ir1tran.lisp
msgid "Repeated tagbody tag: ~S."
msgstr "Epeatedray agbodytay agtay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Illegal tagbody statement: ~S."
msgstr "Illegalway agbodytay tatementsay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"Tagbody {Tag | Statement}*\n"
"  Define tags for used with GO.  The Statements are evaluated in order\n"
"  (skipping Tags) and NIL is returned.  If a statement contains a GO to a\n"
"  defined Tag within the lexical scope of the form, then control is "
"transferred\n"
"  to the next statement following that tag.  A Tag must an integer or a\n"
"  symbol.  A statement must be a list.  Other objects are illegal within "
"the\n"
"  body."
msgstr ""
"Agbodytay {Agtay | Tatementsay}*\n"
"  Efineday agstay orfay usedway ithway GO.  Ethay Tatementssay areway "
"evaluatedway inway orderway\n"
"  (kippingsay Agstay) andway NIL isway eturnedray.  Ifway away tatementsay "
"ontainscay away GO otay away\n"
"  efinedday Agtay ithinway ethay exicallay opescay ofway ethay ormfay, "
"enthay ontrolcay isway ansfertrayedray\n"
"  otay ethay extnay tatementsay ollowingfay atthay agtay.  Away Agtay ustmay "
"anway integerway orway away\n"
"  ymbolsay.  Away tatementsay ustmay ebay away istlay.  Otherway objectsway "
"areway illegalway ithinway ethay\n"
"  odybay."

#: src/compiler/ir1tran.lisp
msgid "Go to nonexistent tag: ~S."
msgstr "Ogay otay onexistentnay agtay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"Go Tag\n"
"  Transfer control to the named Tag in the lexically enclosing TAGBODY.  "
"This\n"
"  is constrained to be used only within the dynamic extent of the TAGBODY."
msgstr ""
"Ogay Agtay\n"
"  Ansfertray ontrolcay otay ethay amednay Agtay inway ethay exicallylay "
"enclosingway TAGBODY.  Isthay\n"
"  isway onstrainedcay otay ebay usedway onlyway ithinway ethay ynamicday "
"extentway ofway ethay TAGBODY."

#: src/compiler/ir1tran.lisp
msgid "Bad compiler-let binding spec: ~S."
msgstr "Adbay ompilercay-etlay indingbay ecspay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"EVAL-WHEN (Situation*) Form*\n"
"  Evaluate the Forms in the specified Situations, any of :COMPILE-TOPLEVEL,\n"
"  :LOAD-TOPLEVEL, :EXECUTE."
msgstr ""
"EVAL-WHEN (Ituation*Say) Orm*Fay\n"
"  Evaluateway ethay Ormsfay inway ethay ecifiedspay Ituationssay, anyway "
"ofway :COMPILE-TOPLEVEL,\n"
"  :LOAD-TOPLEVEL, :EXECUTE."

#: src/compiler/ir1tran.lisp
msgid "Macro name ~S is not a symbol."
msgstr "Acromay amenay ~S isway otnay away ymbolsay."

#: src/compiler/ir1tran.lisp
msgid "Local macro ~S has argument list that is not a list: ~S."
msgstr ""
"Ocallay acromay ~S ashay argumentway istlay atthay isway otnay away istlay: "
"~S."

#: src/compiler/ir1tran.lisp
msgid "Local macro ~S is too short to be a legal definition."
msgstr ""
"Ocallay acromay ~S isway ootay ortshay otay ebay away egallay efinitionday."

#: src/compiler/ir1tran.lisp
msgid ""
"MACROLET ({(Name Lambda-List Form*)}*) Body-Form*\n"
"  Evaluate the Body-Forms in an environment with the specified local macros\n"
"  defined.  Name is the local macro name, Lambda-List is the DEFMACRO style\n"
"  destructuring lambda list, and the Forms evaluate to the expansion."
msgstr ""
"MACROLET ({(Amenay Ambdalay-Istlay Orm*Fay)}*) Odybay-Orm*Fay\n"
"  Evaluateway ethay Odybay-Ormsfay inway anway environmentway ithway ethay "
"ecifiedspay ocallay acrosmay\n"
"  efinedday.  Amenay isway ethay ocallay acromay amenay, Ambdalay-Istlay "
"isway ethay DEFMACRO tylesay\n"
"  estructuringday ambdalay istlay, andway ethay Ormsfay evaluateway otay "
"ethay expansionway."

#: src/compiler/ir1tran.lisp
msgid ""
"Bogus binding for ~\n"
"\t\t\t\t\t\t     COMPILER-OPTION-BIND: ~S"
msgstr ""
"Ogusbay indingbay orfay ~\n"
"\t\t\t\t\t\t     COMPILER-OPTION-BIND: ~S"

#: src/compiler/ir1tran.lisp
msgid ""
"Compiler-Option-Bind ({(Name Value-Form)}*) Body-Form*\n"
"   Establish the specified compiler options for the (lexical) duration of\n"
"   the body.  The Value-Forms are evaluated at compile time."
msgstr ""
"Ompilercay-Optionway-Indbay ({(Amenay Aluevay-Ormfay)}*) Odybay-Orm*Fay\n"
"   Establishway ethay ecifiedspay ompilercay optionsway orfay ethay "
"(exicallay) urationday ofway\n"
"   ethay odybay.  Ethay Aluevay-Ormsfay areway evaluatedway atway ompilecay "
"imetay."

#: src/compiler/ir1tran.lisp
msgid "Lisp error during evaluation of info args:~%~A"
msgstr "Isplay errorway uringday evaluationway ofway infoway argsway:~%~Away"

#: src/compiler/ir1tran.lisp
msgid "%Primitive name is not a symbol: ~S."
msgstr "%Imitivepray amenay isway otnay away ymbolsay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Undefined primitive name: ~A."
msgstr "Undefinedway imitivepray amenay: ~Away."

#: src/compiler/ir1tran.lisp
msgid ""
"Primitive called with ~R argument~:P, ~\n"
"\t    \t\t         but wants at least ~R."
msgstr ""
"Imitivepray alledcay ithway ~R argumentway~:P, ~\n"
"\t    \t\t         utbay antsway atway eastlay ~R."

#: src/compiler/ir1tran.lisp
msgid ""
"Primitive called with ~R argument~:P, ~\n"
"\t\t\t\t but wants exactly ~R."
msgstr ""
"Imitivepray alledcay ithway ~R argumentway~:P, ~\n"
"\t\t\t\t utbay antsway exactlyway ~R."

#: src/compiler/ir1tran.lisp
msgid "%Primitive used with a conditional template."
msgstr "%Imitivepray usedway ithway away onditionalcay emplatetay."

#: src/compiler/ir1tran.lisp
msgid "%Primitive used with an unknown values template."
msgstr "%Imitivepray usedway ithway anway unknownway aluesvay emplatetay."

#: src/compiler/ir1tran.lisp
msgid ""
"QUOTE Value\n"
"  Return Value without evaluating it."
msgstr ""
"QUOTE Aluevay\n"
"  Eturnray Aluevay ithoutway evaluatingway itway."

#: src/compiler/ir1tran.lisp
msgid "Illegal function name: ~S"
msgstr "Illegalway unctionfay amenay: ~S"

#: src/compiler/ir1tran.lisp
msgid ""
"FUNCTION Name\n"
"  Return the lexically apparent definition of the function Name.  Name may "
"also\n"
"  be a lambda."
msgstr ""
"FUNCTION Amenay\n"
"  Eturnray ethay exicallylay apparentway efinitionday ofway ethay unctionfay "
"Amenay.  Amenay aymay alsoway\n"
"  ebay away ambdalay."

#: src/compiler/ir1tran.lisp
msgid "Might be a symbol, so must call FDEFINITION at runtime."
msgstr ""
"Ightmay ebay away ymbolsay, osay ustmay allcay FDEFINITION atway untimeray."

#: src/compiler/ir1tran.lisp
msgid "Malformed symbol macro binding: ~S."
msgstr "Alformedmay ymbolsay acromay indingbay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"Attempt to bind a special or constant variable with SYMBOL-MACROLET: ~S."
msgstr ""
"Attemptway otay indbay away ecialspay orway onstantcay ariablevay ithway "
"SYMBOL-MACROLET: ~S."

#: src/compiler/ir1tran.lisp
msgid "Repeated name in SYMBOL-MACROLET: ~S."
msgstr "Epeatedray amenay inway SYMBOL-MACROLET: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"SYMBOL-MACROLET ({(Name Expansion)}*) Decl* Form*\n"
"  Define the Names as symbol macros with the given Expansions.  Within the\n"
"  body, references to a Name will effectively be replaced with the Expansion."
msgstr ""
"SYMBOL-MACROLET ({(Amenay Expansionway)}*) Ecl*Day Orm*Fay\n"
"  Efineday ethay Amesnay asway ymbolsay acrosmay ithway ethay ivengay "
"Expansionsway.  Ithinway ethay\n"
"  odybay, eferencesray otay away Amenay illway effectivelyway ebay "
"eplacedray ithway ethay Expansionway."

#: src/compiler/ir1tran.lisp
msgid "Name is not a symbol: ~S."
msgstr "Amenay isway otnay away ymbolsay: ~S."

#: src/compiler/ir1tran.lisp
msgid "New proclaimed type ~S for ~S conflicts with old type ~S."
msgstr ""
"Ewnay oclaimedpray ypetay ~S orfay ~S onflictscay ithway oldway ypetay ~S."

#: src/compiler/ir1tran.lisp
msgid "Attempt to proclaim constant ~S to be special."
msgstr "Attemptway otay oclaimpray onstantcay ~S otay ebay ecialspay."

#: src/compiler/ir1tran.lisp
msgid "Malformed TYPE proclamation: ~S."
msgstr "Alformedmay TYPE oclamationpray: ~S."

#: src/compiler/ir1tran.lisp
msgid "Malformed FUNCTION proclamation: ~S."
msgstr "Alformedmay FUNCTION oclamationpray: ~S."

#: src/compiler/ir1tran.lisp
msgid "Malformed FTYPE proclamation: ~S."
msgstr "Alformedmay FTYPE oclamationpray: ~S."

#: src/compiler/ir1tran.lisp
msgid "Malformed ~S binding spec: ~S."
msgstr "Alformedmay ~S indingbay ecspay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"LET ({(Var [Value]) | Var}*) Declaration* Form*\n"
"  During evaluation of the Forms, Bind the Vars to the result of evaluating "
"the\n"
"  Value forms.  The variables are bound in parallel after all of the Values "
"are\n"
"  evaluated."
msgstr ""
"LET ({(Arvay [Aluevay]) | Arvay}*) Eclaration*Day Orm*Fay\n"
"  Uringday evaluationway ofway ethay Ormsfay, Indbay ethay Arsvay otay ethay "
"esultray ofway evaluatingway ethay\n"
"  Aluevay ormsfay.  Ethay ariablesvay areway oundbay inway arallelpay "
"afterway allway ofway ethay Aluesvay areway\n"
"  evaluatedway."

#: src/compiler/ir1tran.lisp
msgid ""
"LOCALLY Declaration* Form*\n"
"   Sequentially evaluates a body of Form's in a lexical environment\n"
"   where the given Declaration's have effect."
msgstr ""
"LOCALLY Eclaration*Day Orm*Fay\n"
"   Equentiallysay evaluatesway away odybay ofway Ormfay's inway away "
"exicallay environmentway\n"
"   erewhay ethay ivengay Eclarationday's avehay effectway."

#: src/compiler/ir1tran.lisp
msgid ""
"LET* ({(Var [Value]) | Var}*) Declaration* Form*\n"
"  Similar to LET, but the variables are bound sequentially, allowing each "
"Value\n"
"  form to reference any of the previous Vars."
msgstr ""
"Et*Lay ({(Arvay [Aluevay]) | Arvay}*) Eclaration*Day Orm*Fay\n"
"  Imilarsay otay LET, utbay ethay ariablesvay areway oundbay equentiallysay, "
"allowingway eachway Aluevay\n"
"  ormfay otay eferenceray anyway ofway ethay eviouspray Arsvay."

#: src/compiler/ir1tran.lisp
msgid "Malformed ~S definition spec: ~S."
msgstr "Alformedmay ~S efinitionday ecspay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"FLET ({(Name Lambda-List Declaration* Form*)}*) Declaration* Body-Form*\n"
"  Evaluate the Body-Forms with some local function definitions.   The "
"bindings\n"
"  do not enclose the definitions; any use of Name in the Forms will refer "
"to\n"
"  the lexically apparent function definition in the enclosing environment."
msgstr ""
"FLET ({(Amenay Ambdalay-Istlay Eclaration*Day Orm*Fay)}*) Eclaration*Day "
"Odybay-Orm*Fay\n"
"  Evaluateway ethay Odybay-Ormsfay ithway omesay ocallay unctionfay "
"efinitionsday.   Ethay indingsbay\n"
"  oday otnay encloseway ethay efinitionsday; anyway useway ofway Amenay "
"inway ethay Ormsfay illway eferray otay\n"
"  ethay exicallylay apparentway unctionfay efinitionday inway ethay "
"enclosingway environmentway."

#: src/compiler/ir1tran.lisp
msgid ""
"LABELS ({(Name Lambda-List Declaration* Form*)}*) Declaration* Body-Form*\n"
"  Evaluate the Body-Forms with some local function definitions.  The "
"bindings\n"
"  enclose the new definitions, so the defined functions can call themselves "
"or\n"
"  each other."
msgstr ""
"LABELS ({(Amenay Ambdalay-Istlay Eclaration*Day Orm*Fay)}*) Eclaration*Day "
"Odybay-Orm*Fay\n"
"  Evaluateway ethay Odybay-Ormsfay ithway omesay ocallay unctionfay "
"efinitionsday.  Ethay indingsbay\n"
"  encloseway ethay ewnay efinitionsday, osay ethay efinedday unctionsfay "
"ancay allcay emselvesthay orway\n"
"  eachway otherway."

#: src/compiler/ir1tran.lisp
msgid "Type ~S in ~S declaration conflicts with enclosing assertion:~%   ~S"
msgstr ""
"Ypetay ~S inway ~S eclarationday onflictscay ithway enclosingway "
"assertionway:~%   ~S"

#: src/compiler/ir1tran.lisp
msgid ""
"THE Type Form\n"
"  Assert that Form evaluates to the specified type (which may be a VALUES\n"
"  type.)"
msgstr ""
"THE Ypetay Ormfay\n"
"  Assertway atthay Ormfay evaluatesway otay ethay ecifiedspay ypetay "
"(ichwhay aymay ebay away VALUES\n"
"  ypetay.)"

#: src/compiler/ir1tran.lisp
msgid ""
"Truly-The Type Value\n"
"  Like the THE special form, except that it believes whatever you tell it.  "
"It\n"
"  will never generate a type check, but will cause a warning if the "
"compiler\n"
"  can prove the assertion is wrong."
msgstr ""
"Ulytray-Ethay Ypetay Aluevay\n"
"  Ikelay ethay THE ecialspay ormfay, exceptway atthay itway elievesbay "
"ateverwhay ouyay elltay itway.  Itway\n"
"  illway evernay enerategay away ypetay eckchay, utbay illway ausecay away "
"arningway ifway ethay ompilercay\n"
"  ancay ovepray ethay assertionway isway ongwray."

#: src/compiler/ir1tran.lisp
msgid "Odd number of args to SETQ: ~S."
msgstr "Oddway umbernay ofway argsway otay SETQ: ~S."

#: src/compiler/ir1tran.lisp
msgid "Attempt to set constant ~S."
msgstr "Attemptway otay etsay onstantcay ~S."

#: src/compiler/ir1tran.lisp
msgid "Setting an ignored variable: ~S."
msgstr "Ettingsay anway ignoredway ariablevay: ~S."

#: src/compiler/ir1tran.lisp
msgid ""
"SETQ {Var Value}*\n"
"  Set the variables to the values.  If more than one pair is supplied, the\n"
"  assignments are done sequentially.  If Var names a symbol macro, SETF the\n"
"  expansion."
msgstr ""
"SETQ {Arvay Aluevay}*\n"
"  Etsay ethay ariablesvay otay ethay aluesvay.  Ifway oremay anthay oneway "
"airpay isway uppliedsay, ethay\n"
"  assignmentsway areway oneday equentiallysay.  Ifway Arvay amesnay away "
"ymbolsay acromay, SETF ethay\n"
"  expansionway."

#: src/compiler/ir1tran.lisp
msgid ""
"Throw Tag Form\n"
"  Do a non-local exit, return the values of Form from the CATCH whose tag\n"
"  evaluates to the same thing as Tag."
msgstr ""
"Rowthay Agtay Ormfay\n"
"  Oday away onnay-ocallay exitway, eturnray ethay aluesvay ofway Ormfay "
"omfray ethay CATCH osewhay agtay\n"
"  evaluatesway otay ethay amesay ingthay asway Agtay."

#: src/compiler/ir1tran.lisp
msgid ""
"Catch Tag Form*\n"
"  Evaluates Tag and instantiates it as a catcher while the body forms are\n"
"  evaluated in an implicit PROGN.  If a THROW is done to Tag within the "
"dynamic\n"
"  scope of the body, then control will be transferred to the end of the "
"body\n"
"  and the thrown values will be returned."
msgstr ""
"Atchcay Agtay Orm*Fay\n"
"  Evaluatesway Agtay andway instantiatesway itway asway away atchercay "
"ilewhay ethay odybay ormsfay areway\n"
"  evaluatedway inway anway implicitway PROGN.  Ifway away THROW isway oneday "
"otay Agtay ithinway ethay ynamicday\n"
"  opescay ofway ethay odybay, enthay ontrolcay illway ebay ansferredtray "
"otay ethay endway ofway ethay odybay\n"
"  andway ethay rownthay aluesvay illway ebay eturnedray."

#: src/compiler/ir1tran.lisp
msgid ""
"Unwind-Protect Protected Cleanup*\n"
"  Evaluate the form Protected, returning its values.  The cleanup forms are\n"
"  evaluated whenever the dynamic scope of the Protected form is exited "
"(either\n"
"  due to normal completion or a non-local exit such as THROW)."
msgstr ""
"Unwindway-Otectpray Otectedpray Eanup*Clay\n"
"  Evaluateway ethay ormfay Otectedpray, eturningray itsway aluesvay.  Ethay "
"eanupclay ormsfay areway\n"
"  evaluatedway eneverwhay ethay ynamicday opescay ofway ethay Otectedpray "
"ormfay isway exitedway (eitherway\n"
"  ueday otay ormalnay ompletioncay orway away onnay-ocallay exitway uchsay "
"asway THROW)."

#: src/compiler/ir1tran.lisp
msgid ""
"MULTIPLE-VALUE-CALL Function Values-Form*\n"
"  Call Function, passing all the values of each Values-Form as arguments,\n"
"  values from the first Values-Form making up the first argument, etc."
msgstr ""
"MULTIPLE-VALUE-CALL Unctionfay Aluesvay-Orm*Fay\n"
"  Allcay Unctionfay, assingpay allway ethay aluesvay ofway eachway Aluesvay-"
"Ormfay asway argumentsway,\n"
"  aluesvay omfray ethay irstfay Aluesvay-Ormfay akingmay upway ethay irstfay "
"argumentway, etcway."

#: src/compiler/ir1tran.lisp
msgid ""
"MULTIPLE-VALUE-PROG1 Values-Form Form*\n"
"  Evaluate Values-Form and then the Forms, but return all the values of\n"
"  Values-Form."
msgstr ""
"MULTIPLE-VALUE-PROG1 Aluesvay-Ormfay Orm*Fay\n"
"  Evaluateway Aluesvay-Ormfay andway enthay ethay Ormsfay, utbay eturnray "
"allway ethay aluesvay ofway\n"
"  Aluesvay-Ormfay."

#: src/compiler/ir1tran.lisp
msgid "Macro name is not a symbol: ~S."
msgstr "Acromay amenay isway otnay away ymbolsay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Defining ~S to be a macro when it was ~(~A~) to be a function."
msgstr ""
"Efiningday ~S otay ebay away acromay enwhay itway asway ~(~Away~) otay ebay "
"away unctionfay."

#: src/compiler/ir1tran.lisp
msgid "Attempt to redefine special form ~S as a macro."
msgstr "Attemptway otay edefineray ecialspay ormfay ~S asway away acromay."

#: src/compiler/ir1tran.lisp
msgid "~&; Converted ~S.~%"
msgstr "~&; Onvertedcay ~S.~%"

#: src/compiler/ir1tran.lisp
msgid "Attempt to define a compiler-macro for special form ~S."
msgstr ""
"Attemptway otay efineday away ompilercay-acromay orfay ecialspay ormfay ~S."

#: src/compiler/ir1tran.lisp
msgid "Constant name is not a symbol: ~S."
msgstr "Onstantcay amenay isway otnay away ymbolsay: ~S."

#: src/compiler/ir1tran.lisp
msgid "Can't change T."
msgstr "Ancay't angechay T."

#: src/compiler/ir1tran.lisp
msgid "Nihil ex nihil (Can't change NIL)."
msgstr "Ihilnay exway ihilnay (Ancay't angechay NIL)."

#: src/compiler/ir1tran.lisp
msgid "Can't change the value of keywords."
msgstr "Ancay't angechay ethay aluevay ofway eywordskay."

#: src/compiler/ir1tran.lisp
msgid "Redefining constant ~S as:~%  ~S"
msgstr "Edefiningray onstantcay ~S asway:~%  ~S"

#: src/compiler/ir1tran.lisp
msgid "Redefining ~(~A~) ~S to be a constant."
msgstr "Edefiningray ~(~Away~) ~S otay ebay away onstantcay."

#: src/compiler/ir1util.lisp
msgid ""
"Return the TLF-NUMBER and FORM-NUMBER encoded as fixnum, if\n"
"  possible.  Otherwise, return Nil."
msgstr ""
"Eturnray ethay TLF-NUMBER andway FORM-NUMBER encodedway asway ixnumfay, "
"ifway\n"
"  ossiblepay.  Otherwiseway, eturnray Ilnay."

#: src/compiler/ir1util.lisp
msgid "Return the tlf-number and form-number from an encoded FIXNUM."
msgstr ""
"Eturnray ethay lftay-umbernay andway ormfay-umbernay omfray anway encodedway "
"FIXNUM."

#: src/compiler/ir1util.lisp
msgid "Return a source-location for the call site."
msgstr "Eturnray away ourcesay-ocationlay orfay ethay allcay itesay."

#: src/compiler/ir1util.lisp
msgid "Deleting unused function~:[.~;~:*~%  ~S~]"
msgstr "Eletingday unusedway unctionfay~:[.~;~:*~%  ~S~]"

#: src/compiler/ir1util.lisp
msgid "Block is already deleted."
msgstr "Ockblay isway alreadyway eletedday."

#: src/compiler/ir1util.lisp
msgid "Variable ~S defined but never used."
msgstr "Ariablevay ~S efinedday utbay evernay usedway."

#: src/compiler/ir1util.lisp
msgid "Deleting unreachable code."
msgstr "Eletingday unreachableway odecay."

#: src/compiler/ir1util.lisp
msgid ""
"If CONT is a call to FUN with NUM-ARGS args, change those arguments\n"
"   to feed directly to the continuation-dest of CONT, which must be\n"
"   a combination."
msgstr ""
"Ifway CONT isway away allcay otay FUN ithway NUM-ARGS argsway, angechay "
"osethay argumentsway\n"
"   otay eedfay irectlyday otay ethay ontinuationcay-estday ofway CONT, "
"ichwhay ustmay ebay\n"
"   away ombinationcay."

#: src/compiler/ir1util.lisp
msgid ""
"An upper limit on the number of inline function calls that will be expanded\n"
"   in any given code object (single function or block compilation.)"
msgstr ""
"Anway upperway imitlay onway ethay umbernay ofway inlineway unctionfay "
"allscay atthay illway ebay expandedway\n"
"   inway anyway ivengay odecay objectway (inglesay unctionfay orway ockblay "
"ompilationcay.)"

#: src/compiler/ir1util.lisp
msgid ""
"*Inline-Expansion-Limit* (~D) exceeded, ~\n"
"\t\t\t     probably trying to~%  ~\n"
"\t\t\t     inline a recursive function."
msgstr ""
"*Inline-Expansion-Limit* (~D) exceededway, ~\n"
"\t\t\t     obablypray yingtray otay~%  ~\n"
"\t\t\t     inlineway away ecursiveray unctionfay."

#: src/compiler/ir1util.lisp
msgid "The value for *Print-Level* when printing compiler error messages."
msgstr ""
"Ethay aluevay orfay *Print-Level* enwhay intingpray ompilercay errorway "
"essagesmay."

#: src/compiler/ir1util.lisp
msgid "The value for *Print-Length* when printing compiler error messages."
msgstr ""
"Ethay aluevay orfay *Print-Length* enwhay intingpray ompilercay errorway "
"essagesmay."

#: src/compiler/ir1util.lisp
msgid "The value for *Print-Lines* when printing compiler error messages."
msgstr ""
"Ethay aluevay orfay *Print-Lines* enwhay intingpray ompilercay errorway "
"essagesmay."

#: src/compiler/ir1util.lisp
msgid ""
"The maximum number of enclosing non-original source forms (i.e. from\n"
"  macroexpansion) that we print in full.  For additional enclosing forms, "
"we\n"
"  print only the CAR."
msgstr ""
"Ethay aximummay umbernay ofway enclosingway onnay-originalway ourcesay "
"ormsfay (i.e. omfray\n"
"  acroexpansionmay) atthay eway intpray inway ullfay.  Orfay additionalway "
"enclosingway ormsfay, eway\n"
"  intpray onlyway ethay CAR."

#: src/compiler/ir1util.lisp
msgid ""
"DEF-SOURCE-CONTEXT Name Lambda-List Form*\n"
"   This macro defines how to extract an abbreviated source context from the\n"
"   Named form when it appears in the compiler input.  Lambda-List is a "
"DEFMACRO\n"
"   style lambda-list used to parse the arguments.  The Body should return a\n"
"   list of subforms suitable for a \"~{~S ~}\" format string."
msgstr ""
"DEF-SOURCE-CONTEXT Amenay Ambdalay-Istlay Orm*Fay\n"
"   Isthay acromay efinesday owhay otay extractway anway abbreviatedway "
"ourcesay ontextcay omfray ethay\n"
"   Amednay ormfay enwhay itway appearsway inway ethay ompilercay inputway.  "
"Ambdalay-Istlay isway away DEFMACRO\n"
"   tylesay ambdalay-istlay usedway otay arsepay ethay argumentsway.  Ethay "
"Odybay ouldshay eturnray away\n"
"   istlay ofway ubformssay uitablesay orfay away \"~{~S ~}\" ormatfay "
"ingstray."

#: src/compiler/ir1util.lisp
msgid "Compiler-Error with no bailout."
msgstr "Ompilercay-Errorway ithway onay ailoutbay."

#: src/compiler/ir1util.lisp
msgid ""
"This is the function called by the compiler to specially note a\n"
"warning, comment, or error. The function must take five arguments: the\n"
"severity, a string describing the nature of the notification, a string\n"
"for context, the file namestring, and the file position. The severity\n"
"is one of :note, :warning, or :error. Except for the severity, all of\n"
"these can be NIL if unavailable or inapplicable."
msgstr ""
"Isthay isway ethay unctionfay alledcay ybay ethay ompilercay otay "
"eciallyspay otenay away\n"
"arningway, ommentcay, orway errorway. Ethay unctionfay ustmay aketay ivefay "
"argumentsway: ethay\n"
"everitysay, away ingstray escribingday ethay aturenay ofway ethay "
"otificationnay, away ingstray\n"
"orfay ontextcay, ethay ilefay amestringnay, andway ethay ilefay ositionpay. "
"Ethay everitysay\n"
"isway oneway ofway :otenay, :arningway, orway :errorway. Exceptway orfay "
"ethay everitysay, allway ofway\n"
"esethay ancay ebay NIL ifway unavailableway orway inapplicableway."

#: src/compiler/ir1util.lisp
msgid "[Last message occurs ~D times]"
msgstr "[Astlay essagemay occursway ~D imestay]"

#: src/compiler/ir1util.lisp
msgid "~2&File: ~A"
msgstr "~2&Ilefay: ~Away"

#: src/compiler/ir1util.lisp
msgid "In:~{~<~%   ~4:;~{ ~S~}~>~^ =>~}"
msgstr "Inway:~{~<~%   ~4:;~{ ~S~}~>~^ =>~}"

#: src/compiler/ir1util.lisp
msgid "replace form with call to ERROR."
msgstr "eplaceray ormfay ithway allcay otay ERROR."

#: src/compiler/ir1util.lisp
msgid "ignore it."
msgstr "ignoreway itway."

#: src/compiler/ir1util.lisp
msgid ""
"If non-null, then an upper limit on the number of unknown function or type\n"
"  warnings that the compiler will print for any given name in a single\n"
"  compilation.  This prevents excessive amounts of output when there really "
"is\n"
"  a missing definition (as opposed to a typo in the use.)"
msgstr ""
"Ifway onnay-ullnay, enthay anway upperway imitlay onway ethay umbernay ofway "
"unknownway unctionfay orway ypetay\n"
"  arningsway atthay ethay ompilercay illway intpray orfay anyway ivengay "
"amenay inway away inglesay\n"
"  ompilationcay.  Isthay eventspray excessiveway amountsway ofway outputway "
"enwhay erethay eallyray isway\n"
"  away issingmay efinitionday (asway opposedway otay away ypotay inway ethay "
"useway.)"

#: src/compiler/ir1util.lisp
msgid "Lisp error during ~A:~%~A"
msgstr "Isplay errorway uringday ~Away:~%~Away"

#: src/compiler/ir1opt.lisp
msgid ""
"New inferred type ~S conflicts with old type:~\n"
"\t\t~%  ~S~%*** Bug?"
msgstr ""
"Ewnay inferredway ypetay ~S onflictscay ithway oldway ypetay:~\n"
"\t\t~%  ~S~%*** Ugbay?"

#: src/compiler/ir1opt.lisp
msgid "The return value of ~A should not be discarded."
msgstr "Ethay eturnray aluevay ofway ~Away ouldshay otnay ebay iscardedday."

#: src/compiler/ir1opt.lisp
msgid ""
"This function is used to throw out of an IR1 transform, aborting this\n"
"  attempt to transform the call, but admitting the possibility that this or\n"
"  some other transform will later suceed.  If arguments are supplied, they "
"are\n"
"  format arguments for an efficiency note."
msgstr ""
"Isthay unctionfay isway usedway otay rowthay outway ofway anway IR1 "
"ansformtray, abortingway isthay\n"
"  attemptway otay ansformtray ethay allcay, utbay admittingway ethay "
"ossibilitypay atthay isthay orway\n"
"  omesay otherway ansformtray illway aterlay uceedsay.  Ifway argumentsway "
"areway uppliedsay, eythay areway\n"
"  ormatfay argumentsway orfay anway efficiencyway otenay."

#: src/compiler/ir1opt.lisp
msgid ""
"This function is used to throw out of an IR1 transform and force a normal\n"
"  call to the function at run time.  No further optimizations will be\n"
"  attempted."
msgstr ""
"Isthay unctionfay isway usedway otay rowthay outway ofway anway IR1 "
"ansformtray andway orcefay away ormalnay\n"
"  allcay otay ethay unctionfay atway unray imetay.  Onay urtherfay "
"optimizationsway illway ebay\n"
"  attemptedway."

#: src/compiler/ir1opt.lisp
msgid ""
"This function is used to throw out of an IR1 transform, and delay the\n"
"  transform on the node until later. The reasons specifies when the "
"transform\n"
"  will be later retried. The :optimize reason causes the transform to be\n"
"  delayed until after the current IR1 optimization pass. The :constraint\n"
"  reason causes the transform to be delayed until after constraint\n"
"  propagation."
msgstr ""
"Isthay unctionfay isway usedway otay rowthay outway ofway anway IR1 "
"ansformtray, andway elayday ethay\n"
"  ansformtray onway ethay odenay untilway aterlay. Ethay easonsray "
"ecifiesspay enwhay ethay ansfortraym\n"
"  illway ebay aterlay etriedray. Ethay :optimizeway easonray ausescay ethay "
"ansformtray otay ebay\n"
"  elayedday untilway afterway ethay urrentcay IR1 optimizationway asspay. "
"Ethay :onstraintcay\n"
"  easonray ausescay ethay ansformtray otay ebay elayedday untilway afterway "
"onstraintcay\n"
"  opagationpray."

#: src/compiler/ir1opt.lisp
msgid ""
"MULTIPLE-VALUE-CALL with ~R values when the function expects ~\n"
"\t     at least ~R."
msgstr ""
"MULTIPLE-VALUE-CALL ithway ~R aluesvay enwhay ethay unctionfay expectsway ~\n"
"\t     atway eastlay ~R."

#: src/compiler/ir1opt.lisp
msgid ""
"MULTIPLE-VALUE-CALL with ~R values when the function expects ~\n"
"\t     at most ~R."
msgstr ""
"MULTIPLE-VALUE-CALL ithway ~R aluesvay enwhay ethay unctionfay expectsway ~\n"
"\t     atway ostmay ~R."

#: src/compiler/ir1final.lisp
msgid "Unable to ~A because:~%~6T~?"
msgstr "Unableway otay ~Away ecausebay:~%~6T~?"

#: src/compiler/ir1final.lisp
msgid ""
"Unable to ~A due to type uncertainty:~@\n"
"\t                      ~{~6T~?~^~&~}"
msgstr ""
"Unableway otay ~Away ueday otay ypetay uncertaintyway:~@\n"
"\t                      ~{~6T~?~^~&~}"

#: src/compiler/ir1final.lisp
msgid ""
"The result type from previous declaration:~%  ~S~@\n"
"\t\t\t\t  conflicts with the result type:~%  ~S"
msgstr ""
"Ethay esultray ypetay omfray eviouspray eclarationday:~%  ~S~@\n"
"\t\t\t\t  onflictscay ithway ethay esultray ypetay:~%  ~S"

#: src/compiler/array-tran.lisp
msgid "Default initial element ~s is not a ~s."
msgstr "Efaultday initialway elementway ~s isway otnay away ~s."

#: src/compiler/array-tran.lisp
msgid "Cannot open-code creation of ~S"
msgstr "Annotcay openway-odecay eationcray ofway ~S"

#: src/compiler/array-tran.lisp
msgid "Element-Type is not constant."
msgstr "Elementway-Ypetay isway otnay onstantcay."

#: src/compiler/array-tran.lisp
msgid "Element-type not constant; cannot open code array creation"
msgstr ""
"Elementway-ypetay otnay onstantcay; annotcay openway odecay arrayway "
"eationcray"

#: src/compiler/array-tran.lisp
msgid "Dimension list not constant; cannot open code array creation"
msgstr ""
"Imensionday istlay otnay onstantcay; annotcay openway odecay arrayway "
"eationcray"

#: src/compiler/array-tran.lisp
msgid "Dimension list contains something other than an integer: ~S"
msgstr ""
"Imensionday istlay ontainscay omethingsay otherway anthay anway integerway: "
"~S"

#: src/compiler/array-tran.lisp
msgid "Array rank not known at compile time: ~S"
msgstr "Arrayway ankray otnay nownkay atway ompilecay imetay: ~S"

#: src/compiler/array-tran.lisp
msgid "Axis not constant."
msgstr "Axisway otnay onstantcay."

#: src/compiler/array-tran.lisp
msgid "Array dimensions unknown, must call array-dimension at runtime."
msgstr ""
"Arrayway imensionsday unknownway, ustmay allcay arrayway-imensionday atway "
"untimeray."

#: src/compiler/array-tran.lisp
msgid "Array has dimensions ~S, ~D is too large."
msgstr "Arrayway ashay imensionsday ~S, ~D isway ootay argelay."

#: src/compiler/array-tran.lisp
msgid "Can't tell if array is simple."
msgstr "Ancay't elltay ifway arrayway isway implesay."

#: src/compiler/array-tran.lisp
msgid "Vector length unknown, must call length at runtime."
msgstr "Ectorvay engthlay unknownway, ustmay allcay engthlay atway untimeray."

#: src/compiler/array-tran.lisp
msgid "Can't tell the rank at compile time."
msgstr "Ancay't elltay ethay ankray atway ompilecay imetay."

#: src/compiler/array-tran.lisp
msgid ""
"Array type ambiguous; must call ~\n"
"\t              array-has-fill-pointer-p at runtime."
msgstr ""
"Arrayway ypetay ambiguousway; ustmay allcay ~\n"
"\t              arrayway-ashay-illfay-ointerpay-p atway untimeray."

#: src/compiler/seqtran.lisp
msgid "Item might be a number"
msgstr "Itemway ightmay ebay away umbernay"

#: src/compiler/seqtran.lisp
msgid "Specified output type ~S is not a sequence type"
msgstr "Ecifiedspay outputway ypetay ~S isway otnay away equencesay ypetay"

#: src/compiler/typetran.lisp
msgid ""
"Define-Type-Predicate Name Type\n"
"  Establish an association between the type predicate Name and the\n"
"  corresponding Type.  This causes the type predicate to be recognized for\n"
"  purposes of optimization."
msgstr ""
"Efineday-Ypetay-Edicatepray Amenay Ypetay\n"
"  Establishway anway associationway etweenbay ethay ypetay edicatepray "
"Amenay andway ethay\n"
"  orrespondingcay Ypetay.  Isthay ausescay ethay ypetay edicatepray otay "
"ebay ecognizedray orfay\n"
"  urposespay ofway optimizationway."

#: src/compiler/typetran.lisp
msgid "Can't open-code test of non-constant type."
msgstr "Ancay't openway-odecay esttay ofway onnay-onstantcay ypetay."

#: src/compiler/typetran.lisp
msgid "Can't open-code test of unknown type ~S."
msgstr "Ancay't openway-odecay esttay ofway unknownway ypetay ~S."

#: src/compiler/typetran.lisp
msgid ""
"Can't compile TYPEP of anonymous or undefined ~\n"
"\t\t\tclass:~%  ~S"
msgstr ""
"Ancay't ompilecay TYPEP ofway anonymousway orway undefinedway ~\n"
"\t\t\tassclay:~%  ~S"

#: src/compiler/typetran.lisp
msgid "Illegal type specifier for Typep: ~S."
msgstr "Illegalway ypetay ecifierspay orfay Ypeptay: ~S."

#: src/compiler/float-tran.lisp
msgid "use inline fixnum operations"
msgstr "useway inlineway ixnumfay operationsway"

#: src/compiler/float-tran.lisp
msgid "use inline (unsigned-byte 32) operations"
msgstr "useway inlineway (unsignedway-ytebay 32) operationsway"

#: src/compiler/float-tran.lisp
msgid "Shouldn't happen"
msgstr "Ouldnshay't appenhay"

#: src/compiler/float-tran.lisp
msgid "Can't open-code float to rational comparison."
msgstr "Ancay't openway-odecay oatflay otay ationalray omparisoncay."

#: src/compiler/float-tran.lisp
msgid "~S doesn't have a precise float representation."
msgstr "~S oesnday't avehay away ecisepray oatflay epresentationray."

#: src/compiler/float-tran.lisp
msgid ""
"Unable to avoid inline argument range check~@\n"
"                      because the argument range (~s) was not within 2^~D"
msgstr ""
"Unableway otay avoidway inlineway argumentway angeray eckchay~@\n"
"                      ecausebay ethay argumentway angeray (~s) asway otnay "
"ithinway 2^~D"

#: src/compiler/float-tran.lisp
msgid ""
"Unable to avoid inline argument range check~@\n"
"                   because the argument range (~s) was not within 2^~D"
msgstr ""
"Unableway otay avoidway inlineway argumentway angeray eckchay~@\n"
"                   ecausebay ethay argumentway angeray (~s) asway otnay "
"ithinway 2^~D"

#: src/compiler/float-tran.lisp
msgid "Float zero bound ~s not correctly canonicalised?"
msgstr "Oatflay erozay oundbay ~s otnay orrectlycay anonicalisedcay?"

#: src/compiler/float-tran-dd.lisp
msgid "Compute fl(a*b) and err(a*b)"
msgstr "Omputecay flay(a*bway) andway errway(a*bway)"

#: src/compiler/float-tran-dd.lisp
msgid ""
"Compute fl(a*a) and err(a*b).  This is a more efficient\n"
"  implementation of two-prod"
msgstr ""
"Omputecay flay(a*away) andway errway(a*bway).  Isthay isway away oremay "
"efficientway\n"
"  implementationway ofway wotay-odpray"

#: src/compiler/float-tran-dd.lisp
msgid "Computes fl(a+b) and err(a+b), assuming |a| >= |b|"
msgstr ""
"Omputescay flay(away+b) andway errway(away+b), assumingway |away| >= |b|"

#: src/compiler/float-tran-dd.lisp
msgid "Computes fl(a+b) and err(a+b)"
msgstr "Omputescay flay(away+b) andway errway(away+b)"

#: src/compiler/float-tran-dd.lisp
msgid "Add the double-double A0,A1 to the double-double B0,B1"
msgstr ""
"Addway ethay oubleday-oubleday Away0,Away1 otay ethay oubleday-oubleday B0,B1"

#: src/compiler/float-tran-dd.lisp
msgid "Compute fl(a-b) and err(a-b), assuming |a| >= |b|"
msgstr ""
"Omputecay flay(away-b) andway errway(away-b), assumingway |away| >= |b|"

#: src/compiler/float-tran-dd.lisp
msgid "Compute fl(a-b) and err(a-b)"
msgstr "Omputecay flay(away-b) andway errway(away-b)"

#: src/compiler/float-tran-dd.lisp
msgid "Subtract the double-double B0,B1 from A0,A1"
msgstr "Ubtractsay ethay oubleday-oubleday B0,B1 omfray Away0,Away1"

#: src/compiler/float-tran-dd.lisp
msgid "Compute double-double = double - double-double"
msgstr "Omputecay oubleday-oubleday = oubleday - oubleday-oubleday"

#: src/compiler/float-tran-dd.lisp
msgid "Subtract the double B from the double-double A0,A1"
msgstr "Ubtractsay ethay oubleday B omfray ethay oubleday-oubleday Away0,Away1"

#: src/compiler/float-tran-dd.lisp
msgid ""
"Split the double-float number a into a-hi and a-lo such that a =\n"
"  a-hi + a-lo and a-hi contains the upper 26 significant bits of a and\n"
"  a-lo contains the lower 26 bits."
msgstr ""
"Litspay ethay oubleday-oatflay umbernay away intoway away-ihay andway away-"
"olay uchsay atthay away =\n"
"  away-ihay + away-olay andway away-ihay ontainscay ethay upperway 26 "
"ignificantsay itsbay ofway away andway\n"
"  away-olay ontainscay ethay owerlay 26 itsbay."

#: src/compiler/float-tran-dd.lisp
msgid "Multiply the double-double A0,A1 with B0,B1"
msgstr "Ultiplymay ethay oubleday-oubleday Away0,Away1 ithway B0,B1"

#: src/compiler/float-tran-dd.lisp
msgid "Add the double-double A0,A1 to the double B"
msgstr "Addway ethay oubleday-oubleday Away0,Away1 otay ethay oubleday B"

#: src/compiler/float-tran-dd.lisp
msgid "Divide the double-double A0,A1 by B0,B1"
msgstr "Ivideday ethay oubleday-oubleday Away0,Away1 ybay B0,B1"

#: src/compiler/float-tran-dd.lisp
msgid "Square"
msgstr "Quaresay"

#: src/compiler/saptran.lisp
msgid "FOREIGN-SYMBOL-ADDRESS flavor ~S is not :CODE or :DATA"
msgstr "FOREIGN-SYMBOL-ADDRESS avorflay ~S isway otnay :CODE orway :DATA"

#: src/compiler/srctran.lisp
msgid "Function doesn't have fixed argument count."
msgstr "Unctionfay oesnday't avehay ixedfay argumentway ountcay."

#: src/compiler/srctran.lisp
msgid "Unknown bound type in make-interval!"
msgstr "Unknownway oundbay ypetay inway akemay-intervalway!"

#: src/compiler/srctran.lisp
msgid "This shouldn't happen!"
msgstr "Isthay ouldnshay't appenhay!"

#: src/compiler/srctran.lisp
msgid "BOOLE code is not a constant."
msgstr "BOOLE odecay isway otnay away onstantcay."

#: src/compiler/srctran.lisp
msgid "~S illegal control arg to BOOLE."
msgstr "~S illegalway ontrolcay argway otay BOOLE."

#: src/compiler/srctran.lisp
msgid "Unexpected types: ~s ~s~%"
msgstr "Unexpectedway ypestay: ~s ~s~%"

#: src/compiler/srctran.lisp
msgid "Operands might not be the same type."
msgstr "Operandsway ightmay otnay ebay ethay amesay ypetay."

#: src/compiler/srctran.lisp
msgid "~s: too few args (~d), need at least ~d"
msgstr "~s: ootay ewfay argsway (~d), eednay atway eastlay ~d"

#: src/compiler/srctran.lisp
msgid "~s: too many args (~d), wants at most ~d"
msgstr "~s: ootay anymay argsway (~d), antsway atway ostmay ~d"

#: src/compiler/srctran.lisp
msgid "Control string is not a constant."
msgstr "Ontrolcay ingstray isway otnay away onstantcay."

#: src/compiler/srctran.lisp
msgid ""
"When non-NIL, the compiler will generate code utilizing modular\n"
"  arithmetic.  Set to NIL to disable this, if you don't want modular\n"
"  arithmetic in some cases."
msgstr ""
"Enwhay onnay-NIL, ethay ompilercay illway enerategay odecay utilizingway "
"odularmay\n"
"  arithmeticway.  Etsay otay NIL otay isableday isthay, ifway ouyay onday't "
"antway odularmay\n"
"  arithmeticway inway omesay asescay."

#: src/compiler/locall.lisp
msgid ""
"Couldn't inline expand because expansion ~\n"
"\t\t\t\t   calls this let-converted local function:~\n"
"\t\t\t\t   ~%  ~S"
msgstr ""
"Ouldncay't inlineway expandway ecausebay expansionway ~\n"
"\t\t\t\t   allscay isthay etlay-onvertedcay ocallay unctionfay:~\n"
"\t\t\t\t   ~%  ~S"

#: src/compiler/locall.lisp
msgid "Function called with ~R argument~:P, but wants exactly ~R."
msgstr ""
"Unctionfay alledcay ithway ~R argumentway~:P, utbay antsway exactlyway ~R."

#: src/compiler/locall.lisp
msgid "Function called with ~R argument~:P, but wants at least ~R."
msgstr ""
"Unctionfay alledcay ithway ~R argumentway~:P, utbay antsway atway eastlay ~R."

#: src/compiler/locall.lisp
msgid "Function called with ~R argument~:P, but wants at most ~R."
msgstr ""
"Unctionfay alledcay ithway ~R argumentway~:P, utbay antsway atway ostmay ~R."

#: src/compiler/locall.lisp
msgid "Can't local-call functions with &MORE args."
msgstr "Ancay't ocallay-allcay unctionsfay ithway &MORE argsway."

#: src/compiler/locall.lisp
msgid ""
"Function called with odd number of ~\n"
"\t  \t\t     arguments in keyword portion."
msgstr ""
"Unctionfay alledcay ithway oddway umbernay ofway ~\n"
"\t  \t\t     argumentsway inway eywordkay ortionpay."

#: src/compiler/locall.lisp
msgid "Non-constant keyword in keyword call."
msgstr "Onnay-onstantcay eywordkay inway eywordkay allcay."

#: src/compiler/locall.lisp
msgid "non-constant :ALLOW-OTHER-KEYS value"
msgstr "onnay-onstantcay :ALLOW-OTHER-KEYS aluevay"

#: src/compiler/locall.lisp
msgid "Function called with unknown argument keyword ~S."
msgstr "Unctionfay alledcay ithway unknownway argumentway eywordkay ~S."

#: src/compiler/dfo.lisp
msgid "Top-Level Form"
msgstr "Optay-Evellay Ormfay"

#: src/compiler/checkgen.lisp
msgid "~:[This~;~:*~A~] is not a ~<~%~9T~:;~S:~>~%  ~S"
msgstr "~:[Isthay~;~:*~Away~] isway otnay away ~<~%~9T~:;~S:~>~%  ~S"

#: src/compiler/checkgen.lisp
msgid "~:[Result~;~:*~A~] is a ~S, ~<~%~9T~:;not a ~S.~>"
msgstr "~:[Esultray~;~:*~Away~] isway away ~S, ~<~%~9T~:;otnay away ~S.~>"

#: src/compiler/checkgen.lisp
msgid "~:[A possible~;The~] binding of ~S"
msgstr "~:[Away ossiblepay~;Ethay~] indingbay ofway ~S"

#: src/compiler/checkgen.lisp
msgid "Type assertion too complex to check:~% ~S."
msgstr "Ypetay assertionway ootay omplexcay otay eckchay:~% ~S."

#: src/compiler/constraint.lisp
msgid ""
"*** Unreachable code in constraint ~\n"
"\t\t\t  propagation...  Bug?"
msgstr ""
"*** Unreachableway odecay inway onstraintcay ~\n"
"\t\t\t  opagationpray...  Ugbay?"

#: src/compiler/tn.lisp
msgid ""
"Do-Packed-TNs (TN-Var Component [Result]) Declaration* Form*\n"
"  Iterate over all packed TNs allocated in Component."
msgstr ""
"Oday-Ackedpay-Nstay (TN-Arvay Omponentcay [Esultray]) Eclaration*Day "
"Orm*Fay\n"
"  Iterateway overway allway ackedpay Nstay allocatedway inway Omponentcay."

#: src/compiler/tn.lisp
msgid "SC ~S has no :unbounded :save-p NIL alternate SC."
msgstr "SC ~S ashay onay :unboundedway :avesay-p NIL alternateway SC."

#: src/compiler/life.lisp
msgid "More operand ~S used more than once in its VOP."
msgstr "Oremay operandway ~S usedway oremay anthay onceway inway itsway VOP."

#: src/compiler/debug-dump.lisp
msgid ""
"Extract the namestring from FILE-INFO for the DEBUG-SOURCE.  \n"
"Return FILE-INFO's untruename (e.g., target:foo) if it is absolute;\n"
"otherwise the truename."
msgstr ""
"Extractway ethay amestringnay omfray FILE-INFO orfay ethay DEBUG-SOURCE.  \n"
"Eturnray FILE-INFO's untruenameway (e.g., argettay:oofay) ifway itway isway "
"absoluteway;\n"
"otherwiseway ethay uenametray."

#: src/compiler/generic/utils.lisp
msgid "Make a fixnum out of NUM.  (i.e. shift by two bits if it will fit.)"
msgstr ""
"Akemay away ixnumfay outway ofway NUM.  (i.e. iftshay ybay wotay itsbay "
"ifway itway illway itfay.)"

#: src/compiler/generic/utils.lisp
msgid "~D is too big for a fixnum."
msgstr "~D isway ootay igbay orfay away ixnumfay."

#: src/compiler/generic/utils.lisp
msgid "Returns the byte offset of the static symbol Symbol."
msgstr ""
"Eturnsray ethay ytebay offsetway ofway ethay taticsay ymbolsay Ymbolsay."

#: src/compiler/generic/utils.lisp
msgid "~S is not a static symbol."
msgstr "~S isway otnay away taticsay ymbolsay."

#: src/compiler/generic/utils.lisp
msgid "Given a byte offset, Offset, returns the appropriate static symbol."
msgstr ""
"Ivengay away ytebay offsetway, Offsetway, eturnsray ethay appropriateway "
"taticsay ymbolsay."

#: src/compiler/generic/utils.lisp
msgid "Byte offset, ~D, is not correct."
msgstr "Ytebay offsetway, ~D, isway otnay orrectcay."

#: src/compiler/generic/utils.lisp
msgid ""
"Return the (byte) offset from NIL to the start of the fdefn object\n"
"   for the static function NAME."
msgstr ""
"Eturnray ethay (ytebay) offsetway omfray NIL otay ethay tartsay ofway ethay "
"defnfay objectway\n"
"   orfay ethay taticsay unctionfay NAME."

#: src/compiler/generic/utils.lisp
msgid "~S isn't a static function."
msgstr "~S isnway't away taticsay unctionfay."

#: src/compiler/generic/utils.lisp
msgid ""
"Given a byte offset, Offset, returns the appropriate static function\n"
"   symbol."
msgstr ""
"Ivengay away ytebay offsetway, Offsetway, eturnsray ethay appropriateway "
"taticsay unctionfay\n"
"   ymbolsay."

#: src/compiler/generic/primtype.lisp
msgid ""
"An a-list for mapping simple array element types to their\n"
"  corresponding primitive types."
msgstr ""
"Anway away-istlay orfay appingmay implesay arrayway elementway ypestay otay "
"eirthay\n"
"  orrespondingcay imitivepray ypestay."

#: src/compiler/aliencomp.lisp
msgid "Slot is not constant, so cannot open code access."
msgstr "Otslay isway otnay onstantcay, osay annotcay openway odecay accessway."

#: src/compiler/aliencomp.lisp
msgid "~S doesn't have a slot named ~S"
msgstr "~S oesnday't avehay away otslay amednay ~S"

#: src/compiler/aliencomp.lisp
msgid "Too many indices for pointer deref: ~D"
msgstr "Ootay anymay indicesway orfay ointerpay erefday: ~D"

#: src/compiler/aliencomp.lisp
msgid "Unknown element size."
msgstr "Unknownway elementway izesay."

#: src/compiler/aliencomp.lisp
msgid "Unknown element alignment."
msgstr "Unknownway elementway alignmentway."

#: src/compiler/aliencomp.lisp
msgid "Incorrect number of indices."
msgstr "Incorrectway umbernay ofway indicesway."

#: src/compiler/aliencomp.lisp
msgid "Element size unknown."
msgstr "Elementway izesay unknownway."

#: src/compiler/aliencomp.lisp
msgid "Element alignment unknown."
msgstr "Elementway alignmentway unknownway."

#: src/compiler/aliencomp.lisp
msgid "~S not either a pointer or array type."
msgstr "~S otnay eitherway away ointerpay orway arrayway ypetay."

#: src/compiler/aliencomp.lisp
msgid "Info not constant; can't open code."
msgstr "Infoway otnay onstantcay; ancay't openway odecay."

#: src/compiler/aliencomp.lisp
msgid "Aliens of type ~S cannot be represented immediately."
msgstr "Aliensway ofway ypetay ~S annotcay ebay epresentedray immediatelyway."

#: src/compiler/aliencomp.lisp
msgid "Local Alien Info isn't constant?"
msgstr "Ocallay Alienway Infoway isnway't onstantcay?"

#: src/compiler/aliencomp.lisp
msgid "This shouldn't happen."
msgstr "Isthay ouldnshay't appenhay."

#: src/compiler/aliencomp.lisp
msgid "Alien type not constant; cannot open code."
msgstr "Alienway ypetay otnay onstantcay; annotcay openway odecay."

#: src/compiler/aliencomp.lisp
msgid ""
"Could not optimize away %SAP-ALIEN: forced to do runtime ~@\n"
"\t    allocation of alien-value structure."
msgstr ""
"Ouldcay otnay optimizeway awayway %SAP-ALIEN: orcedfay otay oday untimeray "
"~@\n"
"\t    allocationway ofway alienway-aluevay ucturestray."

#: src/compiler/aliencomp.lisp
msgid "Type not constant at compile time; can't open code."
msgstr ""
"Ypetay otnay onstantcay atway ompilecay imetay; ancay't openway odecay."

#: src/compiler/aliencomp.lisp
msgid "Can't tell function type at compile time."
msgstr "Ancay't elltay unctionfay ypetay atway ompilecay imetay."

#: src/compiler/aliencomp.lisp
msgid "Wrong number of arguments.  Expected ~D, got ~D."
msgstr "Ongwray umbernay ofway argumentsway.  Expectedway ~D, otgay ~D."

#: src/compiler/aliencomp.lisp
msgid "Something is broken."
msgstr "Omethingsay isway okenbray."

#: src/compiler/aliencomp.lisp
msgid "No unique move-arg-vop for moves in SC ~S."
msgstr "Onay uniqueway ovemay-argway-opvay orfay ovesmay inway SC ~S."

#: src/compiler/ltv.lisp
msgid "(during EVAL of LOAD-TIME-VALUE)~%~A"
msgstr "(uringday EVAL ofway LOAD-TIME-VALUE)~%~Away"

#: src/compiler/ltv.lisp
msgid ""
"Arrange for FORM to be evaluated at load-time and use the value produced\n"
"   as if it were a constant.  If READ-ONLY-P is non-NIL, then the resultant\n"
"   object is guaranteed to never be modified, so it can be put in read-only\n"
"   storage."
msgstr ""
"Arrangeway orfay FORM otay ebay evaluatedway atway oadlay-imetay andway "
"useway ethay aluevay oducedpray\n"
"   asway ifway itway ereway away onstantcay.  Ifway READ-ONLY-P isway onnay-"
"NIL, enthay ethay esultantray\n"
"   objectway isway uaranteedgay otay evernay ebay odifiedmay, osay itway "
"ancay ebay utpay inway eadray-onlyway\n"
"   toragesay."

#: src/compiler/gtn.lisp
msgid ""
"Return value count mismatch prevents known return ~\n"
"\t\t       from these functions:~\n"
"\t\t       ~{~%  ~A~}"
msgstr ""
"Eturnray aluevay ountcay ismatchmay eventspray nownkay eturnray ~\n"
"\t\t       omfray esethay unctionsfay:~\n"
"\t\t       ~{~%  ~Away~}"

#: src/compiler/gtn.lisp
msgid ""
"Return type not fixed values, so can't use known return ~\n"
"\t\t      convention:~%  ~S"
msgstr ""
"Eturnray ypetay otnay ixedfay aluesvay, osay ancay't useway nownkay eturnray "
"~\n"
"\t\t      onventioncay:~%  ~S"

#: src/compiler/ltn.lisp
msgid ""
"Unable to check type assertion in unknown-values ~\n"
"\t                context:~% ~S"
msgstr ""
"Unableway otay eckchay ypetay assertionway inway unknownway-aluesvay ~\n"
"\t                ontextcay:~% ~S"

#: src/compiler/represent.lisp src/compiler/ir2tran.lisp src/compiler/ltn.lisp
msgid "Neither CONT nor TN supplied."
msgstr "Eithernay CONT ornay TN uppliedsay."

#: src/compiler/ltn.lisp
msgid "~S has :MORE results with :TRANSLATE."
msgstr "~S ashay :MORE esultsray ithway :TRANSLATE."

#: src/compiler/ltn.lisp
msgid ""
"This is the maximum number of possible optimization alternatives will be\n"
"  mentioned in a particular efficiency note.  NIL means no limit."
msgstr ""
"Isthay isway ethay aximummay umbernay ofway ossiblepay optimizationway "
"alternativesway illway ebay\n"
"  entionedmay inway away articularpay efficiencyway otenay.  NIL eansmay "
"onay imitlay."

#: src/compiler/ltn.lisp
msgid ""
"This is the minumum cost difference between the chosen implementation and\n"
"  the next alternative that justifies an efficiency note."
msgstr ""
"Isthay isway ethay inumummay ostcay ifferenceday etweenbay ethay osenchay "
"implementationway andway\n"
"  ethay extnay alternativeway atthay ustifiesjay anway efficiencyway otenay."

#: src/compiler/ltn.lisp
msgid "This shouldn't happen!  Bug?"
msgstr "Isthay ouldnshay't appenhay!  Ugbay?"

#: src/compiler/ltn.lisp
msgid "Template guard failed."
msgstr "Emplatetay uardgay ailedfay."

#: src/compiler/ltn.lisp
msgid "Template is not safe, yet we were counting on it."
msgstr ""
"Emplatetay isway otnay afesay, etyay eway ereway ountingcay onway itway."

#: src/compiler/ltn.lisp
msgid "Argument types invalid."
msgstr "Argumentway ypestay invalidway."

#: src/compiler/ltn.lisp
msgid "Argument primitive types:~%  ~S"
msgstr "Argumentway imitivepray ypestay:~%  ~S"

#: src/compiler/ltn.lisp
msgid "Argument type assertions:~%  ~S"
msgstr "Argumentway ypetay assertionsway:~%  ~S"

#: src/compiler/ltn.lisp
msgid "Conditional in a non-conditional context."
msgstr "Onditionalcay inway away onnay-onditionalcay ontextcay."

#: src/compiler/ltn.lisp
msgid "Result types invalid."
msgstr "Esultray ypestay invalidway."

#: src/compiler/ltn.lisp
msgid "etc."
msgstr "etcway."

#: src/compiler/ltn.lisp
msgid "Unable to do ~A (cost ~D) because:"
msgstr "Unableway otay oday ~Away (ostcay ~D) ecausebay:"

#: src/compiler/ltn.lisp
msgid ""
"Can't trust output type assertion under safe ~\n"
"\t\t       policy."
msgstr ""
"Ancay't usttray outputway ypetay assertionway underway afesay ~\n"
"\t\t       olicypay."

#: src/compiler/ltn.lisp
msgid "Forced to do ~A (cost ~D)."
msgstr "Orcedfay otay oday ~Away (ostcay ~D)."

#: src/compiler/ltn.lisp
msgid "Forced to do full call."
msgstr "Orcedfay otay oday ullfay allcay."

#: src/compiler/ltn.lisp
msgid "Recursive known function definition."
msgstr "Ecursiveray nownkay unctionfay efinitionday."

#: src/compiler/ir2tran.lisp
msgid ""
"Always perform stack clearing if non-NIL, independent of the\n"
"compilation policy"
msgstr ""
"Alwaysway erformpay tacksay earingclay ifway onnay-NIL, independentway ofway "
"ethay\n"
"ompilationcay olicypay"

#: src/compiler/ir2tran.lisp
msgid ""
"If non-NIL and the compilation policy allows, stack clearing is enabled."
msgstr ""
"Ifway onnay-NIL andway ethay ompilationcay olicypay allowsway, tacksay "
"earingclay isway enabledway."

#: src/compiler/ir2tran.lisp
msgid "~@<~2I~_~S ~_not found in ~_~S~:>"
msgstr "~@<~2Iway~_~S ~_otnay oundfay inway ~_~S~:>"

#: src/compiler/represent.lisp
msgid "Couldn't find REF?"
msgstr "Ouldncay't indfay REF?"

#: src/compiler/represent.lisp
msgid ""
"Representation selection flamed out for no obvious reason.~@\n"
"\t          Try again after recompiling the VM definition."
msgstr ""
"Epresentationray electionsay amedflay outway orfay onay obviousway easonray."
"~@\n"
"\t          Ytray againway afterway ecompilingray ethay VM efinitionday."

#: src/compiler/represent.lisp
msgid ""
"~S is not valid as the ~:R ~:[result~;argument~] to the~@\n"
"\t        ~S VOP, since the TN's primitive type ~S allows SCs:~%  ~S~@\n"
"\t\t~:[which cannot be coerced or loaded into the allowed SCs:~\n"
"\t\t~%  ~S~;~*~]~:[~;~@\n"
"\t\tCurrent cost info inconsistent with that in effect at compile ~\n"
"\t\ttime.  Recompile.~%Compilation order may be incorrect.~]"
msgstr ""
"~S isway otnay alidvay asway ethay ~:R ~:[esultray~;argumentway~] otay "
"ethay~@\n"
"\t        ~S VOP, incesay ethay TN's imitivepray ypetay ~S allowsway Sscay:"
"~%  ~S~@\n"
"\t\t~:[ichwhay annotcay ebay oercedcay orway oadedlay intoway ethay "
"allowedway Sscay:~\n"
"\t\t~%  ~S~;~*~]~:[~;~@\n"
"\t\tUrrentcay ostcay infoway inconsistentway ithway atthay inway effectway "
"atway ompilecay ~\n"
"\t\timetay.  Ecompileray.~%Ompilationcay orderway aymay ebay incorrectway.~]"

#: src/compiler/represent.lisp
msgid ""
"Representation selection flamed out for no ~\n"
"\t\t             obvious reason."
msgstr ""
"Epresentationray electionsay amedflay outway orfay onay ~\n"
"\t\t             obviousway easonray."

#: src/compiler/represent.lisp
msgid ""
"~S is not valid as the ~:R ~:[result~;argument~] to VOP:~\n"
"\t        ~%  ~S~%Primitive type: ~S~@\n"
"\t\tSC restrictions:~%  ~S~@\n"
"\t\t~@[The primitive type disallows these loadable SCs:~%  ~S~%~]~\n"
"\t\t~@[No move VOPs are defined to coerce to these allowed SCs:~\n"
"\t\t~%  ~S~%~]~\n"
"\t\t~@[These move VOPs couldn't be used due to operand type ~\n"
"\t\trestrictions:~%  ~S~%~]~\n"
"\t\t~:[~;~@\n"
"\t\tCurrent cost info inconsistent with that in effect at compile ~\n"
"\t\ttime.  Recompile.~%Compilation order may be incorrect.~]"
msgstr ""
"~S isway otnay alidvay asway ethay ~:R ~:[esultray~;argumentway~] otay VOP:"
"~\n"
"\t        ~%  ~S~%Imitivepray ypetay: ~S~@\n"
"\t\tSC estrictionsray:~%  ~S~@\n"
"\t\t~@[Ethay imitivepray ypetay isallowsday esethay oadablelay Sscay:~%  "
"~S~%~]~\n"
"\t\t~@[Onay ovemay Opsvay areway efinedday otay oercecay otay esethay "
"allowedway Sscay:~\n"
"\t\t~%  ~S~%~]~\n"
"\t\t~@[Esethay ovemay Opsvay ouldncay't ebay usedway ueday otay operandway "
"ypetay ~\n"
"\t\testrictionsray:~%  ~S~%~]~\n"
"\t\t~:[~;~@\n"
"\t\tUrrentcay ostcay infoway inconsistentway ithway atthay inway effectway "
"atway ompilecay ~\n"
"\t\timetay.  Ecompileray.~%Ompilationcay orderway aymay ebay incorrectway.~]"

#: src/compiler/represent.lisp
msgid ""
"No :MOVE-ARGUMENT VOP defined to move ~S (SC ~S) to ~\n"
"          ~S (SC ~S.)"
msgstr ""
"Onay :MOVE-ARGUMENT VOP efinedday otay ovemay ~S (SC ~S) otay ~\n"
"          ~S (SC ~S.)"

#: src/compiler/represent.lisp
msgid ""
"No move function defined to load SC ~S from constant ~\n"
"\t             SC ~S."
msgstr ""
"Onay ovemay unctionfay efinedday otay oadlay SC ~S omfray onstantcay ~\n"
"\t             SC ~S."

#: src/compiler/represent.lisp
msgid ""
"No move function defined to load SC ~S from alternate ~\n"
"\t             SC ~S."
msgstr ""
"Onay ovemay unctionfay efinedday otay oadlay SC ~S omfray alternateway ~\n"
"\t             SC ~S."

#: src/compiler/represent.lisp
msgid ""
"No move function defined to save SC ~S to alternate ~\n"
"\t             SC ~S."
msgstr ""
"Onay ovemay unctionfay efinedday otay avesay SC ~S otay alternateway ~\n"
"\t             SC ~S."

#: src/compiler/represent.lisp
msgid "<return value>"
msgstr "<eturnray aluevay>"

#: src/compiler/represent.lisp
msgid ""
"Doing ~A (cost ~D)~:[~2*~; ~:[to~;from~] ~S~], for:~%~6T~\n"
"\t       The ~:R ~:[result~;argument~] of ~A."
msgstr ""
"Oingday ~Away (ostcay ~D)~:[~2*~; ~:[otay~;omfray~] ~S~], orfay:~%~6T~\n"
"\t       Ethay ~:R ~:[esultray~;argumentway~] ofway ~Away."

#: src/compiler/represent.lisp
msgid "Doing ~A (cost ~D)~@[ from ~S~]~@[ to ~S~]."
msgstr "Oingday ~Away (ostcay ~D)~@[ omfray ~S~]~@[ otay ~S~]."

#: src/compiler/represent.lisp
msgid "Couldn't fine op?  Bug!"
msgstr "Ouldncay't inefay opway?  Ugbay!"

#: src/compiler/codegen.lisp
msgid "Returns the number of bytes used by the code object header."
msgstr ""
"Eturnsray ethay umbernay ofway ytesbay usedway ybay ethay odecay objectway "
"eaderhay."

#: src/compiler/codegen.lisp
msgid ""
"The size of the Name'd SB in the currently compiled component.  Useful\n"
"  mainly for finding the size for allocating stack frames."
msgstr ""
"Ethay izesay ofway ethay Amenay'd SB inway ethay urrentlycay ompiledcay "
"omponentcay.  Usefulway\n"
"  ainlymay orfay indingfay ethay izesay orfay allocatingway tacksay amesfray."

#: src/compiler/codegen.lisp
msgid ""
"Return the TN that is used to hold the number stack frame-pointer in VOP's\n"
"  function.  Returns NIL if no number stack frame was allocated."
msgstr ""
"Eturnray ethay TN atthay isway usedway otay oldhay ethay umbernay tacksay "
"amefray-ointerpay inway VOP's\n"
"  unctionfay.  Eturnsray NIL ifway onay umbernay tacksay amefray asway "
"allocatedway."

#: src/compiler/codegen.lisp
msgid ""
"Return the TN that is used to hold the number stack frame-pointer in the\n"
"  function designated by 2env.  Returns NIL if no number stack frame was\n"
"  allocated."
msgstr ""
"Eturnray ethay TN atthay isway usedway otay oldhay ethay umbernay tacksay "
"amefray-ointerpay inway ethay\n"
"  unctionfay esignatedday ybay 2envway.  Eturnsray NIL ifway onay umbernay "
"tacksay amefray asway\n"
"  allocatedway."

#: src/compiler/codegen.lisp
msgid ""
"Return the TN used for passing the return PC in a local call to the "
"function\n"
"  designated by 2env."
msgstr ""
"Eturnray ethay TN usedway orfay assingpay ethay eturnray PC inway away "
"ocallay allcay otay ethay unctionfay\n"
"  esignatedday ybay 2envway."

#: src/compiler/codegen.lisp
msgid ""
"Set to NIL to inhibit assembly-level optimization.  For compiler debugging,\n"
"  rather than policy control."
msgstr ""
"Etsay otay NIL otay inhibitway assemblyway-evellay optimizationway.  Orfay "
"ompilercay ebuggingday,\n"
"  atherray anthay olicypay ontrolcay."

#: src/compiler/codegen.lisp
msgid "In the ~A segment:~%"
msgstr "Inway ethay ~Away egmentsay:~%"

#: src/compiler/codegen.lisp
msgid "~|~%Assembly code for ~S~2%"
msgstr "~|~%Assemblyway odecay orfay ~S~2%"

#: src/compiler/codegen.lisp
msgid "Missing generator for ~S.~%"
msgstr "Issingmay eneratorgay orfay ~S.~%"

#: src/compiler/debug.lisp
msgid ""
"This variable is bound to the format arguments when an error is signalled\n"
"  by Barf or Burp."
msgstr ""
"Isthay ariablevay isway oundbay otay ethay ormatfay argumentsway enwhay "
"anway errorway isway ignalledsay\n"
"  ybay Arfbay orway Urpbay."

#: src/compiler/debug.lisp
msgid ""
"Action taken by the Burp function when a possible compiler bug is detected.\n"
"  One of :Warn, :Error or :None."
msgstr ""
"Actionway akentay ybay ethay Urpbay unctionfay enwhay away ossiblepay "
"ompilercay ugbay isway etectedday.\n"
"  Oneway ofway :Arnway, :Errorway orway :Onenay."

#: src/compiler/debug.lisp
msgid ""
"Return a list of a the TNs that conflict with TN.  Sort of, kind of.  For\n"
"  debugging use only.  Probably doesn't work on :COMPONENT TNs."
msgstr ""
"Eturnray away istlay ofway away ethay Nstay atthay onflictcay ithway TN.  "
"Ortsay ofway, indkay ofway.  Orfay\n"
"  ebuggingday useway onlyway.  Obablypray oesnday't orkway onway :COMPONENT "
"Nstay."

#: src/compiler/debug.lisp
msgid "Return the Nth VOP in the IR2-Block pointed to by Thing."
msgstr ""
"Eturnray ethay Thnay VOP inway ethay IR2-Ockblay ointedpay otay ybay Ingthay."

#: src/compiler/xref.lisp
msgid "Reinitialize the cross-reference database."
msgstr "Einitializeray ethay osscray-eferenceray atabaseday."

#: src/compiler/xref.lisp
msgid ""
"Return a list of those program contexts where a globally-defined\n"
"function may be called at runtime."
msgstr ""
"Eturnray away istlay ofway osethay ogrampray ontextscay erewhay away "
"oballyglay-efinedday\n"
"unctionfay aymay ebay alledcay atway untimeray."

#: src/compiler/xref.lisp
msgid ""
"Return a list of those program contexts where GLOBAL-VARIABLE\n"
"may be referenced at runtime."
msgstr ""
"Eturnray away istlay ofway osethay ogrampray ontextscay erewhay GLOBAL-"
"VARIABLE\n"
"aymay ebay eferencedray atway untimeray."

#: src/compiler/xref.lisp
msgid ""
"Return a list of those program contexts where GLOBAL-VARIABLE may\n"
"be bound at runtime."
msgstr ""
"Eturnray away istlay ofway osethay ogrampray ontextscay erewhay GLOBAL-"
"VARIABLE aymay\n"
"ebay oundbay atway untimeray."

#: src/compiler/xref.lisp
msgid ""
"Return a list of those program contexts where GLOBAL-VARIABLE may\n"
"be set at runtime."
msgstr ""
"Eturnray away istlay ofway osethay ogrampray ontextscay erewhay GLOBAL-"
"VARIABLE aymay\n"
"ebay etsay atway untimeray."

#: src/compiler/dyncount.lisp
msgid "When T, emit extra code to collect dynamic statistics about vop usages."
msgstr ""
"Enwhay T, emitway extraway odecay otay ollectcay ynamicday tatisticssay "
"aboutway opvay usagesway."

#: src/compiler/dyncount.lisp
msgid "Holds the TN for the counts vector."
msgstr "Oldshay ethay TN orfay ethay ountscay ectorvay."

#: src/compiler/dump.lisp
msgid "Compiler bug: ~S not a legal fasload operator."
msgstr "Ompilercay ugbay: ~S otnay away egallay asloadfay operatorway."

#: src/compiler/dump.lisp
msgid "Tried to output ~D bytes, but only ~D made it."
msgstr "Iedtray otay outputway ~D ytesbay, utbay onlyway ~D ademay itway."

#: src/compiler/dump.lisp
msgid "This object cannot be dumped into a fasl file:~% ~S"
msgstr ""
"Isthay objectway annotcay ebay umpedday intoway away aslfay ilefay:~% ~S"

#: src/compiler/dump.lisp
msgid "~S already dumped?"
msgstr "~S alreadyway umpedday?"

#: src/compiler/dump.lisp
msgid "Attempt to dump invalid structure:~%  ~S~%How did this happen?"
msgstr ""
"Attemptway otay umpday invalidway ucturestray:~%  ~S~%Owhay idday isthay "
"appenhay?"

#: src/compiler/dump.lisp
msgid "Dumping reference to obsolete class: ~S"
msgstr "Umpingday eferenceray otay obsoleteway assclay: ~S"

#: src/compiler/generic/core.lisp
msgid "Unknown foreign symbol: ~S"
msgstr "Unknownway oreignfay ymbolsay: ~S"

#: src/compiler/generic/core.lisp
msgid "Unresolved forward reference."
msgstr "Unresolvedway orwardfay eferenceray."

#: src/compiler/generic/core.lisp
msgid "#<Code Instruction Stream for ~S>"
msgstr "#<Odecay Instructionway Eamstray orfay ~S>"

#: src/compiler/generic/core.lisp
msgid "Writing ~D bytes to ~S would cause it to overflow."
msgstr "Itingwray ~D ytesbay otay ~S ouldway ausecay itway otay overflowway."

#: src/compiler/generic/core.lisp
msgid "Writing another byte to ~S would cause it to overflow."
msgstr ""
"Itingwray anotherway ytebay otay ~S ouldway ausecay itway otay overflowway."

#: src/compiler/generic/new-genesis.lisp
msgid "Rounds number up to be an integral multiple of size."
msgstr ""
"Oundsray umbernay upway otay ebay anway integralway ultiplemay ofway izesay."

#: src/compiler/generic/new-genesis.lisp
msgid "Handle on Nil."
msgstr "Andlehay onway Ilnay."

#: src/compiler/generic/new-genesis.lisp
msgid "Number of bits in the low half of the descriptor"
msgstr ""
"Umbernay ofway itsbay inway ethay owlay alfhay ofway ethay escriptorday"

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Alignment requirement for spaces in the target.\n"
"  Must be at least (ash 1 descriptor-low-bits"
msgstr ""
"Alignmentway equirementray orfay acesspay inway ethay argettay.\n"
"  Ustmay ebay atway eastlay (ashway 1 escriptorday-owlay-itsbay"

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Return a descriptor for a block of LENGTH bytes out of SPACE.  The free\n"
"  pointer is boosted as necessary.  If any additional memory is needed, we\n"
"  vm_allocate it.  The descriptor returned is a pointer of type LOWTAG."
msgstr ""
"Eturnray away escriptorday orfay away ockblay ofway LENGTH ytesbay outway "
"ofway SPACE.  Ethay eefray\n"
"  ointerpay isway oostedbay asway ecessarynay.  Ifway anyway additionalway "
"emorymay isway eedednay, eway\n"
"  mvay_allocateway itway.  Ethay escriptorday eturnedray isway away "
"ointerpay ofway ypetay LOWTAG."

#: src/compiler/generic/new-genesis.lisp
msgid "Return the lowtag bits for DES."
msgstr "Eturnray ethay owtaglay itsbay orfay DES."

#: src/compiler/generic/new-genesis.lisp
msgid "Return the bits of DES."
msgstr "Eturnray ethay itsbay ofway DES."

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Return a SAP pointing to the piece of memory DES refers to.  The lowtag\n"
"  bits of DES are ignored."
msgstr ""
"Eturnray away SAP ointingpay otay ethay iecepay ofway emorymay DES efersray "
"otay.  Ethay owtaglay\n"
"  itsbay ofway DES areway ignoredway."

#: src/compiler/generic/new-genesis.lisp
msgid "Handle on the trap object."
msgstr "Andlehay onway ethay aptray objectway."

#: src/compiler/generic/new-genesis.lisp
msgid "Head of list of functions to be called when the Lisp starts up."
msgstr ""
"Eadhay ofway istlay ofway unctionsfay otay ebay alledcay enwhay ethay Isplay "
"tartssay upway."

#: src/compiler/generic/new-genesis.lisp
msgid "Used by normal loader."
msgstr "Usedway ybay ormalnay oaderlay."

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Write VALUE (a descriptor) INDEX words from ADDRESS (also a descriptor)."
msgstr ""
"Itewray VALUE (away escriptorday) INDEX ordsway omfray ADDRESS (alsoway away "
"escriptorday)."

#: src/compiler/generic/new-genesis.lisp
msgid "Write VALUE (a descriptor) at ADDRESS (also a descriptor)."
msgstr ""
"Itewray VALUE (away escriptorday) atway ADDRESS (alsoway away escriptorday)."

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Return the value (as a descriptor) INDEX words from ADDRESS (a descriptor)."
msgstr ""
"Eturnray ethay aluevay (asway away escriptorday) INDEX ordsway omfray "
"ADDRESS (away escriptorday)."

#: src/compiler/generic/new-genesis.lisp
msgid "Return the value at ADDRESS (a descriptor)."
msgstr "Eturnray ethay aluevay atway ADDRESS (away escriptorday)."

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Allocate LENGTH words in SPACE and return a new descriptor of type LOWTAG\n"
"  pointing to them."
msgstr ""
"Allocateway LENGTH ordsway inway SPACE andway eturnray away ewnay "
"escriptorday ofway ypetay LOWTAG\n"
"  ointingpay otay emthay."

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Allocate LENGTH units of ELEMENT-SIZE bits plus a header word in SPACE and\n"
"  return an ``other-pointer'' descriptor to them.  Initialize the header "
"word\n"
"  with the resultant length and TYPE."
msgstr ""
"Allocateway LENGTH unitsway ofway ELEMENT-SIZE itsbay usplay away eaderhay "
"ordway inway SPACE andway\n"
"  eturnray anway ``otherway-ointerpay'' escriptorday otay emthay.  "
"Initializeway ethay eaderhay ordway\n"
"  ithway ethay esultantray engthlay andway TYPE."

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Allocate LENGTH units of ELEMENT-SIZE plus a header plus a length slot in\n"
"  SPACE and return an ``other-pointer'' descriptor to them.  Initialize the\n"
"  header word with TYPE and the length slot with LENGTH."
msgstr ""
"Allocateway LENGTH unitsway ofway ELEMENT-SIZE usplay away eaderhay usplay "
"away engthlay otslay inway\n"
"  SPACE andway eturnray anway ``otherway-ointerpay'' escriptorday otay "
"emthay.  Initializeway ethay\n"
"  eaderhay ordway ithway TYPE andway ethay engthlay otslay ithway LENGTH."

#: src/compiler/generic/new-genesis.lisp
msgid "Copy string into the CORE and return a descriptor to it."
msgstr ""
"Opycay ingstray intoway ethay CORE andway eturnray away escriptorday otay "
"itway."

#: src/compiler/generic/new-genesis.lisp
msgid "Copy the bignum to the core."
msgstr "Opycay ethay ignumbay otay ethay orecay."

#: src/compiler/generic/new-genesis.lisp
msgid "Makes a number pair of TYPE (ratio or complex) and fills it in."
msgstr ""
"Akesmay away umbernay airpay ofway TYPE (atioray orway omplexcay) andway "
"illsfay itway inway."

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Copy the given number to the core, or flame out if we can't deal with it."
msgstr ""
"Opycay ethay ivengay umbernay otay ethay orecay, orway ameflay outway ifway "
"eway ancay't ealday ithway itway."

#: src/compiler/generic/new-genesis.lisp
msgid "Allocate a cons cell in SPACE and fill it in with CAR and CDR."
msgstr ""
"Allocateway away onscay ellcay inway SPACE andway illfay itway inway ithway "
"CAR andway CDR."

#: src/compiler/generic/new-genesis.lisp
msgid "Generates code to push the THING onto the given cold load LIST."
msgstr ""
"Eneratesgay odecay otay ushpay ethay THING ontoway ethay ivengay oldcay "
"oadlay LIST."

#: src/compiler/generic/new-genesis.lisp
msgid "Initializes the cold load symbol-hacking data structures."
msgstr ""
"Initializesway ethay oldcay oadlay ymbolsay-ackinghay ataday ucturesstray."

#: src/compiler/generic/new-genesis.lisp
msgid "FOP functions for cold loading."
msgstr "FOP unctionsfay orfay oldcay oadinglay."

#: src/compiler/generic/new-genesis.lisp
msgid "Loads the file named by FileName into the cold load image being built."
msgstr ""
"Oadslay ethay ilefay amednay ybay Ilenamefay intoway ethay oldcay oadlay "
"imageway eingbay uiltbay."

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Return the version number from the symbol table file Filename.\n"
"  Value is 0 if Filename is null or the file doesn't exist."
msgstr ""
"Eturnray ethay ersionvay umbernay omfray ethay ymbolsay abletay ilefay "
"Ilenamefay.\n"
"  Aluevay isway 0 ifway Ilenamefay isway ullnay orway ethay ilefay oesnday't "
"existway."

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Builds a kernel Lisp image from the .FASL files specified in the given\n"
"  File-List and writes it to a file named by Core-Name."
msgstr ""
"Uildsbay away ernelkay Isplay imageway omfray ethay .FASL ilesfay "
"ecifiedspay inway ethay ivengay\n"
"  Ilefay-Istlay andway iteswray itway otay away ilefay amednay ybay Orecay-"
"Amenay."

#: src/compiler/eval-comp.lisp
msgid "Fatal error, aborting evaluation."
msgstr "Atalfay errorway, abortingway evaluationway."

#: src/compiler/eval-comp.lisp
msgid "Wrong argument count, wanted ~D and got ~D."
msgstr "Ongwray argumentway ountcay, antedway ~D andway otgay ~D."

#: src/compiler/eval-comp.lisp
msgid "Wrong number of arguments passed -- ~S."
msgstr "Ongwray umbernay ofway argumentsway assedpay -- ~S."

#: src/compiler/eval-comp.lisp
msgid "Function called with odd number of keyword arguments."
msgstr ""
"Unctionfay alledcay ithway oddway umbernay ofway eywordkay argumentsway."

#: src/compiler/eval-comp.lisp
msgid "Unknown keyword argument -- ~S."
msgstr "Unknownway eywordkay argumentway -- ~S."

#: src/compiler/eval.lisp
msgid "[PUSH: growing stack.]~%"
msgstr "[PUSH: owinggray tacksay.]~%"

#: src/compiler/eval.lisp
msgid "pushing ~D.~%"
msgstr "ushingpay ~D.~%"

#: src/compiler/eval.lisp
msgid "Attempt to pop empty eval stack."
msgstr "Attemptway otay oppay emptyway evalway tacksay."

#: src/compiler/eval.lisp
msgid "popping ~D --> ~S.~%"
msgstr "oppingpay ~D --> ~S.~%"

#: src/compiler/eval.lisp
msgid "[EXTEND: growing stack.]~%"
msgstr "[EXTEND: owinggray tacksay.]~%"

#: src/compiler/eval.lisp
msgid "extending to ~D.~%"
msgstr "extendingway otay ~D.~%"

#: src/compiler/eval.lisp
msgid "shrinking to ~D.~%"
msgstr "rinkingshay otay ~D.~%"

#: src/compiler/eval.lisp
msgid "setting top to ~D.~%"
msgstr "ettingsay optay otay ~D.~%"

#: src/compiler/eval.lisp
msgid ""
"If the interpreted function cache has more functions than this come GC "
"time,\n"
"  then attempt to prune it according to\n"
"  *INTERPRETED-FUNCTION-CACHE-THRESHOLD*."
msgstr ""
"Ifway ethay interpretedway unctionfay achecay ashay oremay unctionsfay "
"anthay isthay omecay GC imetay,\n"
"  enthay attemptway otay unepray itway accordingway otay\n"
"  *INTERPRETED-FUNCTION-CACHE-THRESHOLD*."

#: src/compiler/eval.lisp
msgid ""
"If an interpreted function goes uncalled for more than this many GCs, then\n"
"  it is eligible for flushing from the cache."
msgstr ""
"Ifway anway interpretedway unctionfay oesgay uncalledway orfay oremay anthay "
"isthay anymay Csgay, enthay\n"
"  itway isway eligibleway orfay ushingflay omfray ethay achecay."

#: src/compiler/eval.lisp
msgid ""
"Clear all entries in the eval function cache.  This allows the internal\n"
"  representation of the functions to be reclaimed, and also lazily forces\n"
"  macroexpansions to be recomputed."
msgstr ""
"Earclay allway entriesway inway ethay evalway unctionfay achecay.  Isthay "
"allowsway ethay internalway\n"
"  epresentationray ofway ethay unctionsfay otay ebay eclaimedray, andway "
"alsoway azilylay orcesfay\n"
"  acroexpansionsmay otay ebay ecomputedray."

#: src/compiler/eval.lisp
msgid "C::%UNKNOWN-VALUES should never be in interpreter's IR1."
msgstr "C::%UNKNOWN-VALUES ouldshay evernay ebay inway interpreterway's IR1."

#: src/compiler/byte-comp.lisp
msgid "Unknown XOP ~S"
msgstr "Unknownway XOP ~S"

#: src/compiler/byte-comp.lisp
msgid "Unknown inline function: ~S"
msgstr "Unknownway inlineway unctionfay: ~S"

#: src/compiler/byte-comp.lisp
msgid "Can't find ~S"
msgstr "Ancay't indfay ~S"

#: src/compiler/byte-comp.lisp
msgid "~|~%;;;; Byte component ~S~2%"
msgstr "~|~%;;;; Ytebay omponentcay ~S~2%"

#: src/compiler/byte-comp.lisp
msgid ";;; Functions:~%"
msgstr ";;; Unctionsfay:~%"

#: src/compiler/byte-comp.lisp
msgid "~%;;;Disassembly:~2%"
msgstr "~%;;;Isassemblyday:~2%"

#: src/compiler/byte-comp.lisp
msgid "<bogus index>"
msgstr "<ogusbay indexway>"

#: src/compiler/byte-comp.lisp
msgid "Entry point, frame-size=~D~%"
msgstr "Entryway ointpay, amefray-izesay=~D~%"

#: src/compiler/byte-comp.lisp
msgid "push-local ~D"
msgstr "ushpay-ocallay ~D"

#: src/compiler/byte-comp.lisp
msgid "push-arg ~D"
msgstr "ushpay-argway ~D"

#: src/compiler/byte-comp.lisp
msgid "push-const ~S"
msgstr "ushpay-onstcay ~S"

#: src/compiler/byte-comp.lisp
msgid "push-sys-const ~S"
msgstr "ushpay-yssay-onstcay ~S"

#: src/compiler/byte-comp.lisp
msgid "push-int ~D"
msgstr "ushpay-intway ~D"

#: src/compiler/byte-comp.lisp
msgid "push-neg-int ~D"
msgstr "ushpay-egnay-intway ~D"

#: src/compiler/byte-comp.lisp
msgid "pop-local ~D"
msgstr "oppay-ocallay ~D"

#: src/compiler/byte-comp.lisp
msgid "pop-n ~D"
msgstr "oppay-n ~D"

#: src/compiler/byte-comp.lisp
msgid "~:[~;named-~]call, ~D args"
msgstr "~:[~;amednay-~]allcay, ~D argsway"

#: src/compiler/byte-comp.lisp
msgid "~:[~;named-~]tail-call, ~D args"
msgstr "~:[~;amednay-~]ailtay-allcay, ~D argsway"

#: src/compiler/byte-comp.lisp
msgid "~:[~;named-~]multiple-call, ~D args"
msgstr "~:[~;amednay-~]ultiplemay-allcay, ~D argsway"

#: src/compiler/byte-comp.lisp
msgid "local call ~D, ~D args"
msgstr "ocallay allcay ~D, ~D argsway"

#: src/compiler/byte-comp.lisp
msgid "local tail-call ~D, ~D args"
msgstr "ocallay ailtay-allcay ~D, ~D argsway"

#: src/compiler/byte-comp.lisp
msgid "local multiple-call ~D, ~D args"
msgstr "ocallay ultiplemay-allcay ~D, ~D argsway"

#: src/compiler/byte-comp.lisp
msgid "return, ~D vals"
msgstr "eturnray, ~D alsvay"

#: src/compiler/byte-comp.lisp
msgid "branch ~D"
msgstr "anchbray ~D"

#: src/compiler/byte-comp.lisp
msgid "if-true ~D"
msgstr "ifway-uetray ~D"

#: src/compiler/byte-comp.lisp
msgid "if-false ~D"
msgstr "ifway-alsefay ~D"

#: src/compiler/byte-comp.lisp
msgid "if-eq ~D"
msgstr "ifway-eqway ~D"

#: src/compiler/byte-comp.lisp
msgid "xop ~A~@[ ~D~]"
msgstr "opxay ~Away~@[ ~D~]"

#: src/compiler/byte-comp.lisp
msgid "inline ~A"
msgstr "inlineway ~Away"

#: src/pcl/init.lisp src/pcl/defclass.lisp src/pcl/macros.lisp
msgid "Malformed plist in doplist, odd number of elements."
msgstr ""
"Alformedmay istplay inway oplistday, oddway umbernay ofway elementsway."

#: src/pcl/macros.lisp
msgid "~@<~S is not a legal class name.~@:>"
msgstr "~@<~S isway otnay away egallay assclay amenay.~@:>"

#: src/pcl/macros.lisp
msgid "No class named ~S."
msgstr "Onay assclay amednay ~S."

#: src/pcl/macros.lisp
msgid "~S is not a legal class name."
msgstr "~S isway otnay away egallay assclay amenay."

#: src/pcl/macros.lisp
msgid ""
"Returns the PCL class metaobject named by SYMBOL. An error of type\n"
"   SIMPLE-ERROR is signaled if the class does not exist unless ERRORP\n"
"   is NIL in which case NIL is returned. SYMBOL cannot be a keyword."
msgstr ""
"Eturnsray ethay PCL assclay etaobjectmay amednay ybay SYMBOL. Anway errorway "
"ofway ypetay\n"
"   SIMPLE-ERROR isway ignaledsay ifway ethay assclay oesday otnay existway "
"unlessway ERRORP\n"
"   isway NIL inway ichwhay asecay NIL isway eturnedray. SYMBOL annotcay ebay "
"away eywordkay."

#: src/pcl/low.lisp
msgid "Set the name of a compiled function object and return the function."
msgstr ""
"Etsay ethay amenay ofway away ompiledcay unctionfay objectway andway "
"eturnray ethay unctionfay."

#: src/pcl/low.lisp
msgid ""
"PCL debugging aid that breaks into the debugger each time\n"
"`compile-lambda' is invoked."
msgstr ""
"PCL ebuggingday aidway atthay eaksbray intoway ethay ebuggerday eachway "
"imetay\n"
"`ompilecay-ambdalay' isway invokedway."

#: src/pcl/low.lisp
msgid ""
"If true (the default), then `compile-lambda' will try to silence\n"
"the compiler as completely as possible.  Currently this means that\n"
"`*compile-print*' will be bound to nil during compilation."
msgstr ""
"Ifway uetray (ethay efaultday), enthay `ompilecay-ambdalay' illway ytray "
"otay ilencesay\n"
"ethay ompilercay asway ompletelycay asway ossiblepay.  Urrentlycay isthay "
"eansmay atthay\n"
"`*compile-print*' illway ebay oundbay otay ilnay uringday ompilationcay."

#: src/pcl/info.lisp
msgid ""
"~@<The declaration ~S is not understood by ~S. ~\n"
"                               Please put ~S on one of the lists ~S, ~S, or "
"~S. ~\n"
"                               (Assuming it is a variable declarations "
"without ~\n"
"                               argument).~@:>"
msgstr ""
"~@<Ethay eclarationday ~S isway otnay understoodway ybay ~S. ~\n"
"                               Easeplay utpay ~S onway oneway ofway ethay "
"istslay ~S, ~S, orway ~S. ~\n"
"                               (Assumingway itway isway away ariablevay "
"eclarationsday ithoutway ~\n"
"                               argumentway).~@:>"

#: src/pcl/info.lisp
msgid "~@<Invalid slot access specifier ~s in ~s.~@:>"
msgstr "~@<Invalidway otslay accessway ecifierspay ~s inway ~s.~@:>"

#: src/pcl/info.lisp
msgid "~@<Invalid slot access declaration ~s.~@:>"
msgstr "~@<Invalidway otslay accessway eclarationday ~s.~@:>"

#: src/pcl/info.lisp
msgid "~@<Invalid auto-compile specifier ~s in ~s.~@:>"
msgstr "~@<Invalidway autoway-ompilecay ecifierspay ~s inway ~s.~@:>"

#: src/pcl/info.lisp
msgid "~@<Invalid auto-compile declaration ~s.~@:>"
msgstr "~@<Invalidway autoway-ompilecay eclarationday ~s.~@:>"

#: src/pcl/fin.lisp
msgid ""
"~@<Attempt to funcall a funcallable instance without first ~\n"
"          setting its function.~@:>"
msgstr ""
"~@<Attemptway otay uncallfay away uncallablefay instanceway ithoutway "
"irstfay ~\n"
"          ettingsay itsway unctionfay.~@:>"

#: src/pcl/defclass.lisp
msgid "Defclass already names a declaration: ~S."
msgstr "Efclassday alreadyway amesnay away eclarationday: ~S."

#: src/pcl/defclass.lisp
msgid "~S is not a legal defclass option."
msgstr "~S isway otnay away egallay efclassday optionway."

#: src/pcl/defclass.lisp
msgid ""
"~@<The value of the ~s option (~s) is not a legal ~\n"
"\t        class name.~@:>"
msgstr ""
"~@<Ethay aluevay ofway ethay ~s optionway (~s) isway otnay away egallay ~\n"
"\t        assclay amenay.~@:>"

#: src/pcl/defclass.lisp
msgid "~@<~S is not a legal slot specification.~@:>"
msgstr "~@<~S isway otnay away egallay otslay ecificationspay.~@:>"

#: src/pcl/defclass.lisp
msgid ""
"~@<In the class definintion of ~s, the slot specification ~s ~\n"
"                 is obsolete.  Convert it to ~s.~@:>"
msgstr ""
"~@<Inway ethay assclay efinintionday ofway ~s, ethay otslay ecificationspay "
"~s ~\n"
"                 isway obsoleteway.  Onvertcay itway otay ~s.~@:>"

#: src/pcl/defclass.lisp
msgid "~@<~S is not a class in *early-class-definitions*.~@:>"
msgstr "~@<~S isway otnay away assclay inway *early-class-definitions*.~@:>"

#: src/pcl/defclass.lisp
msgid ""
"~@<More than one early class defines a slot with the ~\n"
"                    name ~S.  This can't work because the bootstrap ~\n"
"                    object system doesn't know how to compute effective ~\n"
"                    slots.~@:>"
msgstr ""
"~@<Oremay anthay oneway earlyway assclay efinesday away otslay ithway ethay "
"~\n"
"                    amenay ~S.  Isthay ancay't orkway ecausebay ethay "
"ootstrapbay ~\n"
"                    objectway ystemsay oesnday't nowkay owhay otay omputecay "
"effectiveway ~\n"
"                    otsslay.~@:>"

#: src/pcl/defclass.lisp
msgid "Discard it."
msgstr "Iscardday itway."

#: src/pcl/defclass.lisp
msgid ""
"~@<The defclass option ~S is not supported by ~\n"
"                                 the bootstrap object system.~@:>"
msgstr ""
"~@<Ethay efclassday optionway ~S isway otnay upportedsay ybay ~\n"
"                                 ethay ootstrapbay objectway ystemsay.~@:>"

#: src/pcl/defclass.lisp
msgid "Slot ~S not found in class ~S"
msgstr "Otslay ~S otnay oundfay inway assclay ~S"

#: src/pcl/defs.lisp
msgid ""
"~@<Trying to load (or compile) PCL in an environment in which it ~\n"
"            has already been loaded.  This doesn't work, you will have to ~\n"
"            get a fresh lisp (reboot) and then load PCL.~@:>"
msgstr ""
"~@<Yingtray otay oadlay (orway ompilecay) PCL inway anway environmentway "
"inway ichwhay itway ~\n"
"            ashay alreadyway eenbay oadedlay.  Isthay oesnday't orkway, "
"ouyay illway avehay otay ~\n"
"            etgay away eshfray isplay (ebootray) andway enthay oadlay PCL.~@:"
">"

#: src/pcl/defs.lisp
msgid "Try loading (or compiling) PCL anyways."
msgstr "Ytray oadinglay (orway ompilingcay) PCL anywaysway."

#: src/pcl/defs.lisp
msgid "Obsolete, don't use."
msgstr "Obsoleteway, onday't useway."

#: src/pcl/defs.lisp
msgid "~@<~S is not a legal specializer type.~@:>"
msgstr "~@<~S isway otnay away egallay ecializerspay ypetay.~@:>"

#: src/pcl/defs.lisp
msgid "~@<~s is neither a type nor a specializer.~@:>"
msgstr "~@<~s isway eithernay away ypetay ornay away ecializerspay.~@:>"

#: src/pcl/defs.lisp
msgid "Bad argument to type-class."
msgstr "Adbay argumentway otay ypetay-assclay."

#: src/pcl/defs.lisp
msgid "~s is not a type."
msgstr "~s isway otnay away ypetay."

#: src/pcl/defs.lisp
msgid ""
"For class slots, the class defininig the slot.\n"
"For inherited class slots, this is the superclass from which the slot\n"
"was inherited."
msgstr ""
"Orfay assclay otsslay, ethay assclay efininigday ethay otslay.\n"
"Orfay inheritedway assclay otsslay, isthay isway ethay uperclasssay omfray "
"ichwhay ethay otslay\n"
"asway inheritedway."

#: src/pcl/fngen.lisp
msgid ""
"Flush cached emf functions.  If GF is supplied, it should be a\n"
"   generic function metaobject or the name of a generic function, and\n"
"   this function flushes all cached emfs for the given generic\n"
"   function.  If GF is not supplied, all cached emfs are flushed."
msgstr ""
"Ushflay achedcay emfway unctionsfay.  Ifway GF isway uppliedsay, itway "
"ouldshay ebay away\n"
"   enericgay unctionfay etaobjectmay orway ethay amenay ofway away enericgay "
"unctionfay, andway\n"
"   isthay unctionfay ushesflay allway achedcay emfsway orfay ethay ivengay "
"enericgay\n"
"   unctionfay.  Ifway GF isway otnay uppliedsay, allway achedcay emfsway "
"areway ushedflay."

#: src/pcl/cache.lisp
msgid "Wrapper ~S"
msgstr "Apperwray ~S"

#: src/pcl/cache.lisp
msgid "Unknown wrapper state"
msgstr "Unknownway apperwray tatesay"

#: src/pcl/cache.lisp
msgid ""
"~@<PCL cannot handle the specializer ~S ~\n"
"                                (meta-specializer ~S).~@:>"
msgstr ""
"~@<PCL annotcay andlehay ethay ecializerspay ~S ~\n"
"                                (etamay-ecializerspay ~S).~@:>"

#: src/pcl/cache.lisp
msgid "Line is reserved."
msgstr "Inelay isway eservedray."

#: src/pcl/cache.lisp
msgid ""
"~@<Bad cache ~S: Value at location ~D is ~D ~\n"
"                               lines from its home, limit is ~D.~@:>"
msgstr ""
"~@<Adbay achecay ~S: Aluevay atway ocationlay ~D isway ~D ~\n"
"                               ineslay omfray itsway omehay, imitlay isway "
"~D.~@:>"

#: src/pcl/cache.lisp
msgid "Attempt to fill a reserved cache line."
msgstr "Attemptway otay illfay away eservedray achecay inelay."

#: src/pcl/cache.lisp
msgid "Transfering something into a reserved cache line."
msgstr "Ansferingtray omethingsay intoway away eservedray achecay inelay."

#: src/pcl/dlisp.lisp
msgid "Every metatype is T."
msgstr "Everyway etatypemay isway T."

#: src/pcl/dlisp.lisp
msgid "Can't do a slot reg for this metatype."
msgstr "Ancay't oday away otslay egray orfay isthay etatypemay."

#: src/pcl/boot.lisp
msgid "~~@<Generic function ~a: ~?.~~@:>"
msgstr "~~@<Enericgay unctionfay ~away: ~?.~~@:>"

#: src/pcl/boot.lisp
msgid "Invalid generic function parameter name ~a"
msgstr "Invalidway enericgay unctionfay arameterpay amenay ~away"

#: src/pcl/boot.lisp
msgid ""
"Optional and key parameters of generic functions ~\n"
"                   may not have default values or supplied-p ~\n"
"                   parameters: ~<~s~>"
msgstr ""
"Optionalway andway eykay arameterspay ofway enericgay unctionsfay ~\n"
"                   aymay otnay avehay efaultday aluesvay orway uppliedsay-p "
"~\n"
"                   arameterspay: ~<~s~>"

#: src/pcl/boot.lisp
msgid "~s is not allowed in generic function lambda lists"
msgstr "~s isway otnay allowedway inway enericgay unctionfay ambdalay istslay"

#: src/pcl/boot.lisp
msgid "~~@<Generic function ~~s: ~?.~~@:>"
msgstr "~~@<Enericgay unctionfay ~~s: ~?.~~@:>"

#: src/pcl/boot.lisp
msgid "The option ~s appears more than once"
msgstr "Ethay optionway ~s appearsway oremay anthay onceway"

#: src/pcl/boot.lisp
msgid "Declaration specifier ~s is not allowed"
msgstr "Eclarationday ecifierspay ~s isway otnay allowedway"

#: src/pcl/boot.lisp
msgid ""
"Argument precedence order must list all ~\n"
"                           required parameters and only those: ~s"
msgstr ""
"Argumentway ecedencepray orderway ustmay istlay allway ~\n"
"                           equiredray arameterspay andway onlyway osethay: ~s"

#: src/pcl/boot.lisp
msgid ""
"Duplicate parameter names in argument ~\n"
"                           precedence order: ~s"
msgstr ""
"Uplicateday arameterpay amesnay inway argumentway ~\n"
"                           ecedencepray orderway: ~s"

#: src/pcl/boot.lisp
msgid "Special operators cannot be made generic functions"
msgstr "Ecialspay operatorsway annotcay ebay ademay enericgay unctionsfay"

#: src/pcl/boot.lisp
msgid "Unsupported option ~s"
msgstr "Unsupportedway optionway ~s"

#: src/pcl/boot.lisp
msgid "If true, allow inlining of methods in effective methods."
msgstr ""
"Ifway uetray, allowway inliningway ofway ethodsmay inway effectiveway "
"ethodsmay."

#: src/pcl/boot.lisp
msgid ""
"~@<Defining method ~s ~s ~s using inline slot access in a ~\n"
"                   non-null lexical environment means that it cannot be ~\n"
"                   automatically recompiled.~@:>"
msgstr ""
"~@<Efiningday ethodmay ~s ~s ~s usingway inlineway otslay accessway inway "
"away ~\n"
"                   onnay-ullnay exicallay environmentway eansmay atthay "
"itway annotcay ebay ~\n"
"                   automaticallyway ecompiledray.~@:>"

#: src/pcl/boot.lisp
msgid ""
"The method-lambda argument to make-method-function, ~S,~\n"
"            is not a lambda form"
msgstr ""
"Ethay ethodmay-ambdalay argumentway otay akemay-ethodmay-unctionfay, ~S,~\n"
"            isway otnay away ambdalay ormfay"

#: src/pcl/boot.lisp
msgid "~@<The ~s argument to ~s, ~s, is not a lambda form.~@:>"
msgstr ""
"~@<Ethay ~s argumentway otay ~s, ~s, isway otnay away ambdalay ormfay.~@:>"

#: src/pcl/boot.lisp
msgid ""
"Assignment to method parameter~p ~{~s~^, ~} ~\n"
"                           might prevent CLOS optimizations"
msgstr ""
"Assignmentway otay ethodmay arameterpay~p ~{~s~^, ~} ~\n"
"                           ightmay eventpray CLOS optimizationsway"

#: src/pcl/boot.lisp
msgid "Wrong number of args."
msgstr "Ongwray umbernay ofway argsway."

#: src/pcl/boot.lisp
msgid "1 or 2 args expected."
msgstr "1 orway 2 argsway expectedway."

#: src/pcl/boot.lisp
msgid "1 arg expected."
msgstr "1 argway expectedway."

#: src/pcl/boot.lisp
msgid ""
"~@<The set of methods ~s applicable to argument~p ~\n"
"                ~{~s~^, ~} to call-next-method is different from ~\n"
"                the set of methods ~s applicable to the original ~\n"
"                method argument~p ~{~s~^, ~}.~@:>"
msgstr ""
"~@<Ethay etsay ofway ethodsmay ~s applicableway otay argumentway~p ~\n"
"                ~{~s~^, ~} otay allcay-extnay-ethodmay isway ifferentday "
"omfray ~\n"
"                ethay etsay ofway ethodsmay ~s applicableway otay ethay "
"originalway ~\n"
"                ethodmay argumentway~p ~{~s~^, ~}.~@:>"

#: src/pcl/boot.lisp
msgid "When true, compile interpreted method functions."
msgstr "Enwhay uetray, ompilecay interpretedway ethodmay unctionsfay."

#: src/pcl/boot.lisp
msgid ""
"~&~@<At the time the method with qualifiers ~S and ~\n"
"               specializers ~S on the generic function ~S ~\n"
"               was compiled, the method class for that generic function was "
"~\n"
"               ~S.  But, the method class is now ~S, this ~\n"
"               may mean that this method was compiled improperly.~@:>"
msgstr ""
"~&~@<Atway ethay imetay ethay ethodmay ithway alifiersquay ~S andway ~\n"
"               ecializersspay ~S onway ethay enericgay unctionfay ~S ~\n"
"               asway ompiledcay, ethay ethodmay assclay orfay atthay "
"enericgay unctionfay asway ~\n"
"               ~S.  Utbay, ethay ethodmay assclay isway ownay ~S, isthay ~\n"
"               aymay eanmay atthay isthay ethodmay asway ompiledcay "
"improperlyway.~@:>"

#: src/pcl/boot.lisp
msgid ""
"~@<~S already names an ordinary function or a macro.  ~\n"
"\tIf you want to replace it with a generic function, you should remove ~\n"
"        the existing definition beforehand.~@:>"
msgstr ""
"~@<~S alreadyway amesnay anway ordinaryway unctionfay orway away acromay.  "
"~\n"
"\tIfway ouyay antway otay eplaceray itway ithway away enericgay unctionfay, "
"ouyay ouldshay emoveray ~\n"
"        ethay existingway efinitionday eforehandbay.~@:>"

#: src/pcl/boot.lisp
msgid "~@<Discard the existing definition of ~S.~@:>"
msgstr "~@<Iscardday ethay existingway efinitionday ofway ~S.~@:>"

#: src/pcl/boot.lisp
msgid ""
"~@<The lambda-list ~S is incompatible with ~\n"
"                      existing methods of ~S.~@:>"
msgstr ""
"~@<Ethay ambdalay-istlay ~S isway incompatibleway ithway ~\n"
"                      existingway ethodsmay ofway ~S.~@:>"

#: src/pcl/boot.lisp
msgid ""
"~~@<Attempt to add the method ~~S to the generic ~\n"
"                           function ~~S, but ~?.~~@:>"
msgstr ""
"~~@<Attemptway otay addway ethay ethodmay ~~S otay ethay enericgay ~\n"
"                           unctionfay ~~S, utbay ~?.~~@:>"

#: src/pcl/boot.lisp
msgid "more"
msgstr "oremay"

#: src/pcl/boot.lisp
msgid "fewer"
msgstr "ewerfay"

#: src/pcl/boot.lisp
msgid ""
"the method has ~A required arguments than the ~\n"
"                 generic function"
msgstr ""
"ethay ethodmay ashay ~Away equiredray argumentsway anthay ethay ~\n"
"                 enericgay unctionfay"

#: src/pcl/boot.lisp
msgid ""
"the method has ~S optional arguments than the ~\n"
"                 generic function"
msgstr ""
"ethay ethodmay ashay ~S optionalway argumentsway anthay ethay ~\n"
"                 enericgay unctionfay"

#: src/pcl/boot.lisp
msgid ""
"the method and generic function differ in whether ~\n"
"                 they accept rest or keyword arguments"
msgstr ""
"ethay ethodmay andway enericgay unctionfay ifferday inway etherwhay ~\n"
"                 eythay acceptway estray orway eywordkay argumentsway"

#: src/pcl/boot.lisp
msgid ""
"the method does not accept each of the keyword ~\n"
"                   arguments ~S"
msgstr ""
"ethay ethodmay oesday otnay acceptway eachway ofway ethay eywordkay ~\n"
"                   argumentsway ~S"

#: src/pcl/boot.lisp
msgid "~@<The function ~S is not already defined.~@:>"
msgstr "~@<Ethay unctionfay ~S isway otnay alreadyway efinedday.~@:>"

#: src/pcl/boot.lisp
msgid "~@<~S should be on the list ~S.~@:>"
msgstr "~@<~S ouldshay ebay onway ethay istlay ~S.~@:>"

#: src/pcl/boot.lisp
msgid ""
"~@<The function of the funcallable instance ~S ~\n"
"\t\t\t has not been set.~@:>"
msgstr ""
"~@<Ethay unctionfay ofway ethay uncallablefay instanceway ~S ~\n"
"\t\t\t ashay otnay eenbay etsay.~@:>"

#: src/pcl/boot.lisp
msgid "~@<No way to determine the lambda list~@:>"
msgstr "~@<Onay ayway otay etermineday ethay ambdalay istlay~@:>"

#: src/pcl/boot.lisp
msgid ""
"~@<The ~s argument (~S) was neither a class nor a ~\n"
"                    symbol naming a class.~@:>"
msgstr ""
"~@<Ethay ~s argumentway (~S) asway eithernay away assclay ornay away ~\n"
"                    ymbolsay amingnay away assclay.~@:>"

#: src/pcl/boot.lisp
msgid "~S is not an early-method."
msgstr "~S isway otnay anway earlyway-ethodmay."

#: src/pcl/boot.lisp
msgid "Early add-method didn't get a funcallable instance."
msgstr ""
"Earlyway addway-ethodmay idnday't etgay away uncallablefay instanceway."

#: src/pcl/boot.lisp
msgid "Early add-method didn't get an early method."
msgstr "Earlyway addway-ethodmay idnday't etgay anway earlyway ethodmay."

#: src/pcl/boot.lisp
msgid "Early remove-method didn't get a funcallable instance."
msgstr ""
"Earlyway emoveray-ethodmay idnday't etgay away uncallablefay instanceway."

#: src/pcl/boot.lisp
msgid "Early remove-method didn't get an early method."
msgstr "Earlyway emoveray-ethodmay idnday't etgay anway earlyway ethodmay."

#: src/pcl/boot.lisp
msgid "Can't get early method."
msgstr "Ancay't etgay earlyway ethodmay."

#: src/pcl/boot.lisp
msgid "~@<Qualifiers must be non-null atoms: ~s~@:>"
msgstr "~@<Alifiersquay ustmay ebay onnay-ullnay atomsway: ~s~@:>"

#: src/pcl/boot.lisp
msgid ""
"~@<~S used as a specializer, ~\n"
"                             but is not the name of a class.~@:>"
msgstr ""
"~@<~S usedway asway away ecializerspay, ~\n"
"                             utbay isway otnay ethay amenay ofway away "
"assclay.~@:>"

#: src/pcl/boot.lisp
msgid "~S is not a legal specializer."
msgstr "~S isway otnay away egallay ecializerspay."

#: src/pcl/method-slot-access-optimization.lisp
msgid "Set to true to activate the inline slot access optimization."
msgstr ""
"Etsay otay uetray otay activateway ethay inlineway otslay accessway "
"optimizationway."

#: src/pcl/method-slot-access-optimization.lisp
msgid "When true, check slot values against specified slot types."
msgstr ""
"Enwhay uetray, eckchay otslay aluesvay againstway ecifiedspay otslay ypestay."

#: src/pcl/method-slot-access-optimization.lisp
msgid "When true, optimize slot access through slot reader/writer functions."
msgstr ""
"Enwhay uetray, optimizeway otslay accessway roughthay otslay eaderray/"
"iterwray unctionsfay."

#: src/pcl/method-slot-access-optimization.lisp
msgid "Cannot optimize slot access to"
msgstr "Annotcay optimizeway otslay accessway otay"

#: src/pcl/method-slot-access-optimization.lisp
msgid "The class is not a standard class"
msgstr "Ethay assclay isway otnay away tandardsay assclay"

#: src/pcl/method-slot-access-optimization.lisp
msgid "The class doesn't contain a slot with name ~s"
msgstr "Ethay assclay oesnday't ontaincay away otslay ithway amenay ~s"

#: src/pcl/method-slot-access-optimization.lisp
msgid "Slot ~s is a class slot"
msgstr "Otslay ~s isway away assclay otslay"

#: src/pcl/method-slot-access-optimization.lisp
msgid "There are non-standard accessors for slot ~s"
msgstr "Erethay areway onnay-tandardsay accessorsway orfay otslay ~s"

#: src/pcl/method-slot-access-optimization.lisp
msgid ""
"Slot ~s is not at the same location ~\n"
"                               in the class and all of its subclasses"
msgstr ""
"Otslay ~s isway otnay atway ethay amesay ocationlay ~\n"
"                               inway ethay assclay andway allway ofway "
"itsway ubclassessay"

#: src/pcl/method-slot-access-optimization.lisp
msgid "Auto-compiling method ~s."
msgstr "Autoway-ompilingcay ethodmay ~s."

#: src/pcl/method-slot-access-optimization.lisp
msgid ""
"Methods may need to be recompiled for the changed ~\n"
"                    class layout of"
msgstr ""
"Ethodsmay aymay eednay otay ebay ecompiledray orfay ethay angedchay ~\n"
"                    assclay ayoutlay ofway"

#: src/pcl/method-slot-access-optimization.lisp
msgid "The class is not defined at compile time"
msgstr "Ethay assclay isway otnay efinedday atway ompilecay imetay"

#: src/pcl/method-slot-access-optimization.lisp
msgid ""
"~s has a method that is not a standard ~\n"
"                                    slot accessor"
msgstr ""
"~s ashay away ethodmay atthay isway otnay away tandardsay ~\n"
"                                    otslay accessorway"

#: src/pcl/method-slot-access-optimization.lisp
msgid "Methods of ~s access different slots"
msgstr "Ethodsmay ofway ~s accessway ifferentday otsslay"

#: src/pcl/slots-boot.lisp
msgid "~@<~S is not a standard-class.~@:>"
msgstr "~@<~S isway otnay away tandardsay-assclay.~@:>"

#: src/pcl/slots-boot.lisp
msgid ""
"~@<Slot ~S in class ~S ~\n"
"                       does not have standard allocation.~@:>"
msgstr ""
"~@<Otslay ~S inway assclay ~S ~\n"
"                       oesday otnay avehay tandardsay allocationway.~@:>"

#: src/pcl/slots-boot.lisp
msgid ""
"~@<Slot ~S in class ~S ~\n"
"                      does not have standard allocation.~@:>"
msgstr ""
"~@<Otslay ~S inway assclay ~S ~\n"
"                      oesday otnay avehay tandardsay allocationway.~@:>"

#: src/pcl/slots-boot.lisp
msgid ""
"~@<The wrapper for class ~S does not have ~\n"
"                               the slot ~S.~@:>"
msgstr ""
"~@<Ethay apperwray orfay assclay ~S oesday otnay avehay ~\n"
"                               ethay otslay ~S.~@:>"

#: src/pcl/defcombin.lisp src/pcl/combin.lisp
msgid "has more than one qualifier"
msgstr "ashay oremay anthay oneway alifierquay"

#: src/pcl/combin.lisp
msgid "has an invalid qualifier"
msgstr "ashay anway invalidway alifierquay"

#: src/pcl/combin.lisp
msgid ""
"~@<~s was called outside the dynamic scope ~\n"
"            of a method combination function (inside the body of ~\n"
"            ~s or a method on the generic function ~s).~@:>"
msgstr ""
"~@<~s asway alledcay outsideway ethay ynamicday opescay ~\n"
"            ofway away ethodmay ombinationcay unctionfay (insideway ethay "
"odybay ofway ~\n"
"            ~s orway away ethodmay onway ethay enericgay unctionfay ~s).~@:>"

#: src/pcl/combin.lisp
msgid "~@<~S used outside of a effective method form.~@:>"
msgstr "~@<~S usedway outsideway ofway away effectiveway ethodmay ormfay.~@:>"

#: src/pcl/combin.lisp
msgid ""
"~@<Invalid keyword argument~p ~{~s~^, ~}.  ~\n"
"               Valid keywords are: ~{~s~^, ~}.~@:>"
msgstr ""
"~@<Invalidway eywordkay argumentway~p ~{~s~^, ~}.  ~\n"
"               Alidvay eywordskay areway: ~{~s~^, ~}.~@:>"

#: src/pcl/combin.lisp
msgid "Invalid keyword argument ~s"
msgstr "Invalidway eywordkay argumentway ~s"

#: src/pcl/dfun.lisp
msgid "~@<Slot ~s of class ~s is unbound in object ~s~@:>"
msgstr "~@<Otslay ~s ofway assclay ~s isway unboundway inway objectway ~s~@:>"

#: src/pcl/dfun.lisp
msgid ""
"~@<Cannot get standard value of slot ~s of class ~s ~\n"
"                in object ~s~@:>"
msgstr ""
"~@<Annotcay etgay tandardsay aluevay ofway otslay ~s ofway assclay ~s ~\n"
"                inway objectway ~s~@:>"

#: src/pcl/dfun.lisp
msgid "~&Name ~S  caching cost ~D  dispatch cost ~D~%"
msgstr "~&Amenay ~S  achingcay ostcay ~D  ispatchday ostcay ~D~%"

#: src/pcl/dfun.lisp
msgid ""
"Precompute effective methods at method load time if the generic\n"
"   function has less than this number of methods.  If zero,\n"
"   no effective methods are precomputed at method load time."
msgstr ""
"Ecomputepray effectiveway ethodsmay atway ethodmay oadlay imetay ifway ethay "
"enericgay\n"
"   unctionfay ashay esslay anthay isthay umbernay ofway ethodsmay.  Ifway "
"erozay,\n"
"   onay effectiveway ethodsmay areway ecomputedpray atway ethodmay oadlay "
"imetay."

#: src/pcl/dfun.lisp
msgid "~@<The function ~S requires at least ~D arguments.~@:>"
msgstr "~@<Ethay unctionfay ~S equiresray atway eastlay ~D argumentsway.~@:>"

#: src/pcl/dfun.lisp
msgid "~<The function ~S requires at least ~D arguments.~@:>"
msgstr "~<Ethay unctionfay ~S equiresray atway eastlay ~D argumentsway.~@:>"

#: src/pcl/dfun.lisp
msgid ""
"~@<Vicious metacircle:  The computation of an ~\n"
"\t   effective method of ~s for arguments of types ~s uses ~\n"
"\t   the effective method being computed.~@:>"
msgstr ""
"~@<Iciousvay etacirclemay:  Ethay omputationcay ofway anway ~\n"
"\t   effectiveway ethodmay ofway ~s orfay argumentsway ofway ypestay ~s "
"usesway ~\n"
"\t   ethay effectiveway ethodmay eingbay omputedcay.~@:>"

#: src/pcl/dfun.lisp
msgid "This can't happen."
msgstr "Isthay ancay't appenhay."

#: src/pcl/dfun.lisp
msgid "~@<~s cannot handle the second argument ~s.~@:>"
msgstr "~@<~s annotcay andlehay ethay econdsay argumentway ~s.~@:>"

#: src/pcl/dfun.lisp
msgid "~&There are ~4d dfuns of type ~s"
msgstr "~&Erethay areway ~4d funsday ofway ypetay ~s"

#: src/pcl/dfun.lisp
msgid "~&DFUN constructor caching is ~A."
msgstr "~&DFUN onstructorcay achingcay isway ~Away."

#: src/pcl/dfun.lisp
msgid "enabled"
msgstr "enabledway"

#: src/pcl/dfun.lisp
msgid "disabled"
msgstr "isabledday"

#: src/pcl/ctor.lisp
msgid "~@<Not a property list: ~S.~@:>"
msgstr "~@<Otnay away opertypray istlay: ~S.~@:>"

#: src/pcl/braid.lisp
msgid ""
"~@<The function of the funcallable instance ~S ~\n"
"                 has not been set.~@:>"
msgstr ""
"~@<Ethay unctionfay ofway ethay uncallablefay instanceway ~S ~\n"
"                 ashay otnay eenbay etsay.~@:>"

#: src/pcl/braid.lisp
msgid ""
"~@<Slot allocation ~S is not supported ~\n"
"                          in bootstrap.~@:>"
msgstr ""
"~@<Otslay allocationway ~S isway otnay upportedsay ~\n"
"                          inway ootstrapbay.~@:>"

#: src/pcl/braid.lisp
msgid "The standard method combination."
msgstr "Ethay tandardsay ethodmay ombinationcay."

#: src/pcl/braid.lisp
msgid ""
"In *built-in-classes*: ~S has ~S as a superclass,~%~\n"
"                but ~S is not itself a class in *built-in-classes*."
msgstr ""
"Inway *built-in-classes*: ~S ashay ~S asway away uperclasssay,~%~\n"
"                utbay ~S isway otnay itselfway away assclay inway *built-in-"
"classes*."

#: src/pcl/braid.lisp
msgid "~@<~S is not the name of a class.~@:>"
msgstr "~@<~S isway otnay ethay amenay ofway away assclay.~@:>"

#: src/pcl/braid.lisp
msgid ""
"~@<No matching method for the generic function ~\n"
"                             ~S, when called with arguments ~S.~@:>"
msgstr ""
"~@<Onay atchingmay ethodmay orfay ethay enericgay unctionfay ~\n"
"                             ~S, enwhay alledcay ithway argumentsway ~S.~@:>"

#: src/pcl/braid.lisp
msgid "Retry call to ~S."
msgstr "Etryray allcay otay ~S."

#: src/pcl/braid.lisp
msgid "~@<In method ~S: No next method for arguments ~S.~@:>"
msgstr "~@<Inway ethodmay ~S: Onay extnay ethodmay orfay argumentsway ~S.~@:>"

#: src/pcl/braid.lisp
msgid ""
"~@<Generic function ~S: ~\n"
"                             No primary method given arguments ~S~@:>"
msgstr ""
"~@<Enericgay unctionfay ~S: ~\n"
"                             Onay imarypray ethodmay ivengay argumentsway "
"~S~@:>"

#: src/pcl/braid.lisp
msgid ""
"~@<In a call to ~s with arguments ~:s: ~\n"
"              The method ~s has invalid qualifiers for method ~\n"
"              combination ~s.~@:>"
msgstr ""
"~@<Inway away allcay otay ~s ithway argumentsway ~:s: ~\n"
"              Ethay ethodmay ~s ashay invalidway alifiersquay orfay ethodmay "
"~\n"
"              ombinationcay ~s.~@:>"

#: src/pcl/braid.lisp
msgid ""
"~@<In a call to ~s with arguments ~:s: ~\n"
"              The methods ~{~s~^, ~} have invalid qualifiers for ~\n"
"              method combination ~s.~@:>"
msgstr ""
"~@<Inway away allcay otay ~s ithway argumentsway ~:s: ~\n"
"              Ethay ethodsmay ~{~s~^, ~} avehay invalidway alifiersquay "
"orfay ~\n"
"              ethodmay ombinationcay ~s.~@:>"

#: src/pcl/slots.lisp
msgid "~@<The slot ~S is unbound in the object ~S.~@:>"
msgstr "~@<Ethay otslay ~S isway unboundway inway ethay objectway ~S.~@:>"

#: src/pcl/slots.lisp
msgid "is not a symbol and so cannot be bound"
msgstr "isway otnay away ymbolsay andway osay annotcay ebay oundbay"

#: src/pcl/slots.lisp
msgid "is a keyword and so cannot be bound"
msgstr "isway away eywordkay andway osay annotcay ebay oundbay"

#: src/pcl/slots.lisp
msgid "cannot be bound"
msgstr "annotcay ebay oundbay"

#: src/pcl/slots.lisp
msgid "is a constant and so cannot be bound"
msgstr "isway away onstantcay andway osay annotcay ebay oundbay"

#: src/pcl/slots.lisp
msgid ""
"~@<The slot ~s has neither ~s nor ~s ~\n"
"                           allocation, so it can't be read by the default ~s "
"~\n"
"                           method.~@:>"
msgstr ""
"~@<Ethay otslay ~s ashay eithernay ~s ornay ~s ~\n"
"                           allocationway, osay itway ancay't ebay eadray "
"ybay ethay efaultday ~s ~\n"
"                           ethodmay.~@:>"

#: src/pcl/slots.lisp
msgid ""
"~@<The slot ~s has neither ~s nor ~s allocation, ~\n"
"               so it can't be written by the default ~s method.~@:>"
msgstr ""
"~@<Ethay otslay ~s ashay eithernay ~s ornay ~s allocationway, ~\n"
"               osay itway ancay't ebay ittenwray ybay ethay efaultday ~s "
"ethodmay.~@:>"

#: src/pcl/slots.lisp
msgid ""
"~@<The slot ~s has neither ~s nor ~s ~\n"
"                           allocation, so it can't be read by the default ~s "
"~\n"
"\t\t\t   method.~@:>"
msgstr ""
"~@<Ethay otslay ~s ashay eithernay ~s ornay ~s ~\n"
"                           allocationway, osay itway ancay't ebay eadray "
"ybay ethay efaultday ~s ~\n"
"\t\t\t   ethodmay.~@:>"

#: src/pcl/slots.lisp
msgid "Structure slots cannot be unbound."
msgstr "Ucturestray otsslay annotcay ebay unboundway."

#: src/pcl/slots.lisp
msgid "Condition slots cannot be unbound."
msgstr "Onditioncay otsslay annotcay ebay unboundway."

#: src/pcl/slots.lisp
msgid ""
"~~@<When attempting to ~A, the slot ~S is missing ~\n"
"                from the object ~S.~~@:>"
msgstr ""
"~~@<Enwhay attemptingway otay ~Away, ethay otslay ~S isway issingmay ~\n"
"                omfray ethay objectway ~S.~~@:>"

#: src/pcl/slots.lisp
msgid "read the slot's value (slot-value)"
msgstr "eadray ethay otslay's aluevay (otslay-aluevay)"

#: src/pcl/slots.lisp
msgid "set the slot's value to ~S (setf of slot-value)"
msgstr "etsay ethay otslay's aluevay otay ~S (etfsay ofway otslay-aluevay)"

#: src/pcl/slots.lisp
msgid "test to see if slot is bound (slot-boundp)"
msgstr "esttay otay eesay ifway otslay isway oundbay (otslay-oundpbay)"

#: src/pcl/slots.lisp
msgid "make the slot unbound (slot-makunbound)"
msgstr "akemay ethay otslay unboundway (otslay-akunboundmay)"

#: src/pcl/slots.lisp
msgid "~@<Can't allocate an instance of class ~S.~@:>"
msgstr "~@<Ancay't allocateway anway instanceway ofway assclay ~S.~@:>"

#: src/pcl/init.lisp
msgid ""
"~@<Invalid initialization argument~P ~2I~_~\n"
"                         ~<~{~S~^, ~}~@:> ~I~_in call for class ~S.~:>"
msgstr ""
"~@<Invalidway initializationway argumentway~P ~2Iway~_~\n"
"                         ~<~{~S~^, ~}~@:> ~Iway~_inway allcay orfay assclay "
"~S.~:>"

#: src/pcl/seal.lisp
msgid "~@<Invalid sealing specifier ~s.~@:>"
msgstr "~@<Invalidway ealingsay ecifierspay ~s.~@:>"

#: src/pcl/seal.lisp
msgid "~s is sealed wrt ~a"
msgstr "~s isway ealedsay twray ~away"

#: src/pcl/cpl.lisp
msgid ""
"~~@<While computing the class precedence list ~\n"
"                of the class ~A: ~?.~~@:>"
msgstr ""
"~~@<Ilewhay omputingcay ethay assclay ecedencepray istlay ~\n"
"                ofway ethay assclay ~Away: ~?.~~@:>"

#: src/pcl/cpl.lisp
msgid "named ~S"
msgstr "amednay ~S"

#: src/pcl/cpl.lisp
msgid "The class ~A is a forward referenced class"
msgstr "Ethay assclay ~Away isway away orwardfay eferencedray assclay"

#: src/pcl/cpl.lisp
msgid ""
"The class ~A is a forward referenced class. ~\n"
"                      The class ~A is ~A."
msgstr ""
"Ethay assclay ~Away isway away orwardfay eferencedray assclay. ~\n"
"                      Ethay assclay ~Away isway ~Away."

#: src/pcl/cpl.lisp
msgid "a direct superclass of the class ~A"
msgstr "away irectday uperclasssay ofway ethay assclay ~Away"

#: src/pcl/cpl.lisp
msgid ""
"reached from the class ~A by following~@\n"
"                                  the direct superclass chain through: ~A~\n"
"                                  ~%  ending at the class ~A"
msgstr ""
"eachedray omfray ethay assclay ~Away ybay ollowingfay~@\n"
"                                  ethay irectday uperclasssay ainchay "
"roughthay: ~Away~\n"
"                                  ~%  endingway atway ethay assclay ~Away"

#: src/pcl/cpl.lisp
msgid "~{~%  the class ~A,~}"
msgstr "~{~%  ethay assclay ~Away,~}"

#: src/pcl/cpl.lisp
msgid ""
"It is not possible to compute the class precedence list because ~\n"
"       there ~A in the local precedence relations.  ~\n"
"       ~A because:~{~%  ~A~}."
msgstr ""
"Itway isway otnay ossiblepay otay omputecay ethay assclay ecedencepray "
"istlay ecausebay ~\n"
"       erethay ~Away inway ethay ocallay ecedencepray elationsray.  ~\n"
"       ~Away ecausebay:~{~%  ~Away~}."

#: src/pcl/cpl.lisp
msgid "are circularities"
msgstr "areway ircularitiescay"

#: src/pcl/cpl.lisp
msgid "is a circularity"
msgstr "isway away ircularitycay"

#: src/pcl/cpl.lisp
msgid "These arise"
msgstr "Esethay ariseway"

#: src/pcl/cpl.lisp
msgid "This arises"
msgstr "Isthay arisesway"

#: src/pcl/cpl.lisp
msgid "the class ~A appears in the supers of the class ~A"
msgstr ""
"ethay assclay ~Away appearsway inway ethay uperssay ofway ethay assclay ~Away"

#: src/pcl/cpl.lisp
msgid "the class ~A follows the class ~A in the supers of the class ~A"
msgstr ""
"ethay assclay ~Away ollowsfay ethay assclay ~Away inway ethay uperssay ofway "
"ethay assclay ~Away"

#: src/pcl/methods.lisp
msgid "Instance"
msgstr "Instanceway"

#: src/pcl/methods.lisp
msgid "~@<Structure slots must have ~s allocation.~@:>"
msgstr "~@<Ucturestray otsslay ustmay avehay ~s allocationway.~@:>"

#: src/pcl/methods.lisp
msgid "~@<~S doesn't seem to have a method function.~@:>"
msgstr "~@<~S oesnday't eemsay otay avehay away ethodmay unctionfay.~@:>"

#: src/pcl/methods.lisp
msgid ""
"~@<Attempt to reinitialize the method ~S.  ~\n"
"          Method objects cannot be reinitialized.~@:>"
msgstr ""
"~@<Attemptway otay einitializeray ethay ethodmay ~S.  ~\n"
"          Ethodmay objectsway annotcay ebay einitializedray.~@:>"

#: src/pcl/methods.lisp
msgid ""
"~@<When initializing the method ~S, ~\n"
"                   the ~S initialization argument was ~S, ~\n"
"                   which ~A.~@:>"
msgstr ""
"~@<Enwhay initializingway ethay ethodmay ~S, ~\n"
"                   ethay ~S initializationway argumentway asway ~S, ~\n"
"                   ichwhay ~Away.~@:>"

#: src/pcl/methods.lisp
msgid "is not a string or NULL"
msgstr "isway otnay away ingstray orway NULL"

#: src/pcl/methods.lisp
msgid "is not a function"
msgstr "isway otnay away unctionfay"

#: src/pcl/methods.lisp
msgid "Contains ~S which ~A"
msgstr "Ontainscay ~S ichwhay ~Away"

#: src/pcl/methods.lisp
msgid "is not a non-null atom"
msgstr "isway otnay away onnay-ullnay atomway"

#: src/pcl/methods.lisp
msgid "is neither a class object nor an eql specializer"
msgstr ""
"isway eithernay away assclay objectway ornay anway eqlway ecializerspay"

#: src/pcl/methods.lisp
msgid "The value of the ~s initarg, ~s, ~A."
msgstr "Ethay aluevay ofway ethay ~s initargway, ~s, ~Away."

#: src/pcl/methods.lisp
msgid ""
"~~@<When initializing the generic-function ~S: ~\n"
"                               The ~S initialization argument was ~A.  ~\n"
"                               It must be ~A.~~@:>"
msgstr ""
"~~@<Enwhay initializingway ethay enericgay-unctionfay ~S: ~\n"
"                               Ethay ~S initializationway argumentway asway "
"~Away.  ~\n"
"                               Itway ustmay ebay ~Away.~~@:>"

#: src/pcl/methods.lisp
msgid "~@<~S does not name a generic function.~@:>"
msgstr "~@<~S oesday otnay amenay away enericgay unctionfay.~@:>"

#: src/pcl/methods.lisp
msgid ""
"~@<There is no method for the generic function ~S ~\n"
"                   matching argument specifiers ~S.~@:>"
msgstr ""
"~@<Erethay isway onay ethodmay orfay ethay enericgay unctionfay ~S ~\n"
"                   atchingmay argumentway ecifiersspay ~S.~@:>"

#: src/pcl/methods.lisp
msgid ""
"~@<No method on ~S with qualifiers ~S and ~\n"
"           specializers ~S.~@:>"
msgstr ""
"~@<Onay ethodmay onway ~S ithway alifiersquay ~S andway ~\n"
"           ecializersspay ~S.~@:>"

#: src/pcl/methods.lisp
msgid ""
"~@<No method on ~S with qualifiers ~S and ~\n"
"            specializers ~S.~@:>"
msgstr ""
"~@<Onay ethodmay onway ~S ithway alifiersquay ~S andway ~\n"
"            ecializersspay ~S.~@:>"

#: src/pcl/methods.lisp
msgid "~@<The generic function ~s takes ~d required argument~p.~@:>"
msgstr ""
"~@<Ethay enericgay unctionfay ~s akestay ~d equiredray argumentway~p.~@:>"

#: src/pcl/methods.lisp
msgid ""
"~@<The method ~S is already part of the generic ~\n"
"            function ~S.  It can't be added to another generic ~\n"
"            function until it is removed from the first one.~@:>"
msgstr ""
"~@<Ethay ethodmay ~S isway alreadyway artpay ofway ethay enericgay ~\n"
"            unctionfay ~S.  Itway ancay't ebay addedway otay anotherway "
"enericgay ~\n"
"            unctionfay untilway itway isway emovedray omfray ethay irstfay "
"oneway.~@:>"

#: src/pcl/methods.lisp
msgid ""
"~@<Method ~s contains invalid qualifiers for ~\n"
"                        the standard method combination.~@:>"
msgstr ""
"~@<Ethodmay ~s ontainscay invalidway alifiersquay orfay ~\n"
"                        ethay tandardsay ethodmay ombinationcay.~@:>"

#: src/pcl/methods.lisp
msgid ""
"~@<Method ~s contains invalid qualifiers for ~\n"
"                          the method combination ~s.~@:>"
msgstr ""
"~@<Ethodmay ~s ontainscay invalidway alifiersquay orfay ~\n"
"                          ethay ethodmay ombinationcay ~s.~@:>"

#: src/pcl/methods.lisp
msgid "~@<Generic function ~S requires at least ~D arguments.~@:>"
msgstr ""
"~@<Enericgay unctionfay ~S equiresray atway eastlay ~D argumentsway.~@:>"

#: src/pcl/methods.lisp
msgid "In get-accessor-method-function."
msgstr "Inway etgay-accessorway-ethodmay-unctionfay."

#: src/pcl/methods.lisp
msgid "The key for the last case arg to mcase was not T."
msgstr ""
"Ethay eykay orfay ethay astlay asecay argway otay casemay asway otnay T."

#: src/pcl/defcombin.lisp
msgid ""
"~@<Invalid options to a short method combination type.  ~\n"
"            The method combination type ~S accepts one option which ~\n"
"            must be either ~s or ~s.~@:>"
msgstr ""
"~@<Invalidway optionsway otay away ortshay ethodmay ombinationcay ypetay.  "
"~\n"
"            Ethay ethodmay ombinationcay ypetay ~S acceptsway oneway "
"optionway ichwhay ~\n"
"            ustmay ebay eitherway ~s orway ~s.~@:>"

#: src/pcl/defcombin.lisp
msgid ""
"~@<The method ~S ~A.  ~\n"
"                    The method combination type ~S was defined with the ~\n"
"                    short form of ~s and so requires all methods have ~\n"
"\t\t    either the single qualifier ~S or the single qualifier ~\n"
"\t\t    ~s.~@:>"
msgstr ""
"~@<Ethay ethodmay ~S ~Away.  ~\n"
"                    Ethay ethodmay ombinationcay ypetay ~S asway efinedday "
"ithway ethay ~\n"
"                    ortshay ormfay ofway ~s andway osay equiresray allway "
"ethodsmay avehay ~\n"
"\t\t    eitherway ethay inglesay alifierquay ~S orway ethay inglesay "
"alifierquay ~\n"
"\t\t    ~s.~@:>"

#: src/pcl/defcombin.lisp
msgid "has no qualifiers"
msgstr "ashay onay alifiersquay"

#: src/pcl/defcombin.lisp
msgid "has an illegal qualifier"
msgstr "ashay anway illegalway alifierquay"

#: src/pcl/defcombin.lisp
msgid ""
"~@<More than one method of type ~S ~\n"
"                                     with the same specializers.~@:>"
msgstr ""
"~@<Oremay anthay oneway ethodmay ofway ypetay ~S ~\n"
"                                     ithway ethay amesay ecializersspay.~@:>"

#: src/pcl/defcombin.lisp
msgid "No ~S methods."
msgstr "Onay ~S ethodsmay."

#: src/pcl/defcombin.lisp
msgid ""
"~@<In the method group specifier ~S, ~\n"
"                   ~S isn't a valid qualifier pattern.~@:>"
msgstr ""
"~@<Inway ethay ethodmay oupgray ecifierspay ~S, ~\n"
"                   ~S isnway't away alidvay alifierquay atternpay.~@:>"

#: src/pcl/defcombin.lisp
msgid "methods matching one of the patterns: ~{~S, ~} ~S"
msgstr "ethodsmay atchingmay oneway ofway ethay atternspay: ~{~S, ~} ~S"

#: src/pcl/defcombin.lisp
msgid "methods matching the pattern: ~S"
msgstr "ethodsmay atchingmay ethay atternpay: ~S"

#: src/pcl/defcombin.lisp
msgid "Invalid parameter specifier: ~s"
msgstr "Invalidway arameterpay ecifierspay: ~s"

#: src/pcl/env.lisp
msgid "~%~S is an instance of class ~S:"
msgstr "~%~S isway anway instanceway ofway assclay ~S:"

#: src/pcl/env.lisp
msgid "~% The following slots have :INSTANCE allocation:"
msgstr "~% Ethay ollowingfay otsslay avehay :INSTANCE allocationway:"

#: src/pcl/env.lisp
msgid "~% The following slots have :CLASS allocation:"
msgstr "~% Ethay ollowingfay otsslay avehay :CLASS allocationway:"

#: src/pcl/env.lisp
msgid "~% The following slots have allocation as shown:"
msgstr "~% Ethay ollowingfay otsslay avehay allocationway asway ownshay:"

#: src/pcl/env.lisp
msgid "~A is a generic function.~%"
msgstr "~Away isway away enericgay unctionfay.~%"

#: src/pcl/env.lisp
msgid "Its lambda-list is:~%  ~S~%"
msgstr "Itsway ambdalay-istlay isway:~%  ~S~%"

#: src/pcl/env.lisp
msgid "Generic function documentation:~%  ~s~%"
msgstr "Enericgay unctionfay ocumentationday:~%  ~s~%"

#: src/pcl/env.lisp
msgid "Its methods are:~%"
msgstr "Itsway ethodsmay areway:~%"

#: src/pcl/env.lisp
msgid "    Method documentation: ~s~%"
msgstr "    Ethodmay ocumentationday: ~s~%"

#: src/pcl/env.lisp
msgid "~&~@<~S is a class, it is an instance of ~S.~@:>~%"
msgstr ""
"~&~@<~S isway away assclay, itway isway anway instanceway ofway ~S.~@:>~%"

#: src/pcl/env.lisp
msgid "Its proper name is ~S.~%"
msgstr "Itsway operpray amenay isway ~S.~%"

#: src/pcl/env.lisp
msgid "Its name is ~S, but this is not a proper name.~%"
msgstr ""
"Itsway amenay isway ~S, utbay isthay isway otnay away operpray amenay.~%"

#: src/pcl/env.lisp
msgid "It has no name (the name is NIL).~%"
msgstr "Itway ashay onay amenay (ethay amenay isway NIL).~%"

#: src/pcl/env.lisp
msgid ""
"The direct superclasses are: ~:S, and the direct~%~\n"
"           subclasses are: ~:S.  The class is ~:[not ~;~]finalized.  ~\n"
"           The class precedence list is:~%~S~%~\n"
"           There are ~D methods specialized for this class."
msgstr ""
"Ethay irectday uperclassessay areway: ~:S, andway ethay irectday~%~\n"
"           ubclassessay areway: ~:S.  Ethay assclay isway ~:[otnay ~;"
"~]inalizedfay.  ~\n"
"           Ethay assclay ecedencepray istlay isway:~%~S~%~\n"
"           Erethay areway ~D ethodsmay ecializedspay orfay isthay assclay."

#: src/pcl/env.lisp
msgid "~&Its direct slots are:~%"
msgstr "~&Itsway irectday otsslay areway:~%"

#: src/pcl/env.lisp
msgid "  ~a, documentation ~s~%"
msgstr "  ~away, ocumentationday ~s~%"

#: src/pcl/env.lisp
msgid "~&~S is a ~S.~%"
msgstr "~&~S isway away ~S.~%"

#: src/pcl/env.lisp
msgid "You can also call it~@[ ~{~S~^, ~} or~] ~S.~%"
msgstr "Ouyay ancay alsoway allcay itway~@[ ~{~S~^, ~} orway~] ~S.~%"

#: src/pcl/env.lisp
msgid "It has ~D internal and ~D external symbols (~D total).~%"
msgstr ""
"Itway ashay ~D internalway andway ~D externalway ymbolssay (~D otaltay).~%"

#: src/pcl/env.lisp
msgid "It uses the packages ~{~S~^, ~}.~%"
msgstr "Itway usesway ethay ackagespay ~{~S~^, ~}.~%"

#: src/pcl/env.lisp
msgid "It is used by the packages ~{~S~^, ~}.~%"
msgstr "Itway isway usedway ybay ethay ackagespay ~{~S~^, ~}.~%"

#: src/pcl/env.lisp
msgid "~&~S is an ~a hash table."
msgstr "~&~S isway anway ~away ashhay abletay."

#: src/pcl/env.lisp
msgid "~&Its size is ~d buckets."
msgstr "~&Itsway izesay isway ~d ucketsbay."

#: src/pcl/env.lisp
msgid "~&Its rehash-size is ~d."
msgstr "~&Itsway ehashray-izesay isway ~d."

#: src/pcl/env.lisp
msgid "~&Its rehash-threshold is ~d."
msgstr "~&Itsway ehashray-resholdthay isway ~d."

#: src/pcl/env.lisp
msgid "~@<Default ~s method for ~s called.~@>"
msgstr "~@<Efaultday ~s ethodmay orfay ~s alledcay.~@>"

#: src/pcl/env.lisp
msgid "~@<Can't dump wrapper for anonymous class ~S.~@:>"
msgstr "~@<Ancay't umpday apperwray orfay anonymousway assclay ~S.~@:>"

#: src/pcl/env.lisp
msgid "~@<Can't use anonymous or undefined class as constant: ~S~:@>"
msgstr ""
"~@<Ancay't useway anonymousway orway undefinedway assclay asway onstantcay: "
"~S~:@>"

#: src/pcl/gray-streams.lisp
msgid ""
"Returns a type specifier for the kind of object returned by the\n"
"  Stream. Class FUNDAMENTAL-CHARACTER-STREAM provides a default method\n"
"  which returns CHARACTER."
msgstr ""
"Eturnsray away ypetay ecifierspay orfay ethay indkay ofway objectway "
"eturnedray ybay ethay\n"
"  Eamstray. Assclay FUNDAMENTAL-CHARACTER-STREAM ovidespray away efaultday "
"ethodmay\n"
"  ichwhay eturnsray CHARACTER."

#: src/pcl/gray-streams.lisp
msgid ""
"Set the type specifier of the kind of object returned by the\n"
"  STREAM. There is no default method as this is optional and only\n"
"  needed for bivalent streams."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Return true if Stream is not closed.  A default method is provided\n"
"  by class FUNDAMENTAL-STREAM which returns true if CLOSE has not been\n"
"  called on the stream."
msgstr ""
"Eturnray uetray ifway Eamstray isway otnay osedclay.  Away efaultday "
"ethodmay isway ovidedpray\n"
"  ybay assclay FUNDAMENTAL-STREAM ichwhay eturnsray uetray ifway CLOSE ashay "
"otnay eenbay\n"
"  alledcay onway ethay eamstray."

#: src/pcl/gray-streams.lisp
msgid ""
"Closes the given Stream.  No more I/O may be performed, but\n"
"  inquiries may still be made.  If :Abort is non-nil, an attempt is made\n"
"  to clean up the side effects of having created the stream."
msgstr ""
"Osesclay ethay ivengay Eamstray.  Onay oremay Iway/O aymay ebay erformedpay, "
"utbay\n"
"  inquiriesway aymay tillsay ebay ademay.  Ifway :Abortway isway onnay-"
"ilnay, anway attemptway isway ademay\n"
"  otay eanclay upway ethay idesay effectsway ofway avinghay eatedcray ethay "
"eamstray."

#: src/pcl/gray-streams.lisp
#, fuzzy
msgid "Returns non-nil if the given Stream can is interactive."
msgstr ""
"Eturnsray onnay-ilnay ifway ethay ivengay Eamstray ancay erformpay inputway "
"operationsway."

#: src/pcl/gray-streams.lisp
#, fuzzy
msgid "Convert pathspec (a pathname, string or stream) into a pathname."
msgstr ""
"Onvertcay ingthay (away athnamepay, ingstray orway eamstray) intoway away "
"athnamepay."

#: src/pcl/gray-streams.lisp
#, fuzzy
msgid ""
"Return the pathname for the actual file described by the filespec.\n"
"  An error of type file-error is signalled if no such file exists,\n"
"  or the pathname is wild."
msgstr ""
"Eturnray ethay athnamepay orfay ethay actualway ilefay escribedday ybay "
"ethay athnamepay\n"
"  Anway errorway ofway ypetay ilefay-errorway isway ignalledsay ifway onay "
"uchsay ilefay existsway,\n"
"  orway ethay athnamepay isway ildway."

#: src/pcl/gray-streams.lisp
msgid ""
"This reads one character from the stream.  It returns either a\n"
"  character object, or the symbol :EOF if the stream is at end-of-file.\n"
"  Every subclass of FUNDAMENTAL-CHARACTER-INPUT-STREAM must define a\n"
"  method for this function."
msgstr ""
"Isthay eadsray oneway aracterchay omfray ethay eamstray.  Itway eturnsray "
"eitherway away\n"
"  aracterchay objectway, orway ethay ymbolsay :EOF ifway ethay eamstray "
"isway atway endway-ofway-ilefay.\n"
"  Everyway ubclasssay ofway FUNDAMENTAL-CHARACTER-INPUT-STREAM ustmay "
"efineday away\n"
"  ethodmay orfay isthay unctionfay."

#: src/pcl/gray-streams.lisp
msgid ""
"Un-does the last call to STREAM-READ-CHAR, as in UNREAD-CHAR.\n"
"  Returns NIL.  Every subclass of FUNDAMENTAL-CHARACTER-INPUT-STREAM\n"
"  must define a method for this function."
msgstr ""
"Unway-oesday ethay astlay allcay otay STREAM-READ-CHAR, asway inway UNREAD-"
"CHAR.\n"
"  Eturnsray NIL.  Everyway ubclasssay ofway FUNDAMENTAL-CHARACTER-INPUT-"
"STREAM\n"
"  ustmay efineday away ethodmay orfay isthay unctionfay."

#: src/pcl/gray-streams.lisp
msgid ""
"This is used to implement READ-CHAR-NO-HANG.  It returns either a\n"
"  character, or NIL if no input is currently available, or :EOF if\n"
"  end-of-file is reached.  The default method provided by\n"
"  FUNDAMENTAL-CHARACTER-INPUT-STREAM simply calls STREAM-READ-CHAR; this\n"
"  is sufficient for file streams, but interactive streams should define\n"
"  their own method."
msgstr ""
"Isthay isway usedway otay implementway READ-CHAR-NO-HANG.  Itway eturnsray "
"eitherway away\n"
"  aracterchay, orway NIL ifway onay inputway isway urrentlycay availableway, "
"orway :EOF ifway\n"
"  endway-ofway-ilefay isway eachedray.  Ethay efaultday ethodmay ovidedpray "
"ybay\n"
"  FUNDAMENTAL-CHARACTER-INPUT-STREAM implysay allscay STREAM-READ-CHAR; "
"isthay\n"
"  isway ufficientsay orfay ilefay eamsstray, utbay interactiveway eamsstray "
"ouldshay efineday\n"
"  eirthay ownway ethodmay."

#: src/pcl/gray-streams.lisp
msgid ""
"Used to implement PEEK-CHAR; this corresponds to peek-type of NIL.\n"
"  It returns either a character or :EOF.  The default method calls\n"
"  STREAM-READ-CHAR and STREAM-UNREAD-CHAR."
msgstr ""
"Usedway otay implementway PEEK-CHAR; isthay orrespondscay otay eekpay-ypetay "
"ofway NIL.\n"
"  Itway eturnsray eitherway away aracterchay orway :EOF.  Ethay efaultday "
"ethodmay allscay\n"
"  STREAM-READ-CHAR andway STREAM-UNREAD-CHAR."

#: src/pcl/gray-streams.lisp
msgid ""
"Used by LISTEN.  Returns true or false.  The default method uses\n"
"  STREAM-READ-CHAR-NO-HANG and STREAM-UNREAD-CHAR.  Most streams should \n"
"  define their own method since it will usually be trivial and will\n"
"  always be more efficient than the default method."
msgstr ""
"Usedway ybay LISTEN.  Eturnsray uetray orway alsefay.  Ethay efaultday "
"ethodmay usesway\n"
"  STREAM-READ-CHAR-NO-HANG andway STREAM-UNREAD-CHAR.  Ostmay eamsstray "
"ouldshay \n"
"  efineday eirthay ownway ethodmay incesay itway illway usuallyway ebay "
"ivialtray andway illway\n"
"  alwaysway ebay oremay efficientway anthay ethay efaultday ethodmay."

#: src/pcl/gray-streams.lisp
msgid ""
"Used by READ-LINE.  A string is returned as the first value.  The\n"
"  second value is true if the string was terminated by end-of-file\n"
"  instead of the end of a line.  The default method uses repeated\n"
"  calls to STREAM-READ-CHAR."
msgstr ""
"Usedway ybay READ-LINE.  Away ingstray isway eturnedray asway ethay irstfay "
"aluevay.  Ethay\n"
"  econdsay aluevay isway uetray ifway ethay ingstray asway erminatedtay ybay "
"endway-ofway-ilefay\n"
"  insteadway ofway ethay endway ofway away inelay.  Ethay efaultday ethodmay "
"usesway epeatedray\n"
"  allscay otay STREAM-READ-CHAR."

#: src/pcl/gray-streams.lisp
msgid ""
"Implements CLEAR-INPUT for the stream, returning NIL.  The default\n"
"  method does nothing."
msgstr ""
"Implementsway CLEAR-INPUT orfay ethay eamstray, eturningray NIL.  Ethay "
"efaultday\n"
"  ethodmay oesday othingnay."

#: src/pcl/gray-streams.lisp
msgid "Implements READ-SEQUENCE for the stream."
msgstr "Implementsway READ-SEQUENCE orfay ethay eamstray."

#: src/pcl/gray-streams.lisp
msgid ""
"Writes character to the stream and returns the character.  Every\n"
"  subclass of FUNDAMENTAL-CHARACTER-OUTPUT-STREAM must have a method\n"
"  defined for this function."
msgstr ""
"Iteswray aracterchay otay ethay eamstray andway eturnsray ethay "
"aracterchay.  Everyway\n"
"  ubclasssay ofway FUNDAMENTAL-CHARACTER-OUTPUT-STREAM ustmay avehay away "
"ethodmay\n"
"  efinedday orfay isthay unctionfay."

#: src/pcl/gray-streams.lisp
msgid ""
"This function returns the column number where the next character\n"
"  will be written, or NIL if that is not meaningful for this stream.\n"
"  The first column on a line is numbered 0.  This function is used in\n"
"  the implementation of PPRINT and the FORMAT ~T directive.  For every\n"
"  character output stream class that is defined, a method must be\n"
"  defined for this function, although it is permissible for it to\n"
"  always return NIL."
msgstr ""
"Isthay unctionfay eturnsray ethay olumncay umbernay erewhay ethay extnay "
"aracterchay\n"
"  illway ebay ittenwray, orway NIL ifway atthay isway otnay eaningfulmay "
"orfay isthay eamstray.\n"
"  Ethay irstfay olumncay onway away inelay isway umberednay 0.  Isthay "
"unctionfay isway usedway inway\n"
"  ethay implementationway ofway PPRINT andway ethay FORMAT ~T irectiveday.  "
"Orfay everyway\n"
"  aracterchay outputway eamstray assclay atthay isway efinedday, away "
"ethodmay ustmay ebay\n"
"  efinedday orfay isthay unctionfay, althoughway itway isway ermissiblepay "
"orfay itway otay\n"
"  alwaysway eturnray NIL."

#: src/pcl/gray-streams.lisp
msgid "Return the stream line length or Nil."
msgstr "Eturnray ethay eamstray inelay engthlay orway Ilnay."

#: src/pcl/gray-streams.lisp
msgid ""
"This is a predicate which returns T if the stream is positioned at\n"
"  the beginning of a line, else NIL.  It is permissible to always return\n"
"  NIL.  This is used in the implementation of FRESH-LINE.  Note that\n"
"  while a value of 0 from STREAM-LINE-COLUMN also indicates the\n"
"  beginning of a line, there are cases where STREAM-START-LINE-P can be\n"
"  meaningfully implemented although STREAM-LINE-COLUMN can't be.  For\n"
"  example, for a window using variable-width characters, the column\n"
"  number isn't very meaningful, but the beginning of the line does have\n"
"  a clear meaning.  The default method for STREAM-START-LINE-P on class\n"
"  FUNDAMENTAL-CHARACTER-OUTPUT-STREAM uses STREAM-LINE-COLUMN, so if\n"
"  that is defined to return NIL, then a method should be provided for\n"
"  either STREAM-START-LINE-P or STREAM-FRESH-LINE."
msgstr ""
"Isthay isway away edicatepray ichwhay eturnsray T ifway ethay eamstray isway "
"ositionedpay atway\n"
"  ethay eginningbay ofway away inelay, elseway NIL.  Itway isway "
"ermissiblepay otay alwaysway eturnray\n"
"  NIL.  Isthay isway usedway inway ethay implementationway ofway FRESH-"
"LINE.  Otenay atthay\n"
"  ilewhay away aluevay ofway 0 omfray STREAM-LINE-COLUMN alsoway "
"indicatesway ethay\n"
"  eginningbay ofway away inelay, erethay areway asescay erewhay STREAM-START-"
"LINE-P ancay ebay\n"
"  eaningfullymay implementedway althoughway STREAM-LINE-COLUMN ancay't "
"ebay.  Orfay\n"
"  exampleway, orfay away indowway usingway ariablevay-idthway aracterschay, "
"ethay olumncay\n"
"  umbernay isnway't eryvay eaningfulmay, utbay ethay eginningbay ofway ethay "
"inelay oesday avehay\n"
"  away earclay eaningmay.  Ethay efaultday ethodmay orfay STREAM-START-LINE-"
"P onway assclay\n"
"  FUNDAMENTAL-CHARACTER-OUTPUT-STREAM usesway STREAM-LINE-COLUMN, osay "
"ifway\n"
"  atthay isway efinedday otay eturnray NIL, enthay away ethodmay ouldshay "
"ebay ovidedpray orfay\n"
"  eitherway STREAM-START-LINE-P orway STREAM-FRESH-LINE."

#: src/pcl/gray-streams.lisp
msgid ""
"This is used by WRITE-STRING.  It writes the string to the stream,\n"
"  optionally delimited by start and end, which default to 0 and NIL.\n"
"  The string argument is returned.  The default method provided by\n"
"  FUNDAMENTAL-CHARACTER-OUTPUT-STREAM uses repeated calls to\n"
"  STREAM-WRITE-CHAR."
msgstr ""
"Isthay isway usedway ybay WRITE-STRING.  Itway iteswray ethay ingstray otay "
"ethay eamstray,\n"
"  optionallyway elimitedday ybay tartsay andway endway, ichwhay efaultday "
"otay 0 andway NIL.\n"
"  Ethay ingstray argumentway isway eturnedray.  Ethay efaultday ethodmay "
"ovidedpray ybay\n"
"  FUNDAMENTAL-CHARACTER-OUTPUT-STREAM usesway epeatedray allscay otay\n"
"  STREAM-WRITE-CHAR."

#: src/pcl/gray-streams.lisp
msgid ""
"Writes an end of line, as for TERPRI.  Returns NIL.  The default\n"
"  method does (STREAM-WRITE-CHAR stream #NEWLINE)."
msgstr ""
"Iteswray anway endway ofway inelay, asway orfay TERPRI.  Eturnsray NIL.  "
"Ethay efaultday\n"
"  ethodmay oesday (STREAM-WRITE-CHAR eamstray #NEWLINE)."

#: src/pcl/gray-streams.lisp
msgid ""
"Outputs a new line to the Stream if it is not positioned at the\n"
"  begining of a line.  Returns T if it output a new line, nil\n"
"  otherwise. Used by FRESH-LINE. The default method uses\n"
"  STREAM-START-LINE-P and STREAM-TERPRI."
msgstr ""
"Outputsway away ewnay inelay otay ethay Eamstray ifway itway isway otnay "
"ositionedpay atway ethay\n"
"  eginingbay ofway away inelay.  Eturnsray T ifway itway outputway away "
"ewnay inelay, ilnay\n"
"  otherwiseway. Usedway ybay FRESH-LINE. Ethay efaultday ethodmay usesway\n"
"  STREAM-START-LINE-P andway STREAM-TERPRI."

#: src/pcl/gray-streams.lisp
msgid ""
"Attempts to ensure that all output sent to the Stream has reached\n"
"  its destination, and only then returns false. Implements\n"
"  FINISH-OUTPUT.  The default method does nothing."
msgstr ""
"Attemptsway otay ensureway atthay allway outputway entsay otay ethay "
"Eamstray ashay eachedray\n"
"  itsway estinationday, andway onlyway enthay eturnsray alsefay. "
"Implementsway\n"
"  FINISH-OUTPUT.  Ethay efaultday ethodmay oesday othingnay."

#: src/pcl/gray-streams.lisp
msgid ""
"Attempts to force any buffered output to be sent. Implements\n"
"  FORCE-OUTPUT.  The default method does nothing."
msgstr ""
"Attemptsway otay orcefay anyway ufferedbay outputway otay ebay entsay. "
"Implementsway\n"
"  FORCE-OUTPUT.  Ethay efaultday ethodmay oesday othingnay."

#: src/pcl/gray-streams.lisp
msgid ""
"Clears the given output Stream. Implements CLEAR-OUTPUT.  The\n"
"  default method does nothing."
msgstr ""
"Earsclay ethay ivengay outputway Eamstray. Implementsway CLEAR-OUTPUT.  "
"Ethay\n"
"  efaultday ethodmay oesday othingnay."

#: src/pcl/gray-streams.lisp
msgid ""
"Writes enough blank space so that the next character will be\n"
"  written at the specified column.  Returns true if the operation is\n"
"  successful, or NIL if it is not supported for this stream.  This is\n"
"  intended for use by by PPRINT and FORMAT ~T.  The default method uses\n"
"  STREAM-LINE-COLUMN and repeated calls to STREAM-WRITE-CHAR with a\n"
"  #SPACE character; it returns NIL if STREAM-LINE-COLUMN returns NIL."
msgstr ""
"Iteswray enoughway ankblay acespay osay atthay ethay extnay aracterchay "
"illway ebay\n"
"  ittenwray atway ethay ecifiedspay olumncay.  Eturnsray uetray ifway ethay "
"operationway isway\n"
"  uccessfulsay, orway NIL ifway itway isway otnay upportedsay orfay isthay "
"eamstray.  Isthay isway\n"
"  intendedway orfay useway ybay ybay PPRINT andway FORMAT ~T.  Ethay "
"efaultday ethodmay usesway\n"
"  STREAM-LINE-COLUMN andway epeatedray allscay otay STREAM-WRITE-CHAR ithway "
"away\n"
"  #SPACE aracterchay; itway eturnsray NIL ifway STREAM-LINE-COLUMN eturnsray "
"NIL."

#: src/pcl/gray-streams.lisp
msgid "Implements WRITE-SEQUENCE for the stream."
msgstr "Implementsway WRITE-SEQUENCE orfay ethay eamstray."

#: src/pcl/gray-streams.lisp
#, fuzzy
msgid "Implements FILE-POSITION for the stream."
msgstr "Implementsway WRITE-SEQUENCE orfay ethay eamstray."

#: src/pcl/gray-streams.lisp
#, fuzzy
msgid "Implements FILE-POSITION for the stream for setting the position."
msgstr ""
"Implementsway CLEAR-INPUT orfay ethay eamstray, eturningray NIL.  Ethay "
"efaultday\n"
"  ethodmay oesday othingnay."

#: src/pcl/gray-streams.lisp
#, fuzzy
msgid "Implements FILE-LENGTH for the stream."
msgstr "Implementsway WRITE-SEQUENCE orfay ethay eamstray."

#: src/pcl/gray-streams.lisp
msgid ""
"Used by READ-BYTE; returns either an integer, or the symbol :EOF\n"
"  if the stream is at end-of-file."
msgstr ""
"Usedway ybay READ-BYTE; eturnsray eitherway anway integerway, orway ethay "
"ymbolsay :EOF\n"
"  ifway ethay eamstray isway atway endway-ofway-ilefay."

#: src/pcl/gray-streams.lisp
msgid ""
"Implements WRITE-BYTE; writes the integer to the stream and\n"
"  returns the integer as the result."
msgstr ""
"Implementsway WRITE-BYTE; iteswray ethay integerway otay ethay eamstray "
"andway\n"
"  eturnsray ethay integerway asway ethay esultray."

#: src/pcl/gray-streams.lisp
msgid "    Gray Streams Protocol Support"
msgstr "    Aygray Eamsstray Otocolpray Upportsay"

msgid ""
"MAC-ROMAN is an 8-bit character encoding for Western European\n"
"languages including English.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"MAC-ROMAN isway anway 8-itbay aracterchay encodingway orfay Esternway "
"Europeanway\n"
"anguageslay includingway Englishway.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"CP1250 is a Windows code page to represent texts in Central and\n"
"Eastern European languages such as Polish, Czech, Slovak, Hungarian,\n"
"Slovene, Bosnian, Croation, Serbian, Romanian, and Albanian.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"CP1250 isway away Indowsway odecay agepay otay epresentray extstay inway "
"Entralcay andway\n"
"Easternway Europeanway anguageslay uchsay asway Olishpay, Zechcay, Ovakslay, "
"Ungarianhay,\n"
"Oveneslay, Osnianbay, Oationcray, Erbiansay, Omanianray, andway "
"Albanianway.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"CP1251 is a Windows code page to represent texts that use the\n"
"Cyrillic alphabet such as Russian, Bulgarian, Serbian Cyrillic, and\n"
"others.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"CP1251 isway away Indowsway odecay agepay otay epresentray extstay atthay "
"useway ethay\n"
"Yrilliccay alphabetway uchsay asway Ussianray, Ulgarianbay, Erbiansay "
"Yrilliccay, andway\n"
"othersway.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"CP1252 is a Windows code page for the Latin alphabet.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"CP1252 isway away Indowsway odecay agepay orfay ethay Atinlay alphabetway.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"CP1253 is a Windows code page for Greek.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"CP1253 isway away Indowsway odecay agepay orfay Eekgray.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"CP1254 is a Windows code page for Turkish.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"CP1254 isway away Indowsway odecay agepay orfay Urkishtay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"CP1255 is a Windows code page for Hebrew.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"CP1255 isway away Indowsway odecay agepay orfay Ebrewhay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"CP1256 is a Windows code page for Arabic.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"CP1256 isway away Indowsway odecay agepay orfay Arabicway.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"CP1257 is a Windows code page for Estonian, Latvian, and Lithuanian.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"CP1257 isway away Indowsway odecay agepay orfay Estonianway, Atvianlay, "
"andway Ithuanianlay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"CP1258 is a Windows code page for Vietnamese.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"CP1258 isway away Indowsway odecay agepay orfay Ietnamesevay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"EUC-KR is an variable-length character encoding generally intended for\n"
"Korean Hangul.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"EUC-KR isway anway ariablevay-engthlay aracterchay encodingway enerallygay "
"intendedway orfay\n"
"Oreankay Angulhay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-2 is an 8-bit character encoding generally intended for\n"
"Eastern European languages including Bosnian, Croation, Czech, German,\n"
"Hungarian, Polish, Romanian, Serbian Latin, Slovak, Slovene, Upper\n"
"Sorbian, and Lower Sorbian.  \n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-2 isway anway 8-itbay aracterchay encodingway enerallygay "
"intendedway orfay\n"
"Easternway Europeanway anguageslay includingway Osnianbay, Oationcray, "
"Zechcay, Ermangay,\n"
"Ungarianhay, Olishpay, Omanianray, Erbiansay Atinlay, Ovakslay, Oveneslay, "
"Upperway\n"
"Orbiansay, andway Owerlay Orbiansay.  \n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-10 is an 8-bit character encoding intended to cover Nordic\n"
"languages.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-10 isway anway 8-itbay aracterchay encodingway intendedway otay "
"overcay Ordicnay\n"
"anguageslay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-13 is an 8-bit character encoding for the Baltic languages.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-13 isway anway 8-itbay aracterchay encodingway orfay ethay Alticbay "
"anguageslay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-14 is an 8-bit character encoding intended for the Celtic\n"
"languages such as Irish, Manx, Scottish Gaelic, Welsh, and Breton.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-14 isway anway 8-itbay aracterchay encodingway intendedway orfay "
"ethay Elticcay\n"
"anguageslay uchsay asway Irishway, Anxmay, Ottishscay Aelicgay, Elshway, "
"andway Etonbray.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-15 is an 8-bit character encoding similar to ISO8859-1 but\n"
"replaces some less common symbols with others, including adding the\n"
"Euro sign.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-15 isway anway 8-itbay aracterchay encodingway imilarsay otay "
"ISO8859-1 utbay\n"
"eplacesray omesay esslay ommoncay ymbolssay ithway othersway, includingway "
"addingway ethay\n"
"Euroway ignsay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-3 is an 8-bit character encoding intended for South European\n"
"languages including Turkish, Maltese, and Esperanto.  For Turkish,\n"
"ISO8859-9 supersedes ISO8859-3.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-3 isway anway 8-itbay aracterchay encodingway intendedway orfay "
"Outhsay Europeanway\n"
"anguageslay includingway Urkishtay, Altesemay, andway Esperantoway.  Orfay "
"Urkishtay,\n"
"ISO8859-9 upersedessay ISO8859-3.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-4 is an 8-bit character encoding for North European languages\n"
"including Estonian, Latvian, Lithuanian, Greenlandic, and Sami.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-4 isway anway 8-itbay aracterchay encodingway orfay Orthnay "
"Europeanway anguageslay\n"
"includingway Estonianway, Atvianlay, Ithuanianlay, Eenlandicgray, andway "
"Amisay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-5, informallly referred to as Latin/Cyrillic, is an 8-bit\n"
"character encoding intended for languages using a Cyrillic alphabet\n"
"such as Bulgarian, Belarusian, Russian, Serbian, and Macedonian.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-5, informalllyway eferredray otay asway Atinlay/Yrilliccay, isway "
"anway 8-itbay\n"
"aracterchay encodingway intendedway orfay anguageslay usingway away "
"Yrilliccay alphabetway\n"
"uchsay asway Ulgarianbay, Elarusianbay, Ussianray, Erbiansay, andway "
"Acedonianmay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-6 is an 8-bit character encoding generally intended languages\n"
"using the Arabic alphabet.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-6 isway anway 8-itbay aracterchay encodingway enerallygay "
"intendedway anguageslay\n"
"usingway ethay Arabicway alphabetway.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-7 is an 8-bit character encoding for the modern Greek\n"
"language.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-7 isway anway 8-itbay aracterchay encodingway orfay ethay odernmay "
"Eekgray\n"
"anguagelay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-8 is an 8-bit character encoding intended for Hebrew.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-8 isway anway 8-itbay aracterchay encodingway intendedway orfay "
"Ebrewhay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"ISO8859-9 is an 8-bit character encoding for the Turkish language.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"ISO8859-9 isway anway 8-itbay aracterchay encodingway orfay ethay Urkishtay "
"anguagelay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"KOI8-R is an 8-bit character encoding designed to cover Russian.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"KOI8-R isway anway 8-itbay aracterchay encodingway esignedday otay overcay "
"Ussianray.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"MAC-CYRILLIC is an 8-bit character encoding for Cyrillic text on\n"
"Apple Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"MAC-CYRILLIC isway anway 8-itbay aracterchay encodingway orfay Yrilliccay "
"exttay onway\n"
"Appleway Acintoshmay omputerscay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"MAC-GREEK is an 8-bit character encoding for Greek text on Apple\n"
"Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"MAC-GREEK isway anway 8-itbay aracterchay encodingway orfay Eekgray exttay "
"onway Appleway\n"
"Acintoshmay omputerscay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"MAC-ICELANDIC is an 8-bit character encoding for Icelandic text on\n"
"Apple Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"MAC-ICELANDIC isway anway 8-itbay aracterchay encodingway orfay Icelandicway "
"exttay onway\n"
"Appleway Acintoshmay omputerscay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"MAC-LATIN2 is an 8-bit character encoding for Central European text\n"
"on Apple Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"MAC-LATIN2 isway anway 8-itbay aracterchay encodingway orfay Entralcay "
"Europeanway exttay\n"
"onway Appleway Acintoshmay omputerscay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"MAC-TURKISH is an 8-bit character encoding for Turkish text on\n"
"Apple Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""
"MAC-TURKISH isway anway 8-itbay aracterchay encodingway orfay Urkishtay "
"exttay onway\n"
"Appleway Acintoshmay omputerscay.\n"
"\n"
"Ybay efaultday, illegalway inputsway areway eplacedray ybay ethay Unicodeway "
"eplacementray\n"
"aracterchay andway illegalway outputsway areway eplacedray ybay away "
"estionquay arkmay."

msgid ""
"UTF-16 is a variable length character encoding for Unicode.  On\n"
"input, a byte-order mark is recognized.  If no byte-order mark is\n"
"given on input, then the encoding is assumed to be big-endian.  For\n"
"output, the byte-order mark is not written, and the output is\n"
"big-endian.  (This is specified by the Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""
"UTF-16 isway away ariablevay engthlay aracterchay encodingway orfay "
"Unicodeway.  Onway\n"
"inputway, away ytebay-orderway arkmay isway ecognizedray.  Ifway onay ytebay-"
"orderway arkmay isway\n"
"ivengay onway inputway, enthay ethay encodingway isway assumedway otay ebay "
"igbay-endianway.  Orfay\n"
"outputway, ethay ytebay-orderway arkmay isway otnay ittenwray, andway ethay "
"outputway isway\n"
"igbay-endianway.  (Isthay isway ecifiedspay ybay ethay Unicodeway "
"tandardsay.)\n"
"\n"
"Ybay efaultday, illegalway inputsway andway illegalway outputsway areway "
"eplacedray ybay ethay\n"
"Unicodeway eplacementray aracterchay."

msgid ""
"UTF-16-BE is a variable length character encoding for Unicode.  For\n"
"both input and output, the data is assumed to be in big-endian order.\n"
"No byte-order mark is allowed on input, and no byte-order mark is\n"
"produced on output.  (This is specified by the Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""
"UTF-16-BE isway away ariablevay engthlay aracterchay encodingway orfay "
"Unicodeway.  Orfay\n"
"othbay inputway andway outputway, ethay ataday isway assumedway otay ebay "
"inway igbay-endianway orderway.\n"
"Onay ytebay-orderway arkmay isway allowedway onway inputway, andway onay "
"ytebay-orderway arkmay isway\n"
"oducedpray onway outputway.  (Isthay isway ecifiedspay ybay ethay Unicodeway "
"tandardsay.)\n"
"\n"
"Ybay efaultday, illegalway inputsway andway illegalway outputsway areway "
"eplacedray ybay ethay\n"
"Unicodeway eplacementray aracterchay."

msgid ""
"UTF-16-LE is a variable length character encoding for Unicode.  For\n"
"both input and output, the data is assumed to be in little-endian\n"
"order.  No byte-order mark is allowed on input, and no byte-order mark\n"
"is produced on output.  (This is specified by the Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""
"UTF-16-LE isway away ariablevay engthlay aracterchay encodingway orfay "
"Unicodeway.  Orfay\n"
"othbay inputway andway outputway, ethay ataday isway assumedway otay ebay "
"inway ittlelay-endianway\n"
"orderway.  Onay ytebay-orderway arkmay isway allowedway onway inputway, "
"andway onay ytebay-orderway arkmay\n"
"isway oducedpray onway outputway.  (Isthay isway ecifiedspay ybay ethay "
"Unicodeway tandardsay.)\n"
"\n"
"Ybay efaultday, illegalway inputsway andway illegalway outputsway areway "
"eplacedray ybay ethay\n"
"Unicodeway eplacementray aracterchay."

msgid ""
"UTF-32 is a fixed-length character encoding of 4 octets for Unicode.\n"
"On input, a byte-order mark is recognized.  If no byte-order mark is\n"
"given on input, then the encoding is assumed to be big-endian.  For\n"
"output, the byte-order mark is not written, and the output is\n"
"big-endian.  (This is specified by the Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""
"UTF-32 isway away ixedfay-engthlay aracterchay encodingway ofway 4 octetsway "
"orfay Unicodeway.\n"
"Onway inputway, away ytebay-orderway arkmay isway ecognizedray.  Ifway onay "
"ytebay-orderway arkmay isway\n"
"ivengay onway inputway, enthay ethay encodingway isway assumedway otay ebay "
"igbay-endianway.  Orfay\n"
"outputway, ethay ytebay-orderway arkmay isway otnay ittenwray, andway ethay "
"outputway isway\n"
"igbay-endianway.  (Isthay isway ecifiedspay ybay ethay Unicodeway "
"tandardsay.)\n"
"\n"
"Ybay efaultday, illegalway inputsway andway illegalway outputsway areway "
"eplacedray ybay ethay\n"
"Unicodeway eplacementray aracterchay."

msgid ""
"UTF-32-BE is a fixed-length character encoding of 4 octets for\n"
"Unicode.  For both input and output, the data is assumed to be in\n"
"big-endian order.  No byte-order mark is allowed on input, and no\n"
"byte-order mark is produced on output.  (This is specified by the\n"
"Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""
"UTF-32-BE isway away ixedfay-engthlay aracterchay encodingway ofway 4 "
"octetsway orfay\n"
"Unicodeway.  Orfay othbay inputway andway outputway, ethay ataday isway "
"assumedway otay ebay inway\n"
"igbay-endianway orderway.  Onay ytebay-orderway arkmay isway allowedway "
"onway inputway, andway onay\n"
"ytebay-orderway arkmay isway oducedpray onway outputway.  (Isthay isway "
"ecifiedspay ybay ethay\n"
"Unicodeway tandardsay.)\n"
"\n"
"Ybay efaultday, illegalway inputsway andway illegalway outputsway areway "
"eplacedray ybay ethay\n"
"Unicodeway eplacementray aracterchay."

msgid ""
"UTF-32-LE is a fixed-length character encoding of 4 octets for\n"
"Unicode.  For both input and output, the data is assumed to be in\n"
"little-endian order.  No byte-order mark is allowed on input, and no\n"
"byte-order mark is produced on output.  (This is specified by the\n"
"Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""
"UTF-32-LE isway away ixedfay-engthlay aracterchay encodingway ofway 4 "
"octetsway orfay\n"
"Unicodeway.  Orfay othbay inputway andway outputway, ethay ataday isway "
"assumedway otay ebay inway\n"
"ittlelay-endianway orderway.  Onay ytebay-orderway arkmay isway allowedway "
"onway inputway, andway onay\n"
"ytebay-orderway arkmay isway oducedpray onway outputway.  (Isthay isway "
"ecifiedspay ybay ethay\n"
"Unicodeway tandardsay.)\n"
"\n"
"Ybay efaultday, illegalway inputsway andway illegalway outputsway areway "
"eplacedray ybay ethay\n"
"Unicodeway eplacementray aracterchay."

#~ msgid "Same as -help."
#~ msgstr "Amesay asway -elphay."

#~ msgid "See <http://www.cmucl.org/> for support information."
#~ msgstr ""
#~ "Eesay <ttphay://wwway.muclcay.orgway/> orfay upportsay informationway."

#~ msgid "Underflow"
#~ msgstr "Underflowway"

#~ msgid "Unknown"
#~ msgstr "Unknownway"

#~ msgid "Site name not initialized"
#~ msgstr "Itesay amenay otnay initializedway"

#~ msgid ""
#~ "Print a breakdown by instance type of all the instances allocated in\n"
#~ "  Space.  If TOP-N is true, print only information for the the TOP-N "
#~ "types with\n"
#~ "  largest usage."
#~ msgstr ""
#~ "Intpray away eakdownbray ybay instanceway ypetay ofway allway ethay "
#~ "instancesway allocatedway inway\n"
#~ "  Acespay.  Ifway TOP-N isway uetray, intpray onlyway informationway "
#~ "orfay ethay ethay TOP-N ypestay ithway\n"
#~ "  argestlay usageway."

#~ msgid "Returns T if a character is available on the given Stream."
#~ msgstr ""
#~ "Eturnsray T ifway away aracterchay isway availableway onway ethay ivengay "
#~ "Eamstray."

#~ msgid "No such program: ~S"
#~ msgstr "Onay uchsay ogrampray: ~S"

#~ msgid "Return any available status information on child processed. "
#~ msgstr ""
#~ "Eturnray anyway availableway tatussay informationway onway ildchay "
#~ "ocessedpray. "

#~ msgid "Cound not create pipe: ~A"
#~ msgstr "Oundcay otnay eatecray ipepay: ~Away"

#~ msgid "Changes the name and nicknames for a package."
#~ msgstr "Angeschay ethay amenay andway icknamesnay orfay away ackagepay."

#~ msgid "No default clause allowed in ~S: ~S"
#~ msgstr "Onay efaultday auseclay allowedway inway ~S: ~S"

#~ msgid "T and OTHERWISE may not be used as key designators for ~A"
#~ msgstr ""
#~ "T andway OTHERWISE aymay otnay ebay usedway asway eykay esignatorsday "
#~ "orfay ~Away"

#~ msgid "Return true if the float X is a NaN (Not a Number)."
#~ msgstr ""
#~ "Eturnray uetray ifway ethay oatflay X isway away Annay (Otnay away "
#~ "Umbernay)."

#~ msgid "Bad style to use T or OTHERWISE in ECASE or CCASE"
#~ msgstr "Adbay tylesay otay useway T orway OTHERWISE inway ECASE orway CCASE"
